"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/@mahindar5/common-lib/dist/chunk-ENJTJAZQ.js
var h = Object.defineProperty;
var i = Object.getOwnPropertyDescriptor;
var j = /* @__PURE__ */ __name((a22, b7) => h(a22, "name", { value: b7, configurable: true }), "j"), k = ((a22) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(a22, { get: /* @__PURE__ */ __name((b7, c21) => (typeof require < "u" ? require : b7)[c21], "get") }) : a22)(function(a22) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + a22 + '" is not supported');
});
var l = /* @__PURE__ */ __name((a22, b7, c21, e10) => {
  for (var d15 = e10 > 1 ? void 0 : e10 ? i(b7, c21) : b7, f13 = a22.length - 1, g10; f13 >= 0; f13--) (g10 = a22[f13]) && (d15 = (e10 ? g10(b7, c21, d15) : g10(d15)) || d15);
  return e10 && d15 && h(b7, c21, d15), d15;
}, "l"), m = /* @__PURE__ */ __name((a22, b7) => (c21, e10) => b7(c21, e10, a22), "m");

// node_modules/@mahindar5/common-lib/dist/chunk-O2L473M6.js
var c = class {
  static {
    __name(this, "c");
  }
  static {
    j(this, "WebSpeechAdapter");
  }
  recognition;
  listening = false;
  active = false;
  restartTimer;
  errors = 0;
  lastStart = 0;
  constructor() {
    if (!window.webkitSpeechRecognition) return;
    let t11 = new window.webkitSpeechRecognition();
    t11.continuous = true, t11.interimResults = true, t11.lang = "en-US", this.recognition = t11;
  }
  start(t11, e10) {
    if (!this.recognition) return console.error("Speech recognition not supported in this browser"), e10?.(new Error("Speech recognition not supported"));
    console.log("Starting speech recognition...");
    let i18 = Date.now(), s18 = i18 - this.lastStart;
    if (s18 < 3e3) {
      console.log(`Delaying recognition restart... ${new Date(i18 + (3e3 - s18)).toLocaleTimeString()}`), setTimeout(() => this.start(t11, e10), 3e3 - s18);
      return;
    }
    this.lastStart = i18, this.active = true, clearTimeout(this.restartTimer);
    let l14 = j((r9 = 1e3, o21 = "auto-restart") => {
      this.active && (clearTimeout(this.restartTimer), console.log(`Scheduling restart in ${r9}ms (${o21})...`), this.restartTimer = setTimeout(() => this.tryStart(t11, e10), r9));
    }, "restart");
    this.recognition.onstart = () => {
      this.listening = true, console.log("Speech recognition started - listening for commands");
    }, this.recognition.onend = () => {
      this.listening = false, console.log("Speech recognition ended"), this.active && !this.restartTimer && this.tryStart(t11, e10);
    }, this.recognition.onerror = (r9) => {
      if (this.listening = false, console.log(`Speech recognition error: ${r9.error}`), ["not-allowed", "service-not-allowed", "aborted"].includes(r9.error)) {
        if (++this.errors >= 8) return console.error(`Speech recognition failed permanently after ${this.errors} permission/abort errors`), e10?.(new Error("Speech recognition failed permanently"));
        console.error(`Permission/abort error count: ${this.errors}/8 - stopping and restarting`), this.recognition.stop(), l14(this.errors >= 3 ? 3e4 : 3e3, "permission-error");
        return;
      }
      console.log(`Non-critical error: ${r9.error} - resetting error count and continuing`), this.errors = 0;
    }, this.recognition.onresult = (r9) => {
      let o21 = r9.results[r9.results.length - 1];
      if (o21?.isFinal) {
        let n11 = o21[0]?.transcript?.trim();
        n11 && (console.log(`\u2705 Final result: "${n11}"`), this.errors = Math.max(0, this.errors - 1), this.errors > 0 && console.log(`Error recovery - count reduced to: ${this.errors}/8`), t11(n11));
      } else {
        let n11 = o21[0]?.transcript || "";
        n11.trim() && console.log(`\u{1F3A4} Partial: "${n11.trim()}" [confidence: ${(o21[0]?.confidence * 100 || 0).toFixed(0)}%]`);
      }
    }, this.tryStart(t11, e10);
  }
  tryStart(t11, e10) {
    if (!this.active || this.listening) {
      console.log("Skipping start - already active or listening");
      return;
    }
    try {
      console.log("Attempting to start recognition..."), this.recognition.start();
    } catch (i18) {
      i18.message?.includes("already started") ? (console.log("Speech recognition already active in another tab - retrying in 3s"), this.restartTimer = setTimeout(() => this.tryStart(t11, e10), 3e3)) : (console.error("Failed to start recognition:", i18.message), e10?.(i18));
    }
  }
  stop() {
    console.log("Stopping speech recognition..."), this.active = false, this.errors = 0, clearTimeout(this.restartTimer), this.listening && (this.recognition?.stop(), console.log("Recognition stopped"));
  }
  isListening() {
    return this.listening;
  }
}, h2 = c;

// node_modules/@mahindar5/common-lib/dist/chunk-B3VVJ3DW.js
var i2 = null;
(async () => {
  let e10 = speechSynthesis.getVoices();
  for (; e10.length === 0; ) await new Promise((t11) => setTimeout(t11, 100)), e10 = speechSynthesis.getVoices();
  i2 = e10.find((t11) => t11.name.includes("Microsoft Neerja")) || e10[0];
})();
function u(e10, t11) {
  let s18;
  return (...r9) => {
    clearTimeout(s18), s18 = setTimeout(() => e10(...r9), t11);
  };
}
__name(u, "u");
j(u, "debounce");
function p(e10) {
  let t11 = new SpeechSynthesisUtterance(e10);
  return t11.voice = i2, t11.volume = 1, new Promise((s18) => {
    t11.onend = () => s18(), speechSynthesis.speak(t11);
  });
}
__name(p, "p");
j(p, "speakText");
function a(e10) {
  return e10.toLowerCase().trim();
}
__name(a, "a");
j(a, "normalizeText");
function l2(e10) {
  let t11 = [];
  (e10.match(/\{([^}]+)\}/g) || []).forEach((n11) => {
    let c21 = n11.slice(1, -1);
    t11.push(c21);
  });
  let r9 = e10.replace(/[.*+?^${}()|[\]\\]/g, (n11) => n11 === "{" || n11 === "}" ? n11 : "\\" + n11);
  return r9 = r9.replace(/\{[^}]+\}/g, "(.+?)"), { re: new RegExp(`^${r9}$`, "i"), keys: t11 };
}
__name(l2, "l");
j(l2, "templateToRegExp");

// node_modules/@mahindar5/common-lib/dist/chunk-AWQYXLUA.js
var a2 = j(() => {
  let e10 = new AudioContext();
  [[660, 0, 0.15], [880, 0.12, 0.22]].forEach(([r9, n11, i18]) => {
    let t11 = e10.createOscillator(), c21 = e10.createGain();
    t11.type = "sine", t11.frequency.setValueAtTime(r9, e10.currentTime + n11), c21.gain.setValueAtTime(0.7, e10.currentTime + n11), c21.gain.exponentialRampToValueAtTime(1e-3, e10.currentTime + n11 + i18), t11.connect(c21).connect(e10.destination), t11.start(e10.currentTime + n11), t11.stop(e10.currentTime + n11 + i18);
  });
}, "playRecognitionSound");

// node_modules/@mahindar5/common-lib/dist/chunk-CZNGPV4D.js
var u2 = class {
  static {
    __name(this, "u");
  }
  static {
    j(this, "VoiceCommandService");
  }
  commands = /* @__PURE__ */ new Map();
  adapter;
  config;
  nextId = 1;
  constructor(t11) {
    this.config = t11, this.adapter = t11.adapter, t11.autoStart !== false && this.start();
  }
  start() {
    this.adapter.start((t11, e10) => this.handleSpeechResult(t11, e10), (t11) => console.error("Speech adapter error:", t11));
  }
  stop() {
    this.adapter.stop();
  }
  isListening() {
    return this.adapter.isListening();
  }
  registerCommand(t11) {
    let e10 = t11.id || `cmd_${this.nextId++}`, n11 = { ...t11, id: e10, priority: t11.priority ?? 0, enabled: t11.enabled ?? true, maxWords: t11.maxWords ?? 2 };
    return this.commands.set(e10, n11), e10;
  }
  unregisterCommand(t11) {
    return this.commands.delete(t11);
  }
  unregisterNamespace(t11) {
    let e10 = 0;
    for (let [n11, r9] of this.commands) r9.namespace === t11 && (this.commands.delete(n11), e10++);
    return e10;
  }
  listCommands(t11) {
    return Array.from(this.commands.values()).filter((e10) => !t11 || e10.namespace === t11);
  }
  async dispatch(t11, e10) {
    let n11 = a(t11), r9 = this.findMatches(n11);
    if (r9.length === 0) {
      this.config.onNoMatch?.({ text: n11, originalText: t11 });
      return;
    }
    a2();
    let a22 = Math.max(...r9.map((o21) => o21.command.priority || 0)), d15 = r9.filter((o21) => (o21.command.priority || 0) === a22);
    for (let o21 of d15) {
      let i18 = { text: n11, matches: o21.matches, event: e10, command: o21.command };
      try {
        await o21.command.handler(i18);
      } catch (m18) {
        console.error(m18);
      }
    }
  }
  handleSpeechResult(t11, e10) {
    this.dispatch(t11, e10);
  }
  findMatches(t11) {
    let e10 = [], n11 = t11.split(" ").length, r9 = t11.toLowerCase().replace(/[^a-z0-9]/g, "");
    for (let a22 of this.commands.values()) {
      if (!a22.enabled) continue;
      let d15 = a22.maxWords ?? 2;
      if (n11 > d15) continue;
      let o21 = [a22.pattern, ...a22.aliases || []].filter(Boolean), i18 = false, m18 = {};
      for (let c21 of o21) {
        if (i18) break;
        let s18 = null;
        if (typeof c21 == "string") {
          let C3 = c21.toLowerCase().replace(/[^a-z0-9]/g, "");
          if (r9.includes(C3)) s18 = [t11], i18 = true;
          else {
            let { re: x3, keys: l14 } = l2(c21);
            s18 = t11.match(x3), s18 && l14.length > 0 && (l14.forEach((v8, y12) => {
              m18[v8] = s18[y12 + 1] || "";
            }), i18 = true);
          }
        } else s18 = t11.match(c21), s18 && (i18 = true);
      }
      i18 && e10.push({ command: a22, matches: m18 });
    }
    return e10;
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-K7VO445L.js
function R() {
  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
__name(R, "R");
j(R, "generateRequestId");
function T(u20, t11, r9, s18, a22, c21) {
  let g10 = { requestId: R(), serviceName: u20, methodName: t11, args: r9, target: c21 };
  return new Promise(async (p15, e10) => {
    let n11 = setTimeout(() => {
      e10(new Error(`RPC timeout: ${u20}.${t11} after ${s18}ms`));
    }, s18);
    try {
      let o21 = await a22(g10, s18);
      clearTimeout(n11), o21.success ? p15(o21.result) : e10(new Error(o21.error || "RPC call failed"));
    } catch (o21) {
      clearTimeout(n11), e10(o21);
    }
  });
}
__name(T, "T");
j(T, "createRpcCall");
function m2(u20, t11, r9, s18) {
  if (t11.has(r9)) return t11.get(r9);
  let a22 = j((g10 = 5e3) => new Proxy({}, { get(p15, e10) {
    return e10 === "withTimeout" ? (n11) => a22(n11) : async (...n11) => T(r9, e10, n11, g10, u20, s18);
  } }), "createProxy"), c21 = a22();
  return t11.set(r9, c21), c21;
}
__name(m2, "m");
j(m2, "createRpcProxy");

// node_modules/@mahindar5/common-lib/dist/chunk-QVPBNTIT.js
var m3 = "pjgheakmmcejmgdoojlnjbgbafjoiedg", p2 = /* @__PURE__ */ new Map(), a3 = j((e10, o21) => new Promise((s18, c21) => {
  chrome.runtime.sendMessage(m3, { ...e10, target: "background" }, (t11) => {
    chrome.runtime.lastError ? c21(new Error(chrome.runtime.lastError.message)) : s18(t11 || { requestId: e10.requestId, success: false, error: "No response received" });
  });
}), "chromeBackgroundRpcTransport");
function R2(e10, o21 = "background") {
  return m2(a3, p2, e10, o21);
}
__name(R2, "R");
j(R2, "resolveChromeBackgroundRpc");

// node_modules/@mahindar5/common-lib/dist/chunk-YOSX3MAP.js
var y = j(() => {
  let c21 = window.fetch;
  window.fetch = async (o21, s18) => {
    if (new Headers(s18?.headers).get("my-org-extension")) {
      let d15 = typeof o21 == "string" ? o21 : o21 instanceof URL ? o21.href : o21.url;
      s18 && s18.headers && (s18.headers instanceof Headers ? s18.headers.delete("my-org-extension") : Array.isArray(s18.headers) ? s18.headers = s18.headers.filter(([h12]) => h12.toLowerCase() !== "my-org-extension") : typeof s18.headers == "object" && s18.headers !== null && delete s18.headers["my-org-extension"]);
      let e10 = await R2("FetchHelper").fetch(d15, s18), r9, t11 = e10.headers?.["Content-Type"] || e10.headers?.["content-type"] || "application/json";
      t11 = t11.trim().toLowerCase();
      let n11 = e10.headers?.["Content-Length"] || e10.headers?.["content-length"];
      return n11 && parseInt(n11) === 0 ? r9 = null : t11.includes("application/x-www-form-urlencoded") ? r9 = new URLSearchParams(e10.body).toString() : t11.includes("application/xml") || t11.includes("text/xml") ? r9 = new DOMParser().parseFromString(e10.body, "text/xml") : t11.includes("application/json") ? r9 = JSON.stringify(e10.body) : t11.includes("text/") ? r9 = e10.body : t11.includes("application/octet-stream") || t11.includes("multipart/form-data") ? r9 = atob(e10.body) : r9 = e10.body, new Response(r9, { status: e10.status || 200, statusText: e10.statusText || "OK", headers: e10.headers || { "Content-Type": t11 }, url: e10.url });
    } else return c21(o21, s18);
  };
}, "fetchProxy");

// node_modules/@mahindar5/common-lib/dist/chunk-WVP4WJ5M.js
var l3 = ((n11) => (n11[n11.InMemory = 0] = "InMemory", n11[n11.LocalStorage = 1] = "LocalStorage", n11[n11.SessionStorage = 2] = "SessionStorage", n11[n11.IndexedDb = 3] = "IndexedDb", n11[n11.IndexedDbSession = 4] = "IndexedDbSession", n11[n11.Firestore = 5] = "Firestore", n11[n11.OPFSSqlLite = 6] = "OPFSSqlLite", n11[n11.IndexedDbSqlite = 7] = "IndexedDbSqlite", n11[n11.WaSqlite = 8] = "WaSqlite", n11[n11.ChromeExtensionStorage = 9] = "ChromeExtensionStorage", n11[n11.LocalFileSystem = 10] = "LocalFileSystem", n11))(l3 || {}), d = ((s18) => (s18.Gemini = "Gemini", s18.AnthropicClaude = "AnthropicClaude", s18.Codestral = "Codestral", s18.Mistral = "Mistral", s18.OpenRouter = "OpenRouter", s18.Groq = "Groq", s18.GithubVsc = "GithubVsc", s18.GithubModels = "GithubModels", s18))(d || {});

// node_modules/@mahindar5/common-lib/dist/chunk-5PITKWPZ.js
var a4 = class {
  static {
    __name(this, "a");
  }
  static {
    j(this, "OffscreenDocumentHelper");
  }
  playAudio(t11) {
    new Audio(t11).play();
  }
  getViewportSize() {
    let t11 = Math.round((window.screen.availHeight - 710) / 2), e10 = Math.round((window.screen.availWidth - 800) / 2);
    return { width: 800, height: 710, top: t11, left: e10 };
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-4HOYCII3.js
var n = /* @__PURE__ */ new Map();
function o(e10) {
  if (!n.has(e10)) throw new Error(`Service '${e10}' instance not found. Please create it first using resolveService.`);
  return n.get(e10);
}
__name(o, "o");
j(o, "resolveServiceByName");
function c2(e10, a22 = [], i18) {
  let t11 = i18 || e10.name;
  if (n.has(t11)) return n.get(t11);
  let s18 = new e10(...a22);
  return n.set(t11, s18), s18;
}
__name(c2, "c");
j(c2, "resolveService");
function u3(e10) {
  return n.has(e10);
}
__name(u3, "u");
j(u3, "hasServiceInstance");
function f() {
  return Array.from(n.keys());
}
__name(f, "f");
j(f, "getServiceInstanceNames");
function g(e10) {
  return n.delete(e10);
}
__name(g, "g");
j(g, "clearServiceInstance");
function l4() {
  n.clear();
}
__name(l4, "l");
j(l4, "clearAllServiceInstances");

// node_modules/@mahindar5/common-lib/dist/chunk-FDQCSBAS.js
var s = /* @__PURE__ */ new Map(), u4 = j((t11) => (e10, n11) => new Promise(async (c21, r9) => {
  let a22 = await chrome.tabs.query(t11);
  if (a22.length !== 1) {
    r9(new Error(`Expected exactly 1 tab, found ${a22.length}`));
    return;
  }
  let o21 = a22[0];
  if (!o21?.id || !o21.url) {
    r9(new Error("Tab has no ID or URL"));
    return;
  }
  chrome.tabs.sendMessage(o21.id, { ...e10, target: "contentscripts", targetUrl: o21.url }, (m18) => {
    chrome.runtime.lastError ? r9(new Error(chrome.runtime.lastError.message)) : c21(m18 || { requestId: e10.requestId, success: false, error: "No response received" });
  });
}), "createChromeContentRpcTransport");
function f2(t11, e10) {
  let n11 = `${t11}_${JSON.stringify(e10)}`;
  if (s.has(n11)) return s.get(n11);
  let c21 = u4(e10), r9 = m2(c21, s, t11, "contentscripts");
  return s.set(n11, r9), r9;
}
__name(f2, "f");
j(f2, "resolveChromeContentRpc");

// node_modules/@mahindar5/common-lib/dist/chunk-4WSCDX7V.js
async function y2(n11, r9 = {}) {
  let l14 = /* @__PURE__ */ new Date(), { requestId: g10, serviceName: e10, methodName: o21, args: m18, target: c21 } = n11, s18 = j((t11, a22, i18) => ({ requestId: g10, success: t11, result: a22, error: i18, target: c21, request: n11, timing: { startTime: l14.toLocaleString(), endTime: (/* @__PURE__ */ new Date()).toLocaleString(), durationSeconds: ((/* @__PURE__ */ new Date()).getTime() - l14.getTime()) / 1e3 } }), "createResponse");
  try {
    if (r9.allowedServices && !r9.allowedServices.includes(e10)) throw new Error(`Service '${e10}' not allowed`);
    if (r9.allowedMethods?.[e10] && !r9.allowedMethods[e10].includes(o21)) throw new Error(`Method '${o21}' not allowed for '${e10}'`);
    if (n11._routeToContent && n11._contentTabQuery) {
      let u20 = await f2(e10, n11._contentTabQuery)[o21](...m18 || []);
      return s18(true, u20);
    }
    if (r9.expectedTarget && c21 !== r9.expectedTarget) throw new Error(`Target mismatch: expected '${r9.expectedTarget}', got '${c21}'`);
    let t11 = o(e10), a22 = t11[o21];
    if (typeof a22 != "function") throw new Error(`Method not found: ${e10}.${o21}`);
    let i18 = await a22.apply(t11, m18 || []);
    return s18(true, i18);
  } catch (t11) {
    return s18(false, void 0, t11 instanceof Error ? t11.message : String(t11));
  }
}
__name(y2, "y");
j(y2, "handleRpcRequest");

// node_modules/@mahindar5/common-lib/dist/chunk-VUH7GPEL.js
var r = class {
  static {
    __name(this, "r");
  }
  static {
    j(this, "ChromeTabHelper");
  }
  ChromeTab_StorageKey = "ChromeTab_key";
  saveItem(e10, a22) {
    chrome.storage.local.set({ [e10]: a22 });
  }
  async getItem(e10) {
    return (await chrome.storage.local.get([e10]))[e10] || null;
  }
  async muteTab(e10) {
    let a22 = await chrome.tabs.query(e10), t11 = a22.find((s18) => s18.audible) || a22[0];
    t11?.id && !t11.mutedInfo?.muted && await chrome.tabs.update(t11.id, { muted: true });
  }
  async unMuteTab(e10) {
    let a22 = await chrome.tabs.query(e10), t11 = a22.find((s18) => s18.audible) || a22[0];
    t11?.id && t11.mutedInfo?.muted && t11.mutedInfo?.reason !== "user" && await chrome.tabs.update(t11.id, { muted: false });
  }
  async handleMessage(e10, a22, t11, s18) {
    let i18 = await y2(e10, { expectedTarget: s18 });
    t11(i18);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-7MAUBKY7.js
var a5 = class {
  static {
    __name(this, "a");
  }
  static {
    j(this, "OffscreenDocumentListener");
  }
  chromeTabHelper = c2(r);
  constructor() {
    this.onMessage();
  }
  onMessage() {
    chrome.runtime.onMessage.addListener((e10, t11, i18) => {
      if (e10.target === "offscreen") return this.chromeTabHelper.handleMessage(e10, t11, i18, "offscreen"), true;
    });
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-QL4T24EN.js
var a6 = ["ibomma", "p22", "iradha", "shaadi", "matrimony", "jeevansathi", "xdiv", "crichd", "telugu-movie", "patri"], s2 = class {
  static {
    __name(this, "s");
  }
  static {
    j(this, "CommonSite");
  }
  constructor() {
    let t11 = window;
    t11.addEventListenerPaste = this.addEventListenerPaste.bind(this), t11.runScriptEval = this.runScript.bind(this, true), t11.runScriptAppend = this.runScript.bind(this, false), a6.some((e10) => window.location.href.includes(e10)) && this.enableSiteFeatures();
  }
  enableSiteFeatures() {
    document.body.oncontextmenu = null, document.querySelectorAll('[oncontextmenu="return false"]').forEach((t11) => {
      t11.oncontextmenu = null, t11.addEventListener("contextmenu", (e10) => e10.stopPropagation(), true);
    }), ["onselectstart", "ondragstart", "oncontextmenu"].forEach((t11) => {
      document.body[t11] = null;
    }), window.addEventListener("keydown", (t11) => t11.ctrlKey && t11.stopPropagation(), true), window.addEventListener("contextmenu", (t11) => t11.stopPropagation(), true);
    try {
      let t11 = window;
      t11.$ && t11.$(document).off("cut copy paste");
    } catch {
    }
    ["shaadi"].every((t11) => !window.location.href.includes(t11)) && (window.open = () => null);
  }
  addEventListenerPaste() {
    window.addEventListener("paste", async (t11) => {
      let e10 = t11.clipboardData?.files[0];
      e10?.type === "text/javascript" && this.runScript(false, e10);
    });
  }
  async runScript(t11, e10) {
    if (!e10 && "showOpenFilePicker" in window) {
      let n11 = window;
      if (n11.showOpenFilePicker) {
        let [r9] = await n11.showOpenFilePicker({ id: t11 ? "runScriptEval" : "runScriptAppend" });
        e10 = await r9.getFile();
      }
    }
    if (!e10) return null;
    let i18 = await e10.text();
    if (console.log(`******* Start ${e10.name} *******`), !t11) {
      let n11 = document.createElement("script");
      n11.textContent = i18, (document.head || document.documentElement).appendChild(n11), n11.remove();
    }
    return console.log(`******* End ${e10.name} *******`), i18;
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-HF3YSR5Q.js
var a7 = class {
  static {
    __name(this, "a");
  }
  static {
    j(this, "GCKeyHelper");
  }
  constructor() {
    this.setupLogin();
  }
  setupLogin() {
    this.autoFillCredentials(), this.autoClickContinue();
  }
  autoFillCredentials() {
    setTimeout(() => {
      this.handleLogin("ircc-tracker-suivi.apps.cic.gc.ca/en/login", { uci: "#uci", password: "#password" }, "#sign-in-btn");
    }, 1e3), this.handleLogin("clegc-gckey.gc.ca/j/eng/l", { username: "#token1", password: "#token2" }, '#button[type="submit"][title="Connect to the GCKey service"]');
  }
  handleLogin(t11, e10, n11) {
    if (!window.location.href.includes(t11)) return;
    Object.entries(e10).forEach(([o21, r9]) => {
      let s18 = localStorage.getItem(o21), u20 = document.querySelector(r9);
      s18 && u20 && (u20.value = s18, u20.focus()), u20 && this.attachInputListener(u20, o21);
    });
    let i18 = Object.values(e10).every((o21) => document.querySelector(o21)?.value), c21 = document.querySelector(n11);
    i18 && c21 && c21.click();
  }
  attachInputListener(t11, e10) {
    t11.addEventListener("input", () => {
      localStorage.setItem(e10, t11.value);
    });
  }
  autoClickContinue() {
    [{ urlPart: "we?execution", selector: "#continue" }, { urlPart: "mfaui/account", selector: "#continue-btn" }, { urlPart: "termsAndConditions", selector: "#_continue" }, { urlPart: "askSecurityQuestion", selector: "#_continue", handleQuestion: true }, { urlPart: "mfaui/l/authenticate", selector: "#continue-btn", handleCodeInput: true }].forEach(({ urlPart: e10, selector: n11, handleQuestion: i18, handleCodeInput: c21 }) => {
      if (window.location.href.includes(e10)) {
        if (i18 && this.handleSecurityQuestion(), c21) {
          this.handleCodeInputFocusAndSubmit(n11);
          return;
        }
        let o21 = document.querySelector(n11);
        o21 && o21.click();
      }
    });
  }
  handleCodeInputFocusAndSubmit(t11) {
    let e10 = document.querySelector("#code");
    e10 && (e10.focus(), e10.addEventListener("input", () => {
      if (e10.value.length === 6) {
        let n11 = document.querySelector(t11);
        n11 && n11.click();
      }
    }));
  }
  handleSecurityQuestion() {
    let t11 = document.querySelector(".question-label"), e10 = document.querySelector("#answer");
    if (!t11 || !e10) return;
    let n11 = { "goal?": "canadapr", "web browser?": "chromium", "media server?": "plex", "favorite color?": "dark" };
    Object.keys(n11).forEach((i18) => {
      t11.innerText.includes(i18) && (e10.value = n11[i18]);
    });
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-UYQXPWCZ.js
var l5 = class {
  static {
    __name(this, "l");
  }
  static {
    j(this, "IcmService");
  }
  aliasToIdMap = /* @__PURE__ */ new Map();
  icmToken = null;
  async fetchAccessToken() {
    let n11 = this.icmToken, e10 = /* @__PURE__ */ new Date();
    if (n11 && e10 < new Date(n11.expiration)) return n11.token;
    let t11 = await fetch("https://portal.microsofticm.com/sso2/token", { method: "POST", body: "grant_type=cookie" });
    if (!t11.ok) throw new Error("Failed to fetch access token");
    let i18 = await t11.json(), o21 = new Date(e10.getTime() + i18.expires_in * 1e3).toString();
    return this.icmToken = { token: i18.access_token, expiration: o21 }, i18.access_token;
  }
  async getApiData(n11, e10, t11, i18 = null) {
    let o21 = "https://prod.microsofticm.com/api2", a22 = "(  ((OwningTeamId eq 27736) or (OwningServiceId eq 25494 or OwningServiceId eq 26132 or OwningServiceId eq 26384 or OwningServiceId eq 26538 or OwningServiceId eq 26922 or OwningServiceId eq 30233 or OwningServiceId eq 31957 or OwningServiceId eq 34535 or OwningServiceId eq 37014))  and (State eq 'Active') and IsAcknowledged eq false)", r9 = { icmCount: `${o21}/incidentapi/IncidentCount?$filter=${encodeURIComponent(a22)}`, incidents: `${o21}/incidentapi/incidents?$filter=${encodeURIComponent(a22)}&$orderby=ContactAlias asc&$top=100&$select=Id,Severity,State,Title,CreatedDate,OwningTenantName,OwningTeamName,ContactAlias,NotificationStatus,HitCount,ChildCount,OwningServiceId,OwningTeamId,AcknowledgeBy,ParentId,IsCustomerImpacting,IsNoise,IsOutage,ExternalLinksCount,CustomFields,RoutingId,RootCause,MonitorName,CorrelationId,MonitorId&$expand=CustomFields,AlertSource`, incidentDetails: `${o21}/incidentapi/incidents(${e10})/GetIncidentDetails?$expand=Attachments,CustomFields,ImpactedServices,ImpactedComponents,ImpactedTeams,AlertSource,RootCause,TrackingTeams,RepairItems,Bridges,Channels,AccessRestrictedToClaims`, outageDetails: `${o21}/user/incidents/${e10}/OutageTimeline`, historyEntries: `${o21}/incidentapi/incidents(${e10})/HistoryEntries`, descriptionEntries: `${o21}/incidentapi/incidents/${e10}/getdescriptionentries?$top=100`, userLookup: `https://portal.microsofticm.com/imp/api/contact/Contacts?categoryId=0&serviceId=0&teamId=0&isSearchByKeyword=true&keyword=${encodeURIComponent(i18)}&take=50&skip=0&order%5Bcolumn%5D=FullName&order%5Bdir%5D=asc` }[t11];
    if (!r9) throw new Error("Invalid type provided");
    let c21 = await fetch(r9, { method: "GET", headers: { Authorization: `Bearer ${n11}` } });
    if (c21.status === 401) {
      await this.fetchAccessToken();
      return;
    }
    return { data: await c21.json(), type: t11, incidentId: e10, alias: i18 };
  }
  async getFullIncidentDetails(n11, e10 = ["incidentDetails", "descriptionEntries"]) {
    let t11 = await this.fetchAccessToken();
    if (!t11) throw new Error("Failed to fetch access token");
    return await Promise.all(n11.map(async (o21) => Object.fromEntries(await Promise.all(e10.map(async (a22) => {
      let s18;
      try {
        s18 = await this.getApiData(t11, o21, a22);
      } catch (r9) {
        console.error(`Failed to get incident data for ID ${o21} and type ${a22}:`, r9), s18 = null;
      }
      return [a22, s18];
    })))));
  }
  async acknowledgeIncident(n11, e10) {
    let t11 = await fetch("https://portal.microsofticm.com/imp/api/incident/Acknowledge", { method: "POST", headers: { "content-type": "application/json", Authorization: `Bearer ${n11}` }, body: JSON.stringify({ incidentIds: [e10] }) });
    if (!t11.ok) throw new Error(`Failed to acknowledge incident ${e10}: ${t11.status} ${t11.statusText}`);
  }
  async assignIncident(n11, e10, t11) {
    let i18 = await this.getUserIdByAlias(n11, t11), o21 = await fetch("https://prod.microsofticm.com/api2/incidentapi/BulkEditIncident", { method: "POST", headers: { authorization: `Bearer ${n11}`, "content-type": "application/json" }, body: JSON.stringify({ incidentandstate: [{ Id: e10, State: "ACTIVE" }], bulkeditrequest: { AssignedTo: i18 } }) });
    if (!o21.ok) throw new Error(`Failed to assign incident ${e10} to ${t11}: ${o21.status} ${o21.statusText}`);
    console.log(`Successfully assigned incident ${e10} to ${t11}`);
  }
  async getUserIdByAlias(n11, e10) {
    let t11 = e10.toLowerCase();
    if (this.aliasToIdMap.has(t11)) return this.aliasToIdMap.get(t11);
    let i18 = await this.getApiData(n11, null, "userLookup", e10), a22 = (i18?.data?.ItemSet || i18?.data)?.find((r9) => r9.Alias?.toLowerCase() === e10.toLowerCase() || r9.AliasShort?.toLowerCase() === e10.toLowerCase());
    if (!a22) throw new Error(`User with alias ${e10} not found`);
    let s18 = a22.ContactId || a22.Id;
    return this.aliasToIdMap.set(t11, s18), s18;
  }
  getPSTDate() {
    let n11 = /* @__PURE__ */ new Date();
    return new Date(n11.toLocaleString("en-US", { timeZone: "America/Los_Angeles" }));
  }
  formatDateAsYYYYMMDD(n11) {
    let e10 = n11.getFullYear(), t11 = (n11.getMonth() + 1).toString().padStart(2, "0"), i18 = n11.getDate().toString().padStart(2, "0");
    return parseInt(`${e10}${t11}${i18}`);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-SXIROMAC.js
var m4 = c2(l5), g2 = class {
  static {
    __name(this, "g");
  }
  static {
    j(this, "IcmBusinessService");
  }
  isSystemIcm(e10) {
    return e10?.MonitorId || e10?.Severity == 25 || e10?.Severity == 2 || !e10?.RoutingId?.toLowerCase().startsWith("icmportal") || e10?.Title?.toLowerCase().includes("hs icm") || e10?.Title?.toLowerCase().startsWith("action required - ");
  }
  customAlias(e10) {
    return e10?.Title?.toLowerCase().includes("commerce.tms") ? "eliyahafzal" : null;
  }
  shouldAcknowledgeIncident(e10, t11) {
    let { enableAutoAcknowledge: a22, acknowledgeIfOwnerAlias: n11, startDate: s18, endDate: i18, startTimeOfDay: r9, endTimeOfDay: o21 } = t11;
    if (!a22 || !s18 || !i18 || !r9 || !o21 || e10.Severity < 2 || e10?.Title?.toLowerCase().includes("jit") || e10?.OwningTenantName?.toLowerCase().includes("commerce shopper service") || n11 && (!e10?.ContactAlias || e10.ContactAlias.toLowerCase() !== n11.toLowerCase())) return false;
    let d15 = m4.getPSTDate(), l14 = m4.formatDateAsYYYYMMDD(d15), c21 = parseInt(s18), p15 = parseInt(i18);
    if (l14 < c21 || l14 > p15) return false;
    let u20 = d15.getHours() * 60 + d15.getMinutes(), [C3, I4] = r9.split(":").map(Number), [D6, w4] = o21.split(":").map(Number), f13 = C3 * 60 + I4, T6 = D6 * 60 + w4;
    return u20 >= f13 && u20 < T6;
  }
  shouldAssignIncident(e10, t11, a22, n11) {
    if (n11.has(e10.Id)) return false;
    let s18 = a22 ? t11.assignmentAliasSystem : t11.assignmentAliasRegular;
    return s18 && s18.trim() !== "";
  }
  static download(e10, t11) {
    let a22 = new Blob([t11], { type: "text/plain" }), n11 = window.URL.createObjectURL(a22), s18 = document.createElement("a");
    s18.href = n11, s18.download = e10, document.body.appendChild(s18), s18.click(), document.body.removeChild(s18), window.URL.revokeObjectURL(n11);
  }
  static getDomText(e10) {
    return new DOMParser().parseFromString(e10, "text/html").body.textContent || "";
  }
  static formatIncidentDetails(e10, t11) {
    let a22 = { id: e10.incidentDetails.incidentId, CreatedBy: e10.incidentDetails.data.CreatedBy, CreatedDate: e10.incidentDetails.data.CreatedDate, HowFixed: e10.incidentDetails.data.HowFixed, Summary: this.getDomText(e10.incidentDetails.data.Summary), MitigatedBy: e10.incidentDetails.data.MitigateData.MitigatedBy, MitigationSteps: this.getDomText(e10.incidentDetails.data.MitigateData.MitigationSteps), Title: e10.incidentDetails.data.Title }, n11 = "alayameka,amanagarwal,aswinaravind,avniga,ayushigoel,bharatgv,chandrasekhar.pasumarthi,christjo,cstidc,eliyahafzal,jinhtang,jobeidat,juanarias,kamath,kudwived,lannampeduba,lravinutala,maazizi,manojma,mmaqsood,naisrael,pabarli,popugazh,prabset,pvatsavai,rajalipa,ravi.s.gupta,ryanlinton,saiprakash.revuri,satyaboddu,satyakhichi,sivali,skesamoni,skorukonda,srisaha,tisharma,v-agrawalsi,v-akmui,v-anawa,v-anupurohit,v-arcmis,v-ashtr,v-aygurram,v-basemo,v-bbilavendr,v-chrramos,v-deepakomar,v-gnagare,v-harioms,v-harkesingh,v-kimel,v-kkatiyar,v-kvinayak,v-lakgad,v-lupole,v-mabore,v-manesingh,v-mealuri,v-moshukla,v-prapuvvada,v-prkovu,v-ramshukla,v-raneyy,v-rsoni,v-sagargupta,v-saginhotri,v-sairev,v-samestry,v-sangdu,v-sanjeevch,v-sgadangi,v-shahrkhan,v-shilpia,v-shivjkumar,v-shraddhar,v-shregoyal,v-sibbehera,v-sishikhar,v-soharitha,v-spramudala,v-srikarp,v-sumanrodda,v-syenuganti,v-tkatiyar,v-tumreddy,v-udahate,v-vaprad,v-vermakajal,v-vijsat,v-vnalagangu,v-vuhoang,viju.sathiyadas,viven".split(",").map((i18) => i18.trim().toLowerCase()).filter((i18) => i18) || [], s18 = e10.descriptionEntries.data.Items.reverse().filter((i18) => n11.includes(i18.ChangedBy) || n11.length === 0).map((i18) => ({ ChangedBy: i18.ChangedBy, ChangedByDisplayName: i18.ChangedByDisplayName, Date: i18.Date, Text: this.getDomText(i18.Text) }));
    return { incidentDetails: a22, descriptionEntries: s18 };
  }
  static formatIncidentText({ incidentDetails: e10, descriptionEntries: t11 }, a22 = false) {
    let n11 = t11.map((s18) => `${s18.ChangedBy} commented on ${s18.Date}
${s18.Text}`).join(`

`);
    return `
## Incident Overview:
IncidentId: ${e10.id}
Title: ${e10.Title}
CreatedBy: ${e10.CreatedBy} ${e10.CreatedDate}

### Summary:
${e10.Summary}

### Comments:
${n11}
		`;
  }
  static generateAIAssistanceRequest(e10) {
    return `
--- Service Ownership Information ---
## My Service Team Names:
Azure CST (C+E)
Azure CMAT - Commerce Support Agent Tool (C+E)

==============================================================================================================================

--- AI Assistance Requested ---

## AI Assistance Requested - How Has My Team Handled Similar ICMs?

### Problem:
We are encountering the issue described in the source incident details provided above?

### Request:
For each incident ID specified below, please provide the following information:

1. Role of My Team ((Azure CST (C+E)) or (Azure CMAT - Commerce Support Agent Tool (C+E))):

1.1. What was my team's role in these incidents?
1.2. Did my team mitigate or transfer the incident?
1.2.1. If mitigated, what were the specific mitigation steps taken?
1.2.2. If transferred, to which team was it transferred, and what actions or requests did they make to that team?

2. Relevance to Source Incident:

2.1. Is this incident actually related to the source incident provided?
`;
  }
  async processIncidentsForJob(e10, t11, a22) {
    let n11 = await m4.fetchAccessToken();
    if (!n11) throw new Error("Failed to fetch access token");
    let s18 = [], i18 = null;
    try {
      await Promise.all(e10.map(async (r9) => {
        try {
          let o21 = this.isSystemIcm(r9), d15 = [];
          if (this.shouldAcknowledgeIncident(r9, t11.inputs) && (await m4.acknowledgeIncident(n11, r9.Id), d15.push("acknowledged"), this.shouldAssignIncident(r9, t11.inputs, o21, a22))) {
            let l14 = o21 ? t11.inputs.assignmentAliasSystem : t11.inputs.assignmentAliasRegular, c21 = this.customAlias(r9);
            l14 && (await m4.assignIncident(n11, r9.Id, c21 || l14), d15.push("assigned"));
          }
          s18.push({ incidentId: r9.Id, status: "processed", actions: d15.length > 0 ? d15 : ["no action needed"], isSystemIcm: o21 });
        } catch (o21) {
          console.error(`Error processing incident ${r9.Id}:`, o21), s18.push({ incidentId: r9.Id, status: "error", error: o21?.message });
        }
      }));
    } catch (r9) {
      i18 = r9, console.error("Error processing incidents:", r9);
    }
    return { processedIncidents: s18, totalProcessed: s18.length, error: i18?.message };
  }
  generateOutageDetails(e10, t11) {
    return e10?.map((a22) => {
      let n11 = t11?.find((c21) => c21.Id === a22?.incidentId), s18 = this.isSystemIcm(n11), i18 = (/* @__PURE__ */ new Date()).getTime() - new Date(n11.CreatedDate).getTime(), r9 = Math.floor(i18 / (1e3 * 60 * 60 * 24)), o21 = Math.floor(i18 % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60)), d15 = Math.floor(i18 % (1e3 * 60 * 60) / (1e3 * 60)), l14 = `${r9 > 0 ? `${r9}D ` : ""}${o21 > 0 ? `${o21}H ` : ""}${d15}m`;
      return { id: a22?.incidentId, severity: n11.Severity, createDate: n11.CreatedDate, daysActive: l14, isSystemIcm: s18, cstCount: a22?.data?.IncidentTransfers?.filter((c21) => c21.OwningTeam.DisplayName.includes("CST") || c21.OwningTeam.DisplayName.includes("CMAT")).length || 0, activateCount: a22?.data?.IncidentStateChanges?.filter((c21) => c21.ChangeCategory === "Activate").length || 0, severityChanges: a22?.data?.SeverityChanges?.map((c21) => c21.Severity).join("->") || "", requestAssistancesCount: a22?.data?.RequestAssistances?.length || 0 };
    }) || [];
  }
  formatOutageMessage(e10, t11 = true) {
    return e10.map((a22) => `${a22.isSystemIcm ? "Sys-:" : ""}${t11 ? "" : a22.id} (CST: ${a22.cstCount}, S: ${a22.severityChanges || a22.severity}, D: ${a22.daysActive}, A: ${a22.activateCount}, A: ${a22.requestAssistancesCount})`).join(`
`);
  }
  formatDetailedOutageMessage(e10) {
    return e10.map((t11) => `${t11.id}: (CST: ${t11.cstCount}, Severity: ${t11.severityChanges || t11.severity}, Days Active: ${t11.daysActive}, ActivateCount: ${t11.activateCount}, Assistances: ${t11.requestAssistancesCount})`).join(`
`);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-ELBH5WMR.js
var f3 = class {
  static {
    __name(this, "f");
  }
  static {
    j(this, "OutlookSearchInterceptor");
  }
  incidentIds = [];
  cvid = null;
  constructor() {
    this.interceptFetchCalls();
  }
  interceptFetchCalls() {
    let t11 = window.fetch;
    window.fetch = async (o21, e10) => {
      if ((typeof o21 == "string" ? o21 : o21 instanceof URL ? o21.href : o21.url).includes("https://outlook.office.com/searchservice/api/v2/query")) {
        let n11 = e10?.body ? JSON.parse(e10.body)?.Cvid : null;
        n11 !== this.cvid && (this.cvid = n11, this.incidentIds = []);
        let c21 = await t11(o21, e10);
        return await this.processResponse(c21), c21;
      }
      return t11(o21, e10);
    };
  }
  async processResponse(t11) {
    let e10 = (await t11.clone().json()).EntitySets.flatMap((n11) => n11.ResultSets?.flatMap((c21) => c21.Results?.filter((a22) => a22.Source.From.EmailAddress.Address === "becim@microsoft.com").flatMap((a22) => a22.Source.ConversationTopic))).filter((n11) => n11?.includes(": ID ")), s18 = [...new Set(e10.map((n11) => n11.match(/: ID (\d+)/i)?.[1]))].filter(Boolean);
    this.incidentIds = [.../* @__PURE__ */ new Set([...this.incidentIds, ...s18])].sort().reverse(), this.createUI(), this.updateDownloadButton();
  }
  createUI() {
    this.createTextBox("idCount", "Number of IDs to consider"), this.createTextBox("sourceIncidentId", "Source Incident ID"), this.createDownloadButton();
  }
  createTextBox(t11, o21) {
    if (document.getElementById(t11)) return;
    let e10 = document.createElement("input");
    e10.id = t11, e10.placeholder = o21, e10.autocomplete = "on", t11 === "idCount" && (e10.value = "5"), e10.style.cssText = `
			position: fixed;
			top: ${t11 === "idCount" ? "40px" : "0"};
			z-index: 9999;
			background-color: #fff;
			color: #000;
			padding: 7px;
			border-radius: 5px;
			font-size: 14px;
		`, e10.oninput = () => this.updateDownloadButton(), document.body.appendChild(e10);
  }
  createDownloadButton() {
    if (document.getElementById("downloadButton")) return;
    let t11 = document.createElement("button");
    t11.id = "downloadButton", t11.style.cssText = `
            position: fixed;
            top: 80px;
            z-index: 9999;
            background-color: #479ef5;
            color: #000;
            padding: 7px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        `, t11.onclick = () => this.downloadIncidentDetails(), document.body.appendChild(t11);
  }
  updateDownloadButton() {
    let t11 = document.getElementById("downloadButton"), e10 = document.getElementById("idCount")?.value, s18 = this.incidentIds.length, n11 = !e10 || isNaN(Number(e10)) || Number(e10) <= 0 || Number(e10) > s18;
    t11 && (t11.disabled = n11, t11.style.backgroundColor = n11 ? "#d3d3d3" : "#479ef5", t11.style.color = n11 ? "#a9a9a9" : "#000", t11.style.cursor = n11 ? "not-allowed" : "pointer", t11.innerText = `Download (${e10} of ${s18})`);
  }
  async downloadIncidentDetails() {
    let t11 = "pjgheakmmcejmgdoojlnjbgbafjoiedg", o21 = document.getElementById("idCount"), e10 = document.getElementById("sourceIncidentId"), s18 = parseInt(o21?.value || "0", 10), n11 = e10?.value, c21 = this.incidentIds.slice(0, s18);
    n11 && c21.unshift(n11);
    let r9 = await R2("IcmService").getFullIncidentDetails(c21, ["incidentDetails", "descriptionEntries"]), l14 = n11 ? r9.find((d15) => d15.incidentDetails.incidentId === n11) : null, u20 = l14 ? g2.formatIncidentText(g2.formatIncidentDetails(l14), true) : "", h12 = r9.filter((d15) => d15.incidentDetails.incidentId !== n11), m18 = "==============================================================================================================================", y12 = h12.map((d15) => g2.formatIncidentText(g2.formatIncidentDetails(d15))).join(`
${m18}
`), x3 = g2.generateAIAssistanceRequest(n11), g10 = `
--- Source Incident ---
${u20}
${u20 ? m18 : ""}
${x3}
`;
    g2.download(`ICM_AI_Assistance_source_${n11}.txt`, g10), g2.download(`Reference_Incidents_For_${n11}.txt`, y12);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-KAFGPC7J.js
function b(n11, e10, o21, r9) {
  e10[n11] = e10[n11] || /* @__PURE__ */ new Map(), e10[n11].set(o21, r9);
}
__name(b, "b");
j(b, "setArgIndex");
function t(n11, e10, o21) {
  b(t.name, n11, e10, o21);
}
__name(t, "t");
j(t, "DataKeyArgIndex");
function y3(n11, e10, o21) {
  b(y3.name, n11, e10, o21);
}
__name(y3, "y");
j(y3, "ForceUpdateArgIndex");
function u5(n11, e10, o21) {
  let r9 = u5.name;
  n11[r9] = n11[r9] || /* @__PURE__ */ new Map();
  let m18 = n11[r9], i18 = m18.get(e10) || [];
  m18.set(e10, [...i18, o21]);
}
__name(u5, "u");
j(u5, "DisplayArgIndexes");

// node_modules/@mahindar5/common-lib/dist/chunk-5CKTECZS.js
function g3(a22) {
  return function(r9, t11, o21) {
    let p15 = o21.value;
    o21.value = async function(...n11) {
      let { cacheService: y12, ttl: h12 } = a22, c21 = r9[t.name]?.get(t11), i18 = a22?.keyName ?? (typeof c21 == "number" ? n11[c21] : void 0);
      if (!i18) throw new Error("InstanceCacheLoader decorator: Please provide keyName either in params or as a method argument.");
      let s18 = r9[y3.name]?.get(t11), e10 = a22?.forceUpdate ?? (typeof s18 == "number" ? n11[s18] : void 0);
      return e10 = typeof e10 == "boolean" ? e10 : false, y12.getOrLoadItem(i18, () => p15.apply(this, n11), e10, h12);
    };
  };
}
__name(g3, "g");
j(g3, "InstanceCacheLoader");

// node_modules/@mahindar5/common-lib/dist/chunk-WPI4TBBI.js
var f4 = 48 * 60 * 60 * 1e3, a8 = 365 * 24 * 60 * 60 * 1e3, c3 = class {
  static {
    __name(this, "c");
  }
  constructor(t11) {
    this.service = t11;
  }
  static {
    j(this, "DirectCacheService");
  }
  async setItem(t11, e10, r9 = a8, i18 = true) {
    if (e10 == null || typeof e10 == "string" && !e10.trim() || Array.isArray(e10) && e10.length === 0) {
      console.error(`[${this.service.constructor.name}] key: ${t11}, value: ${JSON.stringify(e10)}: Invalid Data. Cannot save it`);
      return;
    }
    let n11 = Date.now() + r9, s18 = r9 > a8 - 1, m18 = i18 ? JSON.stringify({ value: e10, expires: n11, groupKey: void 0, persist: s18 }) : { value: e10, expires: n11, groupKey: void 0, persist: s18 };
    await this.service.setItem(t11, m18);
  }
  async removeItem(t11) {
    await this.service.removeItem(t11);
  }
  async getItem(t11, e10 = true) {
    let r9 = await this.service.getItem(t11);
    if (!r9) return;
    let i18 = e10 ? JSON.parse(r9) : r9;
    if (i18.expires >= Date.now()) return i18.value;
    i18.persist || await this.removeItem(t11);
  }
  async getOrLoadItem(t11, e10, r9 = false, i18 = a8) {
    if (!r9) {
      let s18 = await this.getItem(t11);
      if (s18 !== void 0) return s18;
    }
    let n11 = await e10();
    return await this.setItem(t11, n11, i18), n11;
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-U3XU6X3M.js
var o2 = class {
  static {
    __name(this, "o");
  }
  static {
    j(this, "LocalStorageCacheService");
  }
  async setItem(e10, m18) {
    localStorage.setItem(e10, m18);
  }
  async removeItem(e10) {
    localStorage.removeItem(e10);
  }
  async getItem(e10) {
    return localStorage.getItem(e10);
  }
}, n2 = c2(c3, [c2(o2)], "localStorageService");
function v(c21) {
  return g3({ ...c21, cacheService: n2 });
}
__name(v, "v");
j(v, "LocalStorageCacheLoader");

// node_modules/@mahindar5/common-lib/dist/chunk-YQCEXHGA.js
var p3 = class s3 {
  static {
    __name(this, "s");
  }
  static {
    j(this, "VolumeBooster");
  }
  static STORAGE_KEY = "volumeBoosterValue";
  constructor() {
    this.init(), setInterval(() => this.init(), 2e3);
  }
  async init() {
    let o21 = document.querySelector("video"), c21 = document.querySelector("#volume-booster-ui");
    if (!o21 && c21) return c21.remove();
    if (!o21 || c21) return;
    let t11;
    o21.addEventListener("play", async () => {
      setTimeout(async () => {
        let n11 = new (window.AudioContext || window.webkitAudioContext)(), m18 = n11.createMediaElementSource(o21);
        t11 = n11.createGain(), m18.connect(t11).connect(n11.destination);
        let v8 = await n2.getItem(s3.STORAGE_KEY);
        t11 && (t11.gain.value = +(v8 ?? "1"));
      }, 100);
    }, { once: true });
    let e10 = document.createElement("div");
    e10.id = "volume-booster-ui", Object.assign(e10.style, { position: "fixed", bottom: "10px", left: "10px", zIndex: "9999", display: "flex", gap: "5px", alignItems: "center", opacity: "0.1", transition: "opacity 0.3s" });
    let i18 = Object.assign(document.createElement("input"), { type: "range", min: "0", max: "10", step: "0.01", value: "1" }), u20 = await n2.getItem(s3.STORAGE_KEY);
    u20 && (i18.value = u20);
    let r9 = Object.assign(document.createElement("button"), { textContent: "\u21BB", title: "Reset to 100%" });
    Object.assign(r9.style, { width: "30px", height: "30px", fontSize: "18px", cursor: "pointer", border: "1px solid #ccc", borderRadius: "4px", background: "#fff", color: "#333" });
    let l14 = j(async (n11) => {
      t11 && (t11.gain.value = +n11), await n2.setItem(s3.STORAGE_KEY, n11);
    }, "updateGain");
    i18.addEventListener("input", () => l14(i18.value)), r9.addEventListener("click", () => {
      i18.value = "1", l14("1");
    }), e10.addEventListener("mouseenter", () => e10.style.opacity = "1"), e10.addEventListener("mouseleave", () => e10.style.opacity = "0.1"), e10.append(i18, r9), document.body.appendChild(e10);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-7Q7UREUC.js
var i3 = j(() => !!(document.fullscreenElement || document.webkitFullscreenElement), "isFullscreen"), s4 = j((e10, n11) => {
  let t11 = document.getElementById(e10.id);
  if (n11 && !t11 && !i3()) {
    let o21 = Object.assign(document.createElement("button"), { id: e10.id, textContent: e10.text, onclick: e10.onclick });
    o21.style.cssText = `position:fixed;top:50px;right:${e10.right};z-index:2147483647;padding:8px;cursor:pointer;background:${e10.background};color:white;border:none;border-radius:4px;`, document.body.appendChild(o21);
  } else (!n11 || i3()) && t11 && t11.remove();
}, "manageButton"), d2 = j((e10) => e10.split(":").map(Number).reverse().reduce((n11, t11, o21) => n11 + t11 * 60 ** o21, 0), "tsToSec");

// node_modules/@mahindar5/common-lib/dist/chunk-3GB2ITE6.js
var l6 = class {
  static {
    __name(this, "l");
  }
  static {
    j(this, "YoutubeSortHelper");
  }
  apiHeaders;
  constructor() {
    this.apiHeaders = { credentials: "same-origin", headers: { "x-spf-referer": location.href, "x-youtube-client-name": "1", "x-youtube-client-version": (() => {
      let t11 = ytcfg.get("INNERTUBE_CONTEXT_CLIENT_VERSION");
      return t11.startsWith("1.") ? "2.20180308" : t11;
    })(), "x-youtube-identity-token": ytcfg.get("ID_TOKEN") } }, setInterval(() => this.checkButton(), 2e3);
  }
  checkButton() {
    let t11 = !!document.querySelector("a[href^='/watch']");
    s4({ id: "youtube-sort-btn", text: "Sort", background: "#666", right: "100px", onclick: j(() => this.main(), "onclick") }, t11);
  }
  async main() {
    if (!window.ytcfg || !ytcfg.get("ID_TOKEN")) {
      alert("You need to be on youtube.com and logged in to use YouTube sort.");
      return;
    }
    let t11 = [...new Set([...document.querySelectorAll("a[href^='/watch']")].filter((o21) => o21.offsetParent !== null).map((o21) => o21.href.match(/v=([-\w]+)/)?.[1]).filter(Boolean))], r9 = [];
    for (let o21 of t11) {
      if (!o21) continue;
      let d15 = localStorage.getItem(o21), i18;
      d15 ? i18 = JSON.parse(d15) : (i18 = (await (await fetch(`/watch?v=${o21}&pbj=1`, this.apiHeaders)).json()).playerResponse?.videoDetails, i18 && localStorage.setItem(o21, JSON.stringify(i18))), i18 && r9.push(i18);
      let s18 = `
				<main style="background:white;font-size:14px;font-family:Roboto,Arial,sans-serif;">
					<p>Processing videos: ${r9.length} out of ${t11.length}</p>
					<div><progress style="width:100%;" value="${r9.length}" max="${t11.length}"></progress></div>
				</main>
			`, e10 = window.trustedTypes?.createPolicy?.("youtube-sort", { createHTML: j((n11) => n11, "createHTML") });
      document.body.innerHTML = e10 ? e10.createHTML(s18) : s18;
    }
    window.videos = r9, this.renderTable(r9, "viewCount");
  }
  renderTable(t11, r9) {
    let i18 = `
			<table style="background:white;font-size:14px;font-family:Roboto,Arial,sans-serif;border-spacing:1em;">
				<thead>
					<tr>
						<th></th>
						<th style="cursor:pointer;border-bottom:1px solid;" onclick="window.youtubesort.sortAndRender('viewCount')">View count</th>
						<th style="cursor:pointer;border-bottom:1px solid;" onclick="window.youtubesort.sortAndRender('averageRating')">Average rating</th>
						<th></th>
						<th>Video</th>
					</tr>
				</thead>
				<tbody>${t11.sort((e10, n11) => Number(n11[r9]) - Number(e10[r9])).map((e10, n11) => `
			<tr>
				<td>${n11 + 1}</td>
				<td>${e10.viewCount}</td>
				<td>${Number(e10.averageRating).toFixed(2)}</td>
				<td><a href="/watch?v=${e10.videoId}" target="_blank"><img src="${e10.thumbnail.thumbnails[0].url}"></a></td>
				<td><a href="/watch?v=${e10.videoId}" target="_blank">${e10.title}</a></td>
			</tr>
		`).join("")}</tbody>
			</table>
		`, s18 = window.trustedTypes?.createPolicy?.("youtube-sort", { createHTML: j((e10) => e10, "createHTML") });
    document.body.innerHTML = s18 ? s18.createHTML(i18) : i18;
  }
  sortAndRender(t11) {
    this.renderTable(window.videos, t11);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-QZX2ECOY.js
var h3 = class {
  static {
    __name(this, "h");
  }
  static {
    j(this, "YoutubeTranscriptHelper");
  }
  activeLoop = null;
  constructor() {
    setInterval(() => {
      let n11 = !!document.querySelector("ytd-video-description-transcript-section-renderer #primary-button");
      if (s4({ id: "transcript-btn", text: "Transcript", background: "#666", right: "10px", onclick: j(() => this.openTranscript(), "onclick") }, n11), n11 && !document.getElementById("loop-delay-input") && !i3()) {
        let t11 = Object.assign(document.createElement("input"), { id: "loop-delay-input", type: "number", value: "0.4", min: "0.1", max: "10", step: "0.1", placeholder: "Sec" });
        t11.style.cssText = "position:fixed;top:10px;right:110px;width:40px;height:24px;font-size:12px;padding:2px;border:1px solid #ccc;border-radius:3px;z-index:9999;background:white;", document.body.appendChild(t11);
      } else (!n11 || i3()) && document.getElementById("loop-delay-input")?.remove();
    }, 2e3);
  }
  enhance = j((n11) => n11.querySelectorAll("ytd-transcript-segment-renderer").forEach((t11, a22) => {
    if (t11.querySelector(".yt-play-btn")) return;
    let r9 = t11.querySelector(".segment-timestamp");
    if (!r9) return;
    let l14 = j((x3 = false) => {
      this.activeLoop && (clearTimeout(this.activeLoop), this.activeLoop = null);
      let u20 = n11.querySelectorAll("ytd-transcript-segment-renderer"), g10 = d2(r9.textContent?.match(/\d+:\d+/)?.[0] || "0:0"), m18 = u20[a22 + 1] ? d2(u20[a22 + 1].querySelector(".segment-timestamp")?.textContent?.match(/\d+:\d+/)?.[0] || "0:0") : null, e10 = document.querySelector("video");
      if (e10 && (e10.h && e10.removeEventListener("timeupdate", e10.h), e10.currentTime = g10, e10.play(), m18)) {
        let b7 = parseFloat(document.getElementById("loop-delay-input")?.value || "1") * 1e3;
        e10.h = () => {
          e10.currentTime >= m18 && (e10.pause(), x3 && (this.activeLoop = setTimeout(() => i18.click(), b7)));
        }, e10.addEventListener("timeupdate", e10.h);
      }
    }, "playSegment"), p15 = Object.assign(document.createElement("button"), { textContent: "\u25B6", className: "yt-play-btn", onclick: j(() => l14(), "onclick") }), i18 = Object.assign(document.createElement("button"), { textContent: "\u{1F501}", className: "yt-loop-btn", onclick: j(() => l14(true), "onclick") }), d15 = "margin-right:4px;cursor:pointer;background:none;border:1px solid #ccc;padding:2px 6px;font-size:12px;";
    p15.style.cssText = d15, i18.style.cssText = d15, Object.assign(r9.style, { display: "flex", alignItems: "center" }), r9.insertBefore(p15, r9.firstChild), r9.insertBefore(i18, r9.firstChild);
  }), "enhance");
  openTranscript() {
    document.getElementById("transcript-btn")?.remove(), document.getElementById("loop-delay-input")?.remove(), document.querySelector("tp-yt-paper-button#expand")?.click(), setTimeout(() => {
      document.querySelector("ytd-video-description-transcript-section-renderer #primary-button button")?.click();
      let n11 = j(() => {
        let t11 = document.querySelector("ytd-transcript-segment-list-renderer");
        t11 ? (this.enhance(t11), new MutationObserver(() => this.enhance(t11)).observe(t11, { childList: true })) : setTimeout(n11, 500);
      }, "check");
      n11();
    }, 1e3);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-V5YV5R2J.js
var c4 = class {
  static {
    __name(this, "c");
  }
  static {
    j(this, "PcOptimumHelper");
  }
  constructor() {
    this.watchForPage("/offers", () => this.addSaveForNextWeekButtonsFromApi()), this.watchForPage("/points", () => this.getDetailedPoints());
  }
  watchForPage(t11, e10) {
    let o21 = setInterval(() => {
      location.href.includes(t11) && (e10(), clearInterval(o21));
    }, 1e3);
  }
  async addSaveForNextWeekButtonsFromApi() {
    try {
      let e10 = (await this.fetchApi("https://api.pcoptimum.ca/loyalty/bff-api/v2/view/offer-feed?pcid=fb1d5b88-f9f2-4f8f-8d8c-bf82e788aeb1&language=en-CA&minor=2.9", "GET")).layout.sections.mainContentCollection.components.find((n11) => n11.data?.headline === "Offers picked for you")?.data?.offers || [];
      if (!e10.length) return console.warn("No offers found in API response.");
      let o21 = this.createContainer(), r9 = this.createOfferList(e10);
      o21.appendChild(r9), document.body.insertBefore(o21, document.body.firstChild);
    } catch (t11) {
      console.error("Failed to fetch offers:", t11);
    }
  }
  createContainer() {
    let t11 = document.createElement("div");
    t11.style.cssText = "padding: 10px; background-color: #f0f0f0; border-radius: 8px; margin: 20px 0;";
    let e10 = document.createElement("h2");
    return e10.textContent = "Offers from API:", e10.style.cssText = "color: #002D7C; font-family: sans-serif; font-size: 1.2em; margin-bottom: 10px;", t11.appendChild(e10), t11;
  }
  createOfferList(t11) {
    let e10 = document.createElement("ul");
    return e10.style.cssText = "list-style: none; padding: 0; display: flex; flex-wrap: wrap; gap: 10px;", t11.forEach((o21) => {
      if (!o21.offerId) return;
      let r9 = this.createOfferItem(o21);
      e10.appendChild(r9);
    }), e10;
  }
  createOfferItem(t11) {
    let e10 = document.createElement("li");
    e10.style.cssText = "flex: 1 1 150px; padding: 5px; border: 1px solid #ddd; border-radius: 5px; background-color: #fff; text-align: center;";
    let o21 = t11.shoppingListItem?.props?.name || "No Title", r9 = t11.imageAssets?.smallUrl || t11.shoppingListItem?.props?.images || "https://via.placeholder.com/150";
    return e10.innerHTML = `
			<img src="${r9}" alt="${o21}" style="width: 100%; height: 100px; object-fit: contain; margin-bottom: 5px;">
			<h4 style="margin: 0; font-size: 0.9em; height: 3em; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${o21}</h4>
		`, e10.appendChild(this.createSaveButton(t11.offerId)), e10;
  }
  createSaveButton(t11) {
    let e10 = document.createElement("button");
    return Object.assign(e10, { textContent: "Save", className: "my-save-for-next-week", onclick: j((o21) => this.handleOfferClick(o21), "onclick") }), e10.setAttribute("offer-id", t11), e10.style.cssText = "width: 100%; background-color: #002D7C; color: white; border: none; padding: 5px; border-radius: 3px; cursor: pointer; margin-top: 5px; font-size: 0.8em;", e10;
  }
  getClientDateTime() {
    return (/* @__PURE__ */ new Date()).toISOString().slice(0, 19);
  }
  async fetchApi(t11, e10, o21) {
    let r9 = localStorage.getItem("loyalty.auth")?.slice(1, -1);
    if (!r9) throw new Error("Access token not found");
    let n11 = await fetch(t11, { method: e10, ...o21 && { body: o21 }, headers: { Authorization: `Bearer ${r9}`, "content-type": "application/json", "x-lcl-apikey": "HrqoeIWR3gU7UxQrSUQspGFBT1IrBaYU", "x-lcl-client-date-time": this.getClientDateTime() } });
    if (!n11.ok) throw new Error(`API failed: ${n11.status}`);
    return n11.json();
  }
  async handleOfferClick(t11) {
    let e10 = t11.target, o21 = e10.getAttribute("offer-id");
    if (!o21) {
      console.error("Offer ID not found on the button.");
      return;
    }
    try {
      let r9 = `https://api.pcoptimum.ca/loyalty/offers-api/v1/member/1168721053/offer/${o21}`, n11 = await this.fetchApi(r9, "PATCH", '{"status":"DEFERRED"}');
      return e10.textContent = "Saved!", e10.style.backgroundColor = "#28a745", e10.disabled = true, console.log(`Offer ${o21} successfully deferred.`), n11;
    } catch (r9) {
      throw e10.textContent = "Failed", e10.style.backgroundColor = "#dc3545", console.error(`Failed to defer offer ${o21}:`, r9), r9;
    }
  }
  async getPointEvents() {
    return this.fetchApi("https://api.pcoptimum.ca/loyalty/members-api/v2/member/point-events?memberId=1168721053&language=en-CA&offset=0&limit=100", "GET");
  }
  async getPointEvent(t11) {
    let e10 = `https://api.pcoptimum.ca/loyalty/members-api/v2/member/point-event?memberId=1168721053&pointEventId=${t11}&language=en-CA`;
    return this.fetchApi(e10, "GET");
  }
  async getDetailedPoints() {
    let { pointEvents: t11 } = await this.getPointEvents(), o21 = (await Promise.all(t11.map(({ id: r9 }) => this.getPointEvent(r9)))).sort((r9, n11) => new Date(n11.date).getTime() - new Date(r9.date).getTime()).reduce((r9, n11) => {
      let i18 = new Date(n11.date).toISOString().slice(0, 7).replace("-", "");
      return r9[i18] ??= {}, r9[i18][n11.id] = n11, r9;
    }, {});
    return console.log(o21), this.saveToFireStore(o21), o21;
  }
  async triggerJsonDownload(t11, e10) {
    let o21 = JSON.stringify(t11), r9 = new Blob([o21], { type: "application/json" }), n11 = URL.createObjectURL(r9), i18 = document.createElement("a");
    i18.href = n11, i18.download = e10 || "download", i18.click(), URL.revokeObjectURL(n11);
  }
  async saveToFireStore(t11) {
    let e10 = R2("FirestoreUtils");
    await Promise.all(Object.entries(t11).map(([o21, r9]) => e10.saveToFirestore("pcOptimumPoints", o21, r9)));
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-BHBV5IFY.js
var t2 = class {
  static {
    __name(this, "t");
  }
  static {
    j(this, "ReelsHelper");
  }
  observer;
  constructor() {
    this.observer = new MutationObserver((r9) => {
      r9.forEach((e10) => {
        e10.addedNodes.length && this.removeReelsElements();
      });
    }), this.init();
  }
  init() {
    this.removeReelsElements(), this.observer.observe(document.body, { childList: true, subtree: true });
  }
  removeReelsElements() {
    document.querySelectorAll('[aria-label="Reels"]').forEach((e10) => {
      e10.remove();
    });
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-O2WTSDIX.js
var m5 = class {
  static {
    __name(this, "m");
  }
  static {
    j(this, "SpotifyHelper");
  }
  videoElements;
  startAdInterval;
  spotifyAllowMuteTab_Key;
  SpotifyPlayBackRate_Key;
  chromeTabHelper = R2("ChromeTabHelper");
  constructor() {
    this.videoElements = [], this.startAdInterval = null, this.overrideCreateElement(), this.spotifyAllowMuteTab_Key = "spotifyAllowMuteTab", this.SpotifyPlayBackRate_Key = "spotifyPlayBackRate", this.init();
  }
  overrideCreateElement() {
    let e10 = document.createElement.bind(document);
    document.createElement = (t11, a22) => {
      let r9 = e10(t11, a22);
      return ["video", "audio"].includes(t11) && this.videoElements.push(r9), r9;
    };
  }
  changePlaybackRate(e10) {
    this.startAdInterval && clearInterval(this.startAdInterval), this.startAdInterval = e10 !== 1 ? setInterval(() => this.videoElements.forEach((t11) => t11.playbackRate = e10), 1e3) : null;
  }
  async queryAsync(e10) {
    return new Promise((t11, a22) => {
      let r9 = setInterval(() => {
        let n11 = document.querySelector(e10);
        n11 && (clearInterval(r9), t11(n11));
      }, 250);
      setTimeout(() => {
        clearInterval(r9), a22(new Error("player not found"));
      }, 1e3 * 120);
    });
  }
  async init() {
    let e10 = document.body.classList.contains("mobile-web-player"), t11 = e10 ? '[data-testid="floating-now-playing-bar"]' : '[data-testid="root"] [data-testid="now-playing-bar"]', a22 = await this.queryAsync(t11);
    window.nowPlayingBar = a22, new MutationObserver(() => this.handleAdChange(t11, e10)).observe(a22, { characterData: true, attributes: true, childList: e10, subtree: e10 });
  }
  handleAdChange(e10, t11) {
    (t11 ? document.querySelector(e10)?.innerHTML?.toLowerCase()?.includes("advertisement") : document.querySelector('footer[data-testid="now-playing-bar"][data-testadtype="ad-type-ad"]')) ? this.handleAdStart() : this.handleAdStop();
  }
  handleAdStart() {
    this.setPlaybackRate(), this.muteTab("muteTab");
  }
  handleAdStop() {
    this.changePlaybackRate(1), this.unMuteTab();
  }
  async setPlaybackRate() {
    let t11 = await this.chromeTabHelper.getItem(this.SpotifyPlayBackRate_Key) || 4;
    this.changePlaybackRate(t11);
  }
  async muteTab(e10) {
    await this.chromeTabHelper.getItem(this.spotifyAllowMuteTab_Key) && await this.chromeTabHelper.muteTab({ url: "https://open.spotify.com/*" });
  }
  async unMuteTab() {
    await this.chromeTabHelper.getItem(this.spotifyAllowMuteTab_Key) && await this.chromeTabHelper.unMuteTab({ url: "https://open.spotify.com/*" });
  }
  command(e10) {
    e10 === "next" ? this.skipForward() : e10 === "previous" ? this.skipBack() : e10 === "play" || e10 === "pause" ? this.playPause() : e10 === "seek" ? this.seekForwardBy10Percent() : e10 === "mute" ? this.muteTab() : e10 === "unmute" ? this.unMuteTab() : e10 === "backward" ? this.seekBackwardBy10Percent() : e10 === "forward" ? this.seekForwardBy10Percent() : e10 === "volumeup" ? this.seekVolumeUpBy10Percent() : e10 === "volumedown" ? this.seekVolumeDownBy10Percent() : console.error("Invalid command");
  }
  skipForward() {
    document.querySelector('[data-testid="control-button-skip-forward"]')?.click();
  }
  skipBack() {
    document.querySelector('[data-testid="control-button-skip-back"]')?.click(), setTimeout(() => {
      document.querySelector('[data-testid="control-button-skip-back"]')?.click();
    }, 100);
  }
  playPause() {
    document.querySelector('[data-testid="control-button-playpause"]')?.click();
  }
  seekForwardBy10Percent() {
    this.seekByPercentage("track", 0.1);
  }
  seekBackwardBy10Percent() {
    this.seekByPercentage("track", -0.1);
  }
  seekVolumeUpBy10Percent() {
    this.seekByPercentage("volume", 0.1);
  }
  seekVolumeDownBy10Percent() {
    this.seekByPercentage("volume", -0.1);
  }
  seekByPercentage(e10, t11) {
    let a22, r9, n11, c21;
    if (e10 === "track") {
      a22 = '[data-testid="now-playing-bar"] input[type="range"]', r9 = '[data-testid="now-playing-bar"] div[data-testid="progress-bar"]';
      let s18 = document.querySelector(a22);
      n11 = parseInt(s18?.max || "0", 10);
    } else if (e10 === "volume") {
      a22 = '[data-testid="volume-bar"] input[type="range"]', r9 = '[data-testid="volume-bar"] div[data-testid="progress-bar"]';
      let s18 = document.querySelector(a22);
      n11 = parseFloat(s18?.max || "1");
    } else {
      console.error("Invalid type specified for seeking.");
      return;
    }
    let i18 = document.querySelector(a22), l14 = document.querySelector(r9);
    if (i18 && l14) {
      c21 = parseFloat(i18.value);
      let s18 = Math.min(e10 === "track" ? c21 + n11 * t11 : Math.max(c21 + n11 * t11, 0), n11);
      i18.value = s18.toString();
      let o21 = l14.getBoundingClientRect(), u20 = e10 === "track" ? o21.left + o21.width * (s18 / n11) : o21.left + o21.width * s18, h12 = new PointerEvent("pointerdown", { bubbles: true, cancelable: true, clientX: u20, clientY: o21.top + o21.height / 2, pointerType: "mouse" }), y12 = new PointerEvent("pointerup", { bubbles: true, cancelable: true, clientX: u20, clientY: o21.top + o21.height / 2, pointerType: "mouse" });
      if (l14.dispatchEvent(h12), l14.dispatchEvent(y12), e10 === "volume") {
        let b7 = new Event("input", { bubbles: true }), v8 = new Event("change", { bubbles: true });
        i18.dispatchEvent(b7), i18.dispatchEvent(v8);
      }
      console.log(`${e10.charAt(0).toUpperCase() + e10.slice(1)} adjusted to ${Math.round(s18 * 100)}%`);
    } else console.error(`${e10.charAt(0).toUpperCase() + e10.slice(1)} input or progress bar not found.`);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-IJWIZ5LD.js
var o3 = class {
  static {
    __name(this, "o");
  }
  static {
    j(this, "SwaggerHelper");
  }
  constructor() {
    this.createNewButton();
  }
  createNewButton() {
    let e10 = document.createElement("button");
    e10.style.cssText = "z-index: 36; padding: 5px 0; position: fixed; top: 0; left: 0; min-width: 30px;", e10.textContent = "\u200B", document.body.appendChild(e10), e10.addEventListener("click", async () => {
      try {
        document.querySelector(".btn.authorize")?.click();
        let t11 = document.querySelector(".btn.modal-btn.auth");
        t11 && !t11.classList.contains("authorize") && t11?.click();
        let n11 = document.querySelector('[aria-label="auth-bearer-value"]');
        if (n11) {
          let c21 = (await navigator.clipboard.readText()).trim();
          n11.value = `${c21}\r`, n11.dispatchEvent(new Event("change", { bubbles: true, cancelable: true })), document.querySelector(".btn.modal-btn.auth")?.click(), t11 && !t11.classList.contains("authorize") ? (document.querySelector(".btn.modal-btn.auth.btn-done")?.click(), this.showFeedback(e10, "\u2713")) : this.showFeedback(e10, "\u2718");
        } else this.showFeedback(e10, "\u2718");
      } catch {
        this.showFeedback(e10, "\u2718");
      }
    });
  }
  showFeedback(e10, t11) {
    e10.textContent = t11, setTimeout(() => e10.textContent = "\u200B", 3e3);
  }
  setWithUI() {
    window.ui = window.SwaggerUIBundle({ onComplete: j(function() {
      debugger;
    }, "onComplete") });
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-S65JXLK7.js
var m6 = 330;
function u6(t11) {
  return new Date(t11.getTime() - t11.getTimezoneOffset() * 60 * 1e3);
}
__name(u6, "u");
j(u6, "removeTimezone");
function s5(t11, e10) {
  return new Date(t11.getTime() - e10 * 60 * 1e3);
}
__name(s5, "s");
j(s5, "convertFromTimezone");
function D(t11, e10) {
  return new Date(t11.getTime() + e10 * 60 * 1e3);
}
__name(D, "D");
j(D, "convertToTimezone");
function c5(t11, e10 = 8) {
  return t11.toISOString().replace(/-/g, "").replace("T", "").slice(0, e10);
}
__name(c5, "c");
j(c5, "formatDateAsString");
function f5(t11, e10) {
  return { ...t11, [e10]: c5(u6(new Date(t11[e10])), 8) };
}
__name(f5, "f");
j(f5, "updateObjectDateField");
function T2(t11) {
  let e10 = t11.getFullYear(), r9 = String(t11.getMonth() + 1).padStart(2, "0"), o21 = String(t11.getDate()).padStart(2, "0"), a22 = String(t11.getHours()).padStart(2, "0"), i18 = String(t11.getMinutes()).padStart(2, "0");
  return `${e10}-${r9}-${o21} ${a22}:${i18}`;
}
__name(T2, "T");
j(T2, "formatDateToLocalString");
function g4(t11) {
  let e10 = Math.floor(t11 / 6e4 % 60), r9 = Math.floor(t11 / (1e3 * 60 * 60) % 24), o21 = Math.floor(t11 / (1e3 * 60 * 60 * 24));
  return `${o21 ? `${o21}D ` : ""}${r9 ? `${r9}H ` : ""}${e10 ? `${e10}m` : ""}`.trim();
}
__name(g4, "g");
j(g4, "formatDuration");
function p4(t11, e10 = Date.now()) {
  return g4(e10 - t11.getTime());
}
__name(p4, "p");
j(p4, "getDurationFromDate");

// node_modules/@mahindar5/common-lib/dist/chunk-SXLGOJOC.js
var P = class {
  static {
    __name(this, "P");
  }
  static {
    j(this, "Tabs2Helper");
  }
  parseCompactDatetime(e10) {
    if (!e10 || e10.length !== 14) return /* @__PURE__ */ new Date();
    let t11 = parseInt(e10.slice(0, 4)), a22 = parseInt(e10.slice(4, 6)) - 1, c21 = parseInt(e10.slice(6, 8)), p15 = parseInt(e10.slice(8, 10)), d15 = parseInt(e10.slice(10, 12)), i18 = parseInt(e10.slice(12, 14)), r9 = new Date(t11, a22, c21, p15, d15, i18);
    return u6(s5(r9, 330));
  }
  constructor() {
    this.saveTokens(), this.enableUserSelect(), setInterval(() => this.addProfileLinks(), 3e3), this.addShaadiProfilesDisplay();
  }
  addProfileLinks() {
    document.querySelectorAll("div[id^='custom-card-']").forEach((t11) => {
      let p15 = `https://www.jeevansathi.com/profile-detail/${t11.id.replace("custom-card-", "")}`, d15 = t11.nextElementSibling;
      if (!(d15 && d15.tagName === "A" && d15.href === p15)) {
        let r9 = document.createElement("a");
        r9.href = p15, r9.textContent = "View Profile", r9.target = "_blank", r9.style.display = "block", t11.insertAdjacentElement("afterend", r9);
      }
    });
  }
  async addShaadiProfilesDisplay() {
    if (!location.href.includes("my.shaadi.com/inbox/accepted/interests")) return;
    let t11 = j(() => {
      try {
        let o21 = Object.keys(localStorage).find((s18) => s18.includes("sh-TSH36754470::session?"));
        return o21 ? JSON.parse(localStorage.getItem(o21) || "{}")?.data?.auth : null;
      } catch {
        return null;
      }
    }, "getSessionData")(), a22 = t11?.accessToken || Object.values(localStorage).map((o21) => {
      try {
        return JSON.parse(o21)?.data?.auth?.accessToken?.includes("TSH36754470") ? JSON.parse(o21).data.auth.accessToken : null;
      } catch {
        return null;
      }
    }).find(Boolean);
    if (!a22) return console.error("\u274C Token not found");
    let c21 = "https://mm-api.shaadi.com/inbox/v1/TSH36754470/connect/accepted?decorator=inbox_list_details&limitPerPage=100", p15 = { accept: "application/json, text/plain, */*", "x-access-token": a22, "x-app-key": t11?.appKey || "69c3f1c1ea31d60aa5516a439bb65949cf3f8a1330679fa7ff91fc9a5681b564" }, d15 = await Promise.all([1, 2].map((o21) => fetch(`${c21}&page=${o21}`, { headers: p15 }))), i18 = (await Promise.all(d15.map((o21) => o21.json()))).flatMap((o21) => o21?.data || []);
    if (!i18.length) return console.log("\u{1F4ED} No profiles found");
    let r9 = Object.assign(document.createElement("div"), { style: "position:fixed;bottom:0;left:0;right:0;max-height:70vh;overflow-y:auto;background:#fff;z-index:99999;padding:12px 20px;box-shadow:0 -4px 12px rgba(0,0,0,0.2)" }), b7 = Object.assign(document.createElement("select"), { style: "float:right;padding:4px 8px;border:1px solid #ccc;border-radius:4px;font-size:12px;margin-bottom:12px", innerHTML: '<option value="">Default</option><option value="last_login" selected>Last Login</option><option value="premium">Premium</option><option value="country">Country</option><option value="location">Location</option><option value="membership">Membership</option>' }), u20 = Object.assign(document.createElement("div"), { style: "clear:both;display:flex;flex-wrap:wrap;gap:16px;justify-content:center" }), l14 = [...i18].sort((o21, s18) => (s18.account?.last_login_date || 0) - (o21.account?.last_login_date || 0));
    b7.onchange = () => {
      let o21 = b7.value;
      o21 === "last_login" ? l14 = [...i18].sort((s18, n11) => (n11.account?.last_login_date || 0) - (s18.account?.last_login_date || 0)) : o21 === "premium" ? l14 = [...i18].sort((s18, n11) => (n11.profile_fields?.is_premium ? 1 : 0) - (s18.profile_fields?.is_premium ? 1 : 0)) : o21 === "membership" ? l14 = [...i18].sort((s18, n11) => ((s18.account?.membership || []).join("") || "").localeCompare((n11.account?.membership || []).join("") || "")) : o21 === "country" ? l14 = [...i18].sort((s18, n11) => (s18.profile_brief?.country || "").localeCompare(n11.profile_brief?.country || "")) : o21 === "location" ? l14 = [...i18].sort((s18, n11) => (s18.profile_brief?.location || "").localeCompare(n11.profile_brief?.location || "")) : l14 = i18, u20.innerHTML = "", l14.forEach((s18) => u20.appendChild(h12(s18)));
    };
    let h12 = j((o21) => {
      let { profile_brief: s18, account: n11, profile_fields: E3, photo_details: $2 } = o21, y12 = E3?.is_premium, I4 = $2?.photos?.map((f13) => `${f13.domain_name}${f13.semilarge}`) || [], m18 = n11?.last_login_date ? this.parseCompactDatetime(n11.last_login_date.toString()) : null, v8 = m18 ? T2(m18) : null, k5 = m18 ? p4(m18) : null, x3 = Object.assign(document.createElement("div"), { style: "width:240px;border:1px solid #ccc;border-radius:8px;background:#fefefe;overflow:hidden;box-shadow:0 2px 6px rgba(0,0,0,0.1);font-size:13px;display:flex;flex-direction:column" }), T6 = Object.assign(document.createElement("div"), { style: "display:flex;gap:10px;overflow-x:auto;padding:8px;border-bottom:1px solid #eee" });
      I4.forEach((f13) => {
        let U = Object.assign(document.createElement("img"), { src: f13, style: "height:160px;border-radius:6px;object-fit:cover;flex-shrink:0" });
        T6.appendChild(U);
      });
      let O3 = Object.assign(document.createElement("div"), { style: "padding:10px", innerHTML: `<strong>${s18.name.display_name}</strong><br>
					<span style="color:${y12 ? "#c0392b" : "gray"};font-weight:bold">${y12 ? `\u{1F31F} ${(n11?.membership || []).join(", ") || "Premium"}` : "Free Member"}</span><br>
					Age: ${s18.age}<br>Country: ${s18.country}<br>${s18.location}<br>${s18.occupation}<br>${s18.education}<br>
					${v8 ? `Last Login: ${v8}${k5 ? ` (${k5} ago)` : ""}<br>` : ""}
					<a href="https://my.shaadi.com/profile?profileid=${n11?.memberlogin || s18.id}" target="_blank" style="color:#007bff;text-decoration:underline;">View Profile</a>` });
      return x3.append(T6, O3), x3;
    }, "createCard");
    r9.append(b7, u20), l14.forEach((o21) => u20.appendChild(h12(o21))), document.body.appendChild(r9);
  }
  saveTokens() {
    this.saveTab4Token(), this.saveTab2Token(), this.saveTab3Token(), this.hidePopupTab3();
  }
  saveTab4Token() {
    let e10 = this.getCookiesAsObject(), t11 = e10.loginTracking;
    e10.AUTHCHECKSUM && t11 && this.postToken("tabs4accesstoken", { [t11]: { accessToken: e10.AUTHCHECKSUM, id: t11 } });
  }
  saveTab2Token() {
    setTimeout(() => {
      let e10 = Object.keys(localStorage).filter((t11) => t11.includes("::session?"));
      if (e10.length > 0) {
        let t11 = localStorage.getItem(e10[0]);
        if (t11) {
          let a22 = JSON.parse(t11), c21 = a22?.data?.auth?.uid;
          a22?.data?.auth?.accessToken && this.postToken("tabs2accesstoken", { [c21]: { accessToken: a22.data.auth.accessToken, id: c21 } });
        }
      }
    }, 2e3);
  }
  hidePopupTab3() {
    let e10 = 0, t11 = setInterval(() => {
      e10++, e10 == 10 && clearInterval(t11), this.hidePopup();
    }, 1e3);
  }
  hidePopup() {
    let e10 = document.getElementById("bm-login-offer-popup");
    e10 && (e10.style.display = "none"), document.body.classList.remove("bm-modal-open");
  }
  saveTab3Token() {
    let e10 = localStorage.getItem("tid"), t11 = localStorage.getItem("MATRIID");
    e10 && t11 && this.postToken("tabs3accesstoken", { [t11]: { accessToken: e10, id: t11 } });
  }
  getCookiesAsObject() {
    return document.cookie?.split("; ").reduce((e10, t11) => {
      let [a22, c21] = t11.split("=");
      return e10[a22] = c21, e10;
    }, {}) || {};
  }
  enableUserSelect() {
    window.location.href.includes(".jeevansathi.com") && (document.body.classList.remove("no-user-select"), document.querySelector(".select-none")?.classList.remove("select-none"));
  }
  async postToken(e10, t11) {
    await R2("FirestoreUtils").saveToFirestore("tabscollection", e10, t11);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-ISPNLZMG.js
var r2 = class {
  static {
    __name(this, "r");
  }
  static {
    j(this, "VideoSeekableFix");
  }
  constructor() {
    let e10 = document.querySelector("video");
    e10 && (e10.currentTime = 1e101, e10.addEventListener("timeupdate", () => setTimeout(() => e10.play(), 100), { once: true }));
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-XY7HN4BO.js
var m7 = "playbackRate", d3 = class {
  static {
    __name(this, "d");
  }
  static {
    j(this, "PlaybackRateHelper");
  }
  chromeTabHelper = c2(r);
  adElements;
  constructor() {
    this.adElements = [{ selector: '[data-testid="vilos-ad_label"]', indicators: ["advertisement"] }, { selector: ".video-ads", indicators: ["ad will", "video will", "video plays soon", "skip", "advertiser", "of", "Ends"] }, { selector: ".mgp_adRollSkipButtonContent", indicators: ["skip"] }, { selector: ".videoad-skip-txt", indicators: ["skip"] }, { selector: ".ad_label", indicators: ["ad"] }, { selector: '[role="status"]', indicators: ["ad"] }], this.watchPlaybackRate();
  }
  isAd(l14) {
    let s18 = this.adElements.some(({ selector: n11, indicators: e10 }) => {
      let t11 = document.querySelector(n11)?.textContent?.toLowerCase() || "";
      return t11 && e10.some((o21) => t11.includes(o21));
    });
    return l14.outerHTML.includes("Advertisement") || s18;
  }
  async watchPlaybackRate() {
    setTimeout(() => this.watchPlaybackRate(), 1e3), window.location.href.includes("teams.microsoft.com") && document.querySelector('[is-checked="appHeaderBar.isAppSwitcherToggleOn"] input')?.click();
    let s18 = await this.chromeTabHelper.getItem(m7) || 2;
    j(() => {
      let e10 = [], a22 = j((t11) => {
        t11.querySelectorAll && (t11.querySelectorAll("video, audio").forEach((o21) => e10.push(o21)), t11.querySelectorAll("*").forEach((o21) => {
          o21.shadowRoot && a22(o21.shadowRoot);
        }));
      }, "findMedia");
      return a22(document), e10;
    }, "getAllMediaElements")().forEach((e10) => {
      let a22 = this.isAd(e10);
      e10.playbackRate = a22 ? 16 : s18;
    });
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-NT6N5JGI.js
var i4 = class {
  static {
    __name(this, "i");
  }
  static {
    j(this, "YoutubeHelper");
  }
  playbackRateHelper = c2(d3);
  isUserPaused;
  selectors;
  constructor() {
    this.isUserPaused = false, this.selectors = [.../* @__PURE__ */ new Set([".ytp-ad-skip-button-modern", ".ytp-skip-ad-button", "#dismiss-button", ".ytp-ad-skip-button", ".ytp-ad-overlay-close-button", ".ytp-skip-ad-button-modern", ".ytp-ad-skip-button-container", "ytd-button-renderer#dismiss-button.ytd-mealbar-promo-renderer"])], setInterval(() => this.skipAds(), 1e3);
  }
  skipAds() {
    this.selectors.forEach((e10) => {
      document.querySelectorAll(e10).forEach((t11) => {
        t11.click(), t11.remove();
      });
    });
  }
  updateCounter(e10) {
    let t11 = localStorage.getItem("allCounters"), s18 = t11 ? JSON.parse(t11) : {};
    s18[e10] = (s18[e10] || 0) + 1, localStorage.setItem("allCounters", JSON.stringify(s18));
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-VWA2VQDX.js
var p5 = class {
  static {
    __name(this, "p");
  }
  static {
    j(this, "BandhanHelper");
  }
  chromeTabHelper = c2(r);
  tab3ids = [];
  tab2ids = [];
  constructor() {
    this.chromeTabHelper.getItem("tab3ids").then((e10) => {
      this.chromeTabHelper.getItem("tab2ids").then((r9) => {
        this.tab3ids = e10 || [], this.tab2ids = r9 || [], this.updateTitles();
      });
    });
  }
  updateTitles() {
    [...document.querySelectorAll('#resbox a[title="Click to view complete profile."]')].forEach((e10) => {
      let r9 = e10.getAttribute("onclick")?.split(",")[0];
      if (r9?.includes("shaadi.com")) {
        r9 = r9.replace(/&ptnr=ban01'/g, "");
        let i18 = r9.slice(-10);
        e10.href = "javascript:void(0);";
        let t11 = document.createElement("span");
        t11.style.userSelect = "text", t11.style.backgroundColor = "red";
        let s18 = [];
        s18.push(i18), this.tab2ids?.some((n11) => n11.includes(i18?.toLowerCase())) && (t11.style.backgroundColor = "transparent", s18.push("Already Downloaded")), t11.innerText = s18.filter((n11) => n11).join(", "), e10.removeAttribute("onclick"), e10.prepend(t11), e10.removeAttribute("target"), e10.outerHTML = e10.outerHTML;
      }
      if (r9?.includes("viewprofile.php?id=")) {
        let i18 = r9.slice(-9).slice(0, 8);
        e10.href = "javascript:void(0);";
        let t11 = document.createElement("span");
        t11.style.userSelect = "text", t11.style.backgroundColor = "red";
        let s18 = [];
        s18.push(i18), this.tab3ids?.includes(i18?.toLowerCase()) && (t11.style.backgroundColor = "transparent", s18.push("Already Downloaded")), this.loadProfileExistStatusTab3(i18).then((n11) => {
          n11.exists || (t11.style.backgroundColor = "transparent", s18.push("Profile does not exists")), t11.innerText = s18.filter((o21) => o21).join(", "), e10.removeAttribute("onclick"), e10.prepend(t11), e10.removeAttribute("target"), e10.outerHTML = e10.outerHTML;
        });
      }
    }), [...document.querySelectorAll("#pgBot a")].forEach((e10) => {
      e10.removeAttribute("onclick");
    });
  }
  async loadProfileExistStatusTab3(e10) {
    try {
      let r9 = `https://m.telugumatrimony.com/bm.php?viewedid=${e10.split("_v")[0]}&MSTYPE=SHAREPROFILE`, t11 = await (await fetch(new Request(r9))).text(), o21 = new DOMParser().parseFromString(t11, "text/html").querySelector(".profilemember_details .profile_name")?.innerText;
      if (!o21?.includes("Yrs")) throw new Error('Share site response is not as expected. Did not find "Yrs" in html.');
      return o21 = o21?.replace(/,/g, "")?.replace(/Yrs/g, "")?.replace(/ /g, "")?.replace(/\./g, "")?.trim(), { profilememberDetails: o21, id: e10, exists: !!o21 };
    } catch {
      return { profilememberDetails: "later", id: e10 };
    }
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-OMXFQ7RX.js
var l7 = "https://chat.openai.com/", h4 = "userSessionKey";
function m8() {
  function c21() {
    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  }
  __name(c21, "c");
  return j(c21, "s4"), `${c21() + c21()}-${c21()}-${c21()}-${c21()}-${c21()}${c21()}${c21()}`;
}
__name(m8, "m");
j(m8, "createGuid");
var g5 = class {
  static {
    __name(this, "g");
  }
  static {
    j(this, "ChatgptApiHelper");
  }
  parentMessageId;
  conversationId;
  constructor() {
  }
  baseApiCallAnonymoues(s18) {
    return fetch(`${l7}${s18}`, { method: "GET" }).then((e10) => e10.json()).then((e10) => {
      let t11 = e10 || {};
      if (t11.status === 401 || t11.status === 403) throw new Error(`${t11.statusText}-${t11.status}. Login in to https://chat.openai.com/`);
      return t11;
    });
  }
  async baseApiCallPostLoading(s18, e10, t11) {
    let n11 = s18.inputs;
    if (!n11) throw new Error("Please provide inputs");
    let a22 = n11.url, o21 = n11.promptMessage, d15 = n11.parentMessageId, r9 = n11.conversationId, i18 = n11.api || false;
    return await this.makePostRequestToApi(a22, o21, d15, r9, i18);
  }
  async makePostRequestToApi(s18, e10, t11, n11, a22 = false) {
    let o21 = this.createPayload(a22, e10, t11, n11), d15 = await this.getCachedToken(), r9 = await this.makeApiCall(a22, s18, o21, d15);
    if (!r9.ok) {
      let p15 = await this.decodeErrorMessage(r9);
      throw new Error(`${r9.status}-${p15}`);
    }
    let i18 = await this.processResponse(r9);
    return i18 ? this.parseFinalMessage(i18) : r9;
  }
  async decodeErrorMessage(s18) {
    let e10 = s18.body?.getReader();
    if (!e10) return "";
    let t11 = new TextDecoder(), n11 = "";
    for (; ; ) {
      let { done: a22, value: o21 } = await e10.read();
      if (a22) break;
      n11 += t11.decode(o21, { stream: true });
    }
    return n11.trim();
  }
  createPayload(s18, e10, t11, n11) {
    return s18 ? { model: "text-davinci-003", prompt: e10, temperature: 0.7, max_tokens: 256, stream: true, top_p: 1, frequency_penalty: 0, presence_penalty: 0 } : { action: "next", stream: false, messages: [{ role: "user", content: { content_type: "text", parts: [e10] } }], model: "text-davinci-002-render", parent_message_id: t11 || m8(), conversation_id: n11 || void 0 };
  }
  async makeApiCall(s18, e10, t11, n11) {
    return await fetch(s18 ? "https://api.openai.com/v1/completions" : `${l7}${e10}`, { headers: { Authorization: `Bearer ${s18 ? "your-api-key" : n11.accessToken}`, "Content-Type": "application/json" }, body: JSON.stringify(t11), method: "POST" });
  }
  async processResponse(s18) {
    let e10 = s18.body?.getReader();
    if (!e10) return null;
    let t11 = new TextDecoder(), n11 = "", a22 = "";
    for (; ; ) {
      let { done: o21, value: d15 } = await e10.read(), r9 = t11.decode(d15, { stream: !o21 }).trim();
      if (n11 += r9, console.log("tempMessage updated"), o21 || r9.endsWith("}")) {
        if (n11.trim() === "data: [DONE]") break;
        let i18 = n11?.replace("data: [DONE]", "").split(`
`).filter((p15) => p15.startsWith("data: ") && p15 !== "data: [DONE]").pop()?.replace("data: ", "");
        a22 = i18 && i18.startsWith("{") && i18.endsWith("}") ? i18 : "", n11 = "";
      }
      if (o21) break;
    }
    return console.log("finalMessage"), a22;
  }
  parseFinalMessage(s18) {
    let { message: e10, conversation_id: t11 } = JSON.parse(s18);
    return this.parentMessageId = e10.id, this.conversationId = t11, { message: e10.content.parts[0], parentMessageId: this.parentMessageId, conversationId: this.conversationId };
  }
  async getCachedToken() {
    let s18 = localStorage.getItem(h4);
    if (!s18) throw new Error("User session not found");
    let e10 = JSON.parse(s18);
    if (e10 && e10.accessToken && Date.now() > new Date(e10.expires).getTime() + 1e3 * 60) return e10;
    let t11 = await this.baseApiCallAnonymoues("/api/auth/session");
    if (!t11.accessToken) throw new Error("Unauthorized. Login in to https://chat.openai.com/");
    return localStorage.setItem(h4, JSON.stringify(t11)), t11;
  }
  getAuthHeaders(s18) {
    return { Authorization: `Bearer ${s18.accessToken}`, "Content-Type": "application/json" };
  }
  async baseApiCallPost2(s18, e10) {
    let t11 = await this.getCachedToken(), n11 = this.getAuthHeaders(t11);
    try {
      let a22 = await fetch(`${l7}${s18}`, { headers: n11, body: e10, method: "POST" });
      if (!a22.ok) throw new Error("Network response was not ok");
      let o21 = await a22.text(), d15 = new EventSource(`data:text/event-stream;charset=UTF-8,${encodeURIComponent(o21)}`);
      return new Promise((r9, i18) => {
        d15.onmessage = (p15) => {
          r9(p15.data);
        }, d15.onerror = (p15) => {
          i18(p15);
        };
      });
    } catch (a22) {
      throw a22;
    }
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-ITJF4M7V.js
var t3 = class {
  static {
    __name(this, "t");
  }
  static {
    j(this, "ContentScriptsListener");
  }
  chromeTabHelper = c2(r);
  constructor() {
    this.onMessage();
  }
  onMessage() {
    chrome.runtime.onMessage.addListener((e10, s18, i18) => e10.targetUrl && window.location.href !== e10.targetUrl ? false : (this.chromeTabHelper.handleMessage(e10, s18, i18, "contentscripts"), true));
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-BSKLW4HB.js
var n3 = class {
  static {
    __name(this, "n");
  }
  static {
    j(this, "IndexedDbCacheService");
  }
  dbPromise = null;
  storeName = "keyval";
  getDbPromise() {
    return this.dbPromise === null && (typeof indexedDB > "u" ? this.dbPromise = Promise.reject(new Error("IndexedDB not available")) : this.dbPromise = new Promise((e10, t11) => {
      let r9 = indexedDB.open("keyval-store", 3);
      r9.onerror = () => t11(r9.error), r9.onsuccess = () => e10(r9.result), r9.onupgradeneeded = () => r9.result.createObjectStore(this.storeName);
    })), this.dbPromise;
  }
  async runTransaction(e10, t11) {
    let r9 = await this.getDbPromise();
    return new Promise((m18, l14) => {
      let u20 = r9.transaction(this.storeName, e10).objectStore(this.storeName), s18 = t11(u20);
      s18.onsuccess = () => m18(s18.result), s18.onerror = () => l14(s18.error);
    });
  }
  async getItem(e10) {
    return this.runTransaction("readonly", (t11) => t11.get(e10));
  }
  async getAllKeys() {
    return this.runTransaction("readonly", (e10) => e10.getAllKeys());
  }
  async setItem(e10, t11) {
    await this.runTransaction("readwrite", (r9) => r9.put(t11, e10));
  }
  async removeItem(e10) {
    await this.runTransaction("readwrite", (t11) => t11.delete(e10));
  }
}, D2 = c2(c3, [c2(n3)], "indexedDbService");
function v2(a22) {
  return g3({ ...a22, cacheService: D2 });
}
__name(v2, "v");
j(v2, "IndexedDbCacheLoader");

// node_modules/@mahindar5/common-lib/dist/chunk-PNGV33IQ.js
var n4 = "cst-bru-handle", d4 = class {
  static {
    __name(this, "d");
  }
  static {
    j(this, "CSTSAFHelper");
  }
  constructor() {
    let e10 = document.createElement("button");
    e10.style.cssText = "z-index: 36; padding: 5px 0; position: fixed; top: 0; left: 0; min-width: 30px;", e10.textContent = "\u200B", e10.onclick = async (s18) => {
      let a22 = Object.keys(sessionStorage).find((t11) => t11.includes("8deb5/user.read")), w4 = a22 ? JSON.parse(sessionStorage.getItem(a22) || "{}") : {}, { secret: r9, extendedExpiresOn: o21 } = w4;
      if (!r9 || o21 && new Date(o21 * 1e3).getTime() - 6e4 < Date.now()) return this.showFeedback(e10, "\u2716");
      s18.isTrusted && (await navigator.clipboard.writeText(r9), this.showFeedback(e10, "\u2714"));
      try {
        let t11 = await D2.getItem(n4, false);
        if ((!t11 || !await this.tryAccessFile(t11)) && ([t11] = await window.showOpenFilePicker({ id: "cst-bru", types: [{ accept: { "text/plain": [".bru"] } }], multiple: false }), t11 && await D2.setItem(n4, t11, void 0, false)), !t11) return;
        let u20 = (await (await t11.getFile()).text()).replace(/(cst:\s*)([^\n\r}]*)/, `$1${r9}`), c21 = await t11.createWritable();
        await c21.write(u20), await c21.close(), this.showFeedback(e10, "\u{1F4BE}", 1500);
      } catch (t11) {
        console.error("Error updating .bru file:", t11), await D2.removeItem(n4), this.showFeedback(e10, "\u26A0", 1e3);
      }
    }, setTimeout(() => e10.click(), 1e3), setInterval(() => e10.click(), 6e4 * 55), document.body.prepend(e10);
  }
  async tryAccessFile(e10) {
    try {
      return await e10.getFile(), true;
    } catch {
      try {
        if (await e10.requestPermission({ mode: "readwrite" }) === "granted") return await e10.getFile(), true;
      } catch {
      }
      return await D2.removeItem(n4), false;
    }
  }
  showFeedback(e10, s18, a22 = 3e3) {
    e10.textContent = s18, setTimeout(() => e10.textContent = "\u200B", a22);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-3465XAKG.js
var r3 = class {
  static {
    __name(this, "r");
  }
  static {
    j(this, "DownloadQuestions");
  }
  constructor() {
    let e10 = Object.assign(document.createElement("button"), { textContent: "Download Questions", onclick: this.downloadQuestions.bind(this) });
    e10.style.cssText = "position:fixed;top:20px;right:20px;z-index:9999;padding:10px 15px;background:#0078D4;color:#fff;border:none;border-radius:5px;cursor:pointer;font-size:14px", document.body.appendChild(e10);
  }
  async downloadQuestions() {
    let e10 = new URL(window.location.href).searchParams.get("assessmentId") || "23", a22 = localStorage.getItem("docsAuthToken"), c21 = await (await fetch(`https://learn.microsoft.com/api/skillassessment/practice/assessments/${e10}/sessions?locale=en-us&SkipVerification=false&SnapshotVersion=live&ShowAllQuestions=false&TemporaryPreview=false`, { method: "POST", headers: a22 ? { Authorization: `Bearer ${a22}` } : {} })).json(), o21 = `dir_handle_${e10}`, t11 = await D2.getItem(o21, false);
    t11 || (t11 = await window.showDirectoryPicker(), await D2.setItem(o21, t11, void 0, false));
    let n11 = await (await t11.getFileHandle(`questions_${e10}_${Date.now()}.json`, { create: true })).createWritable();
    await n11.write(JSON.stringify(c21, null, 2)), await n11.close();
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-3SW5AIRV.js
var o4 = class {
  static {
    __name(this, "o");
  }
  static {
    j(this, "IcmPortalDownloader");
  }
  chromeExtensionID = "pjgheakmmcejmgdoojlnjbgbafjoiedg";
  incidentId;
  constructor() {
    this.incidentId = this.extractIncidentId(), this.incidentId && this.createDownloadButton();
  }
  extractIncidentId() {
    return window.location.pathname.match(/\/incidents\/details\/(\d+)/)?.[1] || "";
  }
  createDownloadButton() {
    if (document.getElementById("icmDownloadButton")) return;
    let t11 = document.createElement("button");
    t11.id = "icmDownloadButton", t11.textContent = "\u200B", t11.style.cssText = `
			position: fixed;
			top: 0;
			left: 0;
			z-index: 9999;
		`, t11.onclick = () => this.copyIncidentDetails(), document.body.appendChild(t11);
  }
  async copyIncidentDetails() {
    try {
      let i18 = (await R2("IcmService").getFullIncidentDetails([this.incidentId], ["incidentDetails", "descriptionEntries"]))?.[0];
      if (!i18) {
        console.error("No incident data found");
        return;
      }
      let r9 = g2.formatIncidentDetails(i18), d15 = g2.formatIncidentText(r9, true), s18 = g2.generateAIAssistanceRequest(this.incidentId), a22 = `
--- Source Incident ---
${d15}
${s18}
`;
      await navigator.clipboard.writeText(a22), console.log("Incident details copied to clipboard");
    } catch (t11) {
      console.error("Error copying incident details:", t11);
    }
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-VLP2VRF2.js
var a9 = class {
  static {
    __name(this, "a");
  }
  static {
    j(this, "Meetup");
  }
  constructor() {
    setInterval(() => {
      document.querySelectorAll('#modal button, [role="dialog"] a').forEach((e10) => e10.textContent?.match(/continue.*free|no thanks|skip/i) && e10.click());
      let t11 = j((e10) => document.querySelectorAll(`[data-event-label*="attendee"] ${e10}`), "$");
      t11("picture > div > div").forEach((e10) => e10.remove()), t11('.select-none, [class*="blur-"], [class*="rounded-"]').forEach((e10) => {
        e10.classList.remove("select-none"), e10.className = e10.className.replace("blur-", "").replace("rounded-", "");
      }), t11('img[src*="thumb"]').forEach((e10) => e10.src = e10.src.replaceAll("thumb", "highres")), t11('img[srcset*="thumb"]').forEach((e10) => e10.srcset = e10.srcset.replaceAll("thumb", "highres"));
    }, 1e3);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-63O37PW2.js
var i5 = class {
  static {
    __name(this, "i");
  }
  static {
    j(this, "StorageHelper");
  }
  set(n11) {
    let a22 = n11.inputs.key, t11 = n11.inputs.data;
    chrome.storage.local.set({ [a22]: JSON.stringify(t11) });
  }
  get(n11) {
    let a22 = n11.inputs.key, t11 = n11.inputs.defaultVal;
    return new Promise((s18, c21) => chrome.storage.local.get(a22, (e10) => {
      e10 && a22 in e10 ? s18(JSON.parse(e10[a22])) : t11 !== void 0 ? s18(t11) : c21(new Error("No data found in the storage"));
    }));
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-SFPO5S5C.js
var s6 = class {
  static {
    __name(this, "s");
  }
  static {
    j(this, "UtilHelper");
  }
  objConst = "Obj";
  isPositiveInteger(e10, n11 = false) {
    let o21 = Number.isInteger(e10) && e10 >= 0;
    if (!o21 && n11) throw new Error("Invalid Number");
    return o21;
  }
  sleep(e10) {
    return new Promise((n11) => setTimeout(n11, e10));
  }
  log(e10) {
    let n11 = /* @__PURE__ */ new Date();
    console.log(`[${new Date(n11.setMinutes(n11.getMinutes() + 330)).toJSON().slice(0, 19)}] - ${e10}`);
  }
  flatten(e10, n11) {
    return e10.reduce((o21, t11) => (o21 = o21.concat(t11), t11[n11] && (o21 = o21.concat(this.flatten(t11[n11], n11)), t11[n11] = []), o21), []);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-VB76L77A.js
var f6 = class {
  static {
    __name(this, "f");
  }
  static {
    j(this, "PayslipDownloader");
  }
  duplicateCounter = {};
  rows;
  constructor() {
    this.duplicateCounter = {}, this.rows = [...document.querySelectorAll("tr td a[href^='javascript:']")].map((t11) => t11.closest("tr")).filter((t11) => t11 !== null);
  }
  async downloadAll() {
    console.log(`Found ${this.rows.length} payslips`);
    for (let t11 of this.rows) try {
      let r9 = this.extractDocViewUrl(t11), e10 = this.constructFilename(t11), o21 = await this.fetchPdf(r9);
      this.downloadBlob(o21, e10), console.log("\u2705 Downloaded", e10), await this.delay(1e3);
    } catch (r9) {
      console.error("\u274C Failed for row:", t11, r9);
    }
    console.log("All downloads attempted.");
  }
  extractDocViewUrl(t11) {
    let r9 = t11.querySelector("a[href^='javascript:']");
    if (!r9) throw new Error("Cannot find anchor element");
    let e10 = r9.getAttribute("href");
    if (!e10) throw new Error("Cannot find href attribute");
    let o21 = e10.match(/window\.open\(['"]([^'"]+)['"]/);
    if (!o21) throw new Error("Cannot extract DocView URL");
    return new URL(o21[1], location.href).toString();
  }
  constructFilename(t11) {
    let e10 = t11.cells[0].innerText.trim().split("/").pop()?.slice(-2).padStart(2, "0") || "00", o21 = t11.cells[t11.cells.length - 2].innerText.trim().padStart(2, "0"), c21 = `${e10}${o21}`;
    this.duplicateCounter[c21] || (this.duplicateCounter[c21] = 0);
    let a22 = String(this.duplicateCounter[c21]++).padStart(2, "0");
    return `${e10}${o21}${a22}.pdf`;
  }
  async fetchPdf(t11) {
    let r9 = await fetch(t11, { credentials: "include" });
    if (!r9.ok) throw new Error("HTTP " + r9.status);
    let e10 = await r9.text(), o21 = new DOMParser(), a22 = o21.parseFromString(e10, "text/html").querySelector("frame#viewwaitframe")?.getAttribute("src");
    if (!a22) throw new Error("Cannot find frame src");
    let s18 = new URL(a22, t11).toString(), n11 = await fetch(s18, { credentials: "include" });
    if (!n11.ok) throw new Error("HTTP " + n11.status);
    if ((n11.headers.get("content-type") || "").includes("application/pdf")) return n11.blob();
    let w4 = await n11.text(), l14 = o21.parseFromString(w4, "text/html").querySelector("embed[src$='.pdf'], iframe[src$='.pdf']")?.getAttribute("src");
    if (!l14) throw new Error("PDF not found inside frame");
    let m18 = new URL(l14, s18).toString(), i18 = await fetch(m18, { credentials: "include" });
    if (!i18.ok) throw new Error("HTTP " + i18.status);
    return i18.blob();
  }
  downloadBlob(t11, r9) {
    let e10 = document.createElement("a");
    e10.href = URL.createObjectURL(t11), e10.download = r9, document.body.appendChild(e10), e10.click(), document.body.removeChild(e10);
  }
  delay(t11) {
    return new Promise((r9) => setTimeout(r9, t11));
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-4ZTW2UU5.js
var a10 = class {
  static {
    __name(this, "a");
  }
  static {
    j(this, "AdpPayslipDownloader");
  }
  constructor() {
    this.createDownloadButton();
  }
  createDownloadButton() {
    if (document.getElementById("adpDownloadButton")) return;
    let o21 = document.createElement("button");
    o21.id = "adpDownloadButton", o21.textContent = "\u{1F4C4} Download All Payslips", o21.style.cssText = `
			position: fixed;
			top: 20px;
			right: 20px;
			z-index: 9999;
			background: #007acc;
			color: white;
			border: none;
			padding: 10px 15px;
			border-radius: 5px;
			cursor: pointer;
			font-size: 14px;
			box-shadow: 0 2px 8px rgba(0,0,0,0.2);
		`, o21.onmouseover = () => {
      o21.style.background = "#005a9e";
    }, o21.onmouseout = () => {
      o21.style.background = "#007acc";
    }, o21.onclick = () => this.downloadAllPayslips(), document.body.appendChild(o21);
  }
  async downloadAllPayslips() {
    try {
      let o21 = document.getElementById("adpDownloadButton");
      o21 && (o21.textContent = "\u23F3 Downloading...", o21.disabled = true), await c2(f6).downloadAll(), o21 && (o21.textContent = "\u2705 Complete", setTimeout(() => {
        o21.textContent = "\u{1F4C4} Download All Payslips", o21.disabled = false;
      }, 3e3));
    } catch (o21) {
      console.error("Error downloading payslips:", o21);
      let t11 = document.getElementById("adpDownloadButton");
      t11 && (t11.textContent = "\u274C Error", t11.style.background = "#dc3545", setTimeout(() => {
        t11.textContent = "\u{1F4C4} Download All Payslips", t11.style.background = "#007acc", t11.disabled = false;
      }, 3e3));
    }
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-TDVF3UQC.js
function m9(n11, u20, o21 = ",", a22 = `
`, g10 = true) {
  if (!n11.length) return "";
  let t11 = u20 || Object.keys(n11[0]), r9 = j((i18) => {
    let e10 = String(i18 ?? "");
    return e10.includes(o21) || e10.includes(`
`) || e10.includes('"') ? `"${e10.replace(/"/g, '""')}"` : e10;
  }, "escapeField"), s18 = n11.map((i18) => t11.map((e10) => r9(i18[e10])).join(o21));
  return g10 ? [t11.join(o21), ...s18].join(a22) : s18.join(a22);
}
__name(m9, "m");
j(m9, "objectToCsv");
function f7(n11, u20 = false) {
  let o21 = n11.split(/\r?\n/).filter(Boolean);
  if (!o21.length) return [];
  let a22 = j((t11) => {
    let r9 = [], s18 = "", i18 = false;
    for (let e10 = 0; e10 < t11.length; e10++) {
      let l14 = t11[e10], d15 = t11[e10 + 1];
      l14 === '"' ? i18 && d15 === '"' ? (s18 += '"', e10++) : i18 = !i18 : l14 === "," && !i18 ? (r9.push(s18), s18 = "") : s18 += l14;
    }
    return r9.push(s18), r9;
  }, "parseCSVLine"), g10 = a22(o21[0]).map((t11) => {
    let r9 = p6(t11);
    return u20 ? r9.toLowerCase() : r9;
  });
  return o21.slice(1).map((t11) => {
    let r9 = a22(t11).map((s18) => p6(s18));
    return g10.reduce((s18, i18, e10) => (s18[i18] = r9[e10] ?? "", s18), {});
  });
}
__name(f7, "f");
j(f7, "csvToObjects");
function p6(n11) {
  return n11.startsWith('"') && n11.endsWith('"') ? n11.slice(1, -1).replace(/""/g, '"') : n11;
}
__name(p6, "p");
j(p6, "cleanCsvField");
function y4(n11) {
  return f7(n11).map(({ name: u20, suggestedname: o21 }) => ({ name: u20, suggestedname: o21 }));
}
__name(y4, "y");
j(y4, "parseCsvToKeyValue");
function h5(n11, u20, o21, a22) {
  return n11.map((g10) => {
    let t11 = u20.find((r9) => r9.name === g10[o21]);
    return t11?.suggestedname ? { ...g10, [a22]: t11.suggestedname } : g10;
  });
}
__name(h5, "h");
j(h5, "updateObjectsWithLookup");

// node_modules/@mahindar5/common-lib/dist/chunk-2AFNINMC.js
function a11(t11, r9) {
  let n11 = [];
  for (let e10 = 0; e10 < t11.length; e10 += r9) n11.push(t11.slice(e10, e10 + r9));
  return n11;
}
__name(a11, "a");
j(a11, "chunkArray");
function g6(t11, r9, n11) {
  return !t11 || !r9 ? false : Array.isArray(r9) ? r9.some((e10) => e10[n11] === t11[n11]) : r9[n11] === t11[n11];
}
__name(g6, "g");
j(g6, "compareObjects");
function p7(t11, r9) {
  return t11.reduce((n11, e10) => {
    let s18 = r9.map((i18) => e10[i18]).join("|"), c21 = n11.get(s18) || [];
    return n11.set(s18, [...c21, e10]);
  }, /* @__PURE__ */ new Map());
}
__name(p7, "p");
j(p7, "groupByMultipleKeys");
function T3(t11, r9) {
  return t11.reduce((n11, e10) => {
    let s18 = r9.map((i18) => e10[i18]).join("|"), c21 = n11.get(s18) || {};
    return n11.set(s18, { ...c21, ...e10 });
  }, /* @__PURE__ */ new Map());
}
__name(T3, "T");
j(T3, "mergeObjects");
function f8(t11, r9) {
  let n11 = {};
  return t11.forEach((e10) => {
    let s18 = n11;
    r9.forEach((c21, i18) => {
      let u20 = String(e10[c21]);
      i18 === r9.length - 1 ? (s18[u20] = s18[u20] || []).push(e10) : (s18[u20] = s18[u20] || {}, s18 = s18[u20]);
    });
  }), n11;
}
__name(f8, "f");
j(f8, "createNestedGroups");

// node_modules/@mahindar5/common-lib/dist/chunk-HYQWN32Y.js
var m10 = "File System Access API is not supported in this browser";
function l8(e10) {
  if (!(e10 in window)) throw new Error(m10 + ` (${e10} is not supported)`);
}
__name(l8, "l");
j(l8, "ensureBrowserApi");
async function v3(e10, i18, t11 = {}) {
  l8("showSaveFilePicker");
  let n11 = e10 instanceof Blob ? e10 : new Blob([e10], { type: "text/plain" }), o21 = await (await window.showSaveFilePicker({ suggestedName: i18, id: t11.id })).createWritable();
  await o21.write(n11), await o21.close();
}
__name(v3, "v");
j(v3, "saveFile");
async function x(e10 = {}) {
  l8("showOpenFilePicker");
  let [i18] = await window.showOpenFilePicker();
  return await (await i18.getFile()).text();
}
__name(x, "x");
j(x, "readFile");
async function F(e10, i18) {
  let t11 = m9(e10), n11 = i18.endsWith(".csv") ? i18 : `${i18}.csv`;
  await v3(t11, n11);
}
__name(F, "F");
j(F, "saveCsvData");
async function D3(e10, i18, t11) {
  if (!e10.length || t11 < 1) return;
  let n11 = a11(e10, Math.ceil(e10.length / t11));
  for (let [a22, o21] of n11.entries()) {
    let r9 = i18.replace(/\.csv$/i, "") + `_${o21.length}_${a22 + 1}.csv`;
    await F(o21, r9);
  }
}
__name(D3, "D");
j(D3, "saveCsvDataInChunks");
async function y5(e10, i18 = false) {
  let t11 = await e10.text();
  return f7(t11, i18);
}
__name(y5, "y");
j(y5, "loadCsvFile");
async function b2(e10 = false) {
  l8("showDirectoryPicker");
  let i18 = await window.showDirectoryPicker(), t11 = await g7(i18);
  return Promise.all(t11.map((n11) => y5(n11, e10)));
}
__name(b2, "b");
j(b2, "loadCsvFilesFromDirectory");
async function R3(e10, i18 = {}) {
  if (l8("showDirectoryPicker"), !e10.length) throw new Error("No files provided for export");
  let t11 = await window.showDirectoryPicker({ id: i18.id });
  for (let n11 of e10) {
    if (!n11.content) continue;
    let a22 = n11.name.replace(/[^a-zA-Z0-9 -]/g, ""), o21 = n11.content.type.split("/")[1] || "bin", r9 = `${a22}.${o21}`, c21 = await (await t11.getFileHandle(r9, { create: true })).createWritable();
    await c21.write(n11.content), await c21.close();
  }
}
__name(R3, "R");
j(R3, "exportFiles");
function O(e10, i18, t11, n11) {
  let a22 = e10(), o21 = /* @__PURE__ */ new Date();
  o21.setDate(o21.getDate() - 1), o21.setHours(23, 59, 59, 999);
  let [r9, d15] = i18(a22, o21);
  if (localStorage.setItem("heartRateData", JSON.stringify(d15)), r9.length === 0) throw new Error("No data available for download till yesterday");
  let c21 = t11(new Date(parseInt(r9[0].split("~")[1], 10) * 1e3)), u20 = t11(new Date(parseInt(r9[r9.length - 1].split("~")[1], 10) * 1e3)), h12 = `heart-rate-data_${c21}_to_${u20}.dat`;
  n11(r9, h12);
}
__name(O, "O");
j(O, "downloadHeartRateData");
async function g7(e10) {
  let i18 = [];
  for await (let [, t11] of e10.entries()) if (t11.kind === "file" && t11.name.endsWith(".csv")) i18.push(await t11.getFile());
  else if (t11.kind === "directory") {
    let n11 = await g7(t11);
    i18.push(...n11);
  }
  return i18;
}
__name(g7, "g");
j(g7, "collectCsvFiles");

// node_modules/@mahindar5/common-lib/dist/chunk-QH5YHZU2.js
var E = class {
  static {
    __name(this, "E");
  }
  static {
    j(this, "AllTrailsExporter");
  }
  loaded = false;
  limitInput;
  constructor() {
    let m18 = j(() => {
      if (!document.body) return setTimeout(m18, 100);
      let s18 = document.createElement("div");
      s18.style.cssText = "position:fixed;top:40px;left:0px;z-index:9999;display:flex;flex-direction:column;gap:5px;width:60px", this.limitInput = Object.assign(document.createElement("input"), { type: "number", value: "100", style: "width:100%;padding:5px;border-radius:3px" }), s18.appendChild(this.limitInput), ["Log"].forEach((p15, h12) => {
        let v8 = Object.assign(document.createElement("button"), { textContent: p15, style: "padding:5px;background:#4CAF50;color:#fff;border:none;border-radius:3px;cursor:pointer", onclick: j(() => this.run(["log"][h12]), "onclick") });
        s18.appendChild(v8);
      }), document.body.appendChild(s18);
    }, "init");
    m18();
  }
  async run(m18) {
    try {
      !this.loaded && m18 !== "log" && await new Promise((a22, o21) => {
        let t11 = document.createElement("script");
        t11.src = "https://cdn.jsdelivr.net/npm/@mapbox/polyline@1.1.1/src/polyline.js", t11.onload = () => {
          this.loaded = true, a22(void 0);
        }, t11.onerror = o21, document.head.appendChild(t11);
      });
      let s18, p15 = [];
      if (location.pathname.startsWith("/trail")) s18 = [location.pathname];
      else {
        let a22 = location.pathname.split("/").filter(Boolean), o21 = [...document.scripts].find((l14) => l14.textContent?.includes("city_id"))?.textContent || "", t11 = { city: o21.match(/\\"city_id\\":(\d+)/)?.[1], state: o21.match(/\\"state_id\\":(\d+)/)?.[1], country: o21.match(/\\"country_id\\":(\d+)/)?.[1] }, e10 = a22.length >= 3 && t11.city ? { id: +t11.city, placeType: "city" } : a22.length === 2 && t11.state ? { id: +t11.state, placeType: "state" } : a22.length === 1 && t11.country ? { id: +t11.country, placeType: "country" } : null;
        if (!e10) throw new Error("Invalid location");
        if (p15 = (await (await fetch("https://www.alltrails.com/api/alltrails/explore/v1/search?", { method: "POST", headers: { "Content-Type": "application/json", "x-at-caller": "Mugen", "x-at-key": "3p0t5s6b5g4g0e8k3c1j3w7y5c3m4t8i", "x-language-locale": "en-US" }, body: JSON.stringify({ filters: {}, limit: +this.limitInput.value || 50, location: e10, page: 1, sort: "most_popular", recordAttributesToRetrieve: ["area_name", "difficulty_rating", "duration_minutes", "length", "name", "slug", "elevation_gain", "_geoloc", "_cluster_geoloc", "area_id", "area_type", "avg_rating", "num_reviews", "ID", "lat", "lng", "objectID", "type", "verified_map_id", "description", "estimated_time_to_complete"], resultsToInclude: ["searchResults"] }) })).json()).searchResults || [], !p15.length) throw new Error("No trails found");
        s18 = p15.map((l14) => "/" + l14.slug);
      }
      if (m18 === "log") {
        console.table(p15);
        let a22 = p15.map((t11) => {
          let e10 = { linkFormula: `=HYPERLINK("https://www.alltrails.com/${t11.slug}", "${t11.name}")`, avg_rating: t11.avg_rating, num_reviews: t11.num_reviews, difficulty_rating: t11.difficulty_rating, length: t11.length, duration_minutes: t11.duration_minutes, elevation_gain: t11.elevation_gain, estimated_time: t11.estimated_time_to_complete ? (t11.estimated_time_to_complete.value + " " + t11.estimated_time_to_complete.unit).replace(//g, "-").replace(//g, "-") : "", ...t11, geoloc_lat: t11._geoloc?.lat, geoloc_lng: t11._geoloc?.lng, cluster_geoloc_lat: t11._cluster_geoloc?.lat, cluster_geoloc_lng: t11._cluster_geoloc?.lng };
          return delete e10._geoloc, delete e10._cluster_geoloc, delete e10.estimated_time_to_complete, delete e10.featured, e10;
        }), o21 = location.pathname.split("/").pop() || "unknown_trails";
        return F(a22, "all_trails_" + o21), console.log(`Found ${p15.length} trails:`, p15);
      }
      let h12 = j((a22) => window.polyline?.decode(a22) || [], "decode");
      if (m18 === "maps") {
        let o21 = (await (await fetch(`https://www.alltrails.com${s18[0].replace("trail/", "explore/trail/")}?mobileMap=false&initFlyover=true`, { headers: { Accept: "text/html" } })).text()).match(/data-react-props="({.+?})"/), t11 = JSON.parse(o21?.[1]?.replace(/&quot;/g, '"') || "{}").initialExploreMap, e10 = [];
        if (t11.routes?.forEach((g10) => g10.lineSegments?.forEach((x3) => {
          typeof x3.polyline?.pointsData == "string" && e10.push(...h12(x3.polyline.pointsData));
        })), e10.length < 2) return alert("Not enough points");
        let [n11, l14] = [e10[0], e10[e10.length - 1]], r9 = e10.slice(1, -1), c21 = 23, w4 = r9.length / c21, u20 = Array.from({ length: Math.min(c21, r9.length) }, (g10, x3) => {
          let [D6, T6] = r9[Math.floor(x3 * w4)];
          return `${D6},${T6}`;
        }).join("|"), y12 = `https://www.google.com/maps/dir/?api=1&travelmode=walking&origin=${n11[0]},${n11[1]}&destination=${l14[0]},${l14[1]}&waypoints=${encodeURIComponent(u20)}`;
        return window.open(y12, "_blank");
      }
      let d15 = (await Promise.allSettled(s18.map(async (a22, o21) => {
        let [t11, e10] = await Promise.all([fetch(`https://www.alltrails.com${a22.replace("trail/", "explore/trail/")}?mobileMap=false&initFlyover=true`, { headers: { Accept: "text/html" } }).then((u20) => u20.text()), fetch(`https://www.alltrails.com${a22}`, { headers: { Accept: "text/html" } }).then((u20) => u20.text())]), n11 = t11.match(/data-react-props="({.+?})"/), l14 = JSON.parse(n11?.[1]?.replace(/&quot;/g, '"') || "{}").initialExploreMap, r9 = new DOMParser().parseFromString(e10, "text/html"), c21 = {};
        r9.querySelectorAll(".TrailStats_stat__O2GvM").forEach((u20) => {
          let y12 = u20.querySelector(".TrailStats_statLabel__vKMLy")?.textContent?.trim().toLowerCase() || "", g10 = u20.querySelector(".TrailStats_statValueSm__HlKIU")?.textContent?.trim() || "";
          y12.includes("length") ? c21.length = g10 : y12.includes("elevation") ? c21.elevation = g10 : y12.includes("time") && (c21.time = g10);
        });
        let w4 = r9.querySelector('[data-testid="trail-difficulty"]')?.textContent?.trim();
        return w4 && (c21.difficulty = w4), { map: l14, details: c21, apiData: p15[o21] || {} };
      }))).filter((a22) => a22.status === "fulfilled").map((a22) => a22.value);
      if (!d15.length) return alert("No trail data could be fetched.");
      let _ = m18 === "gpx", $2 = d15.length === 1 ? d15[0].map?.name || d15[0].apiData?.name || "Trail" : d15[0].apiData?.area_name ? `${d15[0].apiData.area_name} - ${d15.length} Trails` : "Multiple Trails", i18 = _ ? `<?xml version="1.0" encoding="UTF-8"?><gpx version="1.1" creator="AllTrails" xmlns="http://www.topografix.com/GPX/1/1">
<metadata><name>${$2}</name></metadata>
` : `<?xml version="1.0" encoding="UTF-8"?><kml xmlns="http://www.opengis.net/kml/2.2"><Document>
<name>${$2}</name>
`;
      d15.forEach((a22, o21) => {
        let t11 = a22.map?.name || a22.apiData?.name || `Trail ${o21 + 1}`;
        if (_) i18 += `<trk><name>${t11}</name>
`, a22.map.routes?.forEach((e10) => {
          i18 += `<trkseg>
`, e10.lineSegments?.forEach((n11) => {
            typeof n11.polyline?.pointsData == "string" && (i18 += h12(n11.polyline.pointsData).map(([l14, r9, c21]) => `<trkpt lat="${l14}" lon="${r9}"${c21 ? ` ele="${c21}"` : ""}></trkpt>`).join(`
`) + `
`);
          }), i18 += `</trkseg>
`;
        }), i18 += `</trk>
`, a22.map.waypoints?.forEach((e10) => i18 += `<wpt lat="${e10.location.latitude}" lon="${e10.location.longitude}"><name>${e10.name || "Waypoint"}</name></wpt>
`);
        else {
          i18 += `<Folder><name>${t11}</name>
`;
          let e10 = [];
          a22.map.routes?.forEach((n11) => n11.lineSegments?.forEach((l14) => {
            typeof l14.polyline?.pointsData == "string" && e10.push(...h12(l14.polyline.pointsData).map((r9) => `${r9[1]},${r9[0]},${r9[2] || 0}`));
          })), e10.length && (i18 += `<Placemark><name>${t11}</name><LineString><coordinates>${e10.join(" ")}</coordinates></LineString></Placemark>
`), a22.map.waypoints?.forEach((n11) => i18 += `<Placemark><name>${n11.name}</name><Point><coordinates>${n11.location.longitude},${n11.location.latitude},0</coordinates></Point></Placemark>
`), i18 += `</Folder>
`;
        }
      }), i18 += _ ? "</gpx>" : "</Document></kml>";
      let S7 = `${$2.replace(/[^a-zA-Z0-9\-_]/g, "_")}.${m18}`, b7 = Object.assign(document.createElement("a"), { href: URL.createObjectURL(new Blob([i18], { type: _ ? "application/gpx+xml" : "application/vnd.google-earth.kml+xml" })), download: S7 });
      b7.click(), URL.revokeObjectURL(b7.href);
    } catch (s18) {
      alert("Error: " + s18.message);
    }
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-7DTYW5MW.js
var s7 = class {
  static {
    __name(this, "s");
  }
  static {
    j(this, "AutoClickHandler");
  }
  credentialsPromise = null;
  rules = [{ url: ["https://login.microsoftonline.com"], selector: "input[type='submit'][value='Yes']", maxClicks: 1 }, { url: ["https://login.microsoftonline.com"], selector: "#idSIButton9, input[type='submit'][data-report-event='Signin_Submit']", maxClicks: 2, clickCount: 0, check: j(async () => {
    let e10 = document.querySelector("input[type='email']#i0116");
    if (e10 && !e10.value) {
      let t11 = await this.getCredentials();
      t11 && "id" in t11 && this.fillInput(e10, t11.id);
    }
    return !!e10?.value;
  }, "check") }, { url: ["https://login.microsoftonline.com"], selector: "#idSIButton9, input[type='submit'][data-report-event='Signin_Submit']", maxClicks: 1, clickCount: 0, check: j(async () => {
    let e10 = document.querySelector("input[name='passwd'][type='password'], #i0118"), t11 = !!e10 && e10.getAttribute("aria-hidden") !== "true";
    if (t11 && !e10.value) {
      let i18 = await this.getCredentials();
      i18 && "password" in i18 && typeof i18.password == "string" && this.fillInput(e10, i18.password);
    }
    return !!(t11 && e10?.value);
  }, "check") }, { url: ["https://accounts.pcid.ca/"], selector: ".button.button--inline.button--theme-none.continue-as-page__submit-button", maxClicks: 2 }];
  async getCredentials() {
    return this.credentialsPromise || (this.credentialsPromise = navigator.credentials.get({ password: true, mediation: "optional" }).catch(() => (this.credentialsPromise = null, null))), this.credentialsPromise;
  }
  fillInput(e10, t11) {
    e10.value = t11, e10.dispatchEvent(new Event("input", { bubbles: true }));
  }
  constructor() {
    this.autoClick();
  }
  tryClick(e10, t11) {
    let i18 = document.querySelector(e10);
    i18 && (i18.click(), typeof t11.clickCount == "number" && t11.clickCount++);
  }
  autoClick() {
    setInterval(async () => {
      let e10 = window.location.href;
      for (let t11 of this.rules) t11.url.some((i18) => e10.startsWith(i18)) && (typeof t11.maxClicks == "number" && typeof t11.clickCount == "number" && t11.clickCount >= t11.maxClicks || (t11.check ? await t11.check() && this.tryClick(t11.selector, t11) : t11.selector && this.tryClick(t11.selector, t11)));
    }, 800);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-F6PKY32U.js
var o5 = class {
  static {
    __name(this, "o");
  }
  static {
    j(this, "ChromeStorageCacheService");
  }
  async setItem(e10, i18) {
    await chrome.storage.local.set({ [e10]: i18 });
  }
  async removeItem(e10) {
    await chrome.storage.local.remove(e10);
  }
  async getItem(e10) {
    return (await chrome.storage.local.get(e10))[e10] || null;
  }
}, a12 = c2(c3, [c2(o5)], "chromeExtensionService");
function g8(c21) {
  return g3({ ...c21, cacheService: a12 });
}
__name(g8, "g");
j(g8, "ChromeExtensionCacheLoader");

// node_modules/@mahindar5/common-lib/dist/chunk-U42KSH6Y.js
var y6 = class {
  static {
    __name(this, "y");
  }
  static {
    j(this, "ServiceCanadaMonitorJob");
  }
  configData = { displayName: "ServiceCanadaMonitorJob", isEnabled: false, inputs: { intervalInSeconds: 0, webhookUrl: "", findDate: "" } };
  officeIds;
  constructor() {
    this.officeIds = {};
  }
  async run(n11, t11) {
    let a22 = n11.inputs.findDate || "2024-06-03", i18 = await this.fetchAvailableTimes(), r9 = await this.organizeTimesByOffice(i18, a22);
    return { title: "Service Canada Reminder " + r9.items.length, items: r9.items };
  }
  async fetchAvailableTimes() {
    return await (await fetch("https://eservice-api-production.azurewebsites.net/api/GetAvailableTimeslots", { headers: { "content-type": "application/json" }, method: "POST", body: JSON.stringify({ CrmOrigin: "eservices", BookingId: "800c0af3-e920-ef11-a81c-000d3a0c0520", OfficeIds: Object.keys(this.officeIds), AdditionalParameters: { UserLocalTime: (/* @__PURE__ */ new Date()).toISOString(), BookingServiceOfferingIds: ["b438d0fc-63ab-ea11-a812-000d3af4f03d"] } }) })).json();
  }
  async organizeTimesByOffice(n11, t11) {
    let a22 = await a12.getItem("service-canada-history") || [], i18 = n11.map((s18) => {
      let e10 = this.officeIds[s18.Office.Id], c21 = this.getTimesByDate(s18);
      return this.updateHistory(e10, c21, a22), { officeName: e10, timesByDate: c21 };
    }), r9 = ["Surrey South Service Canada Centre (15.56km)"], o21 = i18.filter((s18) => s18.timesByDate.some((e10) => e10.date === t11) && !r9.includes(s18.officeName)), l14 = [];
    o21.length > 0 && (l14 = o21.map((s18) => ({ title: s18.officeName, message: s18.timesByDate.find((e10) => e10.date === t11)?.times })));
    let d15 = a22.sort((s18, e10) => {
      let c21 = s18.dates.length > 0 ? s18.dates[0].date : "9999-12-31", p15 = e10.dates.length > 0 ? e10.dates[0].date : "9999-12-31";
      return c21.localeCompare(p15);
    });
    return console.log(d15.map((s18) => `${s18.officeName}
${s18.dates.map((e10) => `${e10.date} (slots: ${e10.noOfSlots}) - ${e10.timestamp} (${e10.duration})`).join(`
`)}`).join(`

`)), await a12.setItem("service-canada-history", a22), { data: i18, items: l14 };
  }
  getTimesByDate(n11) {
    return Object.values(n11.AvailableWorkstations).flatMap((t11) => t11).map((t11) => {
      let a22 = t11.Date.split("T")[0], i18 = t11.AvailableTimeslots.map((r9) => r9.CalendarFrom.split("T")[1].split("+")[0]).slice(0, 5).join(", ");
      return { date: a22, times: i18 };
    }).filter((t11) => t11.date < "2024-06-15").sort((t11, a22) => t11.date.localeCompare(a22.date));
  }
  updateHistory(n11, t11, a22) {
    let i18 = t11[0]?.date, r9 = t11[0]?.times.split(",").length;
    if (!i18) return;
    let o21 = a22.find((c21) => c21.officeName === n11);
    o21 || (o21 = { officeName: n11, dates: [] }, a22.push(o21));
    let l14 = o21.dates[0], { date: d15, timestamp: s18 } = l14 || {}, e10 = (/* @__PURE__ */ new Date()).toLocaleString("en-US", { timeZone: "America/Los_Angeles" });
    if (l14) {
      let c21 = this.formatDuration(s18 || e10);
      l14.duration = c21, l14.noOfSlots = r9;
    }
    d15 !== i18 && o21.dates.unshift({ date: i18, noOfSlots: r9, timestamp: e10 }), o21.dates = o21.dates.slice(0, 10);
  }
  formatDuration(n11, t11 = Date.now()) {
    let a22 = (t11 - (typeof n11 == "string" ? Date.parse(n11) : n11)) / 6e4, i18 = Math.floor(a22 / 60), r9 = Math.floor(a22 % 60), o21 = Math.floor(a22 * 60 % 60);
    return `${i18.toString().padStart(2, "0")}:${r9.toString().padStart(2, "0")}:${o21.toString().padStart(2, "0")}`;
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-RFY64IDE.js
var a13 = { apiKey: "AIzaSyDoE2UBK3TKGwW8ZIbFl-Yq5-h6zpiVPbM", authDomain: "mahindar-1.firebaseapp.com", databaseURL: "https://mahindar-1.firebaseio.com", projectId: "mahindar-1", storageBucket: "mahindar-1.appspot.com", messagingSenderId: "280446112313", appId: "1:280446112313:web:854c7107f90fdc329073e8" };

// node_modules/@firebase/util/dist/postinstall.mjs
var getDefaultsFromPostinstall = /* @__PURE__ */ __name(() => void 0, "getDefaultsFromPostinstall");

// node_modules/@firebase/util/dist/node-esm/index.node.esm.js
var CONSTANTS = {
  /**
   * @define {boolean} Whether this is the client Node.js SDK.
   */
  NODE_CLIENT: false,
  /**
   * @define {boolean} Whether this is the Admin Node.js SDK.
   */
  NODE_ADMIN: false,
  /**
   * Firebase SDK Version
   */
  SDK_VERSION: "${JSCORE_VERSION}"
};
var assert = /* @__PURE__ */ __name(function(assertion, message) {
  if (!assertion) {
    throw assertionError(message);
  }
}, "assert");
var assertionError = /* @__PURE__ */ __name(function(message) {
  return new Error("Firebase Database (" + CONSTANTS.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + message);
}, "assertionError");
var stringToByteArray$1 = /* @__PURE__ */ __name(function(str) {
  const out = [];
  let p15 = 0;
  for (let i18 = 0; i18 < str.length; i18++) {
    let c21 = str.charCodeAt(i18);
    if (c21 < 128) {
      out[p15++] = c21;
    } else if (c21 < 2048) {
      out[p15++] = c21 >> 6 | 192;
      out[p15++] = c21 & 63 | 128;
    } else if ((c21 & 64512) === 55296 && i18 + 1 < str.length && (str.charCodeAt(i18 + 1) & 64512) === 56320) {
      c21 = 65536 + ((c21 & 1023) << 10) + (str.charCodeAt(++i18) & 1023);
      out[p15++] = c21 >> 18 | 240;
      out[p15++] = c21 >> 12 & 63 | 128;
      out[p15++] = c21 >> 6 & 63 | 128;
      out[p15++] = c21 & 63 | 128;
    } else {
      out[p15++] = c21 >> 12 | 224;
      out[p15++] = c21 >> 6 & 63 | 128;
      out[p15++] = c21 & 63 | 128;
    }
  }
  return out;
}, "stringToByteArray$1");
var byteArrayToString = /* @__PURE__ */ __name(function(bytes) {
  const out = [];
  let pos = 0, c21 = 0;
  while (pos < bytes.length) {
    const c1 = bytes[pos++];
    if (c1 < 128) {
      out[c21++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      const c22 = bytes[pos++];
      out[c21++] = String.fromCharCode((c1 & 31) << 6 | c22 & 63);
    } else if (c1 > 239 && c1 < 365) {
      const c22 = bytes[pos++];
      const c32 = bytes[pos++];
      const c42 = bytes[pos++];
      const u20 = ((c1 & 7) << 18 | (c22 & 63) << 12 | (c32 & 63) << 6 | c42 & 63) - 65536;
      out[c21++] = String.fromCharCode(55296 + (u20 >> 10));
      out[c21++] = String.fromCharCode(56320 + (u20 & 1023));
    } else {
      const c22 = bytes[pos++];
      const c32 = bytes[pos++];
      out[c21++] = String.fromCharCode((c1 & 15) << 12 | (c22 & 63) << 6 | c32 & 63);
    }
  }
  return out.join("");
}, "byteArrayToString");
var base64 = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob === "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(input, webSafe) {
    if (!Array.isArray(input)) {
      throw Error("encodeByteArray takes an array as a parameter");
    }
    this.init_();
    const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
    const output = [];
    for (let i18 = 0; i18 < input.length; i18 += 3) {
      const byte1 = input[i18];
      const haveByte2 = i18 + 1 < input.length;
      const byte2 = haveByte2 ? input[i18 + 1] : 0;
      const haveByte3 = i18 + 2 < input.length;
      const byte3 = haveByte3 ? input[i18 + 2] : 0;
      const outByte1 = byte1 >> 2;
      const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
      let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
      let outByte4 = byte3 & 63;
      if (!haveByte3) {
        outByte4 = 64;
        if (!haveByte2) {
          outByte3 = 64;
        }
      }
      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
    }
    return output.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return btoa(input);
    }
    return this.encodeByteArray(stringToByteArray$1(input), webSafe);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return atob(input);
    }
    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(input, webSafe) {
    this.init_();
    const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
    const output = [];
    for (let i18 = 0; i18 < input.length; ) {
      const byte1 = charToByteMap[input.charAt(i18++)];
      const haveByte2 = i18 < input.length;
      const byte2 = haveByte2 ? charToByteMap[input.charAt(i18)] : 0;
      ++i18;
      const haveByte3 = i18 < input.length;
      const byte3 = haveByte3 ? charToByteMap[input.charAt(i18)] : 64;
      ++i18;
      const haveByte4 = i18 < input.length;
      const byte4 = haveByte4 ? charToByteMap[input.charAt(i18)] : 64;
      ++i18;
      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
        throw new DecodeBase64StringError();
      }
      const outByte1 = byte1 << 2 | byte2 >> 4;
      output.push(outByte1);
      if (byte3 !== 64) {
        const outByte2 = byte2 << 4 & 240 | byte3 >> 2;
        output.push(outByte2);
        if (byte4 !== 64) {
          const outByte3 = byte3 << 6 & 192 | byte4;
          output.push(outByte3);
        }
      }
    }
    return output;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {};
      this.charToByteMap_ = {};
      this.byteToCharMapWebSafe_ = {};
      this.charToByteMapWebSafe_ = {};
      for (let i18 = 0; i18 < this.ENCODED_VALS.length; i18++) {
        this.byteToCharMap_[i18] = this.ENCODED_VALS.charAt(i18);
        this.charToByteMap_[this.byteToCharMap_[i18]] = i18;
        this.byteToCharMapWebSafe_[i18] = this.ENCODED_VALS_WEBSAFE.charAt(i18);
        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i18]] = i18;
        if (i18 >= this.ENCODED_VALS_BASE.length) {
          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i18)] = i18;
          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i18)] = i18;
        }
      }
    }
  }
};
var DecodeBase64StringError = class extends Error {
  static {
    __name(this, "DecodeBase64StringError");
  }
  constructor() {
    super(...arguments);
    this.name = "DecodeBase64StringError";
  }
};
var base64Encode = /* @__PURE__ */ __name(function(str) {
  const utf8Bytes = stringToByteArray$1(str);
  return base64.encodeByteArray(utf8Bytes, true);
}, "base64Encode");
var base64urlEncodeWithoutPadding = /* @__PURE__ */ __name(function(str) {
  return base64Encode(str).replace(/\./g, "");
}, "base64urlEncodeWithoutPadding");
var base64Decode = /* @__PURE__ */ __name(function(str) {
  try {
    return base64.decodeString(str, true);
  } catch (e10) {
    console.error("base64Decode failed: ", e10);
  }
  return null;
}, "base64Decode");
function deepCopy(value) {
  return deepExtend(void 0, value);
}
__name(deepCopy, "deepCopy");
function deepExtend(target, source) {
  if (!(source instanceof Object)) {
    return source;
  }
  switch (source.constructor) {
    case Date:
      const dateValue = source;
      return new Date(dateValue.getTime());
    case Object:
      if (target === void 0) {
        target = {};
      }
      break;
    case Array:
      target = [];
      break;
    default:
      return source;
  }
  for (const prop in source) {
    if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {
      continue;
    }
    target[prop] = deepExtend(target[prop], source[prop]);
  }
  return target;
}
__name(deepExtend, "deepExtend");
function isValidKey(key) {
  return key !== "__proto__";
}
__name(isValidKey, "isValidKey");
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("Unable to locate global object.");
}
__name(getGlobal, "getGlobal");
var getDefaultsFromGlobal = /* @__PURE__ */ __name(() => getGlobal().__FIREBASE_DEFAULTS__, "getDefaultsFromGlobal");
var getDefaultsFromEnvVariable = /* @__PURE__ */ __name(() => {
  if (typeof process === "undefined" || typeof process.env === "undefined") {
    return;
  }
  const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;
  if (defaultsJsonString) {
    return JSON.parse(defaultsJsonString);
  }
}, "getDefaultsFromEnvVariable");
var getDefaultsFromCookie = /* @__PURE__ */ __name(() => {
  if (typeof document === "undefined") {
    return;
  }
  let match;
  try {
    match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch (e10) {
    return;
  }
  const decoded = match && base64Decode(match[1]);
  return decoded && JSON.parse(decoded);
}, "getDefaultsFromCookie");
var getDefaults = /* @__PURE__ */ __name(() => {
  try {
    return getDefaultsFromPostinstall() || getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();
  } catch (e10) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e10}`);
    return;
  }
}, "getDefaults");
var getDefaultEmulatorHost = /* @__PURE__ */ __name((productName) => {
  var _a, _b;
  return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName];
}, "getDefaultEmulatorHost");
var getDefaultEmulatorHostnameAndPort = /* @__PURE__ */ __name((productName) => {
  const host = getDefaultEmulatorHost(productName);
  if (!host) {
    return void 0;
  }
  const separatorIndex = host.lastIndexOf(":");
  if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {
    throw new Error(`Invalid host ${host} with no separate hostname and port!`);
  }
  const port2 = parseInt(host.substring(separatorIndex + 1), 10);
  if (host[0] === "[") {
    return [host.substring(1, separatorIndex - 1), port2];
  } else {
    return [host.substring(0, separatorIndex), port2];
  }
}, "getDefaultEmulatorHostnameAndPort");
var getDefaultAppConfig = /* @__PURE__ */ __name(() => {
  var _a;
  return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;
}, "getDefaultAppConfig");
var getExperimentalSetting = /* @__PURE__ */ __name((name4) => {
  var _a;
  return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name4}`];
}, "getExperimentalSetting");
var Deferred = class {
  static {
    __name(this, "Deferred");
  }
  constructor() {
    this.reject = () => {
    };
    this.resolve = () => {
    };
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
  /**
   * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(callback) {
    return (error, value) => {
      if (error) {
        this.reject(error);
      } else {
        this.resolve(value);
      }
      if (typeof callback === "function") {
        this.promise.catch(() => {
        });
        if (callback.length === 1) {
          callback(error);
        } else {
          callback(error, value);
        }
      }
    };
  }
};
function isCloudWorkstation(host) {
  return host.endsWith(".cloudworkstations.dev");
}
__name(isCloudWorkstation, "isCloudWorkstation");
async function pingServer(endpoint) {
  const result = await fetch(endpoint, {
    credentials: "include"
  });
  return result.ok;
}
__name(pingServer, "pingServer");
function createMockUserToken(token, projectId) {
  if (token.uid) {
    throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  }
  const header = {
    alg: "none",
    type: "JWT"
  };
  const project = projectId || "demo-project";
  const iat = token.iat || 0;
  const sub = token.sub || token.user_id;
  if (!sub) {
    throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  }
  const payload = Object.assign({
    // Set all required fields to decent defaults
    iss: `https://securetoken.google.com/${project}`,
    aud: project,
    iat,
    exp: iat + 3600,
    auth_time: iat,
    sub,
    user_id: sub,
    firebase: {
      sign_in_provider: "custom",
      identities: {}
    }
  }, token);
  const signature = "";
  return [
    base64urlEncodeWithoutPadding(JSON.stringify(header)),
    base64urlEncodeWithoutPadding(JSON.stringify(payload)),
    signature
  ].join(".");
}
__name(createMockUserToken, "createMockUserToken");
var emulatorStatus = {};
function getEmulatorSummary() {
  const summary = {
    prod: [],
    emulator: []
  };
  for (const key of Object.keys(emulatorStatus)) {
    if (emulatorStatus[key]) {
      summary.emulator.push(key);
    } else {
      summary.prod.push(key);
    }
  }
  return summary;
}
__name(getEmulatorSummary, "getEmulatorSummary");
function getOrCreateEl(id) {
  let parentDiv = document.getElementById(id);
  let created = false;
  if (!parentDiv) {
    parentDiv = document.createElement("div");
    parentDiv.setAttribute("id", id);
    created = true;
  }
  return { created, element: parentDiv };
}
__name(getOrCreateEl, "getOrCreateEl");
var previouslyDismissed = false;
function updateEmulatorBanner(name4, isRunningEmulator) {
  if (typeof window === "undefined" || typeof document === "undefined" || !isCloudWorkstation(window.location.host) || emulatorStatus[name4] === isRunningEmulator || emulatorStatus[name4] || // If already set to use emulator, can't go back to prod.
  previouslyDismissed) {
    return;
  }
  emulatorStatus[name4] = isRunningEmulator;
  function prefixedId(id) {
    return `__firebase__banner__${id}`;
  }
  __name(prefixedId, "prefixedId");
  const bannerId = "__firebase__banner";
  const summary = getEmulatorSummary();
  const showError = summary.prod.length > 0;
  function tearDown() {
    const element = document.getElementById(bannerId);
    if (element) {
      element.remove();
    }
  }
  __name(tearDown, "tearDown");
  function setupBannerStyles(bannerEl) {
    bannerEl.style.display = "flex";
    bannerEl.style.background = "#7faaf0";
    bannerEl.style.position = "fixed";
    bannerEl.style.bottom = "5px";
    bannerEl.style.left = "5px";
    bannerEl.style.padding = ".5em";
    bannerEl.style.borderRadius = "5px";
    bannerEl.style.alignItems = "center";
  }
  __name(setupBannerStyles, "setupBannerStyles");
  function setupIconStyles(prependIcon, iconId) {
    prependIcon.setAttribute("width", "24");
    prependIcon.setAttribute("id", iconId);
    prependIcon.setAttribute("height", "24");
    prependIcon.setAttribute("viewBox", "0 0 24 24");
    prependIcon.setAttribute("fill", "none");
    prependIcon.style.marginLeft = "-6px";
  }
  __name(setupIconStyles, "setupIconStyles");
  function setupCloseBtn() {
    const closeBtn = document.createElement("span");
    closeBtn.style.cursor = "pointer";
    closeBtn.style.marginLeft = "16px";
    closeBtn.style.fontSize = "24px";
    closeBtn.innerHTML = " &times;";
    closeBtn.onclick = () => {
      previouslyDismissed = true;
      tearDown();
    };
    return closeBtn;
  }
  __name(setupCloseBtn, "setupCloseBtn");
  function setupLinkStyles(learnMoreLink, learnMoreId) {
    learnMoreLink.setAttribute("id", learnMoreId);
    learnMoreLink.innerText = "Learn more";
    learnMoreLink.href = "https://firebase.google.com/docs/studio/preview-apps#preview-backend";
    learnMoreLink.setAttribute("target", "__blank");
    learnMoreLink.style.paddingLeft = "5px";
    learnMoreLink.style.textDecoration = "underline";
  }
  __name(setupLinkStyles, "setupLinkStyles");
  function setupDom() {
    const banner = getOrCreateEl(bannerId);
    const firebaseTextId = prefixedId("text");
    const firebaseText = document.getElementById(firebaseTextId) || document.createElement("span");
    const learnMoreId = prefixedId("learnmore");
    const learnMoreLink = document.getElementById(learnMoreId) || document.createElement("a");
    const prependIconId = prefixedId("preprendIcon");
    const prependIcon = document.getElementById(prependIconId) || document.createElementNS("http://www.w3.org/2000/svg", "svg");
    if (banner.created) {
      const bannerEl = banner.element;
      setupBannerStyles(bannerEl);
      setupLinkStyles(learnMoreLink, learnMoreId);
      const closeBtn = setupCloseBtn();
      setupIconStyles(prependIcon, prependIconId);
      bannerEl.append(prependIcon, firebaseText, learnMoreLink, closeBtn);
      document.body.appendChild(bannerEl);
    }
    if (showError) {
      firebaseText.innerText = `Preview backend disconnected.`;
      prependIcon.innerHTML = `<g clip-path="url(#clip0_6013_33858)">
<path d="M4.8 17.6L12 5.6L19.2 17.6H4.8ZM6.91667 16.4H17.0833L12 7.93333L6.91667 16.4ZM12 15.6C12.1667 15.6 12.3056 15.5444 12.4167 15.4333C12.5389 15.3111 12.6 15.1667 12.6 15C12.6 14.8333 12.5389 14.6944 12.4167 14.5833C12.3056 14.4611 12.1667 14.4 12 14.4C11.8333 14.4 11.6889 14.4611 11.5667 14.5833C11.4556 14.6944 11.4 14.8333 11.4 15C11.4 15.1667 11.4556 15.3111 11.5667 15.4333C11.6889 15.5444 11.8333 15.6 12 15.6ZM11.4 13.6H12.6V10.4H11.4V13.6Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6013_33858">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`;
    } else {
      prependIcon.innerHTML = `<g clip-path="url(#clip0_6083_34804)">
<path d="M11.4 15.2H12.6V11.2H11.4V15.2ZM12 10C12.1667 10 12.3056 9.94444 12.4167 9.83333C12.5389 9.71111 12.6 9.56667 12.6 9.4C12.6 9.23333 12.5389 9.09444 12.4167 8.98333C12.3056 8.86111 12.1667 8.8 12 8.8C11.8333 8.8 11.6889 8.86111 11.5667 8.98333C11.4556 9.09444 11.4 9.23333 11.4 9.4C11.4 9.56667 11.4556 9.71111 11.5667 9.83333C11.6889 9.94444 11.8333 10 12 10ZM12 18.4C11.1222 18.4 10.2944 18.2333 9.51667 17.9C8.73889 17.5667 8.05556 17.1111 7.46667 16.5333C6.88889 15.9444 6.43333 15.2611 6.1 14.4833C5.76667 13.7056 5.6 12.8778 5.6 12C5.6 11.1111 5.76667 10.2833 6.1 9.51667C6.43333 8.73889 6.88889 8.06111 7.46667 7.48333C8.05556 6.89444 8.73889 6.43333 9.51667 6.1C10.2944 5.76667 11.1222 5.6 12 5.6C12.8889 5.6 13.7167 5.76667 14.4833 6.1C15.2611 6.43333 15.9389 6.89444 16.5167 7.48333C17.1056 8.06111 17.5667 8.73889 17.9 9.51667C18.2333 10.2833 18.4 11.1111 18.4 12C18.4 12.8778 18.2333 13.7056 17.9 14.4833C17.5667 15.2611 17.1056 15.9444 16.5167 16.5333C15.9389 17.1111 15.2611 17.5667 14.4833 17.9C13.7167 18.2333 12.8889 18.4 12 18.4ZM12 17.2C13.4444 17.2 14.6722 16.6944 15.6833 15.6833C16.6944 14.6722 17.2 13.4444 17.2 12C17.2 10.5556 16.6944 9.32778 15.6833 8.31667C14.6722 7.30555 13.4444 6.8 12 6.8C10.5556 6.8 9.32778 7.30555 8.31667 8.31667C7.30556 9.32778 6.8 10.5556 6.8 12C6.8 13.4444 7.30556 14.6722 8.31667 15.6833C9.32778 16.6944 10.5556 17.2 12 17.2Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6083_34804">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`;
      firebaseText.innerText = "Preview backend running in this workspace.";
    }
    firebaseText.setAttribute("id", firebaseTextId);
  }
  __name(setupDom, "setupDom");
  if (document.readyState === "loading") {
    window.addEventListener("DOMContentLoaded", setupDom);
  } else {
    setupDom();
  }
}
__name(updateEmulatorBanner, "updateEmulatorBanner");
function getUA() {
  if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
    return navigator["userAgent"];
  } else {
    return "";
  }
}
__name(getUA, "getUA");
function isMobileCordova() {
  return typeof window !== "undefined" && // @ts-ignore Setting up an broadly applicable index signature for Window
  // just to deal with this case would probably be a bad idea.
  !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
}
__name(isMobileCordova, "isMobileCordova");
function isNode() {
  var _a;
  const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;
  if (forceEnvironment === "node") {
    return true;
  } else if (forceEnvironment === "browser") {
    return false;
  }
  try {
    return Object.prototype.toString.call(global.process) === "[object process]";
  } catch (e10) {
    return false;
  }
}
__name(isNode, "isNode");
function isBrowser() {
  return typeof window !== "undefined" || isWebWorker();
}
__name(isBrowser, "isBrowser");
function isWebWorker() {
  return typeof WorkerGlobalScope !== "undefined" && typeof self !== "undefined" && self instanceof WorkerGlobalScope;
}
__name(isWebWorker, "isWebWorker");
function isCloudflareWorker() {
  return typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers";
}
__name(isCloudflareWorker, "isCloudflareWorker");
function isBrowserExtension() {
  const runtime = typeof chrome === "object" ? chrome.runtime : typeof browser === "object" ? browser.runtime : void 0;
  return typeof runtime === "object" && runtime.id !== void 0;
}
__name(isBrowserExtension, "isBrowserExtension");
function isReactNative() {
  return typeof navigator === "object" && navigator["product"] === "ReactNative";
}
__name(isReactNative, "isReactNative");
function isElectron() {
  return getUA().indexOf("Electron/") >= 0;
}
__name(isElectron, "isElectron");
function isIE() {
  const ua = getUA();
  return ua.indexOf("MSIE ") >= 0 || ua.indexOf("Trident/") >= 0;
}
__name(isIE, "isIE");
function isUWP() {
  return getUA().indexOf("MSAppHost/") >= 0;
}
__name(isUWP, "isUWP");
function isNodeSdk() {
  return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
}
__name(isNodeSdk, "isNodeSdk");
function isSafari() {
  return !isNode() && !!navigator.userAgent && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome");
}
__name(isSafari, "isSafari");
function isSafariOrWebkit() {
  return !isNode() && !!navigator.userAgent && (navigator.userAgent.includes("Safari") || navigator.userAgent.includes("WebKit")) && !navigator.userAgent.includes("Chrome");
}
__name(isSafariOrWebkit, "isSafariOrWebkit");
function isIndexedDBAvailable() {
  try {
    return typeof indexedDB === "object";
  } catch (e10) {
    return false;
  }
}
__name(isIndexedDBAvailable, "isIndexedDBAvailable");
function validateIndexedDBOpenable() {
  return new Promise((resolve, reject) => {
    try {
      let preExist = true;
      const DB_CHECK_NAME = "validate-browser-context-for-indexeddb-analytics-module";
      const request = self.indexedDB.open(DB_CHECK_NAME);
      request.onsuccess = () => {
        request.result.close();
        if (!preExist) {
          self.indexedDB.deleteDatabase(DB_CHECK_NAME);
        }
        resolve(true);
      };
      request.onupgradeneeded = () => {
        preExist = false;
      };
      request.onerror = () => {
        var _a;
        reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || "");
      };
    } catch (error) {
      reject(error);
    }
  });
}
__name(validateIndexedDBOpenable, "validateIndexedDBOpenable");
function areCookiesEnabled() {
  if (typeof navigator === "undefined" || !navigator.cookieEnabled) {
    return false;
  }
  return true;
}
__name(areCookiesEnabled, "areCookiesEnabled");
var ERROR_NAME = "FirebaseError";
var FirebaseError = class _FirebaseError extends Error {
  static {
    __name(this, "FirebaseError");
  }
  constructor(code, message, customData) {
    super(message);
    this.code = code;
    this.customData = customData;
    this.name = ERROR_NAME;
    Object.setPrototypeOf(this, _FirebaseError.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ErrorFactory.prototype.create);
    }
  }
};
var ErrorFactory = class {
  static {
    __name(this, "ErrorFactory");
  }
  constructor(service, serviceName, errors) {
    this.service = service;
    this.serviceName = serviceName;
    this.errors = errors;
  }
  create(code, ...data) {
    const customData = data[0] || {};
    const fullCode = `${this.service}/${code}`;
    const template = this.errors[code];
    const message = template ? replaceTemplate(template, customData) : "Error";
    const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
    const error = new FirebaseError(fullCode, fullMessage, customData);
    return error;
  }
};
function replaceTemplate(template, data) {
  return template.replace(PATTERN, (_, key) => {
    const value = data[key];
    return value != null ? String(value) : `<${key}?>`;
  });
}
__name(replaceTemplate, "replaceTemplate");
var PATTERN = /\{\$([^}]+)}/g;
function jsonEval(str) {
  return JSON.parse(str);
}
__name(jsonEval, "jsonEval");
function stringify(data) {
  return JSON.stringify(data);
}
__name(stringify, "stringify");
var decode = /* @__PURE__ */ __name(function(token) {
  let header = {}, claims = {}, data = {}, signature = "";
  try {
    const parts = token.split(".");
    header = jsonEval(base64Decode(parts[0]) || "");
    claims = jsonEval(base64Decode(parts[1]) || "");
    signature = parts[2];
    data = claims["d"] || {};
    delete claims["d"];
  } catch (e10) {
  }
  return {
    header,
    claims,
    data,
    signature
  };
}, "decode");
var isValidTimestamp = /* @__PURE__ */ __name(function(token) {
  const claims = decode(token).claims;
  const now = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
  let validSince = 0, validUntil = 0;
  if (typeof claims === "object") {
    if (claims.hasOwnProperty("nbf")) {
      validSince = claims["nbf"];
    } else if (claims.hasOwnProperty("iat")) {
      validSince = claims["iat"];
    }
    if (claims.hasOwnProperty("exp")) {
      validUntil = claims["exp"];
    } else {
      validUntil = validSince + 86400;
    }
  }
  return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;
}, "isValidTimestamp");
var issuedAtTime = /* @__PURE__ */ __name(function(token) {
  const claims = decode(token).claims;
  if (typeof claims === "object" && claims.hasOwnProperty("iat")) {
    return claims["iat"];
  }
  return null;
}, "issuedAtTime");
var isValidFormat = /* @__PURE__ */ __name(function(token) {
  const decoded = decode(token), claims = decoded.claims;
  return !!claims && typeof claims === "object" && claims.hasOwnProperty("iat");
}, "isValidFormat");
var isAdmin = /* @__PURE__ */ __name(function(token) {
  const claims = decode(token).claims;
  return typeof claims === "object" && claims["admin"] === true;
}, "isAdmin");
function contains(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
__name(contains, "contains");
function safeGet(obj, key) {
  if (Object.prototype.hasOwnProperty.call(obj, key)) {
    return obj[key];
  } else {
    return void 0;
  }
}
__name(safeGet, "safeGet");
function isEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
__name(isEmpty, "isEmpty");
function map(obj, fn, contextObj) {
  const res = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      res[key] = fn.call(contextObj, obj[key], key, obj);
    }
  }
  return res;
}
__name(map, "map");
function deepEqual(a22, b7) {
  if (a22 === b7) {
    return true;
  }
  const aKeys = Object.keys(a22);
  const bKeys = Object.keys(b7);
  for (const k5 of aKeys) {
    if (!bKeys.includes(k5)) {
      return false;
    }
    const aProp = a22[k5];
    const bProp = b7[k5];
    if (isObject(aProp) && isObject(bProp)) {
      if (!deepEqual(aProp, bProp)) {
        return false;
      }
    } else if (aProp !== bProp) {
      return false;
    }
  }
  for (const k5 of bKeys) {
    if (!aKeys.includes(k5)) {
      return false;
    }
  }
  return true;
}
__name(deepEqual, "deepEqual");
function isObject(thing) {
  return thing !== null && typeof thing === "object";
}
__name(isObject, "isObject");
function promiseWithTimeout(promise, timeInMS = 2e3) {
  const deferredPromise = new Deferred();
  setTimeout(() => deferredPromise.reject("timeout!"), timeInMS);
  promise.then(deferredPromise.resolve, deferredPromise.reject);
  return deferredPromise.promise;
}
__name(promiseWithTimeout, "promiseWithTimeout");
function querystring(querystringParams) {
  const params = [];
  for (const [key, value] of Object.entries(querystringParams)) {
    if (Array.isArray(value)) {
      value.forEach((arrayVal) => {
        params.push(encodeURIComponent(key) + "=" + encodeURIComponent(arrayVal));
      });
    } else {
      params.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
    }
  }
  return params.length ? "&" + params.join("&") : "";
}
__name(querystring, "querystring");
function querystringDecode(querystring2) {
  const obj = {};
  const tokens = querystring2.replace(/^\?/, "").split("&");
  tokens.forEach((token) => {
    if (token) {
      const [key, value] = token.split("=");
      obj[decodeURIComponent(key)] = decodeURIComponent(value);
    }
  });
  return obj;
}
__name(querystringDecode, "querystringDecode");
function extractQuerystring(url) {
  const queryStart = url.indexOf("?");
  if (!queryStart) {
    return "";
  }
  const fragmentStart = url.indexOf("#", queryStart);
  return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : void 0);
}
__name(extractQuerystring, "extractQuerystring");
var Sha1 = class {
  static {
    __name(this, "Sha1");
  }
  constructor() {
    this.chain_ = [];
    this.buf_ = [];
    this.W_ = [];
    this.pad_ = [];
    this.inbuf_ = 0;
    this.total_ = 0;
    this.blockSize = 512 / 8;
    this.pad_[0] = 128;
    for (let i18 = 1; i18 < this.blockSize; ++i18) {
      this.pad_[i18] = 0;
    }
    this.reset();
  }
  reset() {
    this.chain_[0] = 1732584193;
    this.chain_[1] = 4023233417;
    this.chain_[2] = 2562383102;
    this.chain_[3] = 271733878;
    this.chain_[4] = 3285377520;
    this.inbuf_ = 0;
    this.total_ = 0;
  }
  /**
   * Internal compress helper function.
   * @param buf Block to compress.
   * @param offset Offset of the block in the buffer.
   * @private
   */
  compress_(buf, offset) {
    if (!offset) {
      offset = 0;
    }
    const W = this.W_;
    if (typeof buf === "string") {
      for (let i18 = 0; i18 < 16; i18++) {
        W[i18] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);
        offset += 4;
      }
    } else {
      for (let i18 = 0; i18 < 16; i18++) {
        W[i18] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];
        offset += 4;
      }
    }
    for (let i18 = 16; i18 < 80; i18++) {
      const t11 = W[i18 - 3] ^ W[i18 - 8] ^ W[i18 - 14] ^ W[i18 - 16];
      W[i18] = (t11 << 1 | t11 >>> 31) & 4294967295;
    }
    let a22 = this.chain_[0];
    let b7 = this.chain_[1];
    let c21 = this.chain_[2];
    let d15 = this.chain_[3];
    let e10 = this.chain_[4];
    let f13, k5;
    for (let i18 = 0; i18 < 80; i18++) {
      if (i18 < 40) {
        if (i18 < 20) {
          f13 = d15 ^ b7 & (c21 ^ d15);
          k5 = 1518500249;
        } else {
          f13 = b7 ^ c21 ^ d15;
          k5 = 1859775393;
        }
      } else {
        if (i18 < 60) {
          f13 = b7 & c21 | d15 & (b7 | c21);
          k5 = 2400959708;
        } else {
          f13 = b7 ^ c21 ^ d15;
          k5 = 3395469782;
        }
      }
      const t11 = (a22 << 5 | a22 >>> 27) + f13 + e10 + k5 + W[i18] & 4294967295;
      e10 = d15;
      d15 = c21;
      c21 = (b7 << 30 | b7 >>> 2) & 4294967295;
      b7 = a22;
      a22 = t11;
    }
    this.chain_[0] = this.chain_[0] + a22 & 4294967295;
    this.chain_[1] = this.chain_[1] + b7 & 4294967295;
    this.chain_[2] = this.chain_[2] + c21 & 4294967295;
    this.chain_[3] = this.chain_[3] + d15 & 4294967295;
    this.chain_[4] = this.chain_[4] + e10 & 4294967295;
  }
  update(bytes, length) {
    if (bytes == null) {
      return;
    }
    if (length === void 0) {
      length = bytes.length;
    }
    const lengthMinusBlock = length - this.blockSize;
    let n11 = 0;
    const buf = this.buf_;
    let inbuf = this.inbuf_;
    while (n11 < length) {
      if (inbuf === 0) {
        while (n11 <= lengthMinusBlock) {
          this.compress_(bytes, n11);
          n11 += this.blockSize;
        }
      }
      if (typeof bytes === "string") {
        while (n11 < length) {
          buf[inbuf] = bytes.charCodeAt(n11);
          ++inbuf;
          ++n11;
          if (inbuf === this.blockSize) {
            this.compress_(buf);
            inbuf = 0;
            break;
          }
        }
      } else {
        while (n11 < length) {
          buf[inbuf] = bytes[n11];
          ++inbuf;
          ++n11;
          if (inbuf === this.blockSize) {
            this.compress_(buf);
            inbuf = 0;
            break;
          }
        }
      }
    }
    this.inbuf_ = inbuf;
    this.total_ += length;
  }
  /** @override */
  digest() {
    const digest = [];
    let totalBits = this.total_ * 8;
    if (this.inbuf_ < 56) {
      this.update(this.pad_, 56 - this.inbuf_);
    } else {
      this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
    }
    for (let i18 = this.blockSize - 1; i18 >= 56; i18--) {
      this.buf_[i18] = totalBits & 255;
      totalBits /= 256;
    }
    this.compress_(this.buf_);
    let n11 = 0;
    for (let i18 = 0; i18 < 5; i18++) {
      for (let j2 = 24; j2 >= 0; j2 -= 8) {
        digest[n11] = this.chain_[i18] >> j2 & 255;
        ++n11;
      }
    }
    return digest;
  }
};
function createSubscribe(executor, onNoObservers) {
  const proxy = new ObserverProxy(executor, onNoObservers);
  return proxy.subscribe.bind(proxy);
}
__name(createSubscribe, "createSubscribe");
var ObserverProxy = class {
  static {
    __name(this, "ObserverProxy");
  }
  /**
   * @param executor Function which can make calls to a single Observer
   *     as a proxy.
   * @param onNoObservers Callback when count of Observers goes to zero.
   */
  constructor(executor, onNoObservers) {
    this.observers = [];
    this.unsubscribes = [];
    this.observerCount = 0;
    this.task = Promise.resolve();
    this.finalized = false;
    this.onNoObservers = onNoObservers;
    this.task.then(() => {
      executor(this);
    }).catch((e10) => {
      this.error(e10);
    });
  }
  next(value) {
    this.forEachObserver((observer) => {
      observer.next(value);
    });
  }
  error(error) {
    this.forEachObserver((observer) => {
      observer.error(error);
    });
    this.close(error);
  }
  complete() {
    this.forEachObserver((observer) => {
      observer.complete();
    });
    this.close();
  }
  /**
   * Subscribe function that can be used to add an Observer to the fan-out list.
   *
   * - We require that no event is sent to a subscriber synchronously to their
   *   call to subscribe().
   */
  subscribe(nextOrObserver, error, complete) {
    let observer;
    if (nextOrObserver === void 0 && error === void 0 && complete === void 0) {
      throw new Error("Missing Observer.");
    }
    if (implementsAnyMethods(nextOrObserver, [
      "next",
      "error",
      "complete"
    ])) {
      observer = nextOrObserver;
    } else {
      observer = {
        next: nextOrObserver,
        error,
        complete
      };
    }
    if (observer.next === void 0) {
      observer.next = noop;
    }
    if (observer.error === void 0) {
      observer.error = noop;
    }
    if (observer.complete === void 0) {
      observer.complete = noop;
    }
    const unsub = this.unsubscribeOne.bind(this, this.observers.length);
    if (this.finalized) {
      this.task.then(() => {
        try {
          if (this.finalError) {
            observer.error(this.finalError);
          } else {
            observer.complete();
          }
        } catch (e10) {
        }
        return;
      });
    }
    this.observers.push(observer);
    return unsub;
  }
  // Unsubscribe is synchronous - we guarantee that no events are sent to
  // any unsubscribed Observer.
  unsubscribeOne(i18) {
    if (this.observers === void 0 || this.observers[i18] === void 0) {
      return;
    }
    delete this.observers[i18];
    this.observerCount -= 1;
    if (this.observerCount === 0 && this.onNoObservers !== void 0) {
      this.onNoObservers(this);
    }
  }
  forEachObserver(fn) {
    if (this.finalized) {
      return;
    }
    for (let i18 = 0; i18 < this.observers.length; i18++) {
      this.sendOne(i18, fn);
    }
  }
  // Call the Observer via one of it's callback function. We are careful to
  // confirm that the observe has not been unsubscribed since this asynchronous
  // function had been queued.
  sendOne(i18, fn) {
    this.task.then(() => {
      if (this.observers !== void 0 && this.observers[i18] !== void 0) {
        try {
          fn(this.observers[i18]);
        } catch (e10) {
          if (typeof console !== "undefined" && console.error) {
            console.error(e10);
          }
        }
      }
    });
  }
  close(err) {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    if (err !== void 0) {
      this.finalError = err;
    }
    this.task.then(() => {
      this.observers = void 0;
      this.onNoObservers = void 0;
    });
  }
};
function async(fn, onError) {
  return (...args) => {
    Promise.resolve(true).then(() => {
      fn(...args);
    }).catch((error) => {
      if (onError) {
        onError(error);
      }
    });
  };
}
__name(async, "async");
function implementsAnyMethods(obj, methods) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  for (const method of methods) {
    if (method in obj && typeof obj[method] === "function") {
      return true;
    }
  }
  return false;
}
__name(implementsAnyMethods, "implementsAnyMethods");
function noop() {
}
__name(noop, "noop");
var validateArgCount = /* @__PURE__ */ __name(function(fnName, minCount, maxCount, argCount) {
  let argError;
  if (argCount < minCount) {
    argError = "at least " + minCount;
  } else if (argCount > maxCount) {
    argError = maxCount === 0 ? "none" : "no more than " + maxCount;
  }
  if (argError) {
    const error = fnName + " failed: Was called with " + argCount + (argCount === 1 ? " argument." : " arguments.") + " Expects " + argError + ".";
    throw new Error(error);
  }
}, "validateArgCount");
function errorPrefix(fnName, argName) {
  return `${fnName} failed: ${argName} argument `;
}
__name(errorPrefix, "errorPrefix");
function validateNamespace(fnName, namespace, optional) {
  if (optional && !namespace) {
    return;
  }
  if (typeof namespace !== "string") {
    throw new Error(errorPrefix(fnName, "namespace") + "must be a valid firebase namespace.");
  }
}
__name(validateNamespace, "validateNamespace");
function validateCallback(fnName, argumentName, callback, optional) {
  if (optional && !callback) {
    return;
  }
  if (typeof callback !== "function") {
    throw new Error(errorPrefix(fnName, argumentName) + "must be a valid function.");
  }
}
__name(validateCallback, "validateCallback");
function validateContextObject(fnName, argumentName, context2, optional) {
  if (optional && !context2) {
    return;
  }
  if (typeof context2 !== "object" || context2 === null) {
    throw new Error(errorPrefix(fnName, argumentName) + "must be a valid context object.");
  }
}
__name(validateContextObject, "validateContextObject");
var stringToByteArray = /* @__PURE__ */ __name(function(str) {
  const out = [];
  let p15 = 0;
  for (let i18 = 0; i18 < str.length; i18++) {
    let c21 = str.charCodeAt(i18);
    if (c21 >= 55296 && c21 <= 56319) {
      const high = c21 - 55296;
      i18++;
      assert(i18 < str.length, "Surrogate pair missing trail surrogate.");
      const low = str.charCodeAt(i18) - 56320;
      c21 = 65536 + (high << 10) + low;
    }
    if (c21 < 128) {
      out[p15++] = c21;
    } else if (c21 < 2048) {
      out[p15++] = c21 >> 6 | 192;
      out[p15++] = c21 & 63 | 128;
    } else if (c21 < 65536) {
      out[p15++] = c21 >> 12 | 224;
      out[p15++] = c21 >> 6 & 63 | 128;
      out[p15++] = c21 & 63 | 128;
    } else {
      out[p15++] = c21 >> 18 | 240;
      out[p15++] = c21 >> 12 & 63 | 128;
      out[p15++] = c21 >> 6 & 63 | 128;
      out[p15++] = c21 & 63 | 128;
    }
  }
  return out;
}, "stringToByteArray");
var stringLength = /* @__PURE__ */ __name(function(str) {
  let p15 = 0;
  for (let i18 = 0; i18 < str.length; i18++) {
    const c21 = str.charCodeAt(i18);
    if (c21 < 128) {
      p15++;
    } else if (c21 < 2048) {
      p15 += 2;
    } else if (c21 >= 55296 && c21 <= 56319) {
      p15 += 4;
      i18++;
    } else {
      p15 += 3;
    }
  }
  return p15;
}, "stringLength");
var DEFAULT_INTERVAL_MILLIS = 1e3;
var DEFAULT_BACKOFF_FACTOR = 2;
var MAX_VALUE_MILLIS = 4 * 60 * 60 * 1e3;
var RANDOM_FACTOR = 0.5;
function calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {
  const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);
  const randomWait = Math.round(
    // A fraction of the backoff value to add/subtract.
    // Deviation: changes multiplication order to improve readability.
    RANDOM_FACTOR * currBaseValue * // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines
    // if we add or subtract.
    (Math.random() - 0.5) * 2
  );
  return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);
}
__name(calculateBackoffMillis, "calculateBackoffMillis");
function ordinal(i18) {
  if (!Number.isFinite(i18)) {
    return `${i18}`;
  }
  return i18 + indicator(i18);
}
__name(ordinal, "ordinal");
function indicator(i18) {
  i18 = Math.abs(i18);
  const cent = i18 % 100;
  if (cent >= 10 && cent <= 20) {
    return "th";
  }
  const dec = i18 % 10;
  if (dec === 1) {
    return "st";
  }
  if (dec === 2) {
    return "nd";
  }
  if (dec === 3) {
    return "rd";
  }
  return "th";
}
__name(indicator, "indicator");
function getModularInstance(service) {
  if (service && service._delegate) {
    return service._delegate;
  } else {
    return service;
  }
}
__name(getModularInstance, "getModularInstance");
CONSTANTS.NODE_CLIENT = true;

// node_modules/@firebase/component/dist/esm/index.esm2017.js
var Component = class {
  static {
    __name(this, "Component");
  }
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(name4, instanceFactory, type) {
    this.name = name4;
    this.instanceFactory = instanceFactory;
    this.type = type;
    this.multipleInstances = false;
    this.serviceProps = {};
    this.instantiationMode = "LAZY";
    this.onInstanceCreated = null;
  }
  setInstantiationMode(mode) {
    this.instantiationMode = mode;
    return this;
  }
  setMultipleInstances(multipleInstances) {
    this.multipleInstances = multipleInstances;
    return this;
  }
  setServiceProps(props) {
    this.serviceProps = props;
    return this;
  }
  setInstanceCreatedCallback(callback) {
    this.onInstanceCreated = callback;
    return this;
  }
};
var DEFAULT_ENTRY_NAME = "[DEFAULT]";
var Provider = class {
  static {
    __name(this, "Provider");
  }
  constructor(name4, container) {
    this.name = name4;
    this.container = container;
    this.component = null;
    this.instances = /* @__PURE__ */ new Map();
    this.instancesDeferred = /* @__PURE__ */ new Map();
    this.instancesOptions = /* @__PURE__ */ new Map();
    this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  /**
   * @param identifier A provider can provide multiple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(identifier) {
    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    if (!this.instancesDeferred.has(normalizedIdentifier)) {
      const deferred = new Deferred();
      this.instancesDeferred.set(normalizedIdentifier, deferred);
      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
        try {
          const instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
          if (instance) {
            deferred.resolve(instance);
          }
        } catch (e10) {
        }
      }
    }
    return this.instancesDeferred.get(normalizedIdentifier).promise;
  }
  getImmediate(options) {
    var _a;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
    const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
      try {
        return this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
      } catch (e10) {
        if (optional) {
          return null;
        } else {
          throw e10;
        }
      }
    } else {
      if (optional) {
        return null;
      } else {
        throw Error(`Service ${this.name} is not available`);
      }
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(component) {
    if (component.name !== this.name) {
      throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
    }
    if (this.component) {
      throw Error(`Component for ${this.name} has already been provided`);
    }
    this.component = component;
    if (!this.shouldAutoInitialize()) {
      return;
    }
    if (isComponentEager(component)) {
      try {
        this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });
      } catch (e10) {
      }
    }
    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
      const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      try {
        const instance = this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
        instanceDeferred.resolve(instance);
      } catch (e10) {
      }
    }
  }
  clearInstance(identifier = DEFAULT_ENTRY_NAME) {
    this.instancesDeferred.delete(identifier);
    this.instancesOptions.delete(identifier);
    this.instances.delete(identifier);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const services = Array.from(this.instances.values());
    await Promise.all([
      ...services.filter((service) => "INTERNAL" in service).map((service) => service.INTERNAL.delete()),
      ...services.filter((service) => "_delete" in service).map((service) => service._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(identifier = DEFAULT_ENTRY_NAME) {
    return this.instances.has(identifier);
  }
  getOptions(identifier = DEFAULT_ENTRY_NAME) {
    return this.instancesOptions.get(identifier) || {};
  }
  initialize(opts = {}) {
    const { options = {} } = opts;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
    if (this.isInitialized(normalizedIdentifier)) {
      throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
    }
    if (!this.isComponentSet()) {
      throw Error(`Component ${this.name} has not been registered yet`);
    }
    const instance = this.getOrInitializeService({
      instanceIdentifier: normalizedIdentifier,
      options
    });
    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
      const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      if (normalizedIdentifier === normalizedDeferredIdentifier) {
        instanceDeferred.resolve(instance);
      }
    }
    return instance;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(callback, identifier) {
    var _a;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Set();
    existingCallbacks.add(callback);
    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
    const existingInstance = this.instances.get(normalizedIdentifier);
    if (existingInstance) {
      callback(existingInstance, normalizedIdentifier);
    }
    return () => {
      existingCallbacks.delete(callback);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(instance, identifier) {
    const callbacks = this.onInitCallbacks.get(identifier);
    if (!callbacks) {
      return;
    }
    for (const callback of callbacks) {
      try {
        callback(instance, identifier);
      } catch (_a) {
      }
    }
  }
  getOrInitializeService({ instanceIdentifier, options = {} }) {
    let instance = this.instances.get(instanceIdentifier);
    if (!instance && this.component) {
      instance = this.component.instanceFactory(this.container, {
        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
        options
      });
      this.instances.set(instanceIdentifier, instance);
      this.instancesOptions.set(instanceIdentifier, options);
      this.invokeOnInitCallbacks(instance, instanceIdentifier);
      if (this.component.onInstanceCreated) {
        try {
          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
        } catch (_a) {
        }
      }
    }
    return instance || null;
  }
  normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {
    if (this.component) {
      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
    } else {
      return identifier;
    }
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
};
function normalizeIdentifierForFactory(identifier) {
  return identifier === DEFAULT_ENTRY_NAME ? void 0 : identifier;
}
__name(normalizeIdentifierForFactory, "normalizeIdentifierForFactory");
function isComponentEager(component) {
  return component.instantiationMode === "EAGER";
}
__name(isComponentEager, "isComponentEager");
var ComponentContainer = class {
  static {
    __name(this, "ComponentContainer");
  }
  constructor(name4) {
    this.name = name4;
    this.providers = /* @__PURE__ */ new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(component) {
    const provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
    }
    provider.setComponent(component);
  }
  addOrOverwriteComponent(component) {
    const provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      this.providers.delete(component.name);
    }
    this.addComponent(component);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(name4) {
    if (this.providers.has(name4)) {
      return this.providers.get(name4);
    }
    const provider = new Provider(name4, this);
    this.providers.set(name4, provider);
    return provider;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
};

// node_modules/@firebase/logger/dist/esm/index.esm2017.js
var instances = [];
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
  LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
  LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
var levelStringToEnum = {
  "debug": LogLevel.DEBUG,
  "verbose": LogLevel.VERBOSE,
  "info": LogLevel.INFO,
  "warn": LogLevel.WARN,
  "error": LogLevel.ERROR,
  "silent": LogLevel.SILENT
};
var defaultLogLevel = LogLevel.INFO;
var ConsoleMethod = {
  [LogLevel.DEBUG]: "log",
  [LogLevel.VERBOSE]: "log",
  [LogLevel.INFO]: "info",
  [LogLevel.WARN]: "warn",
  [LogLevel.ERROR]: "error"
};
var defaultLogHandler = /* @__PURE__ */ __name((instance, logType, ...args) => {
  if (logType < instance.logLevel) {
    return;
  }
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const method = ConsoleMethod[logType];
  if (method) {
    console[method](`[${now}]  ${instance.name}:`, ...args);
  } else {
    throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
  }
}, "defaultLogHandler");
var Logger = class {
  static {
    __name(this, "Logger");
  }
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(name4) {
    this.name = name4;
    this._logLevel = defaultLogLevel;
    this._logHandler = defaultLogHandler;
    this._userLogHandler = null;
    instances.push(this);
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(val) {
    if (!(val in LogLevel)) {
      throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
    }
    this._logLevel = val;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(val) {
    this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(val) {
    if (typeof val !== "function") {
      throw new TypeError("Value assigned to `logHandler` must be a function");
    }
    this._logHandler = val;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(val) {
    this._userLogHandler = val;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
    this._logHandler(this, LogLevel.DEBUG, ...args);
  }
  log(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);
    this._logHandler(this, LogLevel.VERBOSE, ...args);
  }
  info(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
    this._logHandler(this, LogLevel.INFO, ...args);
  }
  warn(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
    this._logHandler(this, LogLevel.WARN, ...args);
  }
  error(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
    this._logHandler(this, LogLevel.ERROR, ...args);
  }
};
function setLogLevel(level) {
  instances.forEach((inst) => {
    inst.setLogLevel(level);
  });
}
__name(setLogLevel, "setLogLevel");
function setUserLogHandler(logCallback, options) {
  for (const instance of instances) {
    let customLogLevel = null;
    if (options && options.level) {
      customLogLevel = levelStringToEnum[options.level];
    }
    if (logCallback === null) {
      instance.userLogHandler = null;
    } else {
      instance.userLogHandler = (instance2, level, ...args) => {
        const message = args.map((arg) => {
          if (arg == null) {
            return null;
          } else if (typeof arg === "string") {
            return arg;
          } else if (typeof arg === "number" || typeof arg === "boolean") {
            return arg.toString();
          } else if (arg instanceof Error) {
            return arg.message;
          } else {
            try {
              return JSON.stringify(arg);
            } catch (ignored) {
              return null;
            }
          }
        }).filter((arg) => arg).join(" ");
        if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance2.logLevel)) {
          logCallback({
            level: LogLevel[level].toLowerCase(),
            message,
            args,
            type: instance2.name
          });
        }
      };
    }
  }
}
__name(setUserLogHandler, "setUserLogHandler");

// node_modules/idb/build/wrap-idb-value.js
var instanceOfAny = /* @__PURE__ */ __name((object, constructors) => constructors.some((c21) => object instanceof c21), "instanceOfAny");
var idbProxyableTypes;
var cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
__name(getIdbProxyableTypes, "getIdbProxyableTypes");
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
__name(getCursorAdvanceMethods, "getCursorAdvanceMethods");
var cursorRequestMap = /* @__PURE__ */ new WeakMap();
var transactionDoneMap = /* @__PURE__ */ new WeakMap();
var transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
var transformCache = /* @__PURE__ */ new WeakMap();
var reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = /* @__PURE__ */ __name(() => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    }, "unlisten");
    const success = /* @__PURE__ */ __name(() => {
      resolve(wrap(request.result));
      unlisten();
    }, "success");
    const error = /* @__PURE__ */ __name(() => {
      reject(request.error);
      unlisten();
    }, "error");
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
__name(promisifyRequest, "promisifyRequest");
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = /* @__PURE__ */ __name(() => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    }, "unlisten");
    const complete = /* @__PURE__ */ __name(() => {
      resolve();
      unlisten();
    }, "complete");
    const error = /* @__PURE__ */ __name(() => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    }, "error");
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
__name(cacheDonePromiseForTransaction, "cacheDonePromiseForTransaction");
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
__name(replaceTraps, "replaceTraps");
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
__name(wrapFunction, "wrapFunction");
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
__name(transformCachableValue, "transformCachableValue");
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
__name(wrap, "wrap");
var unwrap = /* @__PURE__ */ __name((value) => reverseTransformCache.get(value), "unwrap");

// node_modules/idb/build/index.js
function openDB(name4, version6, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name4, version6);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
__name(openDB, "openDB");
function deleteDB(name4, { blocked } = {}) {
  const request = indexedDB.deleteDatabase(name4);
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event
    ));
  }
  return wrap(request).then(() => void 0);
}
__name(deleteDB, "deleteDB");
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite2 = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite2 || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = /* @__PURE__ */ __name(async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite2 ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite2 && tx.done
    ]))[0];
  }, "method");
  cachedMethods.set(prop, method);
  return method;
}
__name(getMethod, "getMethod");
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: /* @__PURE__ */ __name((target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver), "get"),
  has: /* @__PURE__ */ __name((target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop), "has")
}));

// node_modules/@firebase/app/dist/esm/index.esm2017.js
var PlatformLoggerServiceImpl = class {
  static {
    __name(this, "PlatformLoggerServiceImpl");
  }
  constructor(container) {
    this.container = container;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    const providers = this.container.getProviders();
    return providers.map((provider) => {
      if (isVersionServiceProvider(provider)) {
        const service = provider.getImmediate();
        return `${service.library}/${service.version}`;
      } else {
        return null;
      }
    }).filter((logString) => logString).join(" ");
  }
};
function isVersionServiceProvider(provider) {
  const component = provider.getComponent();
  return (component === null || component === void 0 ? void 0 : component.type) === "VERSION";
}
__name(isVersionServiceProvider, "isVersionServiceProvider");
var name$q = "@firebase/app";
var version$1 = "0.13.1";
var logger = new Logger("@firebase/app");
var name$p = "@firebase/app-compat";
var name$o = "@firebase/analytics-compat";
var name$n = "@firebase/analytics";
var name$m = "@firebase/app-check-compat";
var name$l = "@firebase/app-check";
var name$k = "@firebase/auth";
var name$j = "@firebase/auth-compat";
var name$i = "@firebase/database";
var name$h = "@firebase/data-connect";
var name$g = "@firebase/database-compat";
var name$f = "@firebase/functions";
var name$e = "@firebase/functions-compat";
var name$d = "@firebase/installations";
var name$c = "@firebase/installations-compat";
var name$b = "@firebase/messaging";
var name$a = "@firebase/messaging-compat";
var name$9 = "@firebase/performance";
var name$8 = "@firebase/performance-compat";
var name$7 = "@firebase/remote-config";
var name$6 = "@firebase/remote-config-compat";
var name$5 = "@firebase/storage";
var name$4 = "@firebase/storage-compat";
var name$3 = "@firebase/firestore";
var name$2 = "@firebase/ai";
var name$1 = "@firebase/firestore-compat";
var name = "firebase";
var version = "11.9.0";
var DEFAULT_ENTRY_NAME2 = "[DEFAULT]";
var PLATFORM_LOG_STRING = {
  [name$q]: "fire-core",
  [name$p]: "fire-core-compat",
  [name$n]: "fire-analytics",
  [name$o]: "fire-analytics-compat",
  [name$l]: "fire-app-check",
  [name$m]: "fire-app-check-compat",
  [name$k]: "fire-auth",
  [name$j]: "fire-auth-compat",
  [name$i]: "fire-rtdb",
  [name$h]: "fire-data-connect",
  [name$g]: "fire-rtdb-compat",
  [name$f]: "fire-fn",
  [name$e]: "fire-fn-compat",
  [name$d]: "fire-iid",
  [name$c]: "fire-iid-compat",
  [name$b]: "fire-fcm",
  [name$a]: "fire-fcm-compat",
  [name$9]: "fire-perf",
  [name$8]: "fire-perf-compat",
  [name$7]: "fire-rc",
  [name$6]: "fire-rc-compat",
  [name$5]: "fire-gcs",
  [name$4]: "fire-gcs-compat",
  [name$3]: "fire-fst",
  [name$1]: "fire-fst-compat",
  [name$2]: "fire-vertex",
  "fire-js": "fire-js",
  // Platform identifier for JS SDK.
  [name]: "fire-js-all"
};
var _apps = /* @__PURE__ */ new Map();
var _serverApps = /* @__PURE__ */ new Map();
var _components = /* @__PURE__ */ new Map();
function _addComponent(app, component) {
  try {
    app.container.addComponent(component);
  } catch (e10) {
    logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e10);
  }
}
__name(_addComponent, "_addComponent");
function _addOrOverwriteComponent(app, component) {
  app.container.addOrOverwriteComponent(component);
}
__name(_addOrOverwriteComponent, "_addOrOverwriteComponent");
function _registerComponent(component) {
  const componentName = component.name;
  if (_components.has(componentName)) {
    logger.debug(`There were multiple attempts to register component ${componentName}.`);
    return false;
  }
  _components.set(componentName, component);
  for (const app of _apps.values()) {
    _addComponent(app, component);
  }
  for (const serverApp of _serverApps.values()) {
    _addComponent(serverApp, component);
  }
  return true;
}
__name(_registerComponent, "_registerComponent");
function _getProvider(app, name4) {
  const heartbeatController = app.container.getProvider("heartbeat").getImmediate({ optional: true });
  if (heartbeatController) {
    void heartbeatController.triggerHeartbeat();
  }
  return app.container.getProvider(name4);
}
__name(_getProvider, "_getProvider");
function _removeServiceInstance(app, name4, instanceIdentifier = DEFAULT_ENTRY_NAME2) {
  _getProvider(app, name4).clearInstance(instanceIdentifier);
}
__name(_removeServiceInstance, "_removeServiceInstance");
function _isFirebaseApp(obj) {
  return obj.options !== void 0;
}
__name(_isFirebaseApp, "_isFirebaseApp");
function _isFirebaseServerApp(obj) {
  if (obj === null || obj === void 0) {
    return false;
  }
  return obj.settings !== void 0;
}
__name(_isFirebaseServerApp, "_isFirebaseServerApp");
function _clearComponents() {
  _components.clear();
}
__name(_clearComponents, "_clearComponents");
var ERRORS = {
  [
    "no-app"
    /* AppError.NO_APP */
  ]: "No Firebase App '{$appName}' has been created - call initializeApp() first",
  [
    "bad-app-name"
    /* AppError.BAD_APP_NAME */
  ]: "Illegal App name: '{$appName}'",
  [
    "duplicate-app"
    /* AppError.DUPLICATE_APP */
  ]: "Firebase App named '{$appName}' already exists with different options or config",
  [
    "app-deleted"
    /* AppError.APP_DELETED */
  ]: "Firebase App named '{$appName}' already deleted",
  [
    "server-app-deleted"
    /* AppError.SERVER_APP_DELETED */
  ]: "Firebase Server App has been deleted",
  [
    "no-options"
    /* AppError.NO_OPTIONS */
  ]: "Need to provide options, when not being deployed to hosting via source.",
  [
    "invalid-app-argument"
    /* AppError.INVALID_APP_ARGUMENT */
  ]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  [
    "invalid-log-argument"
    /* AppError.INVALID_LOG_ARGUMENT */
  ]: "First argument to `onLog` must be null or a function.",
  [
    "idb-open"
    /* AppError.IDB_OPEN */
  ]: "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-get"
    /* AppError.IDB_GET */
  ]: "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-set"
    /* AppError.IDB_WRITE */
  ]: "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-delete"
    /* AppError.IDB_DELETE */
  ]: "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "finalization-registry-not-supported"
    /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */
  ]: "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
  [
    "invalid-server-app-environment"
    /* AppError.INVALID_SERVER_APP_ENVIRONMENT */
  ]: "FirebaseServerApp is not for use in browser environments."
};
var ERROR_FACTORY = new ErrorFactory("app", "Firebase", ERRORS);
var FirebaseAppImpl = class {
  static {
    __name(this, "FirebaseAppImpl");
  }
  constructor(options, config, container) {
    this._isDeleted = false;
    this._options = Object.assign({}, options);
    this._config = Object.assign({}, config);
    this._name = config.name;
    this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;
    this._container = container;
    this.container.addComponent(new Component(
      "app",
      () => this,
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ));
  }
  get automaticDataCollectionEnabled() {
    this.checkDestroyed();
    return this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(val) {
    this.checkDestroyed();
    this._automaticDataCollectionEnabled = val;
  }
  get name() {
    this.checkDestroyed();
    return this._name;
  }
  get options() {
    this.checkDestroyed();
    return this._options;
  }
  get config() {
    this.checkDestroyed();
    return this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(val) {
    this._isDeleted = val;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted) {
      throw ERROR_FACTORY.create("app-deleted", { appName: this._name });
    }
  }
};
function validateTokenTTL(base64Token, tokenName) {
  const secondPart = base64Decode(base64Token.split(".")[1]);
  if (secondPart === null) {
    console.error(`FirebaseServerApp ${tokenName} is invalid: second part could not be parsed.`);
    return;
  }
  const expClaim = JSON.parse(secondPart).exp;
  if (expClaim === void 0) {
    console.error(`FirebaseServerApp ${tokenName} is invalid: expiration claim could not be parsed`);
    return;
  }
  const exp = JSON.parse(secondPart).exp * 1e3;
  const now = (/* @__PURE__ */ new Date()).getTime();
  const diff = exp - now;
  if (diff <= 0) {
    console.error(`FirebaseServerApp ${tokenName} is invalid: the token has expired.`);
  }
}
__name(validateTokenTTL, "validateTokenTTL");
var FirebaseServerAppImpl = class extends FirebaseAppImpl {
  static {
    __name(this, "FirebaseServerAppImpl");
  }
  constructor(options, serverConfig, name4, container) {
    const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== void 0 ? serverConfig.automaticDataCollectionEnabled : true;
    const config = {
      name: name4,
      automaticDataCollectionEnabled
    };
    if (options.apiKey !== void 0) {
      super(options, config, container);
    } else {
      const appImpl = options;
      super(appImpl.options, config, container);
    }
    this._serverConfig = Object.assign({ automaticDataCollectionEnabled }, serverConfig);
    if (this._serverConfig.authIdToken) {
      validateTokenTTL(this._serverConfig.authIdToken, "authIdToken");
    }
    if (this._serverConfig.appCheckToken) {
      validateTokenTTL(this._serverConfig.appCheckToken, "appCheckToken");
    }
    this._finalizationRegistry = null;
    if (typeof FinalizationRegistry !== "undefined") {
      this._finalizationRegistry = new FinalizationRegistry(() => {
        this.automaticCleanup();
      });
    }
    this._refCount = 0;
    this.incRefCount(this._serverConfig.releaseOnDeref);
    this._serverConfig.releaseOnDeref = void 0;
    serverConfig.releaseOnDeref = void 0;
    registerVersion(name$q, version$1, "serverapp");
  }
  toJSON() {
    return void 0;
  }
  get refCount() {
    return this._refCount;
  }
  // Increment the reference count of this server app. If an object is provided, register it
  // with the finalization registry.
  incRefCount(obj) {
    if (this.isDeleted) {
      return;
    }
    this._refCount++;
    if (obj !== void 0 && this._finalizationRegistry !== null) {
      this._finalizationRegistry.register(obj, this);
    }
  }
  // Decrement the reference count.
  decRefCount() {
    if (this.isDeleted) {
      return 0;
    }
    return --this._refCount;
  }
  // Invoked by the FinalizationRegistry callback to note that this app should go through its
  // reference counts and delete itself if no reference count remain. The coordinating logic that
  // handles this is in deleteApp(...).
  automaticCleanup() {
    void deleteApp(this);
  }
  get settings() {
    this.checkDestroyed();
    return this._serverConfig;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted) {
      throw ERROR_FACTORY.create(
        "server-app-deleted"
        /* AppError.SERVER_APP_DELETED */
      );
    }
  }
};
var SDK_VERSION = version;
function initializeApp(_options, rawConfig = {}) {
  let options = _options;
  if (typeof rawConfig !== "object") {
    const name5 = rawConfig;
    rawConfig = { name: name5 };
  }
  const config = Object.assign({ name: DEFAULT_ENTRY_NAME2, automaticDataCollectionEnabled: true }, rawConfig);
  const name4 = config.name;
  if (typeof name4 !== "string" || !name4) {
    throw ERROR_FACTORY.create("bad-app-name", {
      appName: String(name4)
    });
  }
  options || (options = getDefaultAppConfig());
  if (!options) {
    throw ERROR_FACTORY.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  }
  const existingApp = _apps.get(name4);
  if (existingApp) {
    if (deepEqual(options, existingApp.options) && deepEqual(config, existingApp.config)) {
      return existingApp;
    } else {
      throw ERROR_FACTORY.create("duplicate-app", { appName: name4 });
    }
  }
  const container = new ComponentContainer(name4);
  for (const component of _components.values()) {
    container.addComponent(component);
  }
  const newApp = new FirebaseAppImpl(options, config, container);
  _apps.set(name4, newApp);
  return newApp;
}
__name(initializeApp, "initializeApp");
function initializeServerApp(_options, _serverAppConfig) {
  if (isBrowser() && !isWebWorker()) {
    throw ERROR_FACTORY.create(
      "invalid-server-app-environment"
      /* AppError.INVALID_SERVER_APP_ENVIRONMENT */
    );
  }
  if (_serverAppConfig.automaticDataCollectionEnabled === void 0) {
    _serverAppConfig.automaticDataCollectionEnabled = true;
  }
  let appOptions;
  if (_isFirebaseApp(_options)) {
    appOptions = _options.options;
  } else {
    appOptions = _options;
  }
  const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);
  if (nameObj.releaseOnDeref !== void 0) {
    delete nameObj.releaseOnDeref;
  }
  const hashCode = /* @__PURE__ */ __name((s18) => {
    return [...s18].reduce((hash, c21) => Math.imul(31, hash) + c21.charCodeAt(0) | 0, 0);
  }, "hashCode");
  if (_serverAppConfig.releaseOnDeref !== void 0) {
    if (typeof FinalizationRegistry === "undefined") {
      throw ERROR_FACTORY.create("finalization-registry-not-supported", {});
    }
  }
  const nameString = "" + hashCode(JSON.stringify(nameObj));
  const existingApp = _serverApps.get(nameString);
  if (existingApp) {
    existingApp.incRefCount(_serverAppConfig.releaseOnDeref);
    return existingApp;
  }
  const container = new ComponentContainer(nameString);
  for (const component of _components.values()) {
    container.addComponent(component);
  }
  const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);
  _serverApps.set(nameString, newApp);
  return newApp;
}
__name(initializeServerApp, "initializeServerApp");
function getApp(name4 = DEFAULT_ENTRY_NAME2) {
  const app = _apps.get(name4);
  if (!app && name4 === DEFAULT_ENTRY_NAME2 && getDefaultAppConfig()) {
    return initializeApp();
  }
  if (!app) {
    throw ERROR_FACTORY.create("no-app", { appName: name4 });
  }
  return app;
}
__name(getApp, "getApp");
function getApps() {
  return Array.from(_apps.values());
}
__name(getApps, "getApps");
async function deleteApp(app) {
  let cleanupProviders = false;
  const name4 = app.name;
  if (_apps.has(name4)) {
    cleanupProviders = true;
    _apps.delete(name4);
  } else if (_serverApps.has(name4)) {
    const firebaseServerApp = app;
    if (firebaseServerApp.decRefCount() <= 0) {
      _serverApps.delete(name4);
      cleanupProviders = true;
    }
  }
  if (cleanupProviders) {
    await Promise.all(app.container.getProviders().map((provider) => provider.delete()));
    app.isDeleted = true;
  }
}
__name(deleteApp, "deleteApp");
function registerVersion(libraryKeyOrName, version6, variant) {
  var _a;
  let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;
  if (variant) {
    library += `-${variant}`;
  }
  const libraryMismatch = library.match(/\s|\//);
  const versionMismatch = version6.match(/\s|\//);
  if (libraryMismatch || versionMismatch) {
    const warning = [
      `Unable to register library "${library}" with version "${version6}":`
    ];
    if (libraryMismatch) {
      warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
    }
    if (libraryMismatch && versionMismatch) {
      warning.push("and");
    }
    if (versionMismatch) {
      warning.push(`version name "${version6}" contains illegal characters (whitespace or "/")`);
    }
    logger.warn(warning.join(" "));
    return;
  }
  _registerComponent(new Component(
    `${library}-version`,
    () => ({ library, version: version6 }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
__name(registerVersion, "registerVersion");
function onLog(logCallback, options) {
  if (logCallback !== null && typeof logCallback !== "function") {
    throw ERROR_FACTORY.create(
      "invalid-log-argument"
      /* AppError.INVALID_LOG_ARGUMENT */
    );
  }
  setUserLogHandler(logCallback, options);
}
__name(onLog, "onLog");
function setLogLevel2(logLevel) {
  setLogLevel(logLevel);
}
__name(setLogLevel2, "setLogLevel");
var DB_NAME = "firebase-heartbeat-database";
var DB_VERSION = 1;
var STORE_NAME = "firebase-heartbeat-store";
var dbPromise = null;
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = openDB(DB_NAME, DB_VERSION, {
      upgrade: /* @__PURE__ */ __name((db, oldVersion) => {
        switch (oldVersion) {
          case 0:
            try {
              db.createObjectStore(STORE_NAME);
            } catch (e10) {
              console.warn(e10);
            }
        }
      }, "upgrade")
    }).catch((e10) => {
      throw ERROR_FACTORY.create("idb-open", {
        originalErrorMessage: e10.message
      });
    });
  }
  return dbPromise;
}
__name(getDbPromise, "getDbPromise");
async function readHeartbeatsFromIndexedDB(app) {
  try {
    const db = await getDbPromise();
    const tx = db.transaction(STORE_NAME);
    const result = await tx.objectStore(STORE_NAME).get(computeKey(app));
    await tx.done;
    return result;
  } catch (e10) {
    if (e10 instanceof FirebaseError) {
      logger.warn(e10.message);
    } else {
      const idbGetError = ERROR_FACTORY.create("idb-get", {
        originalErrorMessage: e10 === null || e10 === void 0 ? void 0 : e10.message
      });
      logger.warn(idbGetError.message);
    }
  }
}
__name(readHeartbeatsFromIndexedDB, "readHeartbeatsFromIndexedDB");
async function writeHeartbeatsToIndexedDB(app, heartbeatObject) {
  try {
    const db = await getDbPromise();
    const tx = db.transaction(STORE_NAME, "readwrite");
    const objectStore = tx.objectStore(STORE_NAME);
    await objectStore.put(heartbeatObject, computeKey(app));
    await tx.done;
  } catch (e10) {
    if (e10 instanceof FirebaseError) {
      logger.warn(e10.message);
    } else {
      const idbGetError = ERROR_FACTORY.create("idb-set", {
        originalErrorMessage: e10 === null || e10 === void 0 ? void 0 : e10.message
      });
      logger.warn(idbGetError.message);
    }
  }
}
__name(writeHeartbeatsToIndexedDB, "writeHeartbeatsToIndexedDB");
function computeKey(app) {
  return `${app.name}!${app.options.appId}`;
}
__name(computeKey, "computeKey");
var MAX_HEADER_BYTES = 1024;
var MAX_NUM_STORED_HEARTBEATS = 30;
var HeartbeatServiceImpl = class {
  static {
    __name(this, "HeartbeatServiceImpl");
  }
  constructor(container) {
    this.container = container;
    this._heartbeatsCache = null;
    const app = this.container.getProvider("app").getImmediate();
    this._storage = new HeartbeatStorageImpl(app);
    this._heartbeatsCachePromise = this._storage.read().then((result) => {
      this._heartbeatsCache = result;
      return result;
    });
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    var _a, _b;
    try {
      const platformLogger = this.container.getProvider("platform-logger").getImmediate();
      const agent = platformLogger.getPlatformInfoString();
      const date = getUTCDateString();
      if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {
        this._heartbeatsCache = await this._heartbeatsCachePromise;
        if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {
          return;
        }
      }
      if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat) => singleDateHeartbeat.date === date)) {
        return;
      } else {
        this._heartbeatsCache.heartbeats.push({ date, agent });
        if (this._heartbeatsCache.heartbeats.length > MAX_NUM_STORED_HEARTBEATS) {
          const earliestHeartbeatIdx = getEarliestHeartbeatIdx(this._heartbeatsCache.heartbeats);
          this._heartbeatsCache.heartbeats.splice(earliestHeartbeatIdx, 1);
        }
      }
      return this._storage.overwrite(this._heartbeatsCache);
    } catch (e10) {
      logger.warn(e10);
    }
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    var _a;
    try {
      if (this._heartbeatsCache === null) {
        await this._heartbeatsCachePromise;
      }
      if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) {
        return "";
      }
      const date = getUTCDateString();
      const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
      const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));
      this._heartbeatsCache.lastSentHeartbeatDate = date;
      if (unsentEntries.length > 0) {
        this._heartbeatsCache.heartbeats = unsentEntries;
        await this._storage.overwrite(this._heartbeatsCache);
      } else {
        this._heartbeatsCache.heartbeats = [];
        void this._storage.overwrite(this._heartbeatsCache);
      }
      return headerString;
    } catch (e10) {
      logger.warn(e10);
      return "";
    }
  }
};
function getUTCDateString() {
  const today = /* @__PURE__ */ new Date();
  return today.toISOString().substring(0, 10);
}
__name(getUTCDateString, "getUTCDateString");
function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
  const heartbeatsToSend = [];
  let unsentEntries = heartbeatsCache.slice();
  for (const singleDateHeartbeat of heartbeatsCache) {
    const heartbeatEntry = heartbeatsToSend.find((hb) => hb.agent === singleDateHeartbeat.agent);
    if (!heartbeatEntry) {
      heartbeatsToSend.push({
        agent: singleDateHeartbeat.agent,
        dates: [singleDateHeartbeat.date]
      });
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatsToSend.pop();
        break;
      }
    } else {
      heartbeatEntry.dates.push(singleDateHeartbeat.date);
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatEntry.dates.pop();
        break;
      }
    }
    unsentEntries = unsentEntries.slice(1);
  }
  return {
    heartbeatsToSend,
    unsentEntries
  };
}
__name(extractHeartbeatsForHeader, "extractHeartbeatsForHeader");
var HeartbeatStorageImpl = class {
  static {
    __name(this, "HeartbeatStorageImpl");
  }
  constructor(app) {
    this.app = app;
    this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    if (!isIndexedDBAvailable()) {
      return false;
    } else {
      return validateIndexedDBOpenable().then(() => true).catch(() => false);
    }
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return { heartbeats: [] };
    } else {
      const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
      if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {
        return idbHeartbeatObject;
      } else {
        return { heartbeats: [] };
      }
    }
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(heartbeatsObject) {
    var _a;
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return;
    } else {
      const existingHeartbeatsObject = await this.read();
      return writeHeartbeatsToIndexedDB(this.app, {
        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
        heartbeats: heartbeatsObject.heartbeats
      });
    }
  }
  // add heartbeats
  async add(heartbeatsObject) {
    var _a;
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return;
    } else {
      const existingHeartbeatsObject = await this.read();
      return writeHeartbeatsToIndexedDB(this.app, {
        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
        heartbeats: [
          ...existingHeartbeatsObject.heartbeats,
          ...heartbeatsObject.heartbeats
        ]
      });
    }
  }
};
function countBytes(heartbeatsCache) {
  return base64urlEncodeWithoutPadding(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })
  ).length;
}
__name(countBytes, "countBytes");
function getEarliestHeartbeatIdx(heartbeats) {
  if (heartbeats.length === 0) {
    return -1;
  }
  let earliestHeartbeatIdx = 0;
  let earliestHeartbeatDate = heartbeats[0].date;
  for (let i18 = 1; i18 < heartbeats.length; i18++) {
    if (heartbeats[i18].date < earliestHeartbeatDate) {
      earliestHeartbeatDate = heartbeats[i18].date;
      earliestHeartbeatIdx = i18;
    }
  }
  return earliestHeartbeatIdx;
}
__name(getEarliestHeartbeatIdx, "getEarliestHeartbeatIdx");
function registerCoreComponents(variant) {
  _registerComponent(new Component(
    "platform-logger",
    (container) => new PlatformLoggerServiceImpl(container),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ));
  _registerComponent(new Component(
    "heartbeat",
    (container) => new HeartbeatServiceImpl(container),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ));
  registerVersion(name$q, version$1, variant);
  registerVersion(name$q, version$1, "esm2017");
  registerVersion("fire-js", "");
}
__name(registerCoreComponents, "registerCoreComponents");
registerCoreComponents("");

// node_modules/firebase/app/dist/index.mjs
var name2 = "firebase";
var version2 = "11.9.1";
registerVersion(name2, version2, "app");

// node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var bloom_blob_es2018 = {};
var Integer;
var Md5;
(function() {
  var h12;
  function k5(f13, a22) {
    function c21() {
    }
    __name(c21, "c");
    c21.prototype = a22.prototype;
    f13.D = a22.prototype;
    f13.prototype = new c21();
    f13.prototype.constructor = f13;
    f13.C = function(d15, e10, g10) {
      for (var b7 = Array(arguments.length - 2), r9 = 2; r9 < arguments.length; r9++) b7[r9 - 2] = arguments[r9];
      return a22.prototype[e10].apply(d15, b7);
    };
  }
  __name(k5, "k");
  function l14() {
    this.blockSize = -1;
  }
  __name(l14, "l");
  function m18() {
    this.blockSize = -1;
    this.blockSize = 64;
    this.g = Array(4);
    this.B = Array(this.blockSize);
    this.o = this.h = 0;
    this.s();
  }
  __name(m18, "m");
  k5(m18, l14);
  m18.prototype.s = function() {
    this.g[0] = 1732584193;
    this.g[1] = 4023233417;
    this.g[2] = 2562383102;
    this.g[3] = 271733878;
    this.o = this.h = 0;
  };
  function n11(f13, a22, c21) {
    c21 || (c21 = 0);
    var d15 = Array(16);
    if ("string" === typeof a22) for (var e10 = 0; 16 > e10; ++e10) d15[e10] = a22.charCodeAt(c21++) | a22.charCodeAt(c21++) << 8 | a22.charCodeAt(c21++) << 16 | a22.charCodeAt(c21++) << 24;
    else for (e10 = 0; 16 > e10; ++e10) d15[e10] = a22[c21++] | a22[c21++] << 8 | a22[c21++] << 16 | a22[c21++] << 24;
    a22 = f13.g[0];
    c21 = f13.g[1];
    e10 = f13.g[2];
    var g10 = f13.g[3];
    var b7 = a22 + (g10 ^ c21 & (e10 ^ g10)) + d15[0] + 3614090360 & 4294967295;
    a22 = c21 + (b7 << 7 & 4294967295 | b7 >>> 25);
    b7 = g10 + (e10 ^ a22 & (c21 ^ e10)) + d15[1] + 3905402710 & 4294967295;
    g10 = a22 + (b7 << 12 & 4294967295 | b7 >>> 20);
    b7 = e10 + (c21 ^ g10 & (a22 ^ c21)) + d15[2] + 606105819 & 4294967295;
    e10 = g10 + (b7 << 17 & 4294967295 | b7 >>> 15);
    b7 = c21 + (a22 ^ e10 & (g10 ^ a22)) + d15[3] + 3250441966 & 4294967295;
    c21 = e10 + (b7 << 22 & 4294967295 | b7 >>> 10);
    b7 = a22 + (g10 ^ c21 & (e10 ^ g10)) + d15[4] + 4118548399 & 4294967295;
    a22 = c21 + (b7 << 7 & 4294967295 | b7 >>> 25);
    b7 = g10 + (e10 ^ a22 & (c21 ^ e10)) + d15[5] + 1200080426 & 4294967295;
    g10 = a22 + (b7 << 12 & 4294967295 | b7 >>> 20);
    b7 = e10 + (c21 ^ g10 & (a22 ^ c21)) + d15[6] + 2821735955 & 4294967295;
    e10 = g10 + (b7 << 17 & 4294967295 | b7 >>> 15);
    b7 = c21 + (a22 ^ e10 & (g10 ^ a22)) + d15[7] + 4249261313 & 4294967295;
    c21 = e10 + (b7 << 22 & 4294967295 | b7 >>> 10);
    b7 = a22 + (g10 ^ c21 & (e10 ^ g10)) + d15[8] + 1770035416 & 4294967295;
    a22 = c21 + (b7 << 7 & 4294967295 | b7 >>> 25);
    b7 = g10 + (e10 ^ a22 & (c21 ^ e10)) + d15[9] + 2336552879 & 4294967295;
    g10 = a22 + (b7 << 12 & 4294967295 | b7 >>> 20);
    b7 = e10 + (c21 ^ g10 & (a22 ^ c21)) + d15[10] + 4294925233 & 4294967295;
    e10 = g10 + (b7 << 17 & 4294967295 | b7 >>> 15);
    b7 = c21 + (a22 ^ e10 & (g10 ^ a22)) + d15[11] + 2304563134 & 4294967295;
    c21 = e10 + (b7 << 22 & 4294967295 | b7 >>> 10);
    b7 = a22 + (g10 ^ c21 & (e10 ^ g10)) + d15[12] + 1804603682 & 4294967295;
    a22 = c21 + (b7 << 7 & 4294967295 | b7 >>> 25);
    b7 = g10 + (e10 ^ a22 & (c21 ^ e10)) + d15[13] + 4254626195 & 4294967295;
    g10 = a22 + (b7 << 12 & 4294967295 | b7 >>> 20);
    b7 = e10 + (c21 ^ g10 & (a22 ^ c21)) + d15[14] + 2792965006 & 4294967295;
    e10 = g10 + (b7 << 17 & 4294967295 | b7 >>> 15);
    b7 = c21 + (a22 ^ e10 & (g10 ^ a22)) + d15[15] + 1236535329 & 4294967295;
    c21 = e10 + (b7 << 22 & 4294967295 | b7 >>> 10);
    b7 = a22 + (e10 ^ g10 & (c21 ^ e10)) + d15[1] + 4129170786 & 4294967295;
    a22 = c21 + (b7 << 5 & 4294967295 | b7 >>> 27);
    b7 = g10 + (c21 ^ e10 & (a22 ^ c21)) + d15[6] + 3225465664 & 4294967295;
    g10 = a22 + (b7 << 9 & 4294967295 | b7 >>> 23);
    b7 = e10 + (a22 ^ c21 & (g10 ^ a22)) + d15[11] + 643717713 & 4294967295;
    e10 = g10 + (b7 << 14 & 4294967295 | b7 >>> 18);
    b7 = c21 + (g10 ^ a22 & (e10 ^ g10)) + d15[0] + 3921069994 & 4294967295;
    c21 = e10 + (b7 << 20 & 4294967295 | b7 >>> 12);
    b7 = a22 + (e10 ^ g10 & (c21 ^ e10)) + d15[5] + 3593408605 & 4294967295;
    a22 = c21 + (b7 << 5 & 4294967295 | b7 >>> 27);
    b7 = g10 + (c21 ^ e10 & (a22 ^ c21)) + d15[10] + 38016083 & 4294967295;
    g10 = a22 + (b7 << 9 & 4294967295 | b7 >>> 23);
    b7 = e10 + (a22 ^ c21 & (g10 ^ a22)) + d15[15] + 3634488961 & 4294967295;
    e10 = g10 + (b7 << 14 & 4294967295 | b7 >>> 18);
    b7 = c21 + (g10 ^ a22 & (e10 ^ g10)) + d15[4] + 3889429448 & 4294967295;
    c21 = e10 + (b7 << 20 & 4294967295 | b7 >>> 12);
    b7 = a22 + (e10 ^ g10 & (c21 ^ e10)) + d15[9] + 568446438 & 4294967295;
    a22 = c21 + (b7 << 5 & 4294967295 | b7 >>> 27);
    b7 = g10 + (c21 ^ e10 & (a22 ^ c21)) + d15[14] + 3275163606 & 4294967295;
    g10 = a22 + (b7 << 9 & 4294967295 | b7 >>> 23);
    b7 = e10 + (a22 ^ c21 & (g10 ^ a22)) + d15[3] + 4107603335 & 4294967295;
    e10 = g10 + (b7 << 14 & 4294967295 | b7 >>> 18);
    b7 = c21 + (g10 ^ a22 & (e10 ^ g10)) + d15[8] + 1163531501 & 4294967295;
    c21 = e10 + (b7 << 20 & 4294967295 | b7 >>> 12);
    b7 = a22 + (e10 ^ g10 & (c21 ^ e10)) + d15[13] + 2850285829 & 4294967295;
    a22 = c21 + (b7 << 5 & 4294967295 | b7 >>> 27);
    b7 = g10 + (c21 ^ e10 & (a22 ^ c21)) + d15[2] + 4243563512 & 4294967295;
    g10 = a22 + (b7 << 9 & 4294967295 | b7 >>> 23);
    b7 = e10 + (a22 ^ c21 & (g10 ^ a22)) + d15[7] + 1735328473 & 4294967295;
    e10 = g10 + (b7 << 14 & 4294967295 | b7 >>> 18);
    b7 = c21 + (g10 ^ a22 & (e10 ^ g10)) + d15[12] + 2368359562 & 4294967295;
    c21 = e10 + (b7 << 20 & 4294967295 | b7 >>> 12);
    b7 = a22 + (c21 ^ e10 ^ g10) + d15[5] + 4294588738 & 4294967295;
    a22 = c21 + (b7 << 4 & 4294967295 | b7 >>> 28);
    b7 = g10 + (a22 ^ c21 ^ e10) + d15[8] + 2272392833 & 4294967295;
    g10 = a22 + (b7 << 11 & 4294967295 | b7 >>> 21);
    b7 = e10 + (g10 ^ a22 ^ c21) + d15[11] + 1839030562 & 4294967295;
    e10 = g10 + (b7 << 16 & 4294967295 | b7 >>> 16);
    b7 = c21 + (e10 ^ g10 ^ a22) + d15[14] + 4259657740 & 4294967295;
    c21 = e10 + (b7 << 23 & 4294967295 | b7 >>> 9);
    b7 = a22 + (c21 ^ e10 ^ g10) + d15[1] + 2763975236 & 4294967295;
    a22 = c21 + (b7 << 4 & 4294967295 | b7 >>> 28);
    b7 = g10 + (a22 ^ c21 ^ e10) + d15[4] + 1272893353 & 4294967295;
    g10 = a22 + (b7 << 11 & 4294967295 | b7 >>> 21);
    b7 = e10 + (g10 ^ a22 ^ c21) + d15[7] + 4139469664 & 4294967295;
    e10 = g10 + (b7 << 16 & 4294967295 | b7 >>> 16);
    b7 = c21 + (e10 ^ g10 ^ a22) + d15[10] + 3200236656 & 4294967295;
    c21 = e10 + (b7 << 23 & 4294967295 | b7 >>> 9);
    b7 = a22 + (c21 ^ e10 ^ g10) + d15[13] + 681279174 & 4294967295;
    a22 = c21 + (b7 << 4 & 4294967295 | b7 >>> 28);
    b7 = g10 + (a22 ^ c21 ^ e10) + d15[0] + 3936430074 & 4294967295;
    g10 = a22 + (b7 << 11 & 4294967295 | b7 >>> 21);
    b7 = e10 + (g10 ^ a22 ^ c21) + d15[3] + 3572445317 & 4294967295;
    e10 = g10 + (b7 << 16 & 4294967295 | b7 >>> 16);
    b7 = c21 + (e10 ^ g10 ^ a22) + d15[6] + 76029189 & 4294967295;
    c21 = e10 + (b7 << 23 & 4294967295 | b7 >>> 9);
    b7 = a22 + (c21 ^ e10 ^ g10) + d15[9] + 3654602809 & 4294967295;
    a22 = c21 + (b7 << 4 & 4294967295 | b7 >>> 28);
    b7 = g10 + (a22 ^ c21 ^ e10) + d15[12] + 3873151461 & 4294967295;
    g10 = a22 + (b7 << 11 & 4294967295 | b7 >>> 21);
    b7 = e10 + (g10 ^ a22 ^ c21) + d15[15] + 530742520 & 4294967295;
    e10 = g10 + (b7 << 16 & 4294967295 | b7 >>> 16);
    b7 = c21 + (e10 ^ g10 ^ a22) + d15[2] + 3299628645 & 4294967295;
    c21 = e10 + (b7 << 23 & 4294967295 | b7 >>> 9);
    b7 = a22 + (e10 ^ (c21 | ~g10)) + d15[0] + 4096336452 & 4294967295;
    a22 = c21 + (b7 << 6 & 4294967295 | b7 >>> 26);
    b7 = g10 + (c21 ^ (a22 | ~e10)) + d15[7] + 1126891415 & 4294967295;
    g10 = a22 + (b7 << 10 & 4294967295 | b7 >>> 22);
    b7 = e10 + (a22 ^ (g10 | ~c21)) + d15[14] + 2878612391 & 4294967295;
    e10 = g10 + (b7 << 15 & 4294967295 | b7 >>> 17);
    b7 = c21 + (g10 ^ (e10 | ~a22)) + d15[5] + 4237533241 & 4294967295;
    c21 = e10 + (b7 << 21 & 4294967295 | b7 >>> 11);
    b7 = a22 + (e10 ^ (c21 | ~g10)) + d15[12] + 1700485571 & 4294967295;
    a22 = c21 + (b7 << 6 & 4294967295 | b7 >>> 26);
    b7 = g10 + (c21 ^ (a22 | ~e10)) + d15[3] + 2399980690 & 4294967295;
    g10 = a22 + (b7 << 10 & 4294967295 | b7 >>> 22);
    b7 = e10 + (a22 ^ (g10 | ~c21)) + d15[10] + 4293915773 & 4294967295;
    e10 = g10 + (b7 << 15 & 4294967295 | b7 >>> 17);
    b7 = c21 + (g10 ^ (e10 | ~a22)) + d15[1] + 2240044497 & 4294967295;
    c21 = e10 + (b7 << 21 & 4294967295 | b7 >>> 11);
    b7 = a22 + (e10 ^ (c21 | ~g10)) + d15[8] + 1873313359 & 4294967295;
    a22 = c21 + (b7 << 6 & 4294967295 | b7 >>> 26);
    b7 = g10 + (c21 ^ (a22 | ~e10)) + d15[15] + 4264355552 & 4294967295;
    g10 = a22 + (b7 << 10 & 4294967295 | b7 >>> 22);
    b7 = e10 + (a22 ^ (g10 | ~c21)) + d15[6] + 2734768916 & 4294967295;
    e10 = g10 + (b7 << 15 & 4294967295 | b7 >>> 17);
    b7 = c21 + (g10 ^ (e10 | ~a22)) + d15[13] + 1309151649 & 4294967295;
    c21 = e10 + (b7 << 21 & 4294967295 | b7 >>> 11);
    b7 = a22 + (e10 ^ (c21 | ~g10)) + d15[4] + 4149444226 & 4294967295;
    a22 = c21 + (b7 << 6 & 4294967295 | b7 >>> 26);
    b7 = g10 + (c21 ^ (a22 | ~e10)) + d15[11] + 3174756917 & 4294967295;
    g10 = a22 + (b7 << 10 & 4294967295 | b7 >>> 22);
    b7 = e10 + (a22 ^ (g10 | ~c21)) + d15[2] + 718787259 & 4294967295;
    e10 = g10 + (b7 << 15 & 4294967295 | b7 >>> 17);
    b7 = c21 + (g10 ^ (e10 | ~a22)) + d15[9] + 3951481745 & 4294967295;
    f13.g[0] = f13.g[0] + a22 & 4294967295;
    f13.g[1] = f13.g[1] + (e10 + (b7 << 21 & 4294967295 | b7 >>> 11)) & 4294967295;
    f13.g[2] = f13.g[2] + e10 & 4294967295;
    f13.g[3] = f13.g[3] + g10 & 4294967295;
  }
  __name(n11, "n");
  m18.prototype.u = function(f13, a22) {
    void 0 === a22 && (a22 = f13.length);
    for (var c21 = a22 - this.blockSize, d15 = this.B, e10 = this.h, g10 = 0; g10 < a22; ) {
      if (0 == e10) for (; g10 <= c21; ) n11(this, f13, g10), g10 += this.blockSize;
      if ("string" === typeof f13) for (; g10 < a22; ) {
        if (d15[e10++] = f13.charCodeAt(g10++), e10 == this.blockSize) {
          n11(this, d15);
          e10 = 0;
          break;
        }
      }
      else for (; g10 < a22; ) if (d15[e10++] = f13[g10++], e10 == this.blockSize) {
        n11(this, d15);
        e10 = 0;
        break;
      }
    }
    this.h = e10;
    this.o += a22;
  };
  m18.prototype.v = function() {
    var f13 = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h);
    f13[0] = 128;
    for (var a22 = 1; a22 < f13.length - 8; ++a22) f13[a22] = 0;
    var c21 = 8 * this.o;
    for (a22 = f13.length - 8; a22 < f13.length; ++a22) f13[a22] = c21 & 255, c21 /= 256;
    this.u(f13);
    f13 = Array(16);
    for (a22 = c21 = 0; 4 > a22; ++a22) for (var d15 = 0; 32 > d15; d15 += 8) f13[c21++] = this.g[a22] >>> d15 & 255;
    return f13;
  };
  function p15(f13, a22) {
    var c21 = q;
    return Object.prototype.hasOwnProperty.call(c21, f13) ? c21[f13] : c21[f13] = a22(f13);
  }
  __name(p15, "p");
  function t11(f13, a22) {
    this.h = a22;
    for (var c21 = [], d15 = true, e10 = f13.length - 1; 0 <= e10; e10--) {
      var g10 = f13[e10] | 0;
      d15 && g10 == a22 || (c21[e10] = g10, d15 = false);
    }
    this.g = c21;
  }
  __name(t11, "t");
  var q = {};
  function u20(f13) {
    return -128 <= f13 && 128 > f13 ? p15(f13, function(a22) {
      return new t11([a22 | 0], 0 > a22 ? -1 : 0);
    }) : new t11([f13 | 0], 0 > f13 ? -1 : 0);
  }
  __name(u20, "u");
  function v8(f13) {
    if (isNaN(f13) || !isFinite(f13)) return w4;
    if (0 > f13) return x3(v8(-f13));
    for (var a22 = [], c21 = 1, d15 = 0; f13 >= c21; d15++) a22[d15] = f13 / c21 | 0, c21 *= 4294967296;
    return new t11(a22, 0);
  }
  __name(v8, "v");
  function y12(f13, a22) {
    if (0 == f13.length) throw Error("number format error: empty string");
    a22 = a22 || 10;
    if (2 > a22 || 36 < a22) throw Error("radix out of range: " + a22);
    if ("-" == f13.charAt(0)) return x3(y12(f13.substring(1), a22));
    if (0 <= f13.indexOf("-")) throw Error('number format error: interior "-" character');
    for (var c21 = v8(Math.pow(a22, 8)), d15 = w4, e10 = 0; e10 < f13.length; e10 += 8) {
      var g10 = Math.min(8, f13.length - e10), b7 = parseInt(f13.substring(e10, e10 + g10), a22);
      8 > g10 ? (g10 = v8(Math.pow(a22, g10)), d15 = d15.j(g10).add(v8(b7))) : (d15 = d15.j(c21), d15 = d15.add(v8(b7)));
    }
    return d15;
  }
  __name(y12, "y");
  var w4 = u20(0), z = u20(1), A2 = u20(16777216);
  h12 = t11.prototype;
  h12.m = function() {
    if (B(this)) return -x3(this).m();
    for (var f13 = 0, a22 = 1, c21 = 0; c21 < this.g.length; c21++) {
      var d15 = this.i(c21);
      f13 += (0 <= d15 ? d15 : 4294967296 + d15) * a22;
      a22 *= 4294967296;
    }
    return f13;
  };
  h12.toString = function(f13) {
    f13 = f13 || 10;
    if (2 > f13 || 36 < f13) throw Error("radix out of range: " + f13);
    if (C3(this)) return "0";
    if (B(this)) return "-" + x3(this).toString(f13);
    for (var a22 = v8(Math.pow(f13, 6)), c21 = this, d15 = ""; ; ) {
      var e10 = D6(c21, a22).g;
      c21 = F3(c21, e10.j(a22));
      var g10 = ((0 < c21.g.length ? c21.g[0] : c21.h) >>> 0).toString(f13);
      c21 = e10;
      if (C3(c21)) return g10 + d15;
      for (; 6 > g10.length; ) g10 = "0" + g10;
      d15 = g10 + d15;
    }
  };
  h12.i = function(f13) {
    return 0 > f13 ? 0 : f13 < this.g.length ? this.g[f13] : this.h;
  };
  function C3(f13) {
    if (0 != f13.h) return false;
    for (var a22 = 0; a22 < f13.g.length; a22++) if (0 != f13.g[a22]) return false;
    return true;
  }
  __name(C3, "C");
  function B(f13) {
    return -1 == f13.h;
  }
  __name(B, "B");
  h12.l = function(f13) {
    f13 = F3(this, f13);
    return B(f13) ? -1 : C3(f13) ? 0 : 1;
  };
  function x3(f13) {
    for (var a22 = f13.g.length, c21 = [], d15 = 0; d15 < a22; d15++) c21[d15] = ~f13.g[d15];
    return new t11(c21, ~f13.h).add(z);
  }
  __name(x3, "x");
  h12.abs = function() {
    return B(this) ? x3(this) : this;
  };
  h12.add = function(f13) {
    for (var a22 = Math.max(this.g.length, f13.g.length), c21 = [], d15 = 0, e10 = 0; e10 <= a22; e10++) {
      var g10 = d15 + (this.i(e10) & 65535) + (f13.i(e10) & 65535), b7 = (g10 >>> 16) + (this.i(e10) >>> 16) + (f13.i(e10) >>> 16);
      d15 = b7 >>> 16;
      g10 &= 65535;
      b7 &= 65535;
      c21[e10] = b7 << 16 | g10;
    }
    return new t11(c21, c21[c21.length - 1] & -2147483648 ? -1 : 0);
  };
  function F3(f13, a22) {
    return f13.add(x3(a22));
  }
  __name(F3, "F");
  h12.j = function(f13) {
    if (C3(this) || C3(f13)) return w4;
    if (B(this)) return B(f13) ? x3(this).j(x3(f13)) : x3(x3(this).j(f13));
    if (B(f13)) return x3(this.j(x3(f13)));
    if (0 > this.l(A2) && 0 > f13.l(A2)) return v8(this.m() * f13.m());
    for (var a22 = this.g.length + f13.g.length, c21 = [], d15 = 0; d15 < 2 * a22; d15++) c21[d15] = 0;
    for (d15 = 0; d15 < this.g.length; d15++) for (var e10 = 0; e10 < f13.g.length; e10++) {
      var g10 = this.i(d15) >>> 16, b7 = this.i(d15) & 65535, r9 = f13.i(e10) >>> 16, E3 = f13.i(e10) & 65535;
      c21[2 * d15 + 2 * e10] += b7 * E3;
      G(c21, 2 * d15 + 2 * e10);
      c21[2 * d15 + 2 * e10 + 1] += g10 * E3;
      G(c21, 2 * d15 + 2 * e10 + 1);
      c21[2 * d15 + 2 * e10 + 1] += b7 * r9;
      G(c21, 2 * d15 + 2 * e10 + 1);
      c21[2 * d15 + 2 * e10 + 2] += g10 * r9;
      G(c21, 2 * d15 + 2 * e10 + 2);
    }
    for (d15 = 0; d15 < a22; d15++) c21[d15] = c21[2 * d15 + 1] << 16 | c21[2 * d15];
    for (d15 = a22; d15 < 2 * a22; d15++) c21[d15] = 0;
    return new t11(c21, 0);
  };
  function G(f13, a22) {
    for (; (f13[a22] & 65535) != f13[a22]; ) f13[a22 + 1] += f13[a22] >>> 16, f13[a22] &= 65535, a22++;
  }
  __name(G, "G");
  function H(f13, a22) {
    this.g = f13;
    this.h = a22;
  }
  __name(H, "H");
  function D6(f13, a22) {
    if (C3(a22)) throw Error("division by zero");
    if (C3(f13)) return new H(w4, w4);
    if (B(f13)) return a22 = D6(x3(f13), a22), new H(x3(a22.g), x3(a22.h));
    if (B(a22)) return a22 = D6(f13, x3(a22)), new H(x3(a22.g), a22.h);
    if (30 < f13.g.length) {
      if (B(f13) || B(a22)) throw Error("slowDivide_ only works with positive integers.");
      for (var c21 = z, d15 = a22; 0 >= d15.l(f13); ) c21 = I4(c21), d15 = I4(d15);
      var e10 = J(c21, 1), g10 = J(d15, 1);
      d15 = J(d15, 2);
      for (c21 = J(c21, 2); !C3(d15); ) {
        var b7 = g10.add(d15);
        0 >= b7.l(f13) && (e10 = e10.add(c21), g10 = b7);
        d15 = J(d15, 1);
        c21 = J(c21, 1);
      }
      a22 = F3(f13, e10.j(a22));
      return new H(e10, a22);
    }
    for (e10 = w4; 0 <= f13.l(a22); ) {
      c21 = Math.max(1, Math.floor(f13.m() / a22.m()));
      d15 = Math.ceil(Math.log(c21) / Math.LN2);
      d15 = 48 >= d15 ? 1 : Math.pow(2, d15 - 48);
      g10 = v8(c21);
      for (b7 = g10.j(a22); B(b7) || 0 < b7.l(f13); ) c21 -= d15, g10 = v8(c21), b7 = g10.j(a22);
      C3(g10) && (g10 = z);
      e10 = e10.add(g10);
      f13 = F3(f13, b7);
    }
    return new H(e10, f13);
  }
  __name(D6, "D");
  h12.A = function(f13) {
    return D6(this, f13).h;
  };
  h12.and = function(f13) {
    for (var a22 = Math.max(this.g.length, f13.g.length), c21 = [], d15 = 0; d15 < a22; d15++) c21[d15] = this.i(d15) & f13.i(d15);
    return new t11(c21, this.h & f13.h);
  };
  h12.or = function(f13) {
    for (var a22 = Math.max(this.g.length, f13.g.length), c21 = [], d15 = 0; d15 < a22; d15++) c21[d15] = this.i(d15) | f13.i(d15);
    return new t11(c21, this.h | f13.h);
  };
  h12.xor = function(f13) {
    for (var a22 = Math.max(this.g.length, f13.g.length), c21 = [], d15 = 0; d15 < a22; d15++) c21[d15] = this.i(d15) ^ f13.i(d15);
    return new t11(c21, this.h ^ f13.h);
  };
  function I4(f13) {
    for (var a22 = f13.g.length + 1, c21 = [], d15 = 0; d15 < a22; d15++) c21[d15] = f13.i(d15) << 1 | f13.i(d15 - 1) >>> 31;
    return new t11(c21, f13.h);
  }
  __name(I4, "I");
  function J(f13, a22) {
    var c21 = a22 >> 5;
    a22 %= 32;
    for (var d15 = f13.g.length - c21, e10 = [], g10 = 0; g10 < d15; g10++) e10[g10] = 0 < a22 ? f13.i(g10 + c21) >>> a22 | f13.i(g10 + c21 + 1) << 32 - a22 : f13.i(g10 + c21);
    return new t11(e10, f13.h);
  }
  __name(J, "J");
  m18.prototype.digest = m18.prototype.v;
  m18.prototype.reset = m18.prototype.s;
  m18.prototype.update = m18.prototype.u;
  Md5 = bloom_blob_es2018.Md5 = m18;
  t11.prototype.add = t11.prototype.add;
  t11.prototype.multiply = t11.prototype.j;
  t11.prototype.modulo = t11.prototype.A;
  t11.prototype.compare = t11.prototype.l;
  t11.prototype.toNumber = t11.prototype.m;
  t11.prototype.toString = t11.prototype.toString;
  t11.prototype.getBits = t11.prototype.i;
  t11.fromNumber = v8;
  t11.fromString = y12;
  Integer = bloom_blob_es2018.Integer = t11;
}).apply(typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});

// node_modules/@firebase/firestore/dist/lite/index.node.mjs
var import_util4 = require("util");
var import_crypto = require("crypto");
var version$12 = "4.7.17";
var User = class {
  static {
    __name(this, "User");
  }
  constructor(uid) {
    this.uid = uid;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  /**
   * Returns a key representing this user, suitable for inclusion in a
   * dictionary.
   */
  toKey() {
    if (this.isAuthenticated()) {
      return "uid:" + this.uid;
    } else {
      return "anonymous-user";
    }
  }
  isEqual(otherUser) {
    return otherUser.uid === this.uid;
  }
};
User.UNAUTHENTICATED = new User(null);
User.GOOGLE_CREDENTIALS = new User("google-credentials-uid");
User.FIRST_PARTY = new User("first-party-uid");
User.MOCK_USER = new User("mock-user");
var version3 = "11.9.0";
var SDK_VERSION2 = version3;
function setSDKVersion(version6) {
  SDK_VERSION2 = version6;
}
__name(setSDKVersion, "setSDKVersion");
function formatJSON(value) {
  return (0, import_util4.inspect)(value, { depth: 100 });
}
__name(formatJSON, "formatJSON");
var logClient = new Logger("@firebase/firestore");
function setLogLevel3(logLevel) {
  logClient.setLogLevel(logLevel);
}
__name(setLogLevel3, "setLogLevel");
function logDebug(msg, ...obj) {
  if (logClient.logLevel <= LogLevel.DEBUG) {
    const args = obj.map(argToString);
    logClient.debug(`Firestore (${SDK_VERSION2}): ${msg}`, ...args);
  }
}
__name(logDebug, "logDebug");
function logError(msg, ...obj) {
  if (logClient.logLevel <= LogLevel.ERROR) {
    const args = obj.map(argToString);
    logClient.error(`Firestore (${SDK_VERSION2}): ${msg}`, ...args);
  }
}
__name(logError, "logError");
function logWarn(msg, ...obj) {
  if (logClient.logLevel <= LogLevel.WARN) {
    const args = obj.map(argToString);
    logClient.warn(`Firestore (${SDK_VERSION2}): ${msg}`, ...args);
  }
}
__name(logWarn, "logWarn");
function argToString(obj) {
  if (typeof obj === "string") {
    return obj;
  } else {
    try {
      return formatJSON(obj);
    } catch (e10) {
      return obj;
    }
  }
}
__name(argToString, "argToString");
function fail(id, messageOrContext, context2) {
  let message = "Unexpected state";
  if (typeof messageOrContext === "string") {
    message = messageOrContext;
  } else {
    context2 = messageOrContext;
  }
  _fail(id, message, context2);
}
__name(fail, "fail");
function _fail(id, failure, context2) {
  let message = `FIRESTORE (${SDK_VERSION2}) INTERNAL ASSERTION FAILED: ${failure} (ID: ${id.toString(16)})`;
  if (context2 !== void 0) {
    try {
      const stringContext = JSON.stringify(context2);
      message += " CONTEXT: " + stringContext;
    } catch (e10) {
      message += " CONTEXT: " + context2;
    }
  }
  logError(message);
  throw new Error(message);
}
__name(_fail, "_fail");
function hardAssert(assertion, id, messageOrContext, context2) {
  let message = "Unexpected state";
  if (typeof messageOrContext === "string") {
    message = messageOrContext;
  } else {
    context2 = messageOrContext;
  }
  if (!assertion) {
    _fail(id, message, context2);
  }
}
__name(hardAssert, "hardAssert");
function debugCast(obj, constructor) {
  return obj;
}
__name(debugCast, "debugCast");
var Code = {
  // Causes are copied from:
  // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
  /** Not an error; returned on success. */
  OK: "ok",
  /** The operation was cancelled (typically by the caller). */
  CANCELLED: "cancelled",
  /** Unknown error or an error from a different error domain. */
  UNKNOWN: "unknown",
  /**
   * Client specified an invalid argument. Note that this differs from
   * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are
   * problematic regardless of the state of the system (e.g., a malformed file
   * name).
   */
  INVALID_ARGUMENT: "invalid-argument",
  /**
   * Deadline expired before operation could complete. For operations that
   * change the state of the system, this error may be returned even if the
   * operation has completed successfully. For example, a successful response
   * from a server could have been delayed long enough for the deadline to
   * expire.
   */
  DEADLINE_EXCEEDED: "deadline-exceeded",
  /** Some requested entity (e.g., file or directory) was not found. */
  NOT_FOUND: "not-found",
  /**
   * Some entity that we attempted to create (e.g., file or directory) already
   * exists.
   */
  ALREADY_EXISTS: "already-exists",
  /**
   * The caller does not have permission to execute the specified operation.
   * PERMISSION_DENIED must not be used for rejections caused by exhausting
   * some resource (use RESOURCE_EXHAUSTED instead for those errors).
   * PERMISSION_DENIED must not be used if the caller cannot be identified
   * (use UNAUTHENTICATED instead for those errors).
   */
  PERMISSION_DENIED: "permission-denied",
  /**
   * The request does not have valid authentication credentials for the
   * operation.
   */
  UNAUTHENTICATED: "unauthenticated",
  /**
   * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
   * entire file system is out of space.
   */
  RESOURCE_EXHAUSTED: "resource-exhausted",
  /**
   * Operation was rejected because the system is not in a state required for
   * the operation's execution. For example, directory to be deleted may be
   * non-empty, an rmdir operation is applied to a non-directory, etc.
   *
   * A litmus test that may help a service implementor in deciding
   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
   *  (a) Use UNAVAILABLE if the client can retry just the failing call.
   *  (b) Use ABORTED if the client should retry at a higher-level
   *      (e.g., restarting a read-modify-write sequence).
   *  (c) Use FAILED_PRECONDITION if the client should not retry until
   *      the system state has been explicitly fixed. E.g., if an "rmdir"
   *      fails because the directory is non-empty, FAILED_PRECONDITION
   *      should be returned since the client should not retry unless
   *      they have first fixed up the directory by deleting files from it.
   *  (d) Use FAILED_PRECONDITION if the client performs conditional
   *      REST Get/Update/Delete on a resource and the resource on the
   *      server does not match the condition. E.g., conflicting
   *      read-modify-write on the same resource.
   */
  FAILED_PRECONDITION: "failed-precondition",
  /**
   * The operation was aborted, typically due to a concurrency issue like
   * sequencer check failures, transaction aborts, etc.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  ABORTED: "aborted",
  /**
   * Operation was attempted past the valid range. E.g., seeking or reading
   * past end of file.
   *
   * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed
   * if the system state changes. For example, a 32-bit file system will
   * generate INVALID_ARGUMENT if asked to read at an offset that is not in the
   * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from
   * an offset past the current file size.
   *
   * There is a fair bit of overlap between FAILED_PRECONDITION and
   * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)
   * when it applies so that callers who are iterating through a space can
   * easily look for an OUT_OF_RANGE error to detect when they are done.
   */
  OUT_OF_RANGE: "out-of-range",
  /** Operation is not implemented or not supported/enabled in this service. */
  UNIMPLEMENTED: "unimplemented",
  /**
   * Internal errors. Means some invariants expected by underlying System has
   * been broken. If you see one of these errors, Something is very broken.
   */
  INTERNAL: "internal",
  /**
   * The service is currently unavailable. This is a most likely a transient
   * condition and may be corrected by retrying with a backoff.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  UNAVAILABLE: "unavailable",
  /** Unrecoverable data loss or corruption. */
  DATA_LOSS: "data-loss"
};
var FirestoreError = class extends FirebaseError {
  static {
    __name(this, "FirestoreError");
  }
  /** @hideconstructor */
  constructor(code, message) {
    super(code, message);
    this.code = code;
    this.message = message;
    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var Deferred2 = class {
  static {
    __name(this, "Deferred");
  }
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};
var OAuthToken = class {
  static {
    __name(this, "OAuthToken");
  }
  constructor(value, user) {
    this.user = user;
    this.type = "OAuth";
    this.headers = /* @__PURE__ */ new Map();
    this.headers.set("Authorization", `Bearer ${value}`);
  }
};
var EmptyAuthCredentialsProvider = class {
  static {
    __name(this, "EmptyAuthCredentialsProvider");
  }
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(asyncQueue, changeListener) {
    asyncQueue.enqueueRetryable(() => changeListener(User.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var EmulatorAuthCredentialsProvider = class {
  static {
    __name(this, "EmulatorAuthCredentialsProvider");
  }
  constructor(token) {
    this.token = token;
    this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(asyncQueue, changeListener) {
    this.changeListener = changeListener;
    asyncQueue.enqueueRetryable(() => changeListener(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var LiteAuthCredentialsProvider = class {
  static {
    __name(this, "LiteAuthCredentialsProvider");
  }
  constructor(authProvider) {
    this.auth = null;
    authProvider.onInit((auth) => {
      this.auth = auth;
    });
  }
  getToken() {
    if (!this.auth) {
      return Promise.resolve(null);
    }
    return this.auth.getToken().then((tokenData) => {
      if (tokenData) {
        hardAssert(typeof tokenData.accessToken === "string", 42297, { tokenData });
        return new OAuthToken(tokenData.accessToken, new User(this.auth.getUid()));
      } else {
        return null;
      }
    });
  }
  invalidateToken() {
  }
  start(asyncQueue, changeListener) {
  }
  shutdown() {
  }
};
var FirstPartyToken = class {
  static {
    __name(this, "FirstPartyToken");
  }
  constructor(sessionIndex, iamToken, authTokenFactory) {
    this.sessionIndex = sessionIndex;
    this.iamToken = iamToken;
    this.authTokenFactory = authTokenFactory;
    this.type = "FirstParty";
    this.user = User.FIRST_PARTY;
    this._headers = /* @__PURE__ */ new Map();
  }
  /**
   * Gets an authorization token, using a provided factory function, or return
   * null.
   */
  getAuthToken() {
    if (this.authTokenFactory) {
      return this.authTokenFactory();
    } else {
      return null;
    }
  }
  get headers() {
    this._headers.set("X-Goog-AuthUser", this.sessionIndex);
    const authHeaderTokenValue = this.getAuthToken();
    if (authHeaderTokenValue) {
      this._headers.set("Authorization", authHeaderTokenValue);
    }
    if (this.iamToken) {
      this._headers.set("X-Goog-Iam-Authorization-Token", this.iamToken);
    }
    return this._headers;
  }
};
var FirstPartyAuthCredentialsProvider = class {
  static {
    __name(this, "FirstPartyAuthCredentialsProvider");
  }
  constructor(sessionIndex, iamToken, authTokenFactory) {
    this.sessionIndex = sessionIndex;
    this.iamToken = iamToken;
    this.authTokenFactory = authTokenFactory;
  }
  getToken() {
    return Promise.resolve(new FirstPartyToken(this.sessionIndex, this.iamToken, this.authTokenFactory));
  }
  start(asyncQueue, changeListener) {
    asyncQueue.enqueueRetryable(() => changeListener(User.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var AppCheckToken = class {
  static {
    __name(this, "AppCheckToken");
  }
  constructor(value) {
    this.value = value;
    this.type = "AppCheck";
    this.headers = /* @__PURE__ */ new Map();
    if (value && value.length > 0) {
      this.headers.set("x-firebase-appcheck", this.value);
    }
  }
};
var LiteAppCheckTokenProvider = class {
  static {
    __name(this, "LiteAppCheckTokenProvider");
  }
  constructor(app, appCheckProvider) {
    this.appCheckProvider = appCheckProvider;
    this.appCheck = null;
    this.serverAppAppCheckToken = null;
    if (_isFirebaseServerApp(app) && app.settings.appCheckToken) {
      this.serverAppAppCheckToken = app.settings.appCheckToken;
    }
    appCheckProvider.onInit((appCheck) => {
      this.appCheck = appCheck;
    });
  }
  getToken() {
    if (this.serverAppAppCheckToken) {
      return Promise.resolve(new AppCheckToken(this.serverAppAppCheckToken));
    }
    if (!this.appCheck) {
      return Promise.resolve(null);
    }
    return this.appCheck.getToken().then((tokenResult) => {
      if (tokenResult) {
        hardAssert(typeof tokenResult.token === "string", 3470, { tokenResult });
        return new AppCheckToken(tokenResult.token);
      } else {
        return null;
      }
    });
  }
  invalidateToken() {
  }
  start(asyncQueue, changeListener) {
  }
  shutdown() {
  }
};
function makeAuthCredentialsProvider(credentials) {
  if (!credentials) {
    return new EmptyAuthCredentialsProvider();
  }
  switch (credentials["type"]) {
    case "firstParty":
      return new FirstPartyAuthCredentialsProvider(credentials["sessionIndex"] || "0", credentials["iamToken"] || null, credentials["authTokenFactory"] || null);
    case "provider":
      return credentials["client"];
    default:
      throw new FirestoreError(Code.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
  }
}
__name(makeAuthCredentialsProvider, "makeAuthCredentialsProvider");
var DatabaseInfo = class {
  static {
    __name(this, "DatabaseInfo");
  }
  /**
   * Constructs a DatabaseInfo using the provided host, databaseId and
   * persistenceKey.
   *
   * @param databaseId - The database to use.
   * @param appId - The Firebase App Id.
   * @param persistenceKey - A unique identifier for this Firestore's local
   * storage (used in conjunction with the databaseId).
   * @param host - The Firestore backend host to connect to.
   * @param ssl - Whether to use SSL when connecting.
   * @param forceLongPolling - Whether to use the forceLongPolling option
   * when using WebChannel as the network transport.
   * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
   * option when using WebChannel as the network transport.
   * @param longPollingOptions Options that configure long-polling.
   * @param useFetchStreams Whether to use the Fetch API instead of
   * XMLHTTPRequest
   */
  constructor(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling, longPollingOptions, useFetchStreams, isUsingEmulator) {
    this.databaseId = databaseId;
    this.appId = appId;
    this.persistenceKey = persistenceKey;
    this.host = host;
    this.ssl = ssl;
    this.forceLongPolling = forceLongPolling;
    this.autoDetectLongPolling = autoDetectLongPolling;
    this.longPollingOptions = longPollingOptions;
    this.useFetchStreams = useFetchStreams;
    this.isUsingEmulator = isUsingEmulator;
  }
};
var DEFAULT_DATABASE_NAME = "(default)";
var DatabaseId = class _DatabaseId {
  static {
    __name(this, "DatabaseId");
  }
  constructor(projectId, database) {
    this.projectId = projectId;
    this.database = database ? database : DEFAULT_DATABASE_NAME;
  }
  static empty() {
    return new _DatabaseId("", "");
  }
  get isDefaultDatabase() {
    return this.database === DEFAULT_DATABASE_NAME;
  }
  isEqual(other) {
    return other instanceof _DatabaseId && other.projectId === this.projectId && other.database === this.database;
  }
};
function databaseIdFromApp(app, database) {
  if (!Object.prototype.hasOwnProperty.apply(app.options, ["projectId"])) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
  }
  return new DatabaseId(app.options.projectId, database);
}
__name(databaseIdFromApp, "databaseIdFromApp");
function randomBytes(nBytes) {
  return (0, import_crypto.randomBytes)(nBytes);
}
__name(randomBytes, "randomBytes");
function newTextEncoder() {
  return new TextEncoder();
}
__name(newTextEncoder, "newTextEncoder");
var AutoId = class {
  static {
    __name(this, "AutoId");
  }
  static newId() {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const maxMultiple = Math.floor(256 / chars.length) * chars.length;
    let autoId = "";
    const targetLength = 20;
    while (autoId.length < targetLength) {
      const bytes = randomBytes(40);
      for (let i18 = 0; i18 < bytes.length; ++i18) {
        if (autoId.length < targetLength && bytes[i18] < maxMultiple) {
          autoId += chars.charAt(bytes[i18] % chars.length);
        }
      }
    }
    return autoId;
  }
};
function primitiveComparator(left, right) {
  if (left < right) {
    return -1;
  }
  if (left > right) {
    return 1;
  }
  return 0;
}
__name(primitiveComparator, "primitiveComparator");
function compareUtf8Strings(left, right) {
  let i18 = 0;
  while (i18 < left.length && i18 < right.length) {
    const leftCodePoint = left.codePointAt(i18);
    const rightCodePoint = right.codePointAt(i18);
    if (leftCodePoint !== rightCodePoint) {
      if (leftCodePoint < 128 && rightCodePoint < 128) {
        return primitiveComparator(leftCodePoint, rightCodePoint);
      } else {
        const encoder = newTextEncoder();
        const leftBytes = encoder.encode(getUtf8SafeSubstring(left, i18));
        const rightBytes = encoder.encode(getUtf8SafeSubstring(right, i18));
        const comp = compareByteArrays(leftBytes, rightBytes);
        if (comp !== 0) {
          return comp;
        } else {
          return primitiveComparator(leftCodePoint, rightCodePoint);
        }
      }
    }
    i18 += leftCodePoint > 65535 ? 2 : 1;
  }
  return primitiveComparator(left.length, right.length);
}
__name(compareUtf8Strings, "compareUtf8Strings");
function getUtf8SafeSubstring(str, index) {
  const firstCodePoint = str.codePointAt(index);
  if (firstCodePoint > 65535) {
    return str.substring(index, index + 2);
  } else {
    return str.substring(index, index + 1);
  }
}
__name(getUtf8SafeSubstring, "getUtf8SafeSubstring");
function compareByteArrays(left, right) {
  for (let i18 = 0; i18 < left.length && i18 < right.length; ++i18) {
    if (left[i18] !== right[i18]) {
      return primitiveComparator(left[i18], right[i18]);
    }
  }
  return primitiveComparator(left.length, right.length);
}
__name(compareByteArrays, "compareByteArrays");
function arrayEquals(left, right, comparator) {
  if (left.length !== right.length) {
    return false;
  }
  return left.every((value, index) => comparator(value, right[index]));
}
__name(arrayEquals, "arrayEquals");
var DOCUMENT_KEY_NAME = "__name__";
var BasePath = class _BasePath {
  static {
    __name(this, "BasePath");
  }
  constructor(segments, offset, length) {
    if (offset === void 0) {
      offset = 0;
    } else if (offset > segments.length) {
      fail(637, {
        offset,
        range: segments.length
      });
    }
    if (length === void 0) {
      length = segments.length - offset;
    } else if (length > segments.length - offset) {
      fail(1746, {
        length,
        range: segments.length - offset
      });
    }
    this.segments = segments;
    this.offset = offset;
    this.len = length;
  }
  get length() {
    return this.len;
  }
  isEqual(other) {
    return _BasePath.comparator(this, other) === 0;
  }
  child(nameOrPath) {
    const segments = this.segments.slice(this.offset, this.limit());
    if (nameOrPath instanceof _BasePath) {
      nameOrPath.forEach((segment) => {
        segments.push(segment);
      });
    } else {
      segments.push(nameOrPath);
    }
    return this.construct(segments);
  }
  /** The index of one past the last segment of the path. */
  limit() {
    return this.offset + this.length;
  }
  popFirst(size) {
    size = size === void 0 ? 1 : size;
    return this.construct(this.segments, this.offset + size, this.length - size);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(index) {
    return this.segments[this.offset + index];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(other) {
    if (other.length < this.length) {
      return false;
    }
    for (let i18 = 0; i18 < this.length; i18++) {
      if (this.get(i18) !== other.get(i18)) {
        return false;
      }
    }
    return true;
  }
  isImmediateParentOf(potentialChild) {
    if (this.length + 1 !== potentialChild.length) {
      return false;
    }
    for (let i18 = 0; i18 < this.length; i18++) {
      if (this.get(i18) !== potentialChild.get(i18)) {
        return false;
      }
    }
    return true;
  }
  forEach(fn) {
    for (let i18 = this.offset, end = this.limit(); i18 < end; i18++) {
      fn(this.segments[i18]);
    }
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  /**
   * Compare 2 paths segment by segment, prioritizing numeric IDs
   * (e.g., "__id123__") in numeric ascending order, followed by string
   * segments in lexicographical order.
   */
  static comparator(p1, p22) {
    const len = Math.min(p1.length, p22.length);
    for (let i18 = 0; i18 < len; i18++) {
      const comparison = _BasePath.compareSegments(p1.get(i18), p22.get(i18));
      if (comparison !== 0) {
        return comparison;
      }
    }
    return primitiveComparator(p1.length, p22.length);
  }
  static compareSegments(lhs, rhs) {
    const isLhsNumeric = _BasePath.isNumericId(lhs);
    const isRhsNumeric = _BasePath.isNumericId(rhs);
    if (isLhsNumeric && !isRhsNumeric) {
      return -1;
    } else if (!isLhsNumeric && isRhsNumeric) {
      return 1;
    } else if (isLhsNumeric && isRhsNumeric) {
      return _BasePath.extractNumericId(lhs).compare(_BasePath.extractNumericId(rhs));
    } else {
      return compareUtf8Strings(lhs, rhs);
    }
  }
  // Checks if a segment is a numeric ID (starts with "__id" and ends with "__").
  static isNumericId(segment) {
    return segment.startsWith("__id") && segment.endsWith("__");
  }
  static extractNumericId(segment) {
    return Integer.fromString(segment.substring(4, segment.length - 2));
  }
};
var ResourcePath = class _ResourcePath extends BasePath {
  static {
    __name(this, "ResourcePath");
  }
  construct(segments, offset, length) {
    return new _ResourcePath(segments, offset, length);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns a string representation of this path
   * where each path segment has been encoded with
   * `encodeURIComponent`.
   */
  toUriEncodedString() {
    return this.toArray().map(encodeURIComponent).join("/");
  }
  /**
   * Creates a resource path from the given slash-delimited string. If multiple
   * arguments are provided, all components are combined. Leading and trailing
   * slashes from all components are ignored.
   */
  static fromString(...pathComponents) {
    const segments = [];
    for (const path of pathComponents) {
      if (path.indexOf("//") >= 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid segment (${path}). Paths must not contain // in them.`);
      }
      segments.push(...path.split("/").filter((segment) => segment.length > 0));
    }
    return new _ResourcePath(segments);
  }
  static emptyPath() {
    return new _ResourcePath([]);
  }
};
var identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var FieldPath$1 = class _FieldPath$1 extends BasePath {
  static {
    __name(this, "FieldPath$1");
  }
  construct(segments, offset, length) {
    return new _FieldPath$1(segments, offset, length);
  }
  /**
   * Returns true if the string could be used as a segment in a field path
   * without escaping.
   */
  static isValidIdentifier(segment) {
    return identifierRegExp.test(segment);
  }
  canonicalString() {
    return this.toArray().map((str) => {
      str = str.replace(/\\/g, "\\\\").replace(/`/g, "\\`");
      if (!_FieldPath$1.isValidIdentifier(str)) {
        str = "`" + str + "`";
      }
      return str;
    }).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns true if this field references the key of a document.
   */
  isKeyField() {
    return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;
  }
  /**
   * The field designating the key of a document.
   */
  static keyField() {
    return new _FieldPath$1([DOCUMENT_KEY_NAME]);
  }
  /**
   * Parses a field string from the given server-formatted string.
   *
   * - Splitting the empty string is not allowed (for now at least).
   * - Empty segments within the string (e.g. if there are two consecutive
   *   separators) are not allowed.
   *
   * TODO(b/37244157): we should make this more strict. Right now, it allows
   * non-identifier path components, even if they aren't escaped.
   */
  static fromServerFormat(path) {
    const segments = [];
    let current = "";
    let i18 = 0;
    const addCurrentSegment = /* @__PURE__ */ __name(() => {
      if (current.length === 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field path (${path}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      }
      segments.push(current);
      current = "";
    }, "addCurrentSegment");
    let inBackticks = false;
    while (i18 < path.length) {
      const c21 = path[i18];
      if (c21 === "\\") {
        if (i18 + 1 === path.length) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Path has trailing escape character: " + path);
        }
        const next = path[i18 + 1];
        if (!(next === "\\" || next === "." || next === "`")) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Path has invalid escape sequence: " + path);
        }
        current += next;
        i18 += 2;
      } else if (c21 === "`") {
        inBackticks = !inBackticks;
        i18++;
      } else if (c21 === "." && !inBackticks) {
        addCurrentSegment();
        i18++;
      } else {
        current += c21;
        i18++;
      }
    }
    addCurrentSegment();
    if (inBackticks) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Unterminated ` in path: " + path);
    }
    return new _FieldPath$1(segments);
  }
  static emptyPath() {
    return new _FieldPath$1([]);
  }
};
var DocumentKey = class _DocumentKey {
  static {
    __name(this, "DocumentKey");
  }
  constructor(path) {
    this.path = path;
  }
  static fromPath(path) {
    return new _DocumentKey(ResourcePath.fromString(path));
  }
  static fromName(name4) {
    return new _DocumentKey(ResourcePath.fromString(name4).popFirst(5));
  }
  static empty() {
    return new _DocumentKey(ResourcePath.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  /** Returns true if the document is in the specified collectionId. */
  hasCollectionId(collectionId) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === collectionId;
  }
  /** Returns the collection group (i.e. the name of the parent collection) for this key. */
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  /** Returns the fully qualified path to the parent collection. */
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(other) {
    return other !== null && ResourcePath.comparator(this.path, other.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(k1, k22) {
    return ResourcePath.comparator(k1.path, k22.path);
  }
  static isDocumentKey(path) {
    return path.length % 2 === 0;
  }
  /**
   * Creates and returns a new document key with the given segments.
   *
   * @param segments - The segments of the path to the document
   * @returns A new instance of DocumentKey
   */
  static fromSegments(segments) {
    return new _DocumentKey(new ResourcePath(segments.slice()));
  }
};
function validateNonEmptyArgument(functionName, argumentName, argument) {
  if (!argument) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() cannot be called with an empty ${argumentName}.`);
  }
}
__name(validateNonEmptyArgument, "validateNonEmptyArgument");
function validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {
  if (argument1 === true && argument2 === true) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `${optionName1} and ${optionName2} cannot be used together.`);
  }
}
__name(validateIsNotUsedTogether, "validateIsNotUsedTogether");
function validateDocumentPath(path) {
  if (!DocumentKey.isDocumentKey(path)) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${path} has ${path.length}.`);
  }
}
__name(validateDocumentPath, "validateDocumentPath");
function validateCollectionPath(path) {
  if (DocumentKey.isDocumentKey(path)) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${path} has ${path.length}.`);
  }
}
__name(validateCollectionPath, "validateCollectionPath");
function isPlainObject(input) {
  return typeof input === "object" && input !== null && (Object.getPrototypeOf(input) === Object.prototype || Object.getPrototypeOf(input) === null);
}
__name(isPlainObject, "isPlainObject");
function valueDescription(input) {
  if (input === void 0) {
    return "undefined";
  } else if (input === null) {
    return "null";
  } else if (typeof input === "string") {
    if (input.length > 20) {
      input = `${input.substring(0, 20)}...`;
    }
    return JSON.stringify(input);
  } else if (typeof input === "number" || typeof input === "boolean") {
    return "" + input;
  } else if (typeof input === "object") {
    if (input instanceof Array) {
      return "an array";
    } else {
      const customObjectName = tryGetCustomObjectType(input);
      if (customObjectName) {
        return `a custom ${customObjectName} object`;
      } else {
        return "an object";
      }
    }
  } else if (typeof input === "function") {
    return "a function";
  } else {
    return fail(12329, { type: typeof input });
  }
}
__name(valueDescription, "valueDescription");
function tryGetCustomObjectType(input) {
  if (input.constructor) {
    return input.constructor.name;
  }
  return null;
}
__name(tryGetCustomObjectType, "tryGetCustomObjectType");
function cast(obj, constructor) {
  if ("_delegate" in obj) {
    obj = obj._delegate;
  }
  if (!(obj instanceof constructor)) {
    if (constructor.name === obj.constructor.name) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, `Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?`);
    } else {
      const description = valueDescription(obj);
      throw new FirestoreError(Code.INVALID_ARGUMENT, `Expected type '${constructor.name}', but it was: ${description}`);
    }
  }
  return obj;
}
__name(cast, "cast");
function validatePositiveNumber(functionName, n11) {
  if (n11 <= 0) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires a positive number, but it was: ${n11}.`);
  }
}
__name(validatePositiveNumber, "validatePositiveNumber");
function longPollingOptionsEqual(options1, options2) {
  return options1.timeoutSeconds === options2.timeoutSeconds;
}
__name(longPollingOptionsEqual, "longPollingOptionsEqual");
function cloneLongPollingOptions(options) {
  const clone = {};
  if (options.timeoutSeconds !== void 0) {
    clone.timeoutSeconds = options.timeoutSeconds;
  }
  return clone;
}
__name(cloneLongPollingOptions, "cloneLongPollingOptions");
var lastUniqueDebugId = null;
function generateInitialUniqueDebugId() {
  const minResult = 268435456;
  const maxResult = 2415919104;
  const resultRange = maxResult - minResult;
  const resultOffset = Math.round(resultRange * Math.random());
  return minResult + resultOffset;
}
__name(generateInitialUniqueDebugId, "generateInitialUniqueDebugId");
function generateUniqueDebugId() {
  if (lastUniqueDebugId === null) {
    lastUniqueDebugId = generateInitialUniqueDebugId();
  } else {
    lastUniqueDebugId++;
  }
  return "0x" + lastUniqueDebugId.toString(16);
}
__name(generateUniqueDebugId, "generateUniqueDebugId");
var LOG_TAG$3 = "RestConnection";
var RPC_NAME_URL_MAPPING = {};
RPC_NAME_URL_MAPPING["BatchGetDocuments"] = "batchGet";
RPC_NAME_URL_MAPPING["Commit"] = "commit";
RPC_NAME_URL_MAPPING["RunQuery"] = "runQuery";
RPC_NAME_URL_MAPPING["RunAggregationQuery"] = "runAggregationQuery";
var RPC_URL_VERSION = "v1";
function getGoogApiClientValue() {
  return "gl-js/ fire/" + SDK_VERSION2;
}
__name(getGoogApiClientValue, "getGoogApiClientValue");
var RestConnection = class {
  static {
    __name(this, "RestConnection");
  }
  get shouldResourcePathBeIncludedInRequest() {
    return false;
  }
  constructor(databaseInfo) {
    this.databaseInfo = databaseInfo;
    this.databaseId = databaseInfo.databaseId;
    const proto = databaseInfo.ssl ? "https" : "http";
    const projectId = encodeURIComponent(this.databaseId.projectId);
    const databaseId = encodeURIComponent(this.databaseId.database);
    this.baseUrl = proto + "://" + databaseInfo.host;
    this.databasePath = `projects/${projectId}/databases/${databaseId}`;
    this.requestParams = this.databaseId.database === DEFAULT_DATABASE_NAME ? `project_id=${projectId}` : `project_id=${projectId}&database_id=${databaseId}`;
  }
  invokeRPC(rpcName, path, req, authToken, appCheckToken) {
    const streamId = generateUniqueDebugId();
    const url = this.makeUrl(rpcName, path.toUriEncodedString());
    logDebug(LOG_TAG$3, `Sending RPC '${rpcName}' ${streamId}:`, url, req);
    const headers = {
      "google-cloud-resource-prefix": this.databasePath,
      "x-goog-request-params": this.requestParams
    };
    this.modifyHeadersForRequest(headers, authToken, appCheckToken);
    const { host } = new URL(url);
    const forwardCredentials = isCloudWorkstation(host);
    return this.performRPCRequest(rpcName, url, headers, req, forwardCredentials).then((response) => {
      logDebug(LOG_TAG$3, `Received RPC '${rpcName}' ${streamId}: `, response);
      return response;
    }, (err) => {
      logWarn(LOG_TAG$3, `RPC '${rpcName}' ${streamId} failed with error: `, err, "url: ", url, "request:", req);
      throw err;
    });
  }
  invokeStreamingRPC(rpcName, path, request, authToken, appCheckToken, expectedResponseCount) {
    return this.invokeRPC(rpcName, path, request, authToken, appCheckToken);
  }
  /**
   * Modifies the headers for a request, adding any authorization token if
   * present and any additional headers for the request.
   */
  modifyHeadersForRequest(headers, authToken, appCheckToken) {
    headers["X-Goog-Api-Client"] = getGoogApiClientValue();
    headers["Content-Type"] = "text/plain";
    if (this.databaseInfo.appId) {
      headers["X-Firebase-GMPID"] = this.databaseInfo.appId;
    }
    if (authToken) {
      authToken.headers.forEach((value, key) => headers[key] = value);
    }
    if (appCheckToken) {
      appCheckToken.headers.forEach((value, key) => headers[key] = value);
    }
  }
  makeUrl(rpcName, path) {
    const urlRpcName = RPC_NAME_URL_MAPPING[rpcName];
    return `${this.baseUrl}/${RPC_URL_VERSION}/${path}:${urlRpcName}`;
  }
  /**
   * Closes and cleans up any resources associated with the connection. This
   * implementation is a no-op because there are no resources associated
   * with the RestConnection that need to be cleaned up.
   */
  terminate() {
  }
};
var RpcCode;
(function(RpcCode2) {
  RpcCode2[RpcCode2["OK"] = 0] = "OK";
  RpcCode2[RpcCode2["CANCELLED"] = 1] = "CANCELLED";
  RpcCode2[RpcCode2["UNKNOWN"] = 2] = "UNKNOWN";
  RpcCode2[RpcCode2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
  RpcCode2[RpcCode2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
  RpcCode2[RpcCode2["NOT_FOUND"] = 5] = "NOT_FOUND";
  RpcCode2[RpcCode2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
  RpcCode2[RpcCode2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
  RpcCode2[RpcCode2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
  RpcCode2[RpcCode2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
  RpcCode2[RpcCode2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
  RpcCode2[RpcCode2["ABORTED"] = 10] = "ABORTED";
  RpcCode2[RpcCode2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
  RpcCode2[RpcCode2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
  RpcCode2[RpcCode2["INTERNAL"] = 13] = "INTERNAL";
  RpcCode2[RpcCode2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
  RpcCode2[RpcCode2["DATA_LOSS"] = 15] = "DATA_LOSS";
})(RpcCode || (RpcCode = {}));
function isPermanentError(code) {
  switch (code) {
    case Code.OK:
      return fail(64938);
    case Code.CANCELLED:
    case Code.UNKNOWN:
    case Code.DEADLINE_EXCEEDED:
    case Code.RESOURCE_EXHAUSTED:
    case Code.INTERNAL:
    case Code.UNAVAILABLE:
    // Unauthenticated means something went wrong with our token and we need
    // to retry with new credentials which will happen automatically.
    case Code.UNAUTHENTICATED:
      return false;
    case Code.INVALID_ARGUMENT:
    case Code.NOT_FOUND:
    case Code.ALREADY_EXISTS:
    case Code.PERMISSION_DENIED:
    case Code.FAILED_PRECONDITION:
    // Aborted might be retried in some scenarios, but that is dependent on
    // the context and should handled individually by the calling code.
    // See https://cloud.google.com/apis/design/errors.
    case Code.ABORTED:
    case Code.OUT_OF_RANGE:
    case Code.UNIMPLEMENTED:
    case Code.DATA_LOSS:
      return true;
    default:
      return fail(15467, { code });
  }
}
__name(isPermanentError, "isPermanentError");
function mapCodeFromHttpStatus(status) {
  if (status === void 0) {
    logError("RPC_ERROR", "HTTP error has no status");
    return Code.UNKNOWN;
  }
  switch (status) {
    case 200:
      return Code.OK;
    case 400:
      return Code.FAILED_PRECONDITION;
    // Other possibilities based on the forward mapping
    // return Code.INVALID_ARGUMENT;
    // return Code.OUT_OF_RANGE;
    case 401:
      return Code.UNAUTHENTICATED;
    case 403:
      return Code.PERMISSION_DENIED;
    case 404:
      return Code.NOT_FOUND;
    case 409:
      return Code.ABORTED;
    // Other possibilities:
    // return Code.ALREADY_EXISTS;
    case 416:
      return Code.OUT_OF_RANGE;
    case 429:
      return Code.RESOURCE_EXHAUSTED;
    case 499:
      return Code.CANCELLED;
    case 500:
      return Code.UNKNOWN;
    // Other possibilities:
    // return Code.INTERNAL;
    // return Code.DATA_LOSS;
    case 501:
      return Code.UNIMPLEMENTED;
    case 503:
      return Code.UNAVAILABLE;
    case 504:
      return Code.DEADLINE_EXCEEDED;
    default:
      if (status >= 200 && status < 300) {
        return Code.OK;
      }
      if (status >= 400 && status < 500) {
        return Code.FAILED_PRECONDITION;
      }
      if (status >= 500 && status < 600) {
        return Code.INTERNAL;
      }
      return Code.UNKNOWN;
  }
}
__name(mapCodeFromHttpStatus, "mapCodeFromHttpStatus");
var FetchConnection = class extends RestConnection {
  static {
    __name(this, "FetchConnection");
  }
  openStream(rpcName, token) {
    throw new Error("Not supported by FetchConnection");
  }
  async performRPCRequest(rpcName, url, headers, body, forwardCredentials) {
    var _a;
    const requestJson = JSON.stringify(body);
    let response;
    try {
      const fetchArgs = {
        method: "POST",
        headers,
        body: requestJson
      };
      if (forwardCredentials) {
        fetchArgs.credentials = "include";
      }
      response = await fetch(url, fetchArgs);
    } catch (e10) {
      const err = e10;
      throw new FirestoreError(mapCodeFromHttpStatus(err.status), "Request failed with error: " + err.statusText);
    }
    if (!response.ok) {
      let errorResponse = await response.json();
      if (Array.isArray(errorResponse)) {
        errorResponse = errorResponse[0];
      }
      const errorMessage = (_a = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse.error) === null || _a === void 0 ? void 0 : _a.message;
      throw new FirestoreError(mapCodeFromHttpStatus(response.status), `Request failed with error: ${errorMessage !== null && errorMessage !== void 0 ? errorMessage : response.statusText}`);
    }
    return response.json();
  }
};
function newConnection(databaseInfo) {
  return new FetchConnection(databaseInfo);
}
__name(newConnection, "newConnection");
function objectSize(obj) {
  let count2 = 0;
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      count2++;
    }
  }
  return count2;
}
__name(objectSize, "objectSize");
function forEach(obj, fn) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      fn(key, obj[key]);
    }
  }
}
__name(forEach, "forEach");
function mapToArray(obj, fn) {
  const result = [];
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      result.push(fn(obj[key], key, obj));
    }
  }
  return result;
}
__name(mapToArray, "mapToArray");
function isEmpty2(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
__name(isEmpty2, "isEmpty");
function isNullOrUndefined(value) {
  return value === null || value === void 0;
}
__name(isNullOrUndefined, "isNullOrUndefined");
function isNegativeZero(value) {
  return value === 0 && 1 / value === 1 / -0;
}
__name(isNegativeZero, "isNegativeZero");
function isSafeInteger(value) {
  return typeof value === "number" && Number.isInteger(value) && !isNegativeZero(value) && value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER;
}
__name(isSafeInteger, "isSafeInteger");
function decodeBase64(encoded) {
  return Buffer.from(encoded, "base64").toString("binary");
}
__name(decodeBase64, "decodeBase64");
function encodeBase64(raw) {
  return Buffer.from(raw, "binary").toString("base64");
}
__name(encodeBase64, "encodeBase64");
var ByteString = class _ByteString {
  static {
    __name(this, "ByteString");
  }
  constructor(binaryString) {
    this.binaryString = binaryString;
  }
  static fromBase64String(base642) {
    const binaryString = decodeBase64(base642);
    return new _ByteString(binaryString);
  }
  static fromUint8Array(array) {
    const binaryString = binaryStringFromUint8Array(array);
    return new _ByteString(binaryString);
  }
  [Symbol.iterator]() {
    let i18 = 0;
    return {
      next: /* @__PURE__ */ __name(() => {
        if (i18 < this.binaryString.length) {
          return { value: this.binaryString.charCodeAt(i18++), done: false };
        } else {
          return { value: void 0, done: true };
        }
      }, "next")
    };
  }
  toBase64() {
    return encodeBase64(this.binaryString);
  }
  toUint8Array() {
    return uint8ArrayFromBinaryString(this.binaryString);
  }
  approximateByteSize() {
    return this.binaryString.length * 2;
  }
  compareTo(other) {
    return primitiveComparator(this.binaryString, other.binaryString);
  }
  isEqual(other) {
    return this.binaryString === other.binaryString;
  }
};
ByteString.EMPTY_BYTE_STRING = new ByteString("");
function binaryStringFromUint8Array(array) {
  let binaryString = "";
  for (let i18 = 0; i18 < array.length; ++i18) {
    binaryString += String.fromCharCode(array[i18]);
  }
  return binaryString;
}
__name(binaryStringFromUint8Array, "binaryStringFromUint8Array");
function uint8ArrayFromBinaryString(binaryString) {
  const buffer = new Uint8Array(binaryString.length);
  for (let i18 = 0; i18 < binaryString.length; i18++) {
    buffer[i18] = binaryString.charCodeAt(i18);
  }
  return buffer;
}
__name(uint8ArrayFromBinaryString, "uint8ArrayFromBinaryString");
var ISO_TIMESTAMP_REG_EXP = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function normalizeTimestamp(date) {
  hardAssert(!!date, 39018);
  if (typeof date === "string") {
    let nanos = 0;
    const fraction = ISO_TIMESTAMP_REG_EXP.exec(date);
    hardAssert(!!fraction, 46558, {
      timestamp: date
    });
    if (fraction[1]) {
      let nanoStr = fraction[1];
      nanoStr = (nanoStr + "000000000").substr(0, 9);
      nanos = Number(nanoStr);
    }
    const parsedDate = new Date(date);
    const seconds = Math.floor(parsedDate.getTime() / 1e3);
    return { seconds, nanos };
  } else {
    const seconds = normalizeNumber(date.seconds);
    const nanos = normalizeNumber(date.nanos);
    return { seconds, nanos };
  }
}
__name(normalizeTimestamp, "normalizeTimestamp");
function normalizeNumber(value) {
  if (typeof value === "number") {
    return value;
  } else if (typeof value === "string") {
    return Number(value);
  } else {
    return 0;
  }
}
__name(normalizeNumber, "normalizeNumber");
function normalizeByteString(blob) {
  if (typeof blob === "string") {
    return ByteString.fromBase64String(blob);
  } else {
    return ByteString.fromUint8Array(blob);
  }
}
__name(normalizeByteString, "normalizeByteString");
var MIN_SECONDS = -62135596800;
var MS_TO_NANOS = 1e6;
var Timestamp = class _Timestamp {
  static {
    __name(this, "Timestamp");
  }
  /**
   * Creates a new timestamp with the current date, with millisecond precision.
   *
   * @returns a new timestamp representing the current date.
   */
  static now() {
    return _Timestamp.fromMillis(Date.now());
  }
  /**
   * Creates a new timestamp from the given date.
   *
   * @param date - The date to initialize the `Timestamp` from.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     date.
   */
  static fromDate(date) {
    return _Timestamp.fromMillis(date.getTime());
  }
  /**
   * Creates a new timestamp from the given number of milliseconds.
   *
   * @param milliseconds - Number of milliseconds since Unix epoch
   *     1970-01-01T00:00:00Z.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     number of milliseconds.
   */
  static fromMillis(milliseconds) {
    const seconds = Math.floor(milliseconds / 1e3);
    const nanos = Math.floor((milliseconds - seconds * 1e3) * MS_TO_NANOS);
    return new _Timestamp(seconds, nanos);
  }
  /**
   * Creates a new timestamp.
   *
   * @param seconds - The number of seconds of UTC time since Unix epoch
   *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   *     9999-12-31T23:59:59Z inclusive.
   * @param nanoseconds - The non-negative fractions of a second at nanosecond
   *     resolution. Negative second values with fractions must still have
   *     non-negative nanoseconds values that count forward in time. Must be
   *     from 0 to 999,999,999 inclusive.
   */
  constructor(seconds, nanoseconds) {
    this.seconds = seconds;
    this.nanoseconds = nanoseconds;
    if (nanoseconds < 0) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + nanoseconds);
    }
    if (nanoseconds >= 1e9) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + nanoseconds);
    }
    if (seconds < MIN_SECONDS) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp seconds out of range: " + seconds);
    }
    if (seconds >= 253402300800) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp seconds out of range: " + seconds);
    }
  }
  /**
   * Converts a `Timestamp` to a JavaScript `Date` object. This conversion
   * causes a loss of precision since `Date` objects only support millisecond
   * precision.
   *
   * @returns JavaScript `Date` object representing the same point in time as
   *     this `Timestamp`, with millisecond precision.
   */
  toDate() {
    return new Date(this.toMillis());
  }
  /**
   * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
   * epoch). This operation causes a loss of precision.
   *
   * @returns The point in time corresponding to this timestamp, represented as
   *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
   */
  toMillis() {
    return this.seconds * 1e3 + this.nanoseconds / MS_TO_NANOS;
  }
  _compareTo(other) {
    if (this.seconds === other.seconds) {
      return primitiveComparator(this.nanoseconds, other.nanoseconds);
    }
    return primitiveComparator(this.seconds, other.seconds);
  }
  /**
   * Returns true if this `Timestamp` is equal to the provided one.
   *
   * @param other - The `Timestamp` to compare against.
   * @returns true if this `Timestamp` is equal to the provided one.
   */
  isEqual(other) {
    return other.seconds === this.seconds && other.nanoseconds === this.nanoseconds;
  }
  /** Returns a textual representation of this `Timestamp`. */
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  /** Returns a JSON-serializable representation of this `Timestamp`. */
  toJSON() {
    return { seconds: this.seconds, nanoseconds: this.nanoseconds };
  }
  /**
   * Converts this object to a primitive string, which allows `Timestamp` objects
   * to be compared using the `>`, `<=`, `>=` and `>` operators.
   */
  valueOf() {
    const adjustedSeconds = this.seconds - MIN_SECONDS;
    const formattedSeconds = String(adjustedSeconds).padStart(12, "0");
    const formattedNanoseconds = String(this.nanoseconds).padStart(9, "0");
    return formattedSeconds + "." + formattedNanoseconds;
  }
};
var SERVER_TIMESTAMP_SENTINEL = "server_timestamp";
var TYPE_KEY$1 = "__type__";
var PREVIOUS_VALUE_KEY = "__previous_value__";
var LOCAL_WRITE_TIME_KEY = "__local_write_time__";
function isServerTimestamp(value) {
  var _a, _b;
  const type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY$1]) === null || _b === void 0 ? void 0 : _b.stringValue;
  return type === SERVER_TIMESTAMP_SENTINEL;
}
__name(isServerTimestamp, "isServerTimestamp");
function getPreviousValue(value) {
  const previousValue = value.mapValue.fields[PREVIOUS_VALUE_KEY];
  if (isServerTimestamp(previousValue)) {
    return getPreviousValue(previousValue);
  }
  return previousValue;
}
__name(getPreviousValue, "getPreviousValue");
function getLocalWriteTime(value) {
  const localWriteTime = normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);
  return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);
}
__name(getLocalWriteTime, "getLocalWriteTime");
var TYPE_KEY = "__type__";
var MAX_VALUE_TYPE = "__max__";
var MAX_VALUE = {
  mapValue: {
    fields: {
      "__type__": { stringValue: MAX_VALUE_TYPE }
    }
  }
};
var VECTOR_VALUE_SENTINEL = "__vector__";
var VECTOR_MAP_VECTORS_KEY = "value";
function typeOrder(value) {
  if ("nullValue" in value) {
    return 0;
  } else if ("booleanValue" in value) {
    return 1;
  } else if ("integerValue" in value || "doubleValue" in value) {
    return 2;
  } else if ("timestampValue" in value) {
    return 3;
  } else if ("stringValue" in value) {
    return 5;
  } else if ("bytesValue" in value) {
    return 6;
  } else if ("referenceValue" in value) {
    return 7;
  } else if ("geoPointValue" in value) {
    return 8;
  } else if ("arrayValue" in value) {
    return 9;
  } else if ("mapValue" in value) {
    if (isServerTimestamp(value)) {
      return 4;
    } else if (isMaxValue(value)) {
      return 9007199254740991;
    } else if (isVectorValue(value)) {
      return 10;
    }
    return 11;
  } else {
    return fail(28295, { value });
  }
}
__name(typeOrder, "typeOrder");
function valueEquals(left, right) {
  if (left === right) {
    return true;
  }
  const leftType = typeOrder(left);
  const rightType = typeOrder(right);
  if (leftType !== rightType) {
    return false;
  }
  switch (leftType) {
    case 0:
      return true;
    case 1:
      return left.booleanValue === right.booleanValue;
    case 4:
      return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));
    case 3:
      return timestampEquals(left, right);
    case 5:
      return left.stringValue === right.stringValue;
    case 6:
      return blobEquals(left, right);
    case 7:
      return left.referenceValue === right.referenceValue;
    case 8:
      return geoPointEquals(left, right);
    case 2:
      return numberEquals(left, right);
    case 9:
      return arrayEquals(left.arrayValue.values || [], right.arrayValue.values || [], valueEquals);
    case 10:
    case 11:
      return objectEquals(left, right);
    case 9007199254740991:
      return true;
    default:
      return fail(52216, { left });
  }
}
__name(valueEquals, "valueEquals");
function timestampEquals(left, right) {
  if (typeof left.timestampValue === "string" && typeof right.timestampValue === "string" && left.timestampValue.length === right.timestampValue.length) {
    return left.timestampValue === right.timestampValue;
  }
  const leftTimestamp = normalizeTimestamp(left.timestampValue);
  const rightTimestamp = normalizeTimestamp(right.timestampValue);
  return leftTimestamp.seconds === rightTimestamp.seconds && leftTimestamp.nanos === rightTimestamp.nanos;
}
__name(timestampEquals, "timestampEquals");
function geoPointEquals(left, right) {
  return normalizeNumber(left.geoPointValue.latitude) === normalizeNumber(right.geoPointValue.latitude) && normalizeNumber(left.geoPointValue.longitude) === normalizeNumber(right.geoPointValue.longitude);
}
__name(geoPointEquals, "geoPointEquals");
function blobEquals(left, right) {
  return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));
}
__name(blobEquals, "blobEquals");
function numberEquals(left, right) {
  if ("integerValue" in left && "integerValue" in right) {
    return normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue);
  } else if ("doubleValue" in left && "doubleValue" in right) {
    const n1 = normalizeNumber(left.doubleValue);
    const n22 = normalizeNumber(right.doubleValue);
    if (n1 === n22) {
      return isNegativeZero(n1) === isNegativeZero(n22);
    } else {
      return isNaN(n1) && isNaN(n22);
    }
  }
  return false;
}
__name(numberEquals, "numberEquals");
function objectEquals(left, right) {
  const leftMap = left.mapValue.fields || {};
  const rightMap = right.mapValue.fields || {};
  if (objectSize(leftMap) !== objectSize(rightMap)) {
    return false;
  }
  for (const key in leftMap) {
    if (leftMap.hasOwnProperty(key)) {
      if (rightMap[key] === void 0 || !valueEquals(leftMap[key], rightMap[key])) {
        return false;
      }
    }
  }
  return true;
}
__name(objectEquals, "objectEquals");
function arrayValueContains(haystack, needle) {
  return (haystack.values || []).find((v8) => valueEquals(v8, needle)) !== void 0;
}
__name(arrayValueContains, "arrayValueContains");
function valueCompare(left, right) {
  if (left === right) {
    return 0;
  }
  const leftType = typeOrder(left);
  const rightType = typeOrder(right);
  if (leftType !== rightType) {
    return primitiveComparator(leftType, rightType);
  }
  switch (leftType) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return primitiveComparator(left.booleanValue, right.booleanValue);
    case 2:
      return compareNumbers(left, right);
    case 3:
      return compareTimestamps(left.timestampValue, right.timestampValue);
    case 4:
      return compareTimestamps(getLocalWriteTime(left), getLocalWriteTime(right));
    case 5:
      return compareUtf8Strings(left.stringValue, right.stringValue);
    case 6:
      return compareBlobs(left.bytesValue, right.bytesValue);
    case 7:
      return compareReferences(left.referenceValue, right.referenceValue);
    case 8:
      return compareGeoPoints(left.geoPointValue, right.geoPointValue);
    case 9:
      return compareArrays(left.arrayValue, right.arrayValue);
    case 10:
      return compareVectors(left.mapValue, right.mapValue);
    case 11:
      return compareMaps(left.mapValue, right.mapValue);
    default:
      throw fail(23264, { leftType });
  }
}
__name(valueCompare, "valueCompare");
function compareNumbers(left, right) {
  const leftNumber = normalizeNumber(left.integerValue || left.doubleValue);
  const rightNumber = normalizeNumber(right.integerValue || right.doubleValue);
  if (leftNumber < rightNumber) {
    return -1;
  } else if (leftNumber > rightNumber) {
    return 1;
  } else if (leftNumber === rightNumber) {
    return 0;
  } else {
    if (isNaN(leftNumber)) {
      return isNaN(rightNumber) ? 0 : -1;
    } else {
      return 1;
    }
  }
}
__name(compareNumbers, "compareNumbers");
function compareTimestamps(left, right) {
  if (typeof left === "string" && typeof right === "string" && left.length === right.length) {
    return primitiveComparator(left, right);
  }
  const leftTimestamp = normalizeTimestamp(left);
  const rightTimestamp = normalizeTimestamp(right);
  const comparison = primitiveComparator(leftTimestamp.seconds, rightTimestamp.seconds);
  if (comparison !== 0) {
    return comparison;
  }
  return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);
}
__name(compareTimestamps, "compareTimestamps");
function compareReferences(leftPath, rightPath) {
  const leftSegments = leftPath.split("/");
  const rightSegments = rightPath.split("/");
  for (let i18 = 0; i18 < leftSegments.length && i18 < rightSegments.length; i18++) {
    const comparison = primitiveComparator(leftSegments[i18], rightSegments[i18]);
    if (comparison !== 0) {
      return comparison;
    }
  }
  return primitiveComparator(leftSegments.length, rightSegments.length);
}
__name(compareReferences, "compareReferences");
function compareGeoPoints(left, right) {
  const comparison = primitiveComparator(normalizeNumber(left.latitude), normalizeNumber(right.latitude));
  if (comparison !== 0) {
    return comparison;
  }
  return primitiveComparator(normalizeNumber(left.longitude), normalizeNumber(right.longitude));
}
__name(compareGeoPoints, "compareGeoPoints");
function compareBlobs(left, right) {
  const leftBytes = normalizeByteString(left);
  const rightBytes = normalizeByteString(right);
  return leftBytes.compareTo(rightBytes);
}
__name(compareBlobs, "compareBlobs");
function compareArrays(left, right) {
  const leftArray = left.values || [];
  const rightArray = right.values || [];
  for (let i18 = 0; i18 < leftArray.length && i18 < rightArray.length; ++i18) {
    const compare = valueCompare(leftArray[i18], rightArray[i18]);
    if (compare) {
      return compare;
    }
  }
  return primitiveComparator(leftArray.length, rightArray.length);
}
__name(compareArrays, "compareArrays");
function compareVectors(left, right) {
  var _a, _b, _c, _d;
  const leftMap = left.fields || {};
  const rightMap = right.fields || {};
  const leftArrayValue = (_a = leftMap[VECTOR_MAP_VECTORS_KEY]) === null || _a === void 0 ? void 0 : _a.arrayValue;
  const rightArrayValue = (_b = rightMap[VECTOR_MAP_VECTORS_KEY]) === null || _b === void 0 ? void 0 : _b.arrayValue;
  const lengthCompare = primitiveComparator(((_c = leftArrayValue === null || leftArrayValue === void 0 ? void 0 : leftArrayValue.values) === null || _c === void 0 ? void 0 : _c.length) || 0, ((_d = rightArrayValue === null || rightArrayValue === void 0 ? void 0 : rightArrayValue.values) === null || _d === void 0 ? void 0 : _d.length) || 0);
  if (lengthCompare !== 0) {
    return lengthCompare;
  }
  return compareArrays(leftArrayValue, rightArrayValue);
}
__name(compareVectors, "compareVectors");
function compareMaps(left, right) {
  if (left === MAX_VALUE.mapValue && right === MAX_VALUE.mapValue) {
    return 0;
  } else if (left === MAX_VALUE.mapValue) {
    return 1;
  } else if (right === MAX_VALUE.mapValue) {
    return -1;
  }
  const leftMap = left.fields || {};
  const leftKeys = Object.keys(leftMap);
  const rightMap = right.fields || {};
  const rightKeys = Object.keys(rightMap);
  leftKeys.sort();
  rightKeys.sort();
  for (let i18 = 0; i18 < leftKeys.length && i18 < rightKeys.length; ++i18) {
    const keyCompare = compareUtf8Strings(leftKeys[i18], rightKeys[i18]);
    if (keyCompare !== 0) {
      return keyCompare;
    }
    const compare = valueCompare(leftMap[leftKeys[i18]], rightMap[rightKeys[i18]]);
    if (compare !== 0) {
      return compare;
    }
  }
  return primitiveComparator(leftKeys.length, rightKeys.length);
}
__name(compareMaps, "compareMaps");
function refValue(databaseId, key) {
  return {
    referenceValue: `projects/${databaseId.projectId}/databases/${databaseId.database}/documents/${key.path.canonicalString()}`
  };
}
__name(refValue, "refValue");
function isArray(value) {
  return !!value && "arrayValue" in value;
}
__name(isArray, "isArray");
function isNullValue(value) {
  return !!value && "nullValue" in value;
}
__name(isNullValue, "isNullValue");
function isNanValue(value) {
  return !!value && "doubleValue" in value && isNaN(Number(value.doubleValue));
}
__name(isNanValue, "isNanValue");
function isMapValue(value) {
  return !!value && "mapValue" in value;
}
__name(isMapValue, "isMapValue");
function isVectorValue(value) {
  var _a, _b;
  const type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY]) === null || _b === void 0 ? void 0 : _b.stringValue;
  return type === VECTOR_VALUE_SENTINEL;
}
__name(isVectorValue, "isVectorValue");
function deepClone(source) {
  if (source.geoPointValue) {
    return { geoPointValue: Object.assign({}, source.geoPointValue) };
  } else if (source.timestampValue && typeof source.timestampValue === "object") {
    return { timestampValue: Object.assign({}, source.timestampValue) };
  } else if (source.mapValue) {
    const target = { mapValue: { fields: {} } };
    forEach(source.mapValue.fields, (key, val) => target.mapValue.fields[key] = deepClone(val));
    return target;
  } else if (source.arrayValue) {
    const target = { arrayValue: { values: [] } };
    for (let i18 = 0; i18 < (source.arrayValue.values || []).length; ++i18) {
      target.arrayValue.values[i18] = deepClone(source.arrayValue.values[i18]);
    }
    return target;
  } else {
    return Object.assign({}, source);
  }
}
__name(deepClone, "deepClone");
function isMaxValue(value) {
  return (((value.mapValue || {}).fields || {})["__type__"] || {}).stringValue === MAX_VALUE_TYPE;
}
__name(isMaxValue, "isMaxValue");
var Bound = class {
  static {
    __name(this, "Bound");
  }
  constructor(position, inclusive) {
    this.position = position;
    this.inclusive = inclusive;
  }
};
function boundEquals(left, right) {
  if (left === null) {
    return right === null;
  } else if (right === null) {
    return false;
  }
  if (left.inclusive !== right.inclusive || left.position.length !== right.position.length) {
    return false;
  }
  for (let i18 = 0; i18 < left.position.length; i18++) {
    const leftPosition = left.position[i18];
    const rightPosition = right.position[i18];
    if (!valueEquals(leftPosition, rightPosition)) {
      return false;
    }
  }
  return true;
}
__name(boundEquals, "boundEquals");
var Filter = class {
  static {
    __name(this, "Filter");
  }
};
var FieldFilter = class _FieldFilter extends Filter {
  static {
    __name(this, "FieldFilter");
  }
  constructor(field, op, value) {
    super();
    this.field = field;
    this.op = op;
    this.value = value;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(field, op, value) {
    if (field.isKeyField()) {
      if (op === "in" || op === "not-in") {
        return this.createKeyFieldInFilter(field, op, value);
      } else {
        return new KeyFieldFilter(field, op, value);
      }
    } else if (op === "array-contains") {
      return new ArrayContainsFilter(field, value);
    } else if (op === "in") {
      return new InFilter(field, value);
    } else if (op === "not-in") {
      return new NotInFilter(field, value);
    } else if (op === "array-contains-any") {
      return new ArrayContainsAnyFilter(field, value);
    } else {
      return new _FieldFilter(field, op, value);
    }
  }
  static createKeyFieldInFilter(field, op, value) {
    return op === "in" ? new KeyFieldInFilter(field, value) : new KeyFieldNotInFilter(field, value);
  }
  matches(doc2) {
    const other = doc2.data.field(this.field);
    if (this.op === "!=") {
      return other !== null && other.nullValue === void 0 && this.matchesComparison(valueCompare(other, this.value));
    }
    return other !== null && typeOrder(this.value) === typeOrder(other) && this.matchesComparison(valueCompare(other, this.value));
  }
  matchesComparison(comparison) {
    switch (this.op) {
      case "<":
        return comparison < 0;
      case "<=":
        return comparison <= 0;
      case "==":
        return comparison === 0;
      case "!=":
        return comparison !== 0;
      case ">":
        return comparison > 0;
      case ">=":
        return comparison >= 0;
      default:
        return fail(47266, {
          operator: this.op
        });
    }
  }
  isInequality() {
    return [
      "<",
      "<=",
      ">",
      ">=",
      "!=",
      "not-in"
      /* Operator.NOT_IN */
    ].indexOf(this.op) >= 0;
  }
  getFlattenedFilters() {
    return [this];
  }
  getFilters() {
    return [this];
  }
};
var CompositeFilter = class _CompositeFilter extends Filter {
  static {
    __name(this, "CompositeFilter");
  }
  constructor(filters, op) {
    super();
    this.filters = filters;
    this.op = op;
    this.memoizedFlattenedFilters = null;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(filters, op) {
    return new _CompositeFilter(filters, op);
  }
  matches(doc2) {
    if (compositeFilterIsConjunction(this)) {
      return this.filters.find((filter) => !filter.matches(doc2)) === void 0;
    } else {
      return this.filters.find((filter) => filter.matches(doc2)) !== void 0;
    }
  }
  getFlattenedFilters() {
    if (this.memoizedFlattenedFilters !== null) {
      return this.memoizedFlattenedFilters;
    }
    this.memoizedFlattenedFilters = this.filters.reduce((result, subfilter) => {
      return result.concat(subfilter.getFlattenedFilters());
    }, []);
    return this.memoizedFlattenedFilters;
  }
  // Returns a mutable copy of `this.filters`
  getFilters() {
    return Object.assign([], this.filters);
  }
};
function compositeFilterIsConjunction(compositeFilter) {
  return compositeFilter.op === "and";
}
__name(compositeFilterIsConjunction, "compositeFilterIsConjunction");
function filterEquals(f1, f22) {
  if (f1 instanceof FieldFilter) {
    return fieldFilterEquals(f1, f22);
  } else if (f1 instanceof CompositeFilter) {
    return compositeFilterEquals(f1, f22);
  } else {
    fail(19439);
  }
}
__name(filterEquals, "filterEquals");
function fieldFilterEquals(f1, f22) {
  return f22 instanceof FieldFilter && f1.op === f22.op && f1.field.isEqual(f22.field) && valueEquals(f1.value, f22.value);
}
__name(fieldFilterEquals, "fieldFilterEquals");
function compositeFilterEquals(f1, f22) {
  if (f22 instanceof CompositeFilter && f1.op === f22.op && f1.filters.length === f22.filters.length) {
    const subFiltersMatch = f1.filters.reduce((result, f1Filter, index) => result && filterEquals(f1Filter, f22.filters[index]), true);
    return subFiltersMatch;
  }
  return false;
}
__name(compositeFilterEquals, "compositeFilterEquals");
var KeyFieldFilter = class extends FieldFilter {
  static {
    __name(this, "KeyFieldFilter");
  }
  constructor(field, op, value) {
    super(field, op, value);
    this.key = DocumentKey.fromName(value.referenceValue);
  }
  matches(doc2) {
    const comparison = DocumentKey.comparator(doc2.key, this.key);
    return this.matchesComparison(comparison);
  }
};
var KeyFieldInFilter = class extends FieldFilter {
  static {
    __name(this, "KeyFieldInFilter");
  }
  constructor(field, value) {
    super(field, "in", value);
    this.keys = extractDocumentKeysFromArrayValue("in", value);
  }
  matches(doc2) {
    return this.keys.some((key) => key.isEqual(doc2.key));
  }
};
var KeyFieldNotInFilter = class extends FieldFilter {
  static {
    __name(this, "KeyFieldNotInFilter");
  }
  constructor(field, value) {
    super(field, "not-in", value);
    this.keys = extractDocumentKeysFromArrayValue("not-in", value);
  }
  matches(doc2) {
    return !this.keys.some((key) => key.isEqual(doc2.key));
  }
};
function extractDocumentKeysFromArrayValue(op, value) {
  var _a;
  return (((_a = value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) || []).map((v8) => {
    return DocumentKey.fromName(v8.referenceValue);
  });
}
__name(extractDocumentKeysFromArrayValue, "extractDocumentKeysFromArrayValue");
var ArrayContainsFilter = class extends FieldFilter {
  static {
    __name(this, "ArrayContainsFilter");
  }
  constructor(field, value) {
    super(field, "array-contains", value);
  }
  matches(doc2) {
    const other = doc2.data.field(this.field);
    return isArray(other) && arrayValueContains(other.arrayValue, this.value);
  }
};
var InFilter = class extends FieldFilter {
  static {
    __name(this, "InFilter");
  }
  constructor(field, value) {
    super(field, "in", value);
  }
  matches(doc2) {
    const other = doc2.data.field(this.field);
    return other !== null && arrayValueContains(this.value.arrayValue, other);
  }
};
var NotInFilter = class extends FieldFilter {
  static {
    __name(this, "NotInFilter");
  }
  constructor(field, value) {
    super(field, "not-in", value);
  }
  matches(doc2) {
    if (arrayValueContains(this.value.arrayValue, { nullValue: "NULL_VALUE" })) {
      return false;
    }
    const other = doc2.data.field(this.field);
    return other !== null && other.nullValue === void 0 && !arrayValueContains(this.value.arrayValue, other);
  }
};
var ArrayContainsAnyFilter = class extends FieldFilter {
  static {
    __name(this, "ArrayContainsAnyFilter");
  }
  constructor(field, value) {
    super(field, "array-contains-any", value);
  }
  matches(doc2) {
    const other = doc2.data.field(this.field);
    if (!isArray(other) || !other.arrayValue.values) {
      return false;
    }
    return other.arrayValue.values.some((val) => arrayValueContains(this.value.arrayValue, val));
  }
};
var OrderBy = class {
  static {
    __name(this, "OrderBy");
  }
  constructor(field, dir = "asc") {
    this.field = field;
    this.dir = dir;
  }
};
function orderByEquals(left, right) {
  return left.dir === right.dir && left.field.isEqual(right.field);
}
__name(orderByEquals, "orderByEquals");
var SnapshotVersion = class _SnapshotVersion {
  static {
    __name(this, "SnapshotVersion");
  }
  static fromTimestamp(value) {
    return new _SnapshotVersion(value);
  }
  static min() {
    return new _SnapshotVersion(new Timestamp(0, 0));
  }
  static max() {
    return new _SnapshotVersion(new Timestamp(253402300799, 1e9 - 1));
  }
  constructor(timestamp) {
    this.timestamp = timestamp;
  }
  compareTo(other) {
    return this.timestamp._compareTo(other.timestamp);
  }
  isEqual(other) {
    return this.timestamp.isEqual(other.timestamp);
  }
  /** Returns a number representation of the version for use in spec tests. */
  toMicroseconds() {
    return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
var SortedMap = class _SortedMap {
  static {
    __name(this, "SortedMap");
  }
  constructor(comparator, root) {
    this.comparator = comparator;
    this.root = root ? root : LLRBNode.EMPTY;
  }
  // Returns a copy of the map, with the specified key/value added or replaced.
  insert(key, value) {
    return new _SortedMap(this.comparator, this.root.insert(key, value, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
  }
  // Returns a copy of the map, with the specified key removed.
  remove(key) {
    return new _SortedMap(this.comparator, this.root.remove(key, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
  }
  // Returns the value of the node with the given key, or null.
  get(key) {
    let node = this.root;
    while (!node.isEmpty()) {
      const cmp = this.comparator(key, node.key);
      if (cmp === 0) {
        return node.value;
      } else if (cmp < 0) {
        node = node.left;
      } else if (cmp > 0) {
        node = node.right;
      }
    }
    return null;
  }
  // Returns the index of the element in this sorted map, or -1 if it doesn't
  // exist.
  indexOf(key) {
    let prunedNodes = 0;
    let node = this.root;
    while (!node.isEmpty()) {
      const cmp = this.comparator(key, node.key);
      if (cmp === 0) {
        return prunedNodes + node.left.size;
      } else if (cmp < 0) {
        node = node.left;
      } else {
        prunedNodes += node.left.size + 1;
        node = node.right;
      }
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  // Returns the total number of nodes in the map.
  get size() {
    return this.root.size;
  }
  // Returns the minimum key in the map.
  minKey() {
    return this.root.minKey();
  }
  // Returns the maximum key in the map.
  maxKey() {
    return this.root.maxKey();
  }
  // Traverses the map in key order and calls the specified action function
  // for each key/value pair. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(action) {
    return this.root.inorderTraversal(action);
  }
  forEach(fn) {
    this.inorderTraversal((k5, v8) => {
      fn(k5, v8);
      return false;
    });
  }
  toString() {
    const descriptions = [];
    this.inorderTraversal((k5, v8) => {
      descriptions.push(`${k5}:${v8}`);
      return false;
    });
    return `{${descriptions.join(", ")}}`;
  }
  // Traverses the map in reverse key order and calls the specified action
  // function for each key/value pair. If action returns true, traversal is
  // aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(action) {
    return this.root.reverseTraversal(action);
  }
  // Returns an iterator over the SortedMap.
  getIterator() {
    return new SortedMapIterator(this.root, null, this.comparator, false);
  }
  getIteratorFrom(key) {
    return new SortedMapIterator(this.root, key, this.comparator, false);
  }
  getReverseIterator() {
    return new SortedMapIterator(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(key) {
    return new SortedMapIterator(this.root, key, this.comparator, true);
  }
};
var SortedMapIterator = class {
  static {
    __name(this, "SortedMapIterator");
  }
  constructor(node, startKey, comparator, isReverse) {
    this.isReverse = isReverse;
    this.nodeStack = [];
    let cmp = 1;
    while (!node.isEmpty()) {
      cmp = startKey ? comparator(node.key, startKey) : 1;
      if (startKey && isReverse) {
        cmp *= -1;
      }
      if (cmp < 0) {
        if (this.isReverse) {
          node = node.left;
        } else {
          node = node.right;
        }
      } else if (cmp === 0) {
        this.nodeStack.push(node);
        break;
      } else {
        this.nodeStack.push(node);
        if (this.isReverse) {
          node = node.right;
        } else {
          node = node.left;
        }
      }
    }
  }
  getNext() {
    let node = this.nodeStack.pop();
    const result = { key: node.key, value: node.value };
    if (this.isReverse) {
      node = node.left;
      while (!node.isEmpty()) {
        this.nodeStack.push(node);
        node = node.right;
      }
    } else {
      node = node.right;
      while (!node.isEmpty()) {
        this.nodeStack.push(node);
        node = node.left;
      }
    }
    return result;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0) {
      return null;
    }
    const node = this.nodeStack[this.nodeStack.length - 1];
    return { key: node.key, value: node.value };
  }
};
var LLRBNode = class _LLRBNode {
  static {
    __name(this, "LLRBNode");
  }
  constructor(key, value, color, left, right) {
    this.key = key;
    this.value = value;
    this.color = color != null ? color : _LLRBNode.RED;
    this.left = left != null ? left : _LLRBNode.EMPTY;
    this.right = right != null ? right : _LLRBNode.EMPTY;
    this.size = this.left.size + 1 + this.right.size;
  }
  // Returns a copy of the current node, optionally replacing pieces of it.
  copy(key, value, color, left, right) {
    return new _LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
  }
  isEmpty() {
    return false;
  }
  // Traverses the tree in key order and calls the specified action function
  // for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(action) {
    return this.left.inorderTraversal(action) || action(this.key, this.value) || this.right.inorderTraversal(action);
  }
  // Traverses the tree in reverse key order and calls the specified action
  // function for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(action) {
    return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
  }
  // Returns the minimum node in the tree.
  min() {
    if (this.left.isEmpty()) {
      return this;
    } else {
      return this.left.min();
    }
  }
  // Returns the maximum key in the tree.
  minKey() {
    return this.min().key;
  }
  // Returns the maximum key in the tree.
  maxKey() {
    if (this.right.isEmpty()) {
      return this.key;
    } else {
      return this.right.maxKey();
    }
  }
  // Returns new tree, with the key/value added.
  insert(key, value, comparator) {
    let n11 = this;
    const cmp = comparator(key, n11.key);
    if (cmp < 0) {
      n11 = n11.copy(null, null, null, n11.left.insert(key, value, comparator), null);
    } else if (cmp === 0) {
      n11 = n11.copy(null, value, null, null, null);
    } else {
      n11 = n11.copy(null, null, null, null, n11.right.insert(key, value, comparator));
    }
    return n11.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty()) {
      return _LLRBNode.EMPTY;
    }
    let n11 = this;
    if (!n11.left.isRed() && !n11.left.left.isRed()) {
      n11 = n11.moveRedLeft();
    }
    n11 = n11.copy(null, null, null, n11.left.removeMin(), null);
    return n11.fixUp();
  }
  // Returns new tree, with the specified item removed.
  remove(key, comparator) {
    let smallest;
    let n11 = this;
    if (comparator(key, n11.key) < 0) {
      if (!n11.left.isEmpty() && !n11.left.isRed() && !n11.left.left.isRed()) {
        n11 = n11.moveRedLeft();
      }
      n11 = n11.copy(null, null, null, n11.left.remove(key, comparator), null);
    } else {
      if (n11.left.isRed()) {
        n11 = n11.rotateRight();
      }
      if (!n11.right.isEmpty() && !n11.right.isRed() && !n11.right.left.isRed()) {
        n11 = n11.moveRedRight();
      }
      if (comparator(key, n11.key) === 0) {
        if (n11.right.isEmpty()) {
          return _LLRBNode.EMPTY;
        } else {
          smallest = n11.right.min();
          n11 = n11.copy(smallest.key, smallest.value, null, null, n11.right.removeMin());
        }
      }
      n11 = n11.copy(null, null, null, null, n11.right.remove(key, comparator));
    }
    return n11.fixUp();
  }
  isRed() {
    return this.color;
  }
  // Returns new tree after performing any needed rotations.
  fixUp() {
    let n11 = this;
    if (n11.right.isRed() && !n11.left.isRed()) {
      n11 = n11.rotateLeft();
    }
    if (n11.left.isRed() && n11.left.left.isRed()) {
      n11 = n11.rotateRight();
    }
    if (n11.left.isRed() && n11.right.isRed()) {
      n11 = n11.colorFlip();
    }
    return n11;
  }
  moveRedLeft() {
    let n11 = this.colorFlip();
    if (n11.right.left.isRed()) {
      n11 = n11.copy(null, null, null, null, n11.right.rotateRight());
      n11 = n11.rotateLeft();
      n11 = n11.colorFlip();
    }
    return n11;
  }
  moveRedRight() {
    let n11 = this.colorFlip();
    if (n11.left.left.isRed()) {
      n11 = n11.rotateRight();
      n11 = n11.colorFlip();
    }
    return n11;
  }
  rotateLeft() {
    const nl = this.copy(null, null, _LLRBNode.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, nl, null);
  }
  rotateRight() {
    const nr = this.copy(null, null, _LLRBNode.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, nr);
  }
  colorFlip() {
    const left = this.left.copy(null, null, !this.left.color, null, null);
    const right = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, left, right);
  }
  // For testing.
  checkMaxDepth() {
    const blackDepth = this.check();
    if (Math.pow(2, blackDepth) <= this.size + 1) {
      return true;
    } else {
      return false;
    }
  }
  // In a balanced RB tree, the black-depth (number of black nodes) from root to
  // leaves is equal on both sides.  This function verifies that or asserts.
  check() {
    if (this.isRed() && this.left.isRed()) {
      throw fail(43730, {
        key: this.key,
        value: this.value
      });
    }
    if (this.right.isRed()) {
      throw fail(14113, {
        key: this.key,
        value: this.value
      });
    }
    const blackDepth = this.left.check();
    if (blackDepth !== this.right.check()) {
      throw fail(27949);
    } else {
      return blackDepth + (this.isRed() ? 0 : 1);
    }
  }
};
LLRBNode.EMPTY = null;
LLRBNode.RED = true;
LLRBNode.BLACK = false;
var LLRBEmptyNode = class {
  static {
    __name(this, "LLRBEmptyNode");
  }
  constructor() {
    this.size = 0;
  }
  get key() {
    throw fail(57766);
  }
  get value() {
    throw fail(16141);
  }
  get color() {
    throw fail(16727);
  }
  get left() {
    throw fail(29726);
  }
  get right() {
    throw fail(36894);
  }
  // Returns a copy of the current node.
  copy(key, value, color, left, right) {
    return this;
  }
  // Returns a copy of the tree, with the specified key/value added.
  insert(key, value, comparator) {
    return new LLRBNode(key, value);
  }
  // Returns a copy of the tree, with the specified key removed.
  remove(key, comparator) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(action) {
    return false;
  }
  reverseTraversal(action) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  // For testing.
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
};
LLRBNode.EMPTY = new LLRBEmptyNode();
var SortedSet = class _SortedSet {
  static {
    __name(this, "SortedSet");
  }
  constructor(comparator) {
    this.comparator = comparator;
    this.data = new SortedMap(this.comparator);
  }
  has(elem) {
    return this.data.get(elem) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(elem) {
    return this.data.indexOf(elem);
  }
  /** Iterates elements in order defined by "comparator" */
  forEach(cb) {
    this.data.inorderTraversal((k5, v8) => {
      cb(k5);
      return false;
    });
  }
  /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */
  forEachInRange(range, cb) {
    const iter = this.data.getIteratorFrom(range[0]);
    while (iter.hasNext()) {
      const elem = iter.getNext();
      if (this.comparator(elem.key, range[1]) >= 0) {
        return;
      }
      cb(elem.key);
    }
  }
  /**
   * Iterates over `elem`s such that: start &lt;= elem until false is returned.
   */
  forEachWhile(cb, start) {
    let iter;
    if (start !== void 0) {
      iter = this.data.getIteratorFrom(start);
    } else {
      iter = this.data.getIterator();
    }
    while (iter.hasNext()) {
      const elem = iter.getNext();
      const result = cb(elem.key);
      if (!result) {
        return;
      }
    }
  }
  /** Finds the least element greater than or equal to `elem`. */
  firstAfterOrEqual(elem) {
    const iter = this.data.getIteratorFrom(elem);
    return iter.hasNext() ? iter.getNext().key : null;
  }
  getIterator() {
    return new SortedSetIterator(this.data.getIterator());
  }
  getIteratorFrom(key) {
    return new SortedSetIterator(this.data.getIteratorFrom(key));
  }
  /** Inserts or updates an element */
  add(elem) {
    return this.copy(this.data.remove(elem).insert(elem, true));
  }
  /** Deletes an element */
  delete(elem) {
    if (!this.has(elem)) {
      return this;
    }
    return this.copy(this.data.remove(elem));
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(other) {
    let result = this;
    if (result.size < other.size) {
      result = other;
      other = this;
    }
    other.forEach((elem) => {
      result = result.add(elem);
    });
    return result;
  }
  isEqual(other) {
    if (!(other instanceof _SortedSet)) {
      return false;
    }
    if (this.size !== other.size) {
      return false;
    }
    const thisIt = this.data.getIterator();
    const otherIt = other.data.getIterator();
    while (thisIt.hasNext()) {
      const thisElem = thisIt.getNext().key;
      const otherElem = otherIt.getNext().key;
      if (this.comparator(thisElem, otherElem) !== 0) {
        return false;
      }
    }
    return true;
  }
  toArray() {
    const res = [];
    this.forEach((targetId) => {
      res.push(targetId);
    });
    return res;
  }
  toString() {
    const result = [];
    this.forEach((elem) => result.push(elem));
    return "SortedSet(" + result.toString() + ")";
  }
  copy(data) {
    const result = new _SortedSet(this.comparator);
    result.data = data;
    return result;
  }
};
var SortedSetIterator = class {
  static {
    __name(this, "SortedSetIterator");
  }
  constructor(iter) {
    this.iter = iter;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
var FieldMask = class _FieldMask {
  static {
    __name(this, "FieldMask");
  }
  constructor(fields) {
    this.fields = fields;
    fields.sort(FieldPath$1.comparator);
  }
  static empty() {
    return new _FieldMask([]);
  }
  /**
   * Returns a new FieldMask object that is the result of adding all the given
   * fields paths to this field mask.
   */
  unionWith(extraFields) {
    let mergedMaskSet = new SortedSet(FieldPath$1.comparator);
    for (const fieldPath of this.fields) {
      mergedMaskSet = mergedMaskSet.add(fieldPath);
    }
    for (const fieldPath of extraFields) {
      mergedMaskSet = mergedMaskSet.add(fieldPath);
    }
    return new _FieldMask(mergedMaskSet.toArray());
  }
  /**
   * Verifies that `fieldPath` is included by at least one field in this field
   * mask.
   *
   * This is an O(n) operation, where `n` is the size of the field mask.
   */
  covers(fieldPath) {
    for (const fieldMaskPath of this.fields) {
      if (fieldMaskPath.isPrefixOf(fieldPath)) {
        return true;
      }
    }
    return false;
  }
  isEqual(other) {
    return arrayEquals(this.fields, other.fields, (l14, r9) => l14.isEqual(r9));
  }
};
var ObjectValue = class _ObjectValue {
  static {
    __name(this, "ObjectValue");
  }
  constructor(value) {
    this.value = value;
  }
  static empty() {
    return new _ObjectValue({ mapValue: {} });
  }
  /**
   * Returns the value at the given path or null.
   *
   * @param path - the path to search
   * @returns The value at the path or null if the path is not set.
   */
  field(path) {
    if (path.isEmpty()) {
      return this.value;
    } else {
      let currentLevel = this.value;
      for (let i18 = 0; i18 < path.length - 1; ++i18) {
        currentLevel = (currentLevel.mapValue.fields || {})[path.get(i18)];
        if (!isMapValue(currentLevel)) {
          return null;
        }
      }
      currentLevel = (currentLevel.mapValue.fields || {})[path.lastSegment()];
      return currentLevel || null;
    }
  }
  /**
   * Sets the field to the provided value.
   *
   * @param path - The field path to set.
   * @param value - The value to set.
   */
  set(path, value) {
    const fieldsMap = this.getFieldsMap(path.popLast());
    fieldsMap[path.lastSegment()] = deepClone(value);
  }
  /**
   * Sets the provided fields to the provided values.
   *
   * @param data - A map of fields to values (or null for deletes).
   */
  setAll(data) {
    let parent = FieldPath$1.emptyPath();
    let upserts = {};
    let deletes = [];
    data.forEach((value, path) => {
      if (!parent.isImmediateParentOf(path)) {
        const fieldsMap2 = this.getFieldsMap(parent);
        this.applyChanges(fieldsMap2, upserts, deletes);
        upserts = {};
        deletes = [];
        parent = path.popLast();
      }
      if (value) {
        upserts[path.lastSegment()] = deepClone(value);
      } else {
        deletes.push(path.lastSegment());
      }
    });
    const fieldsMap = this.getFieldsMap(parent);
    this.applyChanges(fieldsMap, upserts, deletes);
  }
  /**
   * Removes the field at the specified path. If there is no field at the
   * specified path, nothing is changed.
   *
   * @param path - The field path to remove.
   */
  delete(path) {
    const nestedValue = this.field(path.popLast());
    if (isMapValue(nestedValue) && nestedValue.mapValue.fields) {
      delete nestedValue.mapValue.fields[path.lastSegment()];
    }
  }
  isEqual(other) {
    return valueEquals(this.value, other.value);
  }
  /**
   * Returns the map that contains the leaf element of `path`. If the parent
   * entry does not yet exist, or if it is not a map, a new map will be created.
   */
  getFieldsMap(path) {
    let current = this.value;
    if (!current.mapValue.fields) {
      current.mapValue = { fields: {} };
    }
    for (let i18 = 0; i18 < path.length; ++i18) {
      let next = current.mapValue.fields[path.get(i18)];
      if (!isMapValue(next) || !next.mapValue.fields) {
        next = { mapValue: { fields: {} } };
        current.mapValue.fields[path.get(i18)] = next;
      }
      current = next;
    }
    return current.mapValue.fields;
  }
  /**
   * Modifies `fieldsMap` by adding, replacing or deleting the specified
   * entries.
   */
  applyChanges(fieldsMap, inserts, deletes) {
    forEach(inserts, (key, val) => fieldsMap[key] = val);
    for (const field of deletes) {
      delete fieldsMap[field];
    }
  }
  clone() {
    return new _ObjectValue(deepClone(this.value));
  }
};
var MutableDocument = class _MutableDocument {
  static {
    __name(this, "MutableDocument");
  }
  constructor(key, documentType, version6, readTime, createTime, data, documentState) {
    this.key = key;
    this.documentType = documentType;
    this.version = version6;
    this.readTime = readTime;
    this.createTime = createTime;
    this.data = data;
    this.documentState = documentState;
  }
  /**
   * Creates a document with no known version or data, but which can serve as
   * base document for mutations.
   */
  static newInvalidDocument(documentKey) {
    return new _MutableDocument(
      documentKey,
      0,
      /* version */
      SnapshotVersion.min(),
      /* readTime */
      SnapshotVersion.min(),
      /* createTime */
      SnapshotVersion.min(),
      ObjectValue.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist with the given data at the
   * given version.
   */
  static newFoundDocument(documentKey, version6, createTime, value) {
    return new _MutableDocument(
      documentKey,
      1,
      /* version */
      version6,
      /* readTime */
      SnapshotVersion.min(),
      /* createTime */
      createTime,
      value,
      0
      /* DocumentState.SYNCED */
    );
  }
  /** Creates a new document that is known to not exist at the given version. */
  static newNoDocument(documentKey, version6) {
    return new _MutableDocument(
      documentKey,
      2,
      /* version */
      version6,
      /* readTime */
      SnapshotVersion.min(),
      /* createTime */
      SnapshotVersion.min(),
      ObjectValue.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist at the given version but
   * whose data is not known (e.g. a document that was updated without a known
   * base document).
   */
  static newUnknownDocument(documentKey, version6) {
    return new _MutableDocument(
      documentKey,
      3,
      /* version */
      version6,
      /* readTime */
      SnapshotVersion.min(),
      /* createTime */
      SnapshotVersion.min(),
      ObjectValue.empty(),
      2
      /* DocumentState.HAS_COMMITTED_MUTATIONS */
    );
  }
  /**
   * Changes the document type to indicate that it exists and that its version
   * and data are known.
   */
  convertToFoundDocument(version6, value) {
    if (this.createTime.isEqual(SnapshotVersion.min()) && (this.documentType === 2 || this.documentType === 0)) {
      this.createTime = version6;
    }
    this.version = version6;
    this.documentType = 1;
    this.data = value;
    this.documentState = 0;
    return this;
  }
  /**
   * Changes the document type to indicate that it doesn't exist at the given
   * version.
   */
  convertToNoDocument(version6) {
    this.version = version6;
    this.documentType = 2;
    this.data = ObjectValue.empty();
    this.documentState = 0;
    return this;
  }
  /**
   * Changes the document type to indicate that it exists at a given version but
   * that its data is not known (e.g. a document that was updated without a known
   * base document).
   */
  convertToUnknownDocument(version6) {
    this.version = version6;
    this.documentType = 3;
    this.data = ObjectValue.empty();
    this.documentState = 2;
    return this;
  }
  setHasCommittedMutations() {
    this.documentState = 2;
    return this;
  }
  setHasLocalMutations() {
    this.documentState = 1;
    this.version = SnapshotVersion.min();
    return this;
  }
  setReadTime(readTime) {
    this.readTime = readTime;
    return this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(other) {
    return other instanceof _MutableDocument && this.key.isEqual(other.key) && this.version.isEqual(other.version) && this.documentType === other.documentType && this.documentState === other.documentState && this.data.isEqual(other.data);
  }
  mutableCopy() {
    return new _MutableDocument(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var TargetImpl = class {
  static {
    __name(this, "TargetImpl");
  }
  constructor(path, collectionGroup2 = null, orderBy2 = [], filters = [], limit2 = null, startAt2 = null, endAt2 = null) {
    this.path = path;
    this.collectionGroup = collectionGroup2;
    this.orderBy = orderBy2;
    this.filters = filters;
    this.limit = limit2;
    this.startAt = startAt2;
    this.endAt = endAt2;
    this.memoizedCanonicalId = null;
  }
};
function newTarget(path, collectionGroup2 = null, orderBy2 = [], filters = [], limit2 = null, startAt2 = null, endAt2 = null) {
  return new TargetImpl(path, collectionGroup2, orderBy2, filters, limit2, startAt2, endAt2);
}
__name(newTarget, "newTarget");
function targetEquals(left, right) {
  if (left.limit !== right.limit) {
    return false;
  }
  if (left.orderBy.length !== right.orderBy.length) {
    return false;
  }
  for (let i18 = 0; i18 < left.orderBy.length; i18++) {
    if (!orderByEquals(left.orderBy[i18], right.orderBy[i18])) {
      return false;
    }
  }
  if (left.filters.length !== right.filters.length) {
    return false;
  }
  for (let i18 = 0; i18 < left.filters.length; i18++) {
    if (!filterEquals(left.filters[i18], right.filters[i18])) {
      return false;
    }
  }
  if (left.collectionGroup !== right.collectionGroup) {
    return false;
  }
  if (!left.path.isEqual(right.path)) {
    return false;
  }
  if (!boundEquals(left.startAt, right.startAt)) {
    return false;
  }
  return boundEquals(left.endAt, right.endAt);
}
__name(targetEquals, "targetEquals");
var QueryImpl = class {
  static {
    __name(this, "QueryImpl");
  }
  /**
   * Initializes a Query with a path and optional additional query constraints.
   * Path must currently be empty if this is a collection group query.
   */
  constructor(path, collectionGroup2 = null, explicitOrderBy = [], filters = [], limit2 = null, limitType = "F", startAt2 = null, endAt2 = null) {
    this.path = path;
    this.collectionGroup = collectionGroup2;
    this.explicitOrderBy = explicitOrderBy;
    this.filters = filters;
    this.limit = limit2;
    this.limitType = limitType;
    this.startAt = startAt2;
    this.endAt = endAt2;
    this.memoizedNormalizedOrderBy = null;
    this.memoizedTarget = null;
    this.memoizedAggregateTarget = null;
    if (this.startAt) ;
    if (this.endAt) ;
  }
};
function newQueryForPath(path) {
  return new QueryImpl(path);
}
__name(newQueryForPath, "newQueryForPath");
function getInequalityFilterFields(query2) {
  let result = new SortedSet(FieldPath$1.comparator);
  query2.filters.forEach((filter) => {
    const subFilters = filter.getFlattenedFilters();
    subFilters.forEach((filter2) => {
      if (filter2.isInequality()) {
        result = result.add(filter2.field);
      }
    });
  });
  return result;
}
__name(getInequalityFilterFields, "getInequalityFilterFields");
function newQueryForCollectionGroup(collectionId) {
  return new QueryImpl(ResourcePath.emptyPath(), collectionId);
}
__name(newQueryForCollectionGroup, "newQueryForCollectionGroup");
function isCollectionGroupQuery(query2) {
  return query2.collectionGroup !== null;
}
__name(isCollectionGroupQuery, "isCollectionGroupQuery");
function queryNormalizedOrderBy(query2) {
  const queryImpl = debugCast(query2);
  if (queryImpl.memoizedNormalizedOrderBy === null) {
    queryImpl.memoizedNormalizedOrderBy = [];
    const fieldsNormalized = /* @__PURE__ */ new Set();
    for (const orderBy2 of queryImpl.explicitOrderBy) {
      queryImpl.memoizedNormalizedOrderBy.push(orderBy2);
      fieldsNormalized.add(orderBy2.field.canonicalString());
    }
    const lastDirection = queryImpl.explicitOrderBy.length > 0 ? queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length - 1].dir : "asc";
    const inequalityFields = getInequalityFilterFields(queryImpl);
    inequalityFields.forEach((field) => {
      if (!fieldsNormalized.has(field.canonicalString()) && !field.isKeyField()) {
        queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(field, lastDirection));
      }
    });
    if (!fieldsNormalized.has(FieldPath$1.keyField().canonicalString())) {
      queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), lastDirection));
    }
  }
  return queryImpl.memoizedNormalizedOrderBy;
}
__name(queryNormalizedOrderBy, "queryNormalizedOrderBy");
function queryToTarget(query2) {
  const queryImpl = debugCast(query2);
  if (!queryImpl.memoizedTarget) {
    queryImpl.memoizedTarget = _queryToTarget(queryImpl, queryNormalizedOrderBy(query2));
  }
  return queryImpl.memoizedTarget;
}
__name(queryToTarget, "queryToTarget");
function queryToAggregateTarget(query2) {
  const queryImpl = debugCast(query2);
  if (!queryImpl.memoizedAggregateTarget) {
    queryImpl.memoizedAggregateTarget = _queryToTarget(queryImpl, query2.explicitOrderBy);
  }
  return queryImpl.memoizedAggregateTarget;
}
__name(queryToAggregateTarget, "queryToAggregateTarget");
function _queryToTarget(queryImpl, orderBys) {
  if (queryImpl.limitType === "F") {
    return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, queryImpl.startAt, queryImpl.endAt);
  } else {
    orderBys = orderBys.map((orderBy2) => {
      const dir = orderBy2.dir === "desc" ? "asc" : "desc";
      return new OrderBy(orderBy2.field, dir);
    });
    const startAt2 = queryImpl.endAt ? new Bound(queryImpl.endAt.position, queryImpl.endAt.inclusive) : null;
    const endAt2 = queryImpl.startAt ? new Bound(queryImpl.startAt.position, queryImpl.startAt.inclusive) : null;
    return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, startAt2, endAt2);
  }
}
__name(_queryToTarget, "_queryToTarget");
function queryWithAddedFilter(query2, filter) {
  const newFilters = query2.filters.concat([filter]);
  return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), newFilters, query2.limit, query2.limitType, query2.startAt, query2.endAt);
}
__name(queryWithAddedFilter, "queryWithAddedFilter");
function queryWithAddedOrderBy(query2, orderBy2) {
  const newOrderBy = query2.explicitOrderBy.concat([orderBy2]);
  return new QueryImpl(query2.path, query2.collectionGroup, newOrderBy, query2.filters.slice(), query2.limit, query2.limitType, query2.startAt, query2.endAt);
}
__name(queryWithAddedOrderBy, "queryWithAddedOrderBy");
function queryWithLimit(query2, limit2, limitType) {
  return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), query2.filters.slice(), limit2, limitType, query2.startAt, query2.endAt);
}
__name(queryWithLimit, "queryWithLimit");
function queryWithStartAt(query2, bound) {
  return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), query2.filters.slice(), query2.limit, query2.limitType, bound, query2.endAt);
}
__name(queryWithStartAt, "queryWithStartAt");
function queryWithEndAt(query2, bound) {
  return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), query2.filters.slice(), query2.limit, query2.limitType, query2.startAt, bound);
}
__name(queryWithEndAt, "queryWithEndAt");
function queryEquals(left, right) {
  return targetEquals(queryToTarget(left), queryToTarget(right)) && left.limitType === right.limitType;
}
__name(queryEquals, "queryEquals");
function toDouble(serializer, value) {
  if (serializer.useProto3Json) {
    if (isNaN(value)) {
      return { doubleValue: "NaN" };
    } else if (value === Infinity) {
      return { doubleValue: "Infinity" };
    } else if (value === -Infinity) {
      return { doubleValue: "-Infinity" };
    }
  }
  return { doubleValue: isNegativeZero(value) ? "-0" : value };
}
__name(toDouble, "toDouble");
function toInteger(value) {
  return { integerValue: "" + value };
}
__name(toInteger, "toInteger");
function toNumber(serializer, value) {
  return isSafeInteger(value) ? toInteger(value) : toDouble(serializer, value);
}
__name(toNumber, "toNumber");
var TransformOperation = class {
  static {
    __name(this, "TransformOperation");
  }
  constructor() {
    this._ = void 0;
  }
};
var ServerTimestampTransform = class extends TransformOperation {
  static {
    __name(this, "ServerTimestampTransform");
  }
};
var ArrayUnionTransformOperation = class extends TransformOperation {
  static {
    __name(this, "ArrayUnionTransformOperation");
  }
  constructor(elements) {
    super();
    this.elements = elements;
  }
};
var ArrayRemoveTransformOperation = class extends TransformOperation {
  static {
    __name(this, "ArrayRemoveTransformOperation");
  }
  constructor(elements) {
    super();
    this.elements = elements;
  }
};
var NumericIncrementTransformOperation = class extends TransformOperation {
  static {
    __name(this, "NumericIncrementTransformOperation");
  }
  constructor(serializer, operand) {
    super();
    this.serializer = serializer;
    this.operand = operand;
  }
};
var FieldTransform = class {
  static {
    __name(this, "FieldTransform");
  }
  constructor(field, transform) {
    this.field = field;
    this.transform = transform;
  }
};
var Precondition = class _Precondition {
  static {
    __name(this, "Precondition");
  }
  constructor(updateTime, exists) {
    this.updateTime = updateTime;
    this.exists = exists;
  }
  /** Creates a new empty Precondition. */
  static none() {
    return new _Precondition();
  }
  /** Creates a new Precondition with an exists flag. */
  static exists(exists) {
    return new _Precondition(void 0, exists);
  }
  /** Creates a new Precondition based on a version a document exists at. */
  static updateTime(version6) {
    return new _Precondition(version6);
  }
  /** Returns whether this Precondition is empty. */
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(other) {
    return this.exists === other.exists && (this.updateTime ? !!other.updateTime && this.updateTime.isEqual(other.updateTime) : !other.updateTime);
  }
};
var Mutation = class {
  static {
    __name(this, "Mutation");
  }
};
var SetMutation = class extends Mutation {
  static {
    __name(this, "SetMutation");
  }
  constructor(key, value, precondition, fieldTransforms = []) {
    super();
    this.key = key;
    this.value = value;
    this.precondition = precondition;
    this.fieldTransforms = fieldTransforms;
    this.type = 0;
  }
  getFieldMask() {
    return null;
  }
};
var PatchMutation = class extends Mutation {
  static {
    __name(this, "PatchMutation");
  }
  constructor(key, data, fieldMask, precondition, fieldTransforms = []) {
    super();
    this.key = key;
    this.data = data;
    this.fieldMask = fieldMask;
    this.precondition = precondition;
    this.fieldTransforms = fieldTransforms;
    this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
};
var DeleteMutation = class extends Mutation {
  static {
    __name(this, "DeleteMutation");
  }
  constructor(key, precondition) {
    super();
    this.key = key;
    this.precondition = precondition;
    this.type = 2;
    this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
};
var VerifyMutation = class extends Mutation {
  static {
    __name(this, "VerifyMutation");
  }
  constructor(key, precondition) {
    super();
    this.key = key;
    this.precondition = precondition;
    this.type = 3;
    this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
};
var DIRECTIONS = (() => {
  const dirs = {};
  dirs[
    "asc"
    /* Direction.ASCENDING */
  ] = "ASCENDING";
  dirs[
    "desc"
    /* Direction.DESCENDING */
  ] = "DESCENDING";
  return dirs;
})();
var OPERATORS = (() => {
  const ops = {};
  ops[
    "<"
    /* Operator.LESS_THAN */
  ] = "LESS_THAN";
  ops[
    "<="
    /* Operator.LESS_THAN_OR_EQUAL */
  ] = "LESS_THAN_OR_EQUAL";
  ops[
    ">"
    /* Operator.GREATER_THAN */
  ] = "GREATER_THAN";
  ops[
    ">="
    /* Operator.GREATER_THAN_OR_EQUAL */
  ] = "GREATER_THAN_OR_EQUAL";
  ops[
    "=="
    /* Operator.EQUAL */
  ] = "EQUAL";
  ops[
    "!="
    /* Operator.NOT_EQUAL */
  ] = "NOT_EQUAL";
  ops[
    "array-contains"
    /* Operator.ARRAY_CONTAINS */
  ] = "ARRAY_CONTAINS";
  ops[
    "in"
    /* Operator.IN */
  ] = "IN";
  ops[
    "not-in"
    /* Operator.NOT_IN */
  ] = "NOT_IN";
  ops[
    "array-contains-any"
    /* Operator.ARRAY_CONTAINS_ANY */
  ] = "ARRAY_CONTAINS_ANY";
  return ops;
})();
var COMPOSITE_OPERATORS = (() => {
  const ops = {};
  ops[
    "and"
    /* CompositeOperator.AND */
  ] = "AND";
  ops[
    "or"
    /* CompositeOperator.OR */
  ] = "OR";
  return ops;
})();
function assertPresent(value, description) {
}
__name(assertPresent, "assertPresent");
var JsonProtoSerializer = class {
  static {
    __name(this, "JsonProtoSerializer");
  }
  constructor(databaseId, useProto3Json) {
    this.databaseId = databaseId;
    this.useProto3Json = useProto3Json;
  }
};
function toInt32Proto(serializer, val) {
  if (serializer.useProto3Json || isNullOrUndefined(val)) {
    return val;
  } else {
    return { value: val };
  }
}
__name(toInt32Proto, "toInt32Proto");
function toTimestamp(serializer, timestamp) {
  if (serializer.useProto3Json) {
    const jsDateStr = new Date(timestamp.seconds * 1e3).toISOString();
    const strUntilSeconds = jsDateStr.replace(/\.\d*/, "").replace("Z", "");
    const nanoStr = ("000000000" + timestamp.nanoseconds).slice(-9);
    return `${strUntilSeconds}.${nanoStr}Z`;
  } else {
    return {
      seconds: "" + timestamp.seconds,
      nanos: timestamp.nanoseconds
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    };
  }
}
__name(toTimestamp, "toTimestamp");
function fromTimestamp(date) {
  const timestamp = normalizeTimestamp(date);
  return new Timestamp(timestamp.seconds, timestamp.nanos);
}
__name(fromTimestamp, "fromTimestamp");
function toBytes(serializer, bytes) {
  if (serializer.useProto3Json) {
    return bytes.toBase64();
  } else {
    return bytes.toUint8Array();
  }
}
__name(toBytes, "toBytes");
function toVersion(serializer, version6) {
  return toTimestamp(serializer, version6.toTimestamp());
}
__name(toVersion, "toVersion");
function fromVersion(version6) {
  hardAssert(!!version6, 49232);
  return SnapshotVersion.fromTimestamp(fromTimestamp(version6));
}
__name(fromVersion, "fromVersion");
function toResourceName(databaseId, path) {
  return toResourcePath(databaseId, path).canonicalString();
}
__name(toResourceName, "toResourceName");
function toResourcePath(databaseId, path) {
  const resourcePath = fullyQualifiedPrefixPath(databaseId).child("documents");
  return path === void 0 ? resourcePath : resourcePath.child(path);
}
__name(toResourcePath, "toResourcePath");
function fromResourceName(name4) {
  const resource = ResourcePath.fromString(name4);
  hardAssert(isValidResourceName(resource), 10190, { key: resource.toString() });
  return resource;
}
__name(fromResourceName, "fromResourceName");
function toName(serializer, key) {
  return toResourceName(serializer.databaseId, key.path);
}
__name(toName, "toName");
function fromName(serializer, name4) {
  const resource = fromResourceName(name4);
  if (resource.get(1) !== serializer.databaseId.projectId) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + resource.get(1) + " vs " + serializer.databaseId.projectId);
  }
  if (resource.get(3) !== serializer.databaseId.database) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + resource.get(3) + " vs " + serializer.databaseId.database);
  }
  return new DocumentKey(extractLocalPathFromResourceName(resource));
}
__name(fromName, "fromName");
function toQueryPath(serializer, path) {
  return toResourceName(serializer.databaseId, path);
}
__name(toQueryPath, "toQueryPath");
function fullyQualifiedPrefixPath(databaseId) {
  return new ResourcePath([
    "projects",
    databaseId.projectId,
    "databases",
    databaseId.database
  ]);
}
__name(fullyQualifiedPrefixPath, "fullyQualifiedPrefixPath");
function extractLocalPathFromResourceName(resourceName) {
  hardAssert(resourceName.length > 4 && resourceName.get(4) === "documents", 29091, { key: resourceName.toString() });
  return resourceName.popFirst(5);
}
__name(extractLocalPathFromResourceName, "extractLocalPathFromResourceName");
function toMutationDocument(serializer, key, fields) {
  return {
    name: toName(serializer, key),
    fields: fields.value.mapValue.fields
  };
}
__name(toMutationDocument, "toMutationDocument");
function fromDocument(serializer, document2, hasCommittedMutations) {
  const key = fromName(serializer, document2.name);
  const version6 = fromVersion(document2.updateTime);
  const createTime = document2.createTime ? fromVersion(document2.createTime) : SnapshotVersion.min();
  const data = new ObjectValue({ mapValue: { fields: document2.fields } });
  const result = MutableDocument.newFoundDocument(key, version6, createTime, data);
  if (hasCommittedMutations) {
    result.setHasCommittedMutations();
  }
  return hasCommittedMutations ? result.setHasCommittedMutations() : result;
}
__name(fromDocument, "fromDocument");
function fromFound(serializer, doc2) {
  hardAssert(!!doc2.found, 43571);
  assertPresent(doc2.found.name);
  assertPresent(doc2.found.updateTime);
  const key = fromName(serializer, doc2.found.name);
  const version6 = fromVersion(doc2.found.updateTime);
  const createTime = doc2.found.createTime ? fromVersion(doc2.found.createTime) : SnapshotVersion.min();
  const data = new ObjectValue({ mapValue: { fields: doc2.found.fields } });
  return MutableDocument.newFoundDocument(key, version6, createTime, data);
}
__name(fromFound, "fromFound");
function fromMissing(serializer, result) {
  hardAssert(!!result.missing, 3894);
  hardAssert(!!result.readTime, 22933);
  const key = fromName(serializer, result.missing);
  const version6 = fromVersion(result.readTime);
  return MutableDocument.newNoDocument(key, version6);
}
__name(fromMissing, "fromMissing");
function fromBatchGetDocumentsResponse(serializer, result) {
  if ("found" in result) {
    return fromFound(serializer, result);
  } else if ("missing" in result) {
    return fromMissing(serializer, result);
  }
  return fail(7234, { result });
}
__name(fromBatchGetDocumentsResponse, "fromBatchGetDocumentsResponse");
function toMutation(serializer, mutation) {
  let result;
  if (mutation instanceof SetMutation) {
    result = {
      update: toMutationDocument(serializer, mutation.key, mutation.value)
    };
  } else if (mutation instanceof DeleteMutation) {
    result = { delete: toName(serializer, mutation.key) };
  } else if (mutation instanceof PatchMutation) {
    result = {
      update: toMutationDocument(serializer, mutation.key, mutation.data),
      updateMask: toDocumentMask(mutation.fieldMask)
    };
  } else if (mutation instanceof VerifyMutation) {
    result = {
      verify: toName(serializer, mutation.key)
    };
  } else {
    return fail(16599, {
      mutationType: mutation.type
    });
  }
  if (mutation.fieldTransforms.length > 0) {
    result.updateTransforms = mutation.fieldTransforms.map((transform) => toFieldTransform(serializer, transform));
  }
  if (!mutation.precondition.isNone) {
    result.currentDocument = toPrecondition(serializer, mutation.precondition);
  }
  return result;
}
__name(toMutation, "toMutation");
function toPrecondition(serializer, precondition) {
  if (precondition.updateTime !== void 0) {
    return {
      updateTime: toVersion(serializer, precondition.updateTime)
    };
  } else if (precondition.exists !== void 0) {
    return { exists: precondition.exists };
  } else {
    return fail(27497);
  }
}
__name(toPrecondition, "toPrecondition");
function toFieldTransform(serializer, fieldTransform) {
  const transform = fieldTransform.transform;
  if (transform instanceof ServerTimestampTransform) {
    return {
      fieldPath: fieldTransform.field.canonicalString(),
      setToServerValue: "REQUEST_TIME"
    };
  } else if (transform instanceof ArrayUnionTransformOperation) {
    return {
      fieldPath: fieldTransform.field.canonicalString(),
      appendMissingElements: {
        values: transform.elements
      }
    };
  } else if (transform instanceof ArrayRemoveTransformOperation) {
    return {
      fieldPath: fieldTransform.field.canonicalString(),
      removeAllFromArray: {
        values: transform.elements
      }
    };
  } else if (transform instanceof NumericIncrementTransformOperation) {
    return {
      fieldPath: fieldTransform.field.canonicalString(),
      increment: transform.operand
    };
  } else {
    throw fail(20930, {
      transform: fieldTransform.transform
    });
  }
}
__name(toFieldTransform, "toFieldTransform");
function toQueryTarget(serializer, target) {
  const queryTarget = { structuredQuery: {} };
  const path = target.path;
  let parent;
  if (target.collectionGroup !== null) {
    parent = path;
    queryTarget.structuredQuery.from = [
      {
        collectionId: target.collectionGroup,
        allDescendants: true
      }
    ];
  } else {
    parent = path.popLast();
    queryTarget.structuredQuery.from = [{ collectionId: path.lastSegment() }];
  }
  queryTarget.parent = toQueryPath(serializer, parent);
  const where2 = toFilters(target.filters);
  if (where2) {
    queryTarget.structuredQuery.where = where2;
  }
  const orderBy2 = toOrder(target.orderBy);
  if (orderBy2) {
    queryTarget.structuredQuery.orderBy = orderBy2;
  }
  const limit2 = toInt32Proto(serializer, target.limit);
  if (limit2 !== null) {
    queryTarget.structuredQuery.limit = limit2;
  }
  if (target.startAt) {
    queryTarget.structuredQuery.startAt = toStartAtCursor(target.startAt);
  }
  if (target.endAt) {
    queryTarget.structuredQuery.endAt = toEndAtCursor(target.endAt);
  }
  return { queryTarget, parent };
}
__name(toQueryTarget, "toQueryTarget");
function toRunAggregationQueryRequest(serializer, target, aggregates, skipAliasing) {
  const { queryTarget, parent } = toQueryTarget(serializer, target);
  const aliasMap = {};
  const aggregations = [];
  let aggregationNum = 0;
  aggregates.forEach((aggregate) => {
    const serverAlias = skipAliasing ? aggregate.alias : `aggregate_${aggregationNum++}`;
    aliasMap[serverAlias] = aggregate.alias;
    if (aggregate.aggregateType === "count") {
      aggregations.push({
        alias: serverAlias,
        count: {}
      });
    } else if (aggregate.aggregateType === "avg") {
      aggregations.push({
        alias: serverAlias,
        avg: {
          field: toFieldPathReference(aggregate.fieldPath)
        }
      });
    } else if (aggregate.aggregateType === "sum") {
      aggregations.push({
        alias: serverAlias,
        sum: {
          field: toFieldPathReference(aggregate.fieldPath)
        }
      });
    }
  });
  return {
    request: {
      structuredAggregationQuery: {
        aggregations,
        structuredQuery: queryTarget.structuredQuery
      },
      parent: queryTarget.parent
    },
    aliasMap,
    parent
  };
}
__name(toRunAggregationQueryRequest, "toRunAggregationQueryRequest");
function toFilters(filters) {
  if (filters.length === 0) {
    return;
  }
  return toFilter(CompositeFilter.create(
    filters,
    "and"
    /* CompositeOperator.AND */
  ));
}
__name(toFilters, "toFilters");
function toOrder(orderBys) {
  if (orderBys.length === 0) {
    return;
  }
  return orderBys.map((order) => toPropertyOrder(order));
}
__name(toOrder, "toOrder");
function toStartAtCursor(cursor) {
  return {
    before: cursor.inclusive,
    values: cursor.position
  };
}
__name(toStartAtCursor, "toStartAtCursor");
function toEndAtCursor(cursor) {
  return {
    before: !cursor.inclusive,
    values: cursor.position
  };
}
__name(toEndAtCursor, "toEndAtCursor");
function toDirection(dir) {
  return DIRECTIONS[dir];
}
__name(toDirection, "toDirection");
function toOperatorName(op) {
  return OPERATORS[op];
}
__name(toOperatorName, "toOperatorName");
function toCompositeOperatorName(op) {
  return COMPOSITE_OPERATORS[op];
}
__name(toCompositeOperatorName, "toCompositeOperatorName");
function toFieldPathReference(path) {
  return { fieldPath: path.canonicalString() };
}
__name(toFieldPathReference, "toFieldPathReference");
function toPropertyOrder(orderBy2) {
  return {
    field: toFieldPathReference(orderBy2.field),
    direction: toDirection(orderBy2.dir)
  };
}
__name(toPropertyOrder, "toPropertyOrder");
function toFilter(filter) {
  if (filter instanceof FieldFilter) {
    return toUnaryOrFieldFilter(filter);
  } else if (filter instanceof CompositeFilter) {
    return toCompositeFilter(filter);
  } else {
    return fail(54877, { filter });
  }
}
__name(toFilter, "toFilter");
function toCompositeFilter(filter) {
  const protos = filter.getFilters().map((filter2) => toFilter(filter2));
  if (protos.length === 1) {
    return protos[0];
  }
  return {
    compositeFilter: {
      op: toCompositeOperatorName(filter.op),
      filters: protos
    }
  };
}
__name(toCompositeFilter, "toCompositeFilter");
function toUnaryOrFieldFilter(filter) {
  if (filter.op === "==") {
    if (isNanValue(filter.value)) {
      return {
        unaryFilter: {
          field: toFieldPathReference(filter.field),
          op: "IS_NAN"
        }
      };
    } else if (isNullValue(filter.value)) {
      return {
        unaryFilter: {
          field: toFieldPathReference(filter.field),
          op: "IS_NULL"
        }
      };
    }
  } else if (filter.op === "!=") {
    if (isNanValue(filter.value)) {
      return {
        unaryFilter: {
          field: toFieldPathReference(filter.field),
          op: "IS_NOT_NAN"
        }
      };
    } else if (isNullValue(filter.value)) {
      return {
        unaryFilter: {
          field: toFieldPathReference(filter.field),
          op: "IS_NOT_NULL"
        }
      };
    }
  }
  return {
    fieldFilter: {
      field: toFieldPathReference(filter.field),
      op: toOperatorName(filter.op),
      value: filter.value
    }
  };
}
__name(toUnaryOrFieldFilter, "toUnaryOrFieldFilter");
function toDocumentMask(fieldMask) {
  const canonicalFields = [];
  fieldMask.fields.forEach((field) => canonicalFields.push(field.canonicalString()));
  return {
    fieldPaths: canonicalFields
  };
}
__name(toDocumentMask, "toDocumentMask");
function isValidResourceName(path) {
  return path.length >= 4 && path.get(0) === "projects" && path.get(2) === "databases";
}
__name(isValidResourceName, "isValidResourceName");
function newSerializer(databaseId) {
  return new JsonProtoSerializer(
    databaseId,
    /* useProto3Json= */
    true
  );
}
__name(newSerializer, "newSerializer");
var LOG_TAG$2 = "ExponentialBackoff";
var DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1e3;
var DEFAULT_BACKOFF_FACTOR2 = 1.5;
var DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1e3;
var ExponentialBackoff = class {
  static {
    __name(this, "ExponentialBackoff");
  }
  constructor(queue, timerId, initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS, backoffFactor = DEFAULT_BACKOFF_FACTOR2, maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS) {
    this.queue = queue;
    this.timerId = timerId;
    this.initialDelayMs = initialDelayMs;
    this.backoffFactor = backoffFactor;
    this.maxDelayMs = maxDelayMs;
    this.currentBaseMs = 0;
    this.timerPromise = null;
    this.lastAttemptTime = Date.now();
    this.reset();
  }
  /**
   * Resets the backoff delay.
   *
   * The very next backoffAndWait() will have no delay. If it is called again
   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
   * subsequent ones will increase according to the backoffFactor.
   */
  reset() {
    this.currentBaseMs = 0;
  }
  /**
   * Resets the backoff delay to the maximum delay (e.g. for use after a
   * RESOURCE_EXHAUSTED error).
   */
  resetToMax() {
    this.currentBaseMs = this.maxDelayMs;
  }
  /**
   * Returns a promise that resolves after currentDelayMs, and increases the
   * delay for any subsequent attempts. If there was a pending backoff operation
   * already, it will be canceled.
   */
  backoffAndRun(op) {
    this.cancel();
    const desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());
    const delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);
    const remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);
    if (remainingDelayMs > 0) {
      logDebug(LOG_TAG$2, `Backing off for ${remainingDelayMs} ms (base delay: ${this.currentBaseMs} ms, delay with jitter: ${desiredDelayWithJitterMs} ms, last attempt: ${delaySoFarMs} ms ago)`);
    }
    this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, () => {
      this.lastAttemptTime = Date.now();
      return op();
    });
    this.currentBaseMs *= this.backoffFactor;
    if (this.currentBaseMs < this.initialDelayMs) {
      this.currentBaseMs = this.initialDelayMs;
    }
    if (this.currentBaseMs > this.maxDelayMs) {
      this.currentBaseMs = this.maxDelayMs;
    }
  }
  skipBackoff() {
    if (this.timerPromise !== null) {
      this.timerPromise.skipDelay();
      this.timerPromise = null;
    }
  }
  cancel() {
    if (this.timerPromise !== null) {
      this.timerPromise.cancel();
      this.timerPromise = null;
    }
  }
  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */
  jitterDelayMs() {
    return (Math.random() - 0.5) * this.currentBaseMs;
  }
};
var Datastore = class {
  static {
    __name(this, "Datastore");
  }
};
var DatastoreImpl = class extends Datastore {
  static {
    __name(this, "DatastoreImpl");
  }
  constructor(authCredentials, appCheckCredentials, connection, serializer) {
    super();
    this.authCredentials = authCredentials;
    this.appCheckCredentials = appCheckCredentials;
    this.connection = connection;
    this.serializer = serializer;
    this.terminated = false;
  }
  verifyInitialized() {
    if (this.terminated) {
      throw new FirestoreError(Code.FAILED_PRECONDITION, "The client has already been terminated.");
    }
  }
  /** Invokes the provided RPC with auth and AppCheck tokens. */
  invokeRPC(rpcName, databaseId, resourcePath, request) {
    this.verifyInitialized();
    return Promise.all([
      this.authCredentials.getToken(),
      this.appCheckCredentials.getToken()
    ]).then(([authToken, appCheckToken]) => {
      return this.connection.invokeRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken);
    }).catch((error) => {
      if (error.name === "FirebaseError") {
        if (error.code === Code.UNAUTHENTICATED) {
          this.authCredentials.invalidateToken();
          this.appCheckCredentials.invalidateToken();
        }
        throw error;
      } else {
        throw new FirestoreError(Code.UNKNOWN, error.toString());
      }
    });
  }
  /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */
  invokeStreamingRPC(rpcName, databaseId, resourcePath, request, expectedResponseCount) {
    this.verifyInitialized();
    return Promise.all([
      this.authCredentials.getToken(),
      this.appCheckCredentials.getToken()
    ]).then(([authToken, appCheckToken]) => {
      return this.connection.invokeStreamingRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken, expectedResponseCount);
    }).catch((error) => {
      if (error.name === "FirebaseError") {
        if (error.code === Code.UNAUTHENTICATED) {
          this.authCredentials.invalidateToken();
          this.appCheckCredentials.invalidateToken();
        }
        throw error;
      } else {
        throw new FirestoreError(Code.UNKNOWN, error.toString());
      }
    });
  }
  terminate() {
    this.terminated = true;
    this.connection.terminate();
  }
};
function newDatastore(authCredentials, appCheckCredentials, connection, serializer) {
  return new DatastoreImpl(authCredentials, appCheckCredentials, connection, serializer);
}
__name(newDatastore, "newDatastore");
async function invokeCommitRpc(datastore, mutations) {
  const datastoreImpl = debugCast(datastore);
  const request = {
    writes: mutations.map((m18) => toMutation(datastoreImpl.serializer, m18))
  };
  await datastoreImpl.invokeRPC("Commit", datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request);
}
__name(invokeCommitRpc, "invokeCommitRpc");
async function invokeBatchGetDocumentsRpc(datastore, keys) {
  const datastoreImpl = debugCast(datastore);
  const request = {
    documents: keys.map((k5) => toName(datastoreImpl.serializer, k5))
  };
  const response = await datastoreImpl.invokeStreamingRPC("BatchGetDocuments", datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request, keys.length);
  const docs = /* @__PURE__ */ new Map();
  response.forEach((proto) => {
    const doc2 = fromBatchGetDocumentsResponse(datastoreImpl.serializer, proto);
    docs.set(doc2.key.toString(), doc2);
  });
  const result = [];
  keys.forEach((key) => {
    const doc2 = docs.get(key.toString());
    hardAssert(!!doc2, 55234, {
      key
    });
    result.push(doc2);
  });
  return result;
}
__name(invokeBatchGetDocumentsRpc, "invokeBatchGetDocumentsRpc");
async function invokeRunQueryRpc(datastore, query2) {
  const datastoreImpl = debugCast(datastore);
  const { queryTarget, parent } = toQueryTarget(datastoreImpl.serializer, queryToTarget(query2));
  const response = await datastoreImpl.invokeStreamingRPC("RunQuery", datastoreImpl.serializer.databaseId, parent, {
    structuredQuery: queryTarget.structuredQuery
  });
  return response.filter((proto) => !!proto.document).map((proto) => fromDocument(datastoreImpl.serializer, proto.document, void 0));
}
__name(invokeRunQueryRpc, "invokeRunQueryRpc");
async function invokeRunAggregationQueryRpc(datastore, query2, aggregates) {
  var _a;
  const datastoreImpl = debugCast(datastore);
  const { request, aliasMap, parent } = toRunAggregationQueryRequest(datastoreImpl.serializer, queryToAggregateTarget(query2), aggregates);
  if (!datastoreImpl.connection.shouldResourcePathBeIncludedInRequest) {
    delete request.parent;
  }
  const response = await datastoreImpl.invokeStreamingRPC(
    "RunAggregationQuery",
    datastoreImpl.serializer.databaseId,
    parent,
    request,
    /*expectedResponseCount=*/
    1
  );
  const filteredResult = response.filter((proto) => !!proto.result);
  hardAssert(filteredResult.length === 1, 64727);
  const unmappedAggregateFields = (_a = filteredResult[0].result) === null || _a === void 0 ? void 0 : _a.aggregateFields;
  const remappedFields = Object.keys(unmappedAggregateFields).reduce((accumulator, key) => {
    accumulator[aliasMap[key]] = unmappedAggregateFields[key];
    return accumulator;
  }, {});
  return remappedFields;
}
__name(invokeRunAggregationQueryRpc, "invokeRunAggregationQueryRpc");
var LOG_TAG$1 = "ComponentProvider";
var datastoreInstances = /* @__PURE__ */ new Map();
function getDatastore(firestore) {
  if (firestore._terminated) {
    throw new FirestoreError(Code.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  if (!datastoreInstances.has(firestore)) {
    logDebug(LOG_TAG$1, "Initializing Datastore");
    const databaseInfo = makeDatabaseInfo(firestore._databaseId, firestore.app.options.appId || "", firestore._persistenceKey, firestore._freezeSettings());
    const connection = newConnection(databaseInfo);
    const serializer = newSerializer(firestore._databaseId);
    const datastore = newDatastore(firestore._authCredentials, firestore._appCheckCredentials, connection, serializer);
    datastoreInstances.set(firestore, datastore);
  }
  return datastoreInstances.get(firestore);
}
__name(getDatastore, "getDatastore");
function removeComponents(firestore) {
  const datastore = datastoreInstances.get(firestore);
  if (datastore) {
    logDebug(LOG_TAG$1, "Removing Datastore");
    datastoreInstances.delete(firestore);
    datastore.terminate();
  }
}
__name(removeComponents, "removeComponents");
function makeDatabaseInfo(databaseId, appId, persistenceKey, settings) {
  return new DatabaseInfo(databaseId, appId, persistenceKey, settings.host, settings.ssl, settings.experimentalForceLongPolling, settings.experimentalAutoDetectLongPolling, cloneLongPollingOptions(settings.experimentalLongPollingOptions), settings.useFetchStreams, settings.isUsingEmulator);
}
__name(makeDatabaseInfo, "makeDatabaseInfo");
var LRU_COLLECTION_DISABLED = -1;
var LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;
function isIndexedDbTransactionError(e10) {
  return e10.name === "IndexedDbTransactionError";
}
__name(isIndexedDbTransactionError, "isIndexedDbTransactionError");
var LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;
var DEFAULT_HOST = "firestore.googleapis.com";
var DEFAULT_SSL = true;
var MIN_LONG_POLLING_TIMEOUT_SECONDS = 5;
var MAX_LONG_POLLING_TIMEOUT_SECONDS = 30;
var DEFAULT_AUTO_DETECT_LONG_POLLING = true;
var FirestoreSettingsImpl = class {
  static {
    __name(this, "FirestoreSettingsImpl");
  }
  constructor(settings) {
    var _a, _b;
    if (settings.host === void 0) {
      if (settings.ssl !== void 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      }
      this.host = DEFAULT_HOST;
      this.ssl = DEFAULT_SSL;
    } else {
      this.host = settings.host;
      this.ssl = (_a = settings.ssl) !== null && _a !== void 0 ? _a : DEFAULT_SSL;
    }
    this.isUsingEmulator = settings.emulatorOptions !== void 0;
    this.credentials = settings.credentials;
    this.ignoreUndefinedProperties = !!settings.ignoreUndefinedProperties;
    this.localCache = settings.localCache;
    if (settings.cacheSizeBytes === void 0) {
      this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;
    } else {
      if (settings.cacheSizeBytes !== LRU_COLLECTION_DISABLED && settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);
      } else {
        this.cacheSizeBytes = settings.cacheSizeBytes;
      }
    }
    validateIsNotUsedTogether("experimentalForceLongPolling", settings.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", settings.experimentalAutoDetectLongPolling);
    this.experimentalForceLongPolling = !!settings.experimentalForceLongPolling;
    if (this.experimentalForceLongPolling) {
      this.experimentalAutoDetectLongPolling = false;
    } else if (settings.experimentalAutoDetectLongPolling === void 0) {
      this.experimentalAutoDetectLongPolling = DEFAULT_AUTO_DETECT_LONG_POLLING;
    } else {
      this.experimentalAutoDetectLongPolling = !!settings.experimentalAutoDetectLongPolling;
    }
    this.experimentalLongPollingOptions = cloneLongPollingOptions((_b = settings.experimentalLongPollingOptions) !== null && _b !== void 0 ? _b : {});
    validateLongPollingOptions(this.experimentalLongPollingOptions);
    this.useFetchStreams = !!settings.useFetchStreams;
  }
  isEqual(other) {
    return this.host === other.host && this.ssl === other.ssl && this.credentials === other.credentials && this.cacheSizeBytes === other.cacheSizeBytes && this.experimentalForceLongPolling === other.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === other.experimentalAutoDetectLongPolling && longPollingOptionsEqual(this.experimentalLongPollingOptions, other.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === other.ignoreUndefinedProperties && this.useFetchStreams === other.useFetchStreams;
  }
};
function validateLongPollingOptions(options) {
  if (options.timeoutSeconds !== void 0) {
    if (isNaN(options.timeoutSeconds)) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} (must not be NaN)`);
    }
    if (options.timeoutSeconds < MIN_LONG_POLLING_TIMEOUT_SECONDS) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} (minimum allowed value is ${MIN_LONG_POLLING_TIMEOUT_SECONDS})`);
    }
    if (options.timeoutSeconds > MAX_LONG_POLLING_TIMEOUT_SECONDS) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} (maximum allowed value is ${MAX_LONG_POLLING_TIMEOUT_SECONDS})`);
    }
  }
}
__name(validateLongPollingOptions, "validateLongPollingOptions");
var Firestore = class {
  static {
    __name(this, "Firestore");
  }
  /** @hideconstructor */
  constructor(_authCredentials, _appCheckCredentials, _databaseId, _app) {
    this._authCredentials = _authCredentials;
    this._appCheckCredentials = _appCheckCredentials;
    this._databaseId = _databaseId;
    this._app = _app;
    this.type = "firestore-lite";
    this._persistenceKey = "(lite)";
    this._settings = new FirestoreSettingsImpl({});
    this._settingsFrozen = false;
    this._emulatorOptions = {};
    this._terminateTask = "notTerminated";
  }
  /**
   * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service
   * instance.
   */
  get app() {
    if (!this._app) {
      throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    }
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== "notTerminated";
  }
  _setSettings(settings) {
    if (this._settingsFrozen) {
      throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    }
    this._settings = new FirestoreSettingsImpl(settings);
    this._emulatorOptions = settings.emulatorOptions || {};
    if (settings.credentials !== void 0) {
      this._authCredentials = makeAuthCredentialsProvider(settings.credentials);
    }
  }
  _getSettings() {
    return this._settings;
  }
  _getEmulatorOptions() {
    return this._emulatorOptions;
  }
  _freezeSettings() {
    this._settingsFrozen = true;
    return this._settings;
  }
  _delete() {
    if (this._terminateTask === "notTerminated") {
      this._terminateTask = this._terminate();
    }
    return this._terminateTask;
  }
  async _restart() {
    if (this._terminateTask === "notTerminated") {
      await this._terminate();
    } else {
      this._terminateTask = "notTerminated";
    }
  }
  /** Returns a JSON-serializable representation of this `Firestore` instance. */
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  /**
   * Terminates all components used by this client. Subclasses can override
   * this method to clean up their own dependencies, but must also call this
   * method.
   *
   * Only ever called once.
   */
  _terminate() {
    removeComponents(this);
    return Promise.resolve();
  }
};
function initializeFirestore(app, settings, databaseId) {
  if (!databaseId) {
    databaseId = DEFAULT_DATABASE_NAME;
  }
  const provider = _getProvider(app, "firestore/lite");
  if (provider.isInitialized(databaseId)) {
    throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore can only be initialized once per app.");
  }
  return provider.initialize({
    options: settings,
    instanceIdentifier: databaseId
  });
}
__name(initializeFirestore, "initializeFirestore");
function getFirestore(appOrDatabaseId, optionalDatabaseId) {
  const app = typeof appOrDatabaseId === "object" ? appOrDatabaseId : getApp();
  const databaseId = typeof appOrDatabaseId === "string" ? appOrDatabaseId : optionalDatabaseId || "(default)";
  const db = _getProvider(app, "firestore/lite").getImmediate({
    identifier: databaseId
  });
  if (!db._initialized) {
    const emulator = getDefaultEmulatorHostnameAndPort("firestore");
    if (emulator) {
      connectFirestoreEmulator(db, ...emulator);
    }
  }
  return db;
}
__name(getFirestore, "getFirestore");
function connectFirestoreEmulator(firestore, host, port2, options = {}) {
  var _a;
  firestore = cast(firestore, Firestore);
  const useSsl = isCloudWorkstation(host);
  const settings = firestore._getSettings();
  const existingConfig = Object.assign(Object.assign({}, settings), { emulatorOptions: firestore._getEmulatorOptions() });
  const newHostSetting = `${host}:${port2}`;
  if (useSsl) {
    void pingServer(`https://${newHostSetting}`);
    updateEmulatorBanner("Firestore", true);
  }
  if (settings.host !== DEFAULT_HOST && settings.host !== newHostSetting) {
    logWarn("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used.");
  }
  const newConfig = Object.assign(Object.assign({}, settings), { host: newHostSetting, ssl: useSsl, emulatorOptions: options });
  if (deepEqual(newConfig, existingConfig)) {
    return;
  }
  firestore._setSettings(newConfig);
  if (options.mockUserToken) {
    let token;
    let user;
    if (typeof options.mockUserToken === "string") {
      token = options.mockUserToken;
      user = User.MOCK_USER;
    } else {
      token = createMockUserToken(options.mockUserToken, (_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.projectId);
      const uid = options.mockUserToken.sub || options.mockUserToken.user_id;
      if (!uid) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      }
      user = new User(uid);
    }
    firestore._authCredentials = new EmulatorAuthCredentialsProvider(new OAuthToken(token, user));
  }
}
__name(connectFirestoreEmulator, "connectFirestoreEmulator");
function terminate(firestore) {
  firestore = cast(firestore, Firestore);
  _removeServiceInstance(firestore.app, "firestore/lite");
  return firestore._delete();
}
__name(terminate, "terminate");
function registerFirestore() {
  setSDKVersion(`${SDK_VERSION}_lite`);
  _registerComponent(new Component("firestore/lite", (container, { instanceIdentifier: databaseId, options: settings }) => {
    const app = container.getProvider("app").getImmediate();
    const firestoreInstance = new Firestore(new LiteAuthCredentialsProvider(container.getProvider("auth-internal")), new LiteAppCheckTokenProvider(app, container.getProvider("app-check-internal")), databaseIdFromApp(app, databaseId), app);
    if (settings) {
      firestoreInstance._setSettings(settings);
    }
    return firestoreInstance;
  }, "PUBLIC").setMultipleInstances(true));
  registerVersion("firestore-lite", version$12, "node");
  registerVersion("firestore-lite", version$12, "esm2017");
}
__name(registerFirestore, "registerFirestore");
var AggregateImpl = class {
  static {
    __name(this, "AggregateImpl");
  }
  constructor(alias, aggregateType, fieldPath) {
    this.alias = alias;
    this.aggregateType = aggregateType;
    this.fieldPath = fieldPath;
  }
};
var AggregateField = class {
  static {
    __name(this, "AggregateField");
  }
  /**
   * Create a new AggregateField<T>
   * @param aggregateType Specifies the type of aggregation operation to perform.
   * @param _internalFieldPath Optionally specifies the field that is aggregated.
   * @internal
   */
  constructor(aggregateType = "count", _internalFieldPath) {
    this._internalFieldPath = _internalFieldPath;
    this.type = "AggregateField";
    this.aggregateType = aggregateType;
  }
};
var AggregateQuerySnapshot = class {
  static {
    __name(this, "AggregateQuerySnapshot");
  }
  /** @hideconstructor */
  constructor(query2, _userDataWriter, _data) {
    this._userDataWriter = _userDataWriter;
    this._data = _data;
    this.type = "AggregateQuerySnapshot";
    this.query = query2;
  }
  /**
   * Returns the results of the aggregations performed over the underlying
   * query.
   *
   * The keys of the returned object will be the same as those of the
   * `AggregateSpec` object specified to the aggregation method, and the values
   * will be the corresponding aggregation result.
   *
   * @returns The results of the aggregations performed over the underlying
   * query.
   */
  data() {
    return this._userDataWriter.convertObjectMap(this._data);
  }
};
var Query = class _Query {
  static {
    __name(this, "Query");
  }
  // This is the lite version of the Query class in the main SDK.
  /** @hideconstructor protected */
  constructor(firestore, converter, _query) {
    this.converter = converter;
    this._query = _query;
    this.type = "query";
    this.firestore = firestore;
  }
  withConverter(converter) {
    return new _Query(this.firestore, converter, this._query);
  }
};
var DocumentReference = class _DocumentReference {
  static {
    __name(this, "DocumentReference");
  }
  /** @hideconstructor */
  constructor(firestore, converter, _key) {
    this.converter = converter;
    this._key = _key;
    this.type = "document";
    this.firestore = firestore;
  }
  get _path() {
    return this._key.path;
  }
  /**
   * The document's identifier within its collection.
   */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced document (relative
   * to the root of the database).
   */
  get path() {
    return this._key.path.canonicalString();
  }
  /**
   * The collection this `DocumentReference` belongs to.
   */
  get parent() {
    return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(converter) {
    return new _DocumentReference(this.firestore, converter, this._key);
  }
};
var CollectionReference = class _CollectionReference extends Query {
  static {
    __name(this, "CollectionReference");
  }
  /** @hideconstructor */
  constructor(firestore, converter, _path) {
    super(firestore, converter, newQueryForPath(_path));
    this._path = _path;
    this.type = "collection";
  }
  /** The collection's identifier. */
  get id() {
    return this._query.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced collection (relative
   * to the root of the database).
   */
  get path() {
    return this._query.path.canonicalString();
  }
  /**
   * A reference to the containing `DocumentReference` if this is a
   * subcollection. If this isn't a subcollection, the reference is null.
   */
  get parent() {
    const parentPath = this._path.popLast();
    if (parentPath.isEmpty()) {
      return null;
    } else {
      return new DocumentReference(
        this.firestore,
        /* converter= */
        null,
        new DocumentKey(parentPath)
      );
    }
  }
  withConverter(converter) {
    return new _CollectionReference(this.firestore, converter, this._path);
  }
};
function collection(parent, path, ...pathSegments) {
  parent = getModularInstance(parent);
  validateNonEmptyArgument("collection", "path", path);
  if (parent instanceof Firestore) {
    const absolutePath = ResourcePath.fromString(path, ...pathSegments);
    validateCollectionPath(absolutePath);
    return new CollectionReference(
      parent,
      /* converter= */
      null,
      absolutePath
    );
  } else {
    if (!(parent instanceof DocumentReference) && !(parent instanceof CollectionReference)) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    }
    const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));
    validateCollectionPath(absolutePath);
    return new CollectionReference(
      parent.firestore,
      /* converter= */
      null,
      absolutePath
    );
  }
}
__name(collection, "collection");
function collectionGroup(firestore, collectionId) {
  firestore = cast(firestore, Firestore);
  validateNonEmptyArgument("collectionGroup", "collection id", collectionId);
  if (collectionId.indexOf("/") >= 0) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection ID '${collectionId}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  }
  return new Query(
    firestore,
    /* converter= */
    null,
    newQueryForCollectionGroup(collectionId)
  );
}
__name(collectionGroup, "collectionGroup");
function doc(parent, path, ...pathSegments) {
  parent = getModularInstance(parent);
  if (arguments.length === 1) {
    path = AutoId.newId();
  }
  validateNonEmptyArgument("doc", "path", path);
  if (parent instanceof Firestore) {
    const absolutePath = ResourcePath.fromString(path, ...pathSegments);
    validateDocumentPath(absolutePath);
    return new DocumentReference(
      parent,
      /* converter= */
      null,
      new DocumentKey(absolutePath)
    );
  } else {
    if (!(parent instanceof DocumentReference) && !(parent instanceof CollectionReference)) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    }
    const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));
    validateDocumentPath(absolutePath);
    return new DocumentReference(parent.firestore, parent instanceof CollectionReference ? parent.converter : null, new DocumentKey(absolutePath));
  }
}
__name(doc, "doc");
function refEqual(left, right) {
  left = getModularInstance(left);
  right = getModularInstance(right);
  if ((left instanceof DocumentReference || left instanceof CollectionReference) && (right instanceof DocumentReference || right instanceof CollectionReference)) {
    return left.firestore === right.firestore && left.path === right.path && left.converter === right.converter;
  }
  return false;
}
__name(refEqual, "refEqual");
function queryEqual(left, right) {
  left = getModularInstance(left);
  right = getModularInstance(right);
  if (left instanceof Query && right instanceof Query) {
    return left.firestore === right.firestore && queryEquals(left._query, right._query) && left.converter === right.converter;
  }
  return false;
}
__name(queryEqual, "queryEqual");
var Bytes = class _Bytes {
  static {
    __name(this, "Bytes");
  }
  /** @hideconstructor */
  constructor(byteString) {
    this._byteString = byteString;
  }
  /**
   * Creates a new `Bytes` object from the given Base64 string, converting it to
   * bytes.
   *
   * @param base64 - The Base64 string used to create the `Bytes` object.
   */
  static fromBase64String(base642) {
    try {
      return new _Bytes(ByteString.fromBase64String(base642));
    } catch (e10) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + e10);
    }
  }
  /**
   * Creates a new `Bytes` object from the given Uint8Array.
   *
   * @param array - The Uint8Array used to create the `Bytes` object.
   */
  static fromUint8Array(array) {
    return new _Bytes(ByteString.fromUint8Array(array));
  }
  /**
   * Returns the underlying bytes as a Base64-encoded string.
   *
   * @returns The Base64-encoded string created from the `Bytes` object.
   */
  toBase64() {
    return this._byteString.toBase64();
  }
  /**
   * Returns the underlying bytes in a new `Uint8Array`.
   *
   * @returns The Uint8Array created from the `Bytes` object.
   */
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  /**
   * Returns a string representation of the `Bytes` object.
   *
   * @returns A string representation of the `Bytes` object.
   */
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  /**
   * Returns true if this `Bytes` object is equal to the provided one.
   *
   * @param other - The `Bytes` object to compare against.
   * @returns true if this `Bytes` object is equal to the provided one.
   */
  isEqual(other) {
    return this._byteString.isEqual(other._byteString);
  }
};
var FieldPath = class {
  static {
    __name(this, "FieldPath");
  }
  /**
   * Creates a `FieldPath` from the provided field names. If more than one field
   * name is provided, the path will point to a nested field in a document.
   *
   * @param fieldNames - A list of field names.
   */
  constructor(...fieldNames) {
    for (let i18 = 0; i18 < fieldNames.length; ++i18) {
      if (fieldNames[i18].length === 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field name at argument $(i + 1). Field names must not be empty.`);
      }
    }
    this._internalPath = new FieldPath$1(fieldNames);
  }
  /**
   * Returns true if this `FieldPath` is equal to the provided one.
   *
   * @param other - The `FieldPath` to compare against.
   * @returns true if this `FieldPath` is equal to the provided one.
   */
  isEqual(other) {
    return this._internalPath.isEqual(other._internalPath);
  }
};
function documentId() {
  return new FieldPath(DOCUMENT_KEY_NAME);
}
__name(documentId, "documentId");
var FieldValue = class {
  static {
    __name(this, "FieldValue");
  }
  /**
   * @param _methodName - The public API endpoint that returns this class.
   * @hideconstructor
   */
  constructor(_methodName) {
    this._methodName = _methodName;
  }
};
var GeoPoint = class {
  static {
    __name(this, "GeoPoint");
  }
  /**
   * Creates a new immutable `GeoPoint` object with the provided latitude and
   * longitude values.
   * @param latitude - The latitude as number between -90 and 90.
   * @param longitude - The longitude as number between -180 and 180.
   */
  constructor(latitude, longitude) {
    if (!isFinite(latitude) || latitude < -90 || latitude > 90) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + latitude);
    }
    if (!isFinite(longitude) || longitude < -180 || longitude > 180) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + longitude);
    }
    this._lat = latitude;
    this._long = longitude;
  }
  /**
   * The latitude of this `GeoPoint` instance.
   */
  get latitude() {
    return this._lat;
  }
  /**
   * The longitude of this `GeoPoint` instance.
   */
  get longitude() {
    return this._long;
  }
  /**
   * Returns true if this `GeoPoint` is equal to the provided one.
   *
   * @param other - The `GeoPoint` to compare against.
   * @returns true if this `GeoPoint` is equal to the provided one.
   */
  isEqual(other) {
    return this._lat === other._lat && this._long === other._long;
  }
  /** Returns a JSON-serializable representation of this GeoPoint. */
  toJSON() {
    return { latitude: this._lat, longitude: this._long };
  }
  /**
   * Actually private to JS consumers of our API, so this function is prefixed
   * with an underscore.
   */
  _compareTo(other) {
    return primitiveComparator(this._lat, other._lat) || primitiveComparator(this._long, other._long);
  }
};
function isPrimitiveArrayEqual(left, right) {
  if (left.length !== right.length) {
    return false;
  }
  for (let i18 = 0; i18 < left.length; ++i18) {
    if (left[i18] !== right[i18]) {
      return false;
    }
  }
  return true;
}
__name(isPrimitiveArrayEqual, "isPrimitiveArrayEqual");
var VectorValue = class {
  static {
    __name(this, "VectorValue");
  }
  /**
   * @private
   * @internal
   */
  constructor(values) {
    this._values = (values || []).map((n11) => n11);
  }
  /**
   * Returns a copy of the raw number array form of the vector.
   */
  toArray() {
    return this._values.map((n11) => n11);
  }
  /**
   * Returns `true` if the two `VectorValue` values have the same raw number arrays, returns `false` otherwise.
   */
  isEqual(other) {
    return isPrimitiveArrayEqual(this._values, other._values);
  }
};
var RESERVED_FIELD_REGEX = /^__.*__$/;
var ParsedSetData = class {
  static {
    __name(this, "ParsedSetData");
  }
  constructor(data, fieldMask, fieldTransforms) {
    this.data = data;
    this.fieldMask = fieldMask;
    this.fieldTransforms = fieldTransforms;
  }
  toMutation(key, precondition) {
    if (this.fieldMask !== null) {
      return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);
    } else {
      return new SetMutation(key, this.data, precondition, this.fieldTransforms);
    }
  }
};
var ParsedUpdateData = class {
  static {
    __name(this, "ParsedUpdateData");
  }
  constructor(data, fieldMask, fieldTransforms) {
    this.data = data;
    this.fieldMask = fieldMask;
    this.fieldTransforms = fieldTransforms;
  }
  toMutation(key, precondition) {
    return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);
  }
};
function isWrite(dataSource) {
  switch (dataSource) {
    case 0:
    // fall through
    case 2:
    // fall through
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw fail(40011, {
        dataSource
      });
  }
}
__name(isWrite, "isWrite");
var ParseContextImpl = class _ParseContextImpl {
  static {
    __name(this, "ParseContextImpl");
  }
  /**
   * Initializes a ParseContext with the given source and path.
   *
   * @param settings - The settings for the parser.
   * @param databaseId - The database ID of the Firestore instance.
   * @param serializer - The serializer to use to generate the Value proto.
   * @param ignoreUndefinedProperties - Whether to ignore undefined properties
   * rather than throw.
   * @param fieldTransforms - A mutable list of field transforms encountered
   * while parsing the data.
   * @param fieldMask - A mutable list of field paths encountered while parsing
   * the data.
   *
   * TODO(b/34871131): We don't support array paths right now, so path can be
   * null to indicate the context represents any location within an array (in
   * which case certain features will not work and errors will be somewhat
   * compromised).
   */
  constructor(settings, databaseId, serializer, ignoreUndefinedProperties, fieldTransforms, fieldMask) {
    this.settings = settings;
    this.databaseId = databaseId;
    this.serializer = serializer;
    this.ignoreUndefinedProperties = ignoreUndefinedProperties;
    if (fieldTransforms === void 0) {
      this.validatePath();
    }
    this.fieldTransforms = fieldTransforms || [];
    this.fieldMask = fieldMask || [];
  }
  get path() {
    return this.settings.path;
  }
  get dataSource() {
    return this.settings.dataSource;
  }
  /** Returns a new context with the specified settings overwritten. */
  contextWith(configuration) {
    return new _ParseContextImpl(Object.assign(Object.assign({}, this.settings), configuration), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  childContextForField(field) {
    var _a;
    const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);
    const context2 = this.contextWith({ path: childPath, arrayElement: false });
    context2.validatePathSegment(field);
    return context2;
  }
  childContextForFieldPath(field) {
    var _a;
    const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);
    const context2 = this.contextWith({ path: childPath, arrayElement: false });
    context2.validatePath();
    return context2;
  }
  childContextForArray(index) {
    return this.contextWith({ path: void 0, arrayElement: true });
  }
  createError(reason) {
    return createError(reason, this.settings.methodName, this.settings.hasConverter || false, this.path, this.settings.targetDoc);
  }
  /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
  contains(fieldPath) {
    return this.fieldMask.find((field) => fieldPath.isPrefixOf(field)) !== void 0 || this.fieldTransforms.find((transform) => fieldPath.isPrefixOf(transform.field)) !== void 0;
  }
  validatePath() {
    if (!this.path) {
      return;
    }
    for (let i18 = 0; i18 < this.path.length; i18++) {
      this.validatePathSegment(this.path.get(i18));
    }
  }
  validatePathSegment(segment) {
    if (segment.length === 0) {
      throw this.createError("Document fields must not be empty");
    }
    if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {
      throw this.createError('Document fields cannot begin and end with "__"');
    }
  }
};
var UserDataReader = class {
  static {
    __name(this, "UserDataReader");
  }
  constructor(databaseId, ignoreUndefinedProperties, serializer) {
    this.databaseId = databaseId;
    this.ignoreUndefinedProperties = ignoreUndefinedProperties;
    this.serializer = serializer || newSerializer(databaseId);
  }
  /** Creates a new top-level parse context. */
  createContext(dataSource, methodName, targetDoc, hasConverter = false) {
    return new ParseContextImpl({
      dataSource,
      methodName,
      targetDoc,
      path: FieldPath$1.emptyPath(),
      arrayElement: false,
      hasConverter
    }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);
  }
};
function newUserDataReader(firestore) {
  const settings = firestore._freezeSettings();
  const serializer = newSerializer(firestore._databaseId);
  return new UserDataReader(firestore._databaseId, !!settings.ignoreUndefinedProperties, serializer);
}
__name(newUserDataReader, "newUserDataReader");
function parseSetData(userDataReader, methodName, targetDoc, input, hasConverter, options = {}) {
  const context2 = userDataReader.createContext(options.merge || options.mergeFields ? 2 : 0, methodName, targetDoc, hasConverter);
  validatePlainObject("Data must be an object, but it was:", context2, input);
  const updateData = parseObject(input, context2);
  let fieldMask;
  let fieldTransforms;
  if (options.merge) {
    fieldMask = new FieldMask(context2.fieldMask);
    fieldTransforms = context2.fieldTransforms;
  } else if (options.mergeFields) {
    const validatedFieldPaths = [];
    for (const stringOrFieldPath of options.mergeFields) {
      const fieldPath = fieldPathFromArgument$1(methodName, stringOrFieldPath, targetDoc);
      if (!context2.contains(fieldPath)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Field '${fieldPath}' is specified in your field mask but missing from your input data.`);
      }
      if (!fieldMaskContains(validatedFieldPaths, fieldPath)) {
        validatedFieldPaths.push(fieldPath);
      }
    }
    fieldMask = new FieldMask(validatedFieldPaths);
    fieldTransforms = context2.fieldTransforms.filter((transform) => fieldMask.covers(transform.field));
  } else {
    fieldMask = null;
    fieldTransforms = context2.fieldTransforms;
  }
  return new ParsedSetData(new ObjectValue(updateData), fieldMask, fieldTransforms);
}
__name(parseSetData, "parseSetData");
var DeleteFieldValueImpl = class _DeleteFieldValueImpl extends FieldValue {
  static {
    __name(this, "DeleteFieldValueImpl");
  }
  _toFieldTransform(context2) {
    if (context2.dataSource === 2) {
      context2.fieldMask.push(context2.path);
    } else if (context2.dataSource === 1) {
      throw context2.createError(`${this._methodName}() can only appear at the top level of your update data`);
    } else {
      throw context2.createError(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    }
    return null;
  }
  isEqual(other) {
    return other instanceof _DeleteFieldValueImpl;
  }
};
function createSentinelChildContext(fieldValue, context2, arrayElement) {
  return new ParseContextImpl({
    dataSource: 3,
    targetDoc: context2.settings.targetDoc,
    methodName: fieldValue._methodName,
    arrayElement
  }, context2.databaseId, context2.serializer, context2.ignoreUndefinedProperties);
}
__name(createSentinelChildContext, "createSentinelChildContext");
var ServerTimestampFieldValueImpl = class _ServerTimestampFieldValueImpl extends FieldValue {
  static {
    __name(this, "ServerTimestampFieldValueImpl");
  }
  _toFieldTransform(context2) {
    return new FieldTransform(context2.path, new ServerTimestampTransform());
  }
  isEqual(other) {
    return other instanceof _ServerTimestampFieldValueImpl;
  }
};
var ArrayUnionFieldValueImpl = class _ArrayUnionFieldValueImpl extends FieldValue {
  static {
    __name(this, "ArrayUnionFieldValueImpl");
  }
  constructor(methodName, _elements) {
    super(methodName);
    this._elements = _elements;
  }
  _toFieldTransform(context2) {
    const parseContext = createSentinelChildContext(
      this,
      context2,
      /*array=*/
      true
    );
    const parsedElements = this._elements.map((element) => parseData(element, parseContext));
    const arrayUnion2 = new ArrayUnionTransformOperation(parsedElements);
    return new FieldTransform(context2.path, arrayUnion2);
  }
  isEqual(other) {
    return other instanceof _ArrayUnionFieldValueImpl && deepEqual(this._elements, other._elements);
  }
};
var ArrayRemoveFieldValueImpl = class _ArrayRemoveFieldValueImpl extends FieldValue {
  static {
    __name(this, "ArrayRemoveFieldValueImpl");
  }
  constructor(methodName, _elements) {
    super(methodName);
    this._elements = _elements;
  }
  _toFieldTransform(context2) {
    const parseContext = createSentinelChildContext(
      this,
      context2,
      /*array=*/
      true
    );
    const parsedElements = this._elements.map((element) => parseData(element, parseContext));
    const arrayUnion2 = new ArrayRemoveTransformOperation(parsedElements);
    return new FieldTransform(context2.path, arrayUnion2);
  }
  isEqual(other) {
    return other instanceof _ArrayRemoveFieldValueImpl && deepEqual(this._elements, other._elements);
  }
};
var NumericIncrementFieldValueImpl = class _NumericIncrementFieldValueImpl extends FieldValue {
  static {
    __name(this, "NumericIncrementFieldValueImpl");
  }
  constructor(methodName, _operand) {
    super(methodName);
    this._operand = _operand;
  }
  _toFieldTransform(context2) {
    const numericIncrement = new NumericIncrementTransformOperation(context2.serializer, toNumber(context2.serializer, this._operand));
    return new FieldTransform(context2.path, numericIncrement);
  }
  isEqual(other) {
    return other instanceof _NumericIncrementFieldValueImpl && this._operand === other._operand;
  }
};
function parseUpdateData(userDataReader, methodName, targetDoc, input) {
  const context2 = userDataReader.createContext(1, methodName, targetDoc);
  validatePlainObject("Data must be an object, but it was:", context2, input);
  const fieldMaskPaths = [];
  const updateData = ObjectValue.empty();
  forEach(input, (key, value) => {
    const path = fieldPathFromDotSeparatedString(methodName, key, targetDoc);
    value = getModularInstance(value);
    const childContext = context2.childContextForFieldPath(path);
    if (value instanceof DeleteFieldValueImpl) {
      fieldMaskPaths.push(path);
    } else {
      const parsedValue = parseData(value, childContext);
      if (parsedValue != null) {
        fieldMaskPaths.push(path);
        updateData.set(path, parsedValue);
      }
    }
  });
  const mask = new FieldMask(fieldMaskPaths);
  return new ParsedUpdateData(updateData, mask, context2.fieldTransforms);
}
__name(parseUpdateData, "parseUpdateData");
function parseUpdateVarargs(userDataReader, methodName, targetDoc, field, value, moreFieldsAndValues) {
  const context2 = userDataReader.createContext(1, methodName, targetDoc);
  const keys = [fieldPathFromArgument$1(methodName, field, targetDoc)];
  const values = [value];
  if (moreFieldsAndValues.length % 2 !== 0) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${methodName}() needs to be called with an even number of arguments that alternate between field names and values.`);
  }
  for (let i18 = 0; i18 < moreFieldsAndValues.length; i18 += 2) {
    keys.push(fieldPathFromArgument$1(methodName, moreFieldsAndValues[i18]));
    values.push(moreFieldsAndValues[i18 + 1]);
  }
  const fieldMaskPaths = [];
  const updateData = ObjectValue.empty();
  for (let i18 = keys.length - 1; i18 >= 0; --i18) {
    if (!fieldMaskContains(fieldMaskPaths, keys[i18])) {
      const path = keys[i18];
      let value2 = values[i18];
      value2 = getModularInstance(value2);
      const childContext = context2.childContextForFieldPath(path);
      if (value2 instanceof DeleteFieldValueImpl) {
        fieldMaskPaths.push(path);
      } else {
        const parsedValue = parseData(value2, childContext);
        if (parsedValue != null) {
          fieldMaskPaths.push(path);
          updateData.set(path, parsedValue);
        }
      }
    }
  }
  const mask = new FieldMask(fieldMaskPaths);
  return new ParsedUpdateData(updateData, mask, context2.fieldTransforms);
}
__name(parseUpdateVarargs, "parseUpdateVarargs");
function parseQueryValue(userDataReader, methodName, input, allowArrays = false) {
  const context2 = userDataReader.createContext(allowArrays ? 4 : 3, methodName);
  const parsed = parseData(input, context2);
  return parsed;
}
__name(parseQueryValue, "parseQueryValue");
function parseData(input, context2) {
  input = getModularInstance(input);
  if (looksLikeJsonObject(input)) {
    validatePlainObject("Unsupported field value:", context2, input);
    return parseObject(input, context2);
  } else if (input instanceof FieldValue) {
    parseSentinelFieldValue(input, context2);
    return null;
  } else if (input === void 0 && context2.ignoreUndefinedProperties) {
    return null;
  } else {
    if (context2.path) {
      context2.fieldMask.push(context2.path);
    }
    if (input instanceof Array) {
      if (context2.settings.arrayElement && context2.dataSource !== 4) {
        throw context2.createError("Nested arrays are not supported");
      }
      return parseArray(input, context2);
    } else {
      return parseScalarValue(input, context2);
    }
  }
}
__name(parseData, "parseData");
function parseObject(obj, context2) {
  const fields = {};
  if (isEmpty2(obj)) {
    if (context2.path && context2.path.length > 0) {
      context2.fieldMask.push(context2.path);
    }
  } else {
    forEach(obj, (key, val) => {
      const parsedValue = parseData(val, context2.childContextForField(key));
      if (parsedValue != null) {
        fields[key] = parsedValue;
      }
    });
  }
  return { mapValue: { fields } };
}
__name(parseObject, "parseObject");
function parseArray(array, context2) {
  const values = [];
  let entryIndex = 0;
  for (const entry of array) {
    let parsedEntry = parseData(entry, context2.childContextForArray(entryIndex));
    if (parsedEntry == null) {
      parsedEntry = { nullValue: "NULL_VALUE" };
    }
    values.push(parsedEntry);
    entryIndex++;
  }
  return { arrayValue: { values } };
}
__name(parseArray, "parseArray");
function parseSentinelFieldValue(value, context2) {
  if (!isWrite(context2.dataSource)) {
    throw context2.createError(`${value._methodName}() can only be used with update() and set()`);
  }
  if (!context2.path) {
    throw context2.createError(`${value._methodName}() is not currently supported inside arrays`);
  }
  const fieldTransform = value._toFieldTransform(context2);
  if (fieldTransform) {
    context2.fieldTransforms.push(fieldTransform);
  }
}
__name(parseSentinelFieldValue, "parseSentinelFieldValue");
function parseScalarValue(value, context2) {
  value = getModularInstance(value);
  if (value === null) {
    return { nullValue: "NULL_VALUE" };
  } else if (typeof value === "number") {
    return toNumber(context2.serializer, value);
  } else if (typeof value === "boolean") {
    return { booleanValue: value };
  } else if (typeof value === "string") {
    return { stringValue: value };
  } else if (value instanceof Date) {
    const timestamp = Timestamp.fromDate(value);
    return {
      timestampValue: toTimestamp(context2.serializer, timestamp)
    };
  } else if (value instanceof Timestamp) {
    const timestamp = new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1e3) * 1e3);
    return {
      timestampValue: toTimestamp(context2.serializer, timestamp)
    };
  } else if (value instanceof GeoPoint) {
    return {
      geoPointValue: {
        latitude: value.latitude,
        longitude: value.longitude
      }
    };
  } else if (value instanceof Bytes) {
    return { bytesValue: toBytes(context2.serializer, value._byteString) };
  } else if (value instanceof DocumentReference) {
    const thisDb = context2.databaseId;
    const otherDb = value.firestore._databaseId;
    if (!otherDb.isEqual(thisDb)) {
      throw context2.createError(`Document reference is for database ${otherDb.projectId}/${otherDb.database} but should be for database ${thisDb.projectId}/${thisDb.database}`);
    }
    return {
      referenceValue: toResourceName(value.firestore._databaseId || context2.databaseId, value._key.path)
    };
  } else if (value instanceof VectorValue) {
    return parseVectorValue(value, context2);
  } else {
    throw context2.createError(`Unsupported field value: ${valueDescription(value)}`);
  }
}
__name(parseScalarValue, "parseScalarValue");
function parseVectorValue(value, context2) {
  const mapValue = {
    fields: {
      [TYPE_KEY]: {
        stringValue: VECTOR_VALUE_SENTINEL
      },
      [VECTOR_MAP_VECTORS_KEY]: {
        arrayValue: {
          values: value.toArray().map((value2) => {
            if (typeof value2 !== "number") {
              throw context2.createError("VectorValues must only contain numeric values.");
            }
            return toDouble(context2.serializer, value2);
          })
        }
      }
    }
  };
  return { mapValue };
}
__name(parseVectorValue, "parseVectorValue");
function looksLikeJsonObject(input) {
  return typeof input === "object" && input !== null && !(input instanceof Array) && !(input instanceof Date) && !(input instanceof Timestamp) && !(input instanceof GeoPoint) && !(input instanceof Bytes) && !(input instanceof DocumentReference) && !(input instanceof FieldValue) && !(input instanceof VectorValue);
}
__name(looksLikeJsonObject, "looksLikeJsonObject");
function validatePlainObject(message, context2, input) {
  if (!looksLikeJsonObject(input) || !isPlainObject(input)) {
    const description = valueDescription(input);
    if (description === "an object") {
      throw context2.createError(message + " a custom object");
    } else {
      throw context2.createError(message + " " + description);
    }
  }
}
__name(validatePlainObject, "validatePlainObject");
function fieldPathFromArgument$1(methodName, path, targetDoc) {
  path = getModularInstance(path);
  if (path instanceof FieldPath) {
    return path._internalPath;
  } else if (typeof path === "string") {
    return fieldPathFromDotSeparatedString(methodName, path);
  } else {
    const message = "Field path arguments must be of type string or ";
    throw createError(
      message,
      methodName,
      /* hasConverter= */
      false,
      /* path= */
      void 0,
      targetDoc
    );
  }
}
__name(fieldPathFromArgument$1, "fieldPathFromArgument$1");
var FIELD_PATH_RESERVED = new RegExp("[~\\*/\\[\\]]");
function fieldPathFromDotSeparatedString(methodName, path, targetDoc) {
  const found = path.search(FIELD_PATH_RESERVED);
  if (found >= 0) {
    throw createError(
      `Invalid field path (${path}). Paths must not contain '~', '*', '/', '[', or ']'`,
      methodName,
      /* hasConverter= */
      false,
      /* path= */
      void 0,
      targetDoc
    );
  }
  try {
    return new FieldPath(...path.split("."))._internalPath;
  } catch (e10) {
    throw createError(
      `Invalid field path (${path}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      methodName,
      /* hasConverter= */
      false,
      /* path= */
      void 0,
      targetDoc
    );
  }
}
__name(fieldPathFromDotSeparatedString, "fieldPathFromDotSeparatedString");
function createError(reason, methodName, hasConverter, path, targetDoc) {
  const hasPath = path && !path.isEmpty();
  const hasDocument = targetDoc !== void 0;
  let message = `Function ${methodName}() called with invalid data`;
  if (hasConverter) {
    message += " (via `toFirestore()`)";
  }
  message += ". ";
  let description = "";
  if (hasPath || hasDocument) {
    description += " (found";
    if (hasPath) {
      description += ` in field ${path}`;
    }
    if (hasDocument) {
      description += ` in document ${targetDoc}`;
    }
    description += ")";
  }
  return new FirestoreError(Code.INVALID_ARGUMENT, message + reason + description);
}
__name(createError, "createError");
function fieldMaskContains(haystack, needle) {
  return haystack.some((v8) => v8.isEqual(needle));
}
__name(fieldMaskContains, "fieldMaskContains");
var DocumentSnapshot = class {
  static {
    __name(this, "DocumentSnapshot");
  }
  // Note: This class is stripped down version of the DocumentSnapshot in
  // the legacy SDK. The changes are:
  // - No support for SnapshotMetadata.
  // - No support for SnapshotOptions.
  /** @hideconstructor protected */
  constructor(_firestore, _userDataWriter, _key, _document, _converter) {
    this._firestore = _firestore;
    this._userDataWriter = _userDataWriter;
    this._key = _key;
    this._document = _document;
    this._converter = _converter;
  }
  /** Property of the `DocumentSnapshot` that provides the document's ID. */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * The `DocumentReference` for the document included in the `DocumentSnapshot`.
   */
  get ref() {
    return new DocumentReference(this._firestore, this._converter, this._key);
  }
  /**
   * Signals whether or not the document at the snapshot's location exists.
   *
   * @returns true if the document exists.
   */
  exists() {
    return this._document !== null;
  }
  /**
   * Retrieves all fields in the document as an `Object`. Returns `undefined` if
   * the document doesn't exist.
   *
   * @returns An `Object` containing all fields in the document or `undefined`
   * if the document doesn't exist.
   */
  data() {
    if (!this._document) {
      return void 0;
    } else if (this._converter) {
      const snapshot = new QueryDocumentSnapshot(
        this._firestore,
        this._userDataWriter,
        this._key,
        this._document,
        /* converter= */
        null
      );
      return this._converter.fromFirestore(snapshot);
    } else {
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  /**
   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
   * document or field doesn't exist.
   *
   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
   * field.
   * @returns The data at the specified field location or undefined if no such
   * field exists in the document.
   */
  // We are using `any` here to avoid an explicit cast by our users.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get(fieldPath) {
    if (this._document) {
      const value = this._document.data.field(fieldPathFromArgument("DocumentSnapshot.get", fieldPath));
      if (value !== null) {
        return this._userDataWriter.convertValue(value);
      }
    }
    return void 0;
  }
};
var QueryDocumentSnapshot = class extends DocumentSnapshot {
  static {
    __name(this, "QueryDocumentSnapshot");
  }
  /**
   * Retrieves all fields in the document as an `Object`.
   *
   * @override
   * @returns An `Object` containing all fields in the document.
   */
  data() {
    return super.data();
  }
};
var QuerySnapshot = class {
  static {
    __name(this, "QuerySnapshot");
  }
  /** @hideconstructor */
  constructor(_query, _docs) {
    this._docs = _docs;
    this.query = _query;
  }
  /** An array of all the documents in the `QuerySnapshot`. */
  get docs() {
    return [...this._docs];
  }
  /** The number of documents in the `QuerySnapshot`. */
  get size() {
    return this.docs.length;
  }
  /** True if there are no documents in the `QuerySnapshot`. */
  get empty() {
    return this.docs.length === 0;
  }
  /**
   * Enumerates all of the documents in the `QuerySnapshot`.
   *
   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for
   * each document in the snapshot.
   * @param thisArg - The `this` binding for the callback.
   */
  forEach(callback, thisArg) {
    this._docs.forEach(callback, thisArg);
  }
};
function snapshotEqual(left, right) {
  left = getModularInstance(left);
  right = getModularInstance(right);
  if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {
    return left._firestore === right._firestore && left._key.isEqual(right._key) && (left._document === null ? right._document === null : left._document.isEqual(right._document)) && left._converter === right._converter;
  } else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {
    return queryEqual(left.query, right.query) && arrayEquals(left.docs, right.docs, snapshotEqual);
  }
  return false;
}
__name(snapshotEqual, "snapshotEqual");
function fieldPathFromArgument(methodName, arg) {
  if (typeof arg === "string") {
    return fieldPathFromDotSeparatedString(methodName, arg);
  } else if (arg instanceof FieldPath) {
    return arg._internalPath;
  } else {
    return arg._delegate._internalPath;
  }
}
__name(fieldPathFromArgument, "fieldPathFromArgument");
function validateHasExplicitOrderByForLimitToLast(query2) {
  if (query2.limitType === "L" && query2.explicitOrderBy.length === 0) {
    throw new FirestoreError(Code.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
  }
}
__name(validateHasExplicitOrderByForLimitToLast, "validateHasExplicitOrderByForLimitToLast");
var AppliableConstraint = class {
  static {
    __name(this, "AppliableConstraint");
  }
};
var QueryConstraint = class extends AppliableConstraint {
  static {
    __name(this, "QueryConstraint");
  }
};
function query(query2, queryConstraint, ...additionalQueryConstraints) {
  let queryConstraints = [];
  if (queryConstraint instanceof AppliableConstraint) {
    queryConstraints.push(queryConstraint);
  }
  queryConstraints = queryConstraints.concat(additionalQueryConstraints);
  validateQueryConstraintArray(queryConstraints);
  for (const constraint of queryConstraints) {
    query2 = constraint._apply(query2);
  }
  return query2;
}
__name(query, "query");
var QueryFieldFilterConstraint = class _QueryFieldFilterConstraint extends QueryConstraint {
  static {
    __name(this, "QueryFieldFilterConstraint");
  }
  /**
   * @internal
   */
  constructor(_field, _op, _value) {
    super();
    this._field = _field;
    this._op = _op;
    this._value = _value;
    this.type = "where";
  }
  static _create(_field, _op, _value) {
    return new _QueryFieldFilterConstraint(_field, _op, _value);
  }
  _apply(query2) {
    const filter = this._parse(query2);
    validateNewFieldFilter(query2._query, filter);
    return new Query(query2.firestore, query2.converter, queryWithAddedFilter(query2._query, filter));
  }
  _parse(query2) {
    const reader = newUserDataReader(query2.firestore);
    const filter = newQueryFilter(query2._query, "where", reader, query2.firestore._databaseId, this._field, this._op, this._value);
    return filter;
  }
};
function where(fieldPath, opStr, value) {
  const op = opStr;
  const field = fieldPathFromArgument("where", fieldPath);
  return QueryFieldFilterConstraint._create(field, op, value);
}
__name(where, "where");
var QueryCompositeFilterConstraint = class _QueryCompositeFilterConstraint extends AppliableConstraint {
  static {
    __name(this, "QueryCompositeFilterConstraint");
  }
  /**
   * @internal
   */
  constructor(type, _queryConstraints) {
    super();
    this.type = type;
    this._queryConstraints = _queryConstraints;
  }
  static _create(type, _queryConstraints) {
    return new _QueryCompositeFilterConstraint(type, _queryConstraints);
  }
  _parse(query2) {
    const parsedFilters = this._queryConstraints.map((queryConstraint) => {
      return queryConstraint._parse(query2);
    }).filter((parsedFilter) => parsedFilter.getFilters().length > 0);
    if (parsedFilters.length === 1) {
      return parsedFilters[0];
    }
    return CompositeFilter.create(parsedFilters, this._getOperator());
  }
  _apply(query2) {
    const parsedFilter = this._parse(query2);
    if (parsedFilter.getFilters().length === 0) {
      return query2;
    }
    validateNewFilter(query2._query, parsedFilter);
    return new Query(query2.firestore, query2.converter, queryWithAddedFilter(query2._query, parsedFilter));
  }
  _getQueryConstraints() {
    return this._queryConstraints;
  }
  _getOperator() {
    return this.type === "and" ? "and" : "or";
  }
};
function or(...queryConstraints) {
  queryConstraints.forEach((queryConstraint) => validateQueryFilterConstraint("or", queryConstraint));
  return QueryCompositeFilterConstraint._create("or", queryConstraints);
}
__name(or, "or");
function and(...queryConstraints) {
  queryConstraints.forEach((queryConstraint) => validateQueryFilterConstraint("and", queryConstraint));
  return QueryCompositeFilterConstraint._create("and", queryConstraints);
}
__name(and, "and");
var QueryOrderByConstraint = class _QueryOrderByConstraint extends QueryConstraint {
  static {
    __name(this, "QueryOrderByConstraint");
  }
  /**
   * @internal
   */
  constructor(_field, _direction) {
    super();
    this._field = _field;
    this._direction = _direction;
    this.type = "orderBy";
  }
  static _create(_field, _direction) {
    return new _QueryOrderByConstraint(_field, _direction);
  }
  _apply(query2) {
    const orderBy2 = newQueryOrderBy(query2._query, this._field, this._direction);
    return new Query(query2.firestore, query2.converter, queryWithAddedOrderBy(query2._query, orderBy2));
  }
};
function orderBy(fieldPath, directionStr = "asc") {
  const direction = directionStr;
  const path = fieldPathFromArgument("orderBy", fieldPath);
  return QueryOrderByConstraint._create(path, direction);
}
__name(orderBy, "orderBy");
var QueryLimitConstraint = class _QueryLimitConstraint extends QueryConstraint {
  static {
    __name(this, "QueryLimitConstraint");
  }
  /**
   * @internal
   */
  constructor(type, _limit, _limitType) {
    super();
    this.type = type;
    this._limit = _limit;
    this._limitType = _limitType;
  }
  static _create(type, _limit, _limitType) {
    return new _QueryLimitConstraint(type, _limit, _limitType);
  }
  _apply(query2) {
    return new Query(query2.firestore, query2.converter, queryWithLimit(query2._query, this._limit, this._limitType));
  }
};
function limit(limit2) {
  validatePositiveNumber("limit", limit2);
  return QueryLimitConstraint._create(
    "limit",
    limit2,
    "F"
    /* LimitType.First */
  );
}
__name(limit, "limit");
function limitToLast(limit2) {
  validatePositiveNumber("limitToLast", limit2);
  return QueryLimitConstraint._create(
    "limitToLast",
    limit2,
    "L"
    /* LimitType.Last */
  );
}
__name(limitToLast, "limitToLast");
var QueryStartAtConstraint = class _QueryStartAtConstraint extends QueryConstraint {
  static {
    __name(this, "QueryStartAtConstraint");
  }
  /**
   * @internal
   */
  constructor(type, _docOrFields, _inclusive) {
    super();
    this.type = type;
    this._docOrFields = _docOrFields;
    this._inclusive = _inclusive;
  }
  static _create(type, _docOrFields, _inclusive) {
    return new _QueryStartAtConstraint(type, _docOrFields, _inclusive);
  }
  _apply(query2) {
    const bound = newQueryBoundFromDocOrFields(query2, this.type, this._docOrFields, this._inclusive);
    return new Query(query2.firestore, query2.converter, queryWithStartAt(query2._query, bound));
  }
};
function startAt(...docOrFields) {
  return QueryStartAtConstraint._create(
    "startAt",
    docOrFields,
    /*inclusive=*/
    true
  );
}
__name(startAt, "startAt");
function startAfter(...docOrFields) {
  return QueryStartAtConstraint._create(
    "startAfter",
    docOrFields,
    /*inclusive=*/
    false
  );
}
__name(startAfter, "startAfter");
var QueryEndAtConstraint = class _QueryEndAtConstraint extends QueryConstraint {
  static {
    __name(this, "QueryEndAtConstraint");
  }
  /**
   * @internal
   */
  constructor(type, _docOrFields, _inclusive) {
    super();
    this.type = type;
    this._docOrFields = _docOrFields;
    this._inclusive = _inclusive;
  }
  static _create(type, _docOrFields, _inclusive) {
    return new _QueryEndAtConstraint(type, _docOrFields, _inclusive);
  }
  _apply(query2) {
    const bound = newQueryBoundFromDocOrFields(query2, this.type, this._docOrFields, this._inclusive);
    return new Query(query2.firestore, query2.converter, queryWithEndAt(query2._query, bound));
  }
};
function endBefore(...docOrFields) {
  return QueryEndAtConstraint._create(
    "endBefore",
    docOrFields,
    /*inclusive=*/
    false
  );
}
__name(endBefore, "endBefore");
function endAt(...docOrFields) {
  return QueryEndAtConstraint._create(
    "endAt",
    docOrFields,
    /*inclusive=*/
    true
  );
}
__name(endAt, "endAt");
function newQueryBoundFromDocOrFields(query2, methodName, docOrFields, inclusive) {
  docOrFields[0] = getModularInstance(docOrFields[0]);
  if (docOrFields[0] instanceof DocumentSnapshot) {
    return newQueryBoundFromDocument(query2._query, query2.firestore._databaseId, methodName, docOrFields[0]._document, inclusive);
  } else {
    const reader = newUserDataReader(query2.firestore);
    return newQueryBoundFromFields(query2._query, query2.firestore._databaseId, reader, methodName, docOrFields, inclusive);
  }
}
__name(newQueryBoundFromDocOrFields, "newQueryBoundFromDocOrFields");
function newQueryFilter(query2, methodName, dataReader, databaseId, fieldPath, op, value) {
  let fieldValue;
  if (fieldPath.isKeyField()) {
    if (op === "array-contains" || op === "array-contains-any") {
      throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid Query. You can't perform '${op}' queries on documentId().`);
    } else if (op === "in" || op === "not-in") {
      validateDisjunctiveFilterElements(value, op);
      const referenceList = [];
      for (const arrayValue of value) {
        referenceList.push(parseDocumentIdValue(databaseId, query2, arrayValue));
      }
      fieldValue = { arrayValue: { values: referenceList } };
    } else {
      fieldValue = parseDocumentIdValue(databaseId, query2, value);
    }
  } else {
    if (op === "in" || op === "not-in" || op === "array-contains-any") {
      validateDisjunctiveFilterElements(value, op);
    }
    fieldValue = parseQueryValue(
      dataReader,
      methodName,
      value,
      /* allowArrays= */
      op === "in" || op === "not-in"
      /* Operator.NOT_IN */
    );
  }
  const filter = FieldFilter.create(fieldPath, op, fieldValue);
  return filter;
}
__name(newQueryFilter, "newQueryFilter");
function newQueryOrderBy(query2, fieldPath, direction) {
  if (query2.startAt !== null) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
  }
  if (query2.endAt !== null) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
  }
  const orderBy2 = new OrderBy(fieldPath, direction);
  return orderBy2;
}
__name(newQueryOrderBy, "newQueryOrderBy");
function newQueryBoundFromDocument(query2, databaseId, methodName, doc2, inclusive) {
  if (!doc2) {
    throw new FirestoreError(Code.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${methodName}().`);
  }
  const components = [];
  for (const orderBy2 of queryNormalizedOrderBy(query2)) {
    if (orderBy2.field.isKeyField()) {
      components.push(refValue(databaseId, doc2.key));
    } else {
      const value = doc2.data.field(orderBy2.field);
      if (isServerTimestamp(value)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + orderBy2.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
      } else if (value !== null) {
        components.push(value);
      } else {
        const field = orderBy2.field.canonicalString();
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${field}' (used as the orderBy) does not exist.`);
      }
    }
  }
  return new Bound(components, inclusive);
}
__name(newQueryBoundFromDocument, "newQueryBoundFromDocument");
function newQueryBoundFromFields(query2, databaseId, dataReader, methodName, values, inclusive) {
  const orderBy2 = query2.explicitOrderBy;
  if (values.length > orderBy2.length) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `Too many arguments provided to ${methodName}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
  }
  const components = [];
  for (let i18 = 0; i18 < values.length; i18++) {
    const rawValue = values[i18];
    const orderByComponent = orderBy2[i18];
    if (orderByComponent.field.isKeyField()) {
      if (typeof rawValue !== "string") {
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${methodName}(), but got a ${typeof rawValue}`);
      }
      if (!isCollectionGroupQuery(query2) && rawValue.indexOf("/") !== -1) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${methodName}() must be a plain document ID, but '${rawValue}' contains a slash.`);
      }
      const path = query2.path.child(ResourcePath.fromString(rawValue));
      if (!DocumentKey.isDocumentKey(path)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${methodName}() must result in a valid document path, but '${path}' is not because it contains an odd number of segments.`);
      }
      const key = new DocumentKey(path);
      components.push(refValue(databaseId, key));
    } else {
      const wrapped = parseQueryValue(dataReader, methodName, rawValue);
      components.push(wrapped);
    }
  }
  return new Bound(components, inclusive);
}
__name(newQueryBoundFromFields, "newQueryBoundFromFields");
function parseDocumentIdValue(databaseId, query2, documentIdValue) {
  documentIdValue = getModularInstance(documentIdValue);
  if (typeof documentIdValue === "string") {
    if (documentIdValue === "") {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    }
    if (!isCollectionGroupQuery(query2) && documentIdValue.indexOf("/") !== -1) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${documentIdValue}' contains a '/' character.`);
    }
    const path = query2.path.child(ResourcePath.fromString(documentIdValue));
    if (!DocumentKey.isDocumentKey(path)) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${path}' is not because it has an odd number of segments (${path.length}).`);
    }
    return refValue(databaseId, new DocumentKey(path));
  } else if (documentIdValue instanceof DocumentReference) {
    return refValue(databaseId, documentIdValue._key);
  } else {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${valueDescription(documentIdValue)}.`);
  }
}
__name(parseDocumentIdValue, "parseDocumentIdValue");
function validateDisjunctiveFilterElements(value, operator) {
  if (!Array.isArray(value) || value.length === 0) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${operator.toString()}' filters.`);
  }
}
__name(validateDisjunctiveFilterElements, "validateDisjunctiveFilterElements");
function conflictingOps(op) {
  switch (op) {
    case "!=":
      return [
        "!=",
        "not-in"
        /* Operator.NOT_IN */
      ];
    case "array-contains-any":
    case "in":
      return [
        "not-in"
        /* Operator.NOT_IN */
      ];
    case "not-in":
      return [
        "array-contains-any",
        "in",
        "not-in",
        "!="
        /* Operator.NOT_EQUAL */
      ];
    default:
      return [];
  }
}
__name(conflictingOps, "conflictingOps");
function validateNewFieldFilter(query2, fieldFilter) {
  const conflictingOp = findOpInsideFilters(query2.filters, conflictingOps(fieldFilter.op));
  if (conflictingOp !== null) {
    if (conflictingOp === fieldFilter.op) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${fieldFilter.op.toString()}' filter.`);
    } else {
      throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You cannot use '${fieldFilter.op.toString()}' filters with '${conflictingOp.toString()}' filters.`);
    }
  }
}
__name(validateNewFieldFilter, "validateNewFieldFilter");
function validateNewFilter(query2, filter) {
  let testQuery = query2;
  const subFilters = filter.getFlattenedFilters();
  for (const subFilter of subFilters) {
    validateNewFieldFilter(testQuery, subFilter);
    testQuery = queryWithAddedFilter(testQuery, subFilter);
  }
}
__name(validateNewFilter, "validateNewFilter");
function findOpInsideFilters(filters, operators) {
  for (const filter of filters) {
    for (const fieldFilter of filter.getFlattenedFilters()) {
      if (operators.indexOf(fieldFilter.op) >= 0) {
        return fieldFilter.op;
      }
    }
  }
  return null;
}
__name(findOpInsideFilters, "findOpInsideFilters");
function validateQueryFilterConstraint(functionName, queryConstraint) {
  if (!(queryConstraint instanceof QueryFieldFilterConstraint) && !(queryConstraint instanceof QueryCompositeFilterConstraint)) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`);
  }
}
__name(validateQueryFilterConstraint, "validateQueryFilterConstraint");
function validateQueryConstraintArray(queryConstraint) {
  const compositeFilterCount = queryConstraint.filter((filter) => filter instanceof QueryCompositeFilterConstraint).length;
  const fieldFilterCount = queryConstraint.filter((filter) => filter instanceof QueryFieldFilterConstraint).length;
  if (compositeFilterCount > 1 || compositeFilterCount > 0 && fieldFilterCount > 0) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.");
  }
}
__name(validateQueryConstraintArray, "validateQueryConstraintArray");
var AbstractUserDataWriter = class {
  static {
    __name(this, "AbstractUserDataWriter");
  }
  convertValue(value, serverTimestampBehavior = "none") {
    switch (typeOrder(value)) {
      case 0:
        return null;
      case 1:
        return value.booleanValue;
      case 2:
        return normalizeNumber(value.integerValue || value.doubleValue);
      case 3:
        return this.convertTimestamp(value.timestampValue);
      case 4:
        return this.convertServerTimestamp(value, serverTimestampBehavior);
      case 5:
        return value.stringValue;
      case 6:
        return this.convertBytes(normalizeByteString(value.bytesValue));
      case 7:
        return this.convertReference(value.referenceValue);
      case 8:
        return this.convertGeoPoint(value.geoPointValue);
      case 9:
        return this.convertArray(value.arrayValue, serverTimestampBehavior);
      case 11:
        return this.convertObject(value.mapValue, serverTimestampBehavior);
      case 10:
        return this.convertVectorValue(value.mapValue);
      default:
        throw fail(62114, {
          value
        });
    }
  }
  convertObject(mapValue, serverTimestampBehavior) {
    return this.convertObjectMap(mapValue.fields, serverTimestampBehavior);
  }
  /**
   * @internal
   */
  convertObjectMap(fields, serverTimestampBehavior = "none") {
    const result = {};
    forEach(fields, (key, value) => {
      result[key] = this.convertValue(value, serverTimestampBehavior);
    });
    return result;
  }
  /**
   * @internal
   */
  convertVectorValue(mapValue) {
    var _a, _b, _c;
    const values = (_c = (_b = (_a = mapValue.fields) === null || _a === void 0 ? void 0 : _a[VECTOR_MAP_VECTORS_KEY].arrayValue) === null || _b === void 0 ? void 0 : _b.values) === null || _c === void 0 ? void 0 : _c.map((value) => {
      return normalizeNumber(value.doubleValue);
    });
    return new VectorValue(values);
  }
  convertGeoPoint(value) {
    return new GeoPoint(normalizeNumber(value.latitude), normalizeNumber(value.longitude));
  }
  convertArray(arrayValue, serverTimestampBehavior) {
    return (arrayValue.values || []).map((value) => this.convertValue(value, serverTimestampBehavior));
  }
  convertServerTimestamp(value, serverTimestampBehavior) {
    switch (serverTimestampBehavior) {
      case "previous":
        const previousValue = getPreviousValue(value);
        if (previousValue == null) {
          return null;
        }
        return this.convertValue(previousValue, serverTimestampBehavior);
      case "estimate":
        return this.convertTimestamp(getLocalWriteTime(value));
      default:
        return null;
    }
  }
  convertTimestamp(value) {
    const normalizedValue = normalizeTimestamp(value);
    return new Timestamp(normalizedValue.seconds, normalizedValue.nanos);
  }
  convertDocumentKey(name4, expectedDatabaseId) {
    const resourcePath = ResourcePath.fromString(name4);
    hardAssert(isValidResourceName(resourcePath), 9688, { name: name4 });
    const databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));
    const key = new DocumentKey(resourcePath.popFirst(5));
    if (!databaseId.isEqual(expectedDatabaseId)) {
      logError(`Document ${key} contains a document reference within a different database (${databaseId.projectId}/${databaseId.database}) which is not supported. It will be treated as a reference in the current database (${expectedDatabaseId.projectId}/${expectedDatabaseId.database}) instead.`);
    }
    return key;
  }
};
function applyFirestoreDataConverter(converter, value, options) {
  let convertedValue;
  if (converter) {
    if (options && (options.merge || options.mergeFields)) {
      convertedValue = converter.toFirestore(value, options);
    } else {
      convertedValue = converter.toFirestore(value);
    }
  } else {
    convertedValue = value;
  }
  return convertedValue;
}
__name(applyFirestoreDataConverter, "applyFirestoreDataConverter");
var LiteUserDataWriter = class extends AbstractUserDataWriter {
  static {
    __name(this, "LiteUserDataWriter");
  }
  constructor(firestore) {
    super();
    this.firestore = firestore;
  }
  convertBytes(bytes) {
    return new Bytes(bytes);
  }
  convertReference(name4) {
    const key = this.convertDocumentKey(name4, this.firestore._databaseId);
    return new DocumentReference(
      this.firestore,
      /* converter= */
      null,
      key
    );
  }
};
function getDoc(reference) {
  reference = cast(reference, DocumentReference);
  const datastore = getDatastore(reference.firestore);
  const userDataWriter = new LiteUserDataWriter(reference.firestore);
  return invokeBatchGetDocumentsRpc(datastore, [reference._key]).then((result) => {
    hardAssert(result.length === 1, 15618);
    const document2 = result[0];
    return new DocumentSnapshot(reference.firestore, userDataWriter, reference._key, document2.isFoundDocument() ? document2 : null, reference.converter);
  });
}
__name(getDoc, "getDoc");
function getDocs(query2) {
  query2 = cast(query2, Query);
  validateHasExplicitOrderByForLimitToLast(query2._query);
  const datastore = getDatastore(query2.firestore);
  const userDataWriter = new LiteUserDataWriter(query2.firestore);
  return invokeRunQueryRpc(datastore, query2._query).then((result) => {
    const docs = result.map((doc2) => new QueryDocumentSnapshot(query2.firestore, userDataWriter, doc2.key, doc2, query2.converter));
    if (query2._query.limitType === "L") {
      docs.reverse();
    }
    return new QuerySnapshot(query2, docs);
  });
}
__name(getDocs, "getDocs");
function setDoc(reference, data, options) {
  reference = cast(reference, DocumentReference);
  const convertedValue = applyFirestoreDataConverter(reference.converter, data, options);
  const dataReader = newUserDataReader(reference.firestore);
  const parsed = parseSetData(dataReader, "setDoc", reference._key, convertedValue, reference.converter !== null, options);
  const datastore = getDatastore(reference.firestore);
  return invokeCommitRpc(datastore, [
    parsed.toMutation(reference._key, Precondition.none())
  ]);
}
__name(setDoc, "setDoc");
function updateDoc(reference, fieldOrUpdateData, value, ...moreFieldsAndValues) {
  reference = cast(reference, DocumentReference);
  const dataReader = newUserDataReader(reference.firestore);
  fieldOrUpdateData = getModularInstance(fieldOrUpdateData);
  let parsed;
  if (typeof fieldOrUpdateData === "string" || fieldOrUpdateData instanceof FieldPath) {
    parsed = parseUpdateVarargs(dataReader, "updateDoc", reference._key, fieldOrUpdateData, value, moreFieldsAndValues);
  } else {
    parsed = parseUpdateData(dataReader, "updateDoc", reference._key, fieldOrUpdateData);
  }
  const datastore = getDatastore(reference.firestore);
  return invokeCommitRpc(datastore, [
    parsed.toMutation(reference._key, Precondition.exists(true))
  ]);
}
__name(updateDoc, "updateDoc");
function deleteDoc(reference) {
  reference = cast(reference, DocumentReference);
  const datastore = getDatastore(reference.firestore);
  return invokeCommitRpc(datastore, [
    new DeleteMutation(reference._key, Precondition.none())
  ]);
}
__name(deleteDoc, "deleteDoc");
function addDoc(reference, data) {
  reference = cast(reference, CollectionReference);
  const docRef = doc(reference);
  const convertedValue = applyFirestoreDataConverter(reference.converter, data);
  const dataReader = newUserDataReader(reference.firestore);
  const parsed = parseSetData(dataReader, "addDoc", docRef._key, convertedValue, docRef.converter !== null, {});
  const datastore = getDatastore(reference.firestore);
  return invokeCommitRpc(datastore, [
    parsed.toMutation(docRef._key, Precondition.exists(false))
  ]).then(() => docRef);
}
__name(addDoc, "addDoc");
function getCount(query2) {
  const countQuerySpec = {
    count: count()
  };
  return getAggregate(query2, countQuerySpec);
}
__name(getCount, "getCount");
function getAggregate(query2, aggregateSpec) {
  const firestore = cast(query2.firestore, Firestore);
  const datastore = getDatastore(firestore);
  const internalAggregates = mapToArray(aggregateSpec, (aggregate, alias) => {
    return new AggregateImpl(alias, aggregate.aggregateType, aggregate._internalFieldPath);
  });
  return invokeRunAggregationQueryRpc(datastore, query2._query, internalAggregates).then((aggregateResult) => convertToAggregateQuerySnapshot(firestore, query2, aggregateResult));
}
__name(getAggregate, "getAggregate");
function convertToAggregateQuerySnapshot(firestore, query2, aggregateResult) {
  const userDataWriter = new LiteUserDataWriter(firestore);
  const querySnapshot = new AggregateQuerySnapshot(query2, userDataWriter, aggregateResult);
  return querySnapshot;
}
__name(convertToAggregateQuerySnapshot, "convertToAggregateQuerySnapshot");
function sum(field) {
  return new AggregateField("sum", fieldPathFromArgument$1("sum", field));
}
__name(sum, "sum");
function average(field) {
  return new AggregateField("avg", fieldPathFromArgument$1("average", field));
}
__name(average, "average");
function count() {
  return new AggregateField("count");
}
__name(count, "count");
function aggregateFieldEqual(left, right) {
  var _a, _b;
  return left instanceof AggregateField && right instanceof AggregateField && left.aggregateType === right.aggregateType && ((_a = left._internalFieldPath) === null || _a === void 0 ? void 0 : _a.canonicalString()) === ((_b = right._internalFieldPath) === null || _b === void 0 ? void 0 : _b.canonicalString());
}
__name(aggregateFieldEqual, "aggregateFieldEqual");
function aggregateQuerySnapshotEqual(left, right) {
  return queryEqual(left.query, right.query) && deepEqual(left.data(), right.data());
}
__name(aggregateQuerySnapshotEqual, "aggregateQuerySnapshotEqual");
function deleteField() {
  return new DeleteFieldValueImpl("deleteField");
}
__name(deleteField, "deleteField");
function serverTimestamp() {
  return new ServerTimestampFieldValueImpl("serverTimestamp");
}
__name(serverTimestamp, "serverTimestamp");
function arrayUnion(...elements) {
  return new ArrayUnionFieldValueImpl("arrayUnion", elements);
}
__name(arrayUnion, "arrayUnion");
function arrayRemove(...elements) {
  return new ArrayRemoveFieldValueImpl("arrayRemove", elements);
}
__name(arrayRemove, "arrayRemove");
function increment(n11) {
  return new NumericIncrementFieldValueImpl("increment", n11);
}
__name(increment, "increment");
function vector(values) {
  return new VectorValue(values);
}
__name(vector, "vector");
var WriteBatch = class {
  static {
    __name(this, "WriteBatch");
  }
  /** @hideconstructor */
  constructor(_firestore, _commitHandler) {
    this._firestore = _firestore;
    this._commitHandler = _commitHandler;
    this._mutations = [];
    this._committed = false;
    this._dataReader = newUserDataReader(_firestore);
  }
  set(documentRef, data, options) {
    this._verifyNotCommitted();
    const ref = validateReference(documentRef, this._firestore);
    const convertedValue = applyFirestoreDataConverter(ref.converter, data, options);
    const parsed = parseSetData(this._dataReader, "WriteBatch.set", ref._key, convertedValue, ref.converter !== null, options);
    this._mutations.push(parsed.toMutation(ref._key, Precondition.none()));
    return this;
  }
  update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {
    this._verifyNotCommitted();
    const ref = validateReference(documentRef, this._firestore);
    fieldOrUpdateData = getModularInstance(fieldOrUpdateData);
    let parsed;
    if (typeof fieldOrUpdateData === "string" || fieldOrUpdateData instanceof FieldPath) {
      parsed = parseUpdateVarargs(this._dataReader, "WriteBatch.update", ref._key, fieldOrUpdateData, value, moreFieldsAndValues);
    } else {
      parsed = parseUpdateData(this._dataReader, "WriteBatch.update", ref._key, fieldOrUpdateData);
    }
    this._mutations.push(parsed.toMutation(ref._key, Precondition.exists(true)));
    return this;
  }
  /**
   * Deletes the document referred to by the provided {@link DocumentReference}.
   *
   * @param documentRef - A reference to the document to be deleted.
   * @returns This `WriteBatch` instance. Used for chaining method calls.
   */
  delete(documentRef) {
    this._verifyNotCommitted();
    const ref = validateReference(documentRef, this._firestore);
    this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.none()));
    return this;
  }
  /**
   * Commits all of the writes in this write batch as a single atomic unit.
   *
   * The result of these writes will only be reflected in document reads that
   * occur after the returned promise resolves. If the client is offline, the
   * write fails. If you would like to see local modifications or buffer writes
   * until the client is online, use the full Firestore SDK.
   *
   * @returns A `Promise` resolved once all of the writes in the batch have been
   * successfully written to the backend as an atomic unit (note that it won't
   * resolve while you're offline).
   */
  commit() {
    this._verifyNotCommitted();
    this._committed = true;
    if (this._mutations.length > 0) {
      return this._commitHandler(this._mutations);
    }
    return Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed) {
      throw new FirestoreError(Code.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
    }
  }
};
function validateReference(documentRef, firestore) {
  documentRef = getModularInstance(documentRef);
  if (documentRef.firestore !== firestore) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  } else {
    return documentRef;
  }
}
__name(validateReference, "validateReference");
function writeBatch(firestore) {
  firestore = cast(firestore, Firestore);
  const datastore = getDatastore(firestore);
  return new WriteBatch(firestore, (writes) => invokeCommitRpc(datastore, writes));
}
__name(writeBatch, "writeBatch");
var DEFAULT_TRANSACTION_OPTIONS = {
  maxAttempts: 5
};
function validateTransactionOptions(options) {
  if (options.maxAttempts < 1) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, "Max attempts must be at least 1");
  }
}
__name(validateTransactionOptions, "validateTransactionOptions");
var Transaction$1 = class {
  static {
    __name(this, "Transaction$1");
  }
  constructor(datastore) {
    this.datastore = datastore;
    this.readVersions = /* @__PURE__ */ new Map();
    this.mutations = [];
    this.committed = false;
    this.lastTransactionError = null;
    this.writtenDocs = /* @__PURE__ */ new Set();
  }
  async lookup(keys) {
    this.ensureCommitNotCalled();
    if (this.mutations.length > 0) {
      this.lastTransactionError = new FirestoreError(Code.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
      throw this.lastTransactionError;
    }
    const docs = await invokeBatchGetDocumentsRpc(this.datastore, keys);
    docs.forEach((doc2) => this.recordVersion(doc2));
    return docs;
  }
  set(key, data) {
    this.write(data.toMutation(key, this.precondition(key)));
    this.writtenDocs.add(key.toString());
  }
  update(key, data) {
    try {
      this.write(data.toMutation(key, this.preconditionForUpdate(key)));
    } catch (e10) {
      this.lastTransactionError = e10;
    }
    this.writtenDocs.add(key.toString());
  }
  delete(key) {
    this.write(new DeleteMutation(key, this.precondition(key)));
    this.writtenDocs.add(key.toString());
  }
  async commit() {
    this.ensureCommitNotCalled();
    if (this.lastTransactionError) {
      throw this.lastTransactionError;
    }
    const unwritten = this.readVersions;
    this.mutations.forEach((mutation) => {
      unwritten.delete(mutation.key.toString());
    });
    unwritten.forEach((_, path) => {
      const key = DocumentKey.fromPath(path);
      this.mutations.push(new VerifyMutation(key, this.precondition(key)));
    });
    await invokeCommitRpc(this.datastore, this.mutations);
    this.committed = true;
  }
  recordVersion(doc2) {
    let docVersion;
    if (doc2.isFoundDocument()) {
      docVersion = doc2.version;
    } else if (doc2.isNoDocument()) {
      docVersion = SnapshotVersion.min();
    } else {
      throw fail(50498, {
        documentName: doc2.constructor.name
      });
    }
    const existingVersion = this.readVersions.get(doc2.key.toString());
    if (existingVersion) {
      if (!docVersion.isEqual(existingVersion)) {
        throw new FirestoreError(Code.ABORTED, "Document version changed between two reads.");
      }
    } else {
      this.readVersions.set(doc2.key.toString(), docVersion);
    }
  }
  /**
   * Returns the version of this document when it was read in this transaction,
   * as a precondition, or no precondition if it was not read.
   */
  precondition(key) {
    const version6 = this.readVersions.get(key.toString());
    if (!this.writtenDocs.has(key.toString()) && version6) {
      if (version6.isEqual(SnapshotVersion.min())) {
        return Precondition.exists(false);
      } else {
        return Precondition.updateTime(version6);
      }
    } else {
      return Precondition.none();
    }
  }
  /**
   * Returns the precondition for a document if the operation is an update.
   */
  preconditionForUpdate(key) {
    const version6 = this.readVersions.get(key.toString());
    if (!this.writtenDocs.has(key.toString()) && version6) {
      if (version6.isEqual(SnapshotVersion.min())) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      }
      return Precondition.updateTime(version6);
    } else {
      return Precondition.exists(true);
    }
  }
  write(mutation) {
    this.ensureCommitNotCalled();
    this.mutations.push(mutation);
  }
  ensureCommitNotCalled() {
  }
};
var TransactionRunner = class {
  static {
    __name(this, "TransactionRunner");
  }
  constructor(asyncQueue, datastore, options, updateFunction, deferred) {
    this.asyncQueue = asyncQueue;
    this.datastore = datastore;
    this.options = options;
    this.updateFunction = updateFunction;
    this.deferred = deferred;
    this.attemptsRemaining = options.maxAttempts;
    this.backoff = new ExponentialBackoff(
      this.asyncQueue,
      "transaction_retry"
      /* TimerId.TransactionRetry */
    );
  }
  /** Runs the transaction and sets the result on deferred. */
  run() {
    this.attemptsRemaining -= 1;
    this.runWithBackOff();
  }
  runWithBackOff() {
    this.backoff.backoffAndRun(async () => {
      const transaction = new Transaction$1(this.datastore);
      const userPromise = this.tryRunUpdateFunction(transaction);
      if (userPromise) {
        userPromise.then((result) => {
          this.asyncQueue.enqueueAndForget(() => {
            return transaction.commit().then(() => {
              this.deferred.resolve(result);
            }).catch((commitError) => {
              this.handleTransactionError(commitError);
            });
          });
        }).catch((userPromiseError) => {
          this.handleTransactionError(userPromiseError);
        });
      }
    });
  }
  tryRunUpdateFunction(transaction) {
    try {
      const userPromise = this.updateFunction(transaction);
      if (isNullOrUndefined(userPromise) || !userPromise.catch || !userPromise.then) {
        this.deferred.reject(Error("Transaction callback must return a Promise"));
        return null;
      }
      return userPromise;
    } catch (error) {
      this.deferred.reject(error);
      return null;
    }
  }
  handleTransactionError(error) {
    if (this.attemptsRemaining > 0 && this.isRetryableTransactionError(error)) {
      this.attemptsRemaining -= 1;
      this.asyncQueue.enqueueAndForget(() => {
        this.runWithBackOff();
        return Promise.resolve();
      });
    } else {
      this.deferred.reject(error);
    }
  }
  isRetryableTransactionError(error) {
    if (error.name === "FirebaseError") {
      const code = error.code;
      return code === "aborted" || code === "failed-precondition" || code === "already-exists" || !isPermanentError(code);
    }
    return false;
  }
};
var DelayedOperation = class _DelayedOperation {
  static {
    __name(this, "DelayedOperation");
  }
  constructor(asyncQueue, timerId, targetTimeMs, op, removalCallback) {
    this.asyncQueue = asyncQueue;
    this.timerId = timerId;
    this.targetTimeMs = targetTimeMs;
    this.op = op;
    this.removalCallback = removalCallback;
    this.deferred = new Deferred2();
    this.then = this.deferred.promise.then.bind(this.deferred.promise);
    this.deferred.promise.catch((err) => {
    });
  }
  get promise() {
    return this.deferred.promise;
  }
  /**
   * Creates and returns a DelayedOperation that has been scheduled to be
   * executed on the provided asyncQueue after the provided delayMs.
   *
   * @param asyncQueue - The queue to schedule the operation on.
   * @param id - A Timer ID identifying the type of operation this is.
   * @param delayMs - The delay (ms) before the operation should be scheduled.
   * @param op - The operation to run.
   * @param removalCallback - A callback to be called synchronously once the
   *   operation is executed or canceled, notifying the AsyncQueue to remove it
   *   from its delayedOperations list.
   *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and
   *   the DelayedOperation class public.
   */
  static createAndSchedule(asyncQueue, timerId, delayMs, op, removalCallback) {
    const targetTime = Date.now() + delayMs;
    const delayedOp = new _DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);
    delayedOp.start(delayMs);
    return delayedOp;
  }
  /**
   * Starts the timer. This is called immediately after construction by
   * createAndSchedule().
   */
  start(delayMs) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), delayMs);
  }
  /**
   * Queues the operation to run immediately (if it hasn't already been run or
   * canceled).
   */
  skipDelay() {
    return this.handleDelayElapsed();
  }
  /**
   * Cancels the operation if it hasn't already been executed or canceled. The
   * promise will be rejected.
   *
   * As long as the operation has not yet been run, calling cancel() provides a
   * guarantee that the operation will not be run.
   */
  cancel(reason) {
    if (this.timerHandle !== null) {
      this.clearTimeout();
      this.deferred.reject(new FirestoreError(Code.CANCELLED, "Operation cancelled" + (reason ? ": " + reason : "")));
    }
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => {
      if (this.timerHandle !== null) {
        this.clearTimeout();
        return this.op().then((result) => {
          return this.deferred.resolve(result);
        });
      } else {
        return Promise.resolve();
      }
    });
  }
  clearTimeout() {
    if (this.timerHandle !== null) {
      this.removalCallback(this);
      clearTimeout(this.timerHandle);
      this.timerHandle = null;
    }
  }
};
var LOG_TAG = "AsyncQueue";
var AsyncQueueImpl = class {
  static {
    __name(this, "AsyncQueueImpl");
  }
  constructor(tail = Promise.resolve()) {
    this.retryableOps = [];
    this._isShuttingDown = false;
    this.delayedOperations = [];
    this.failure = null;
    this.operationInProgress = false;
    this.skipNonRestrictedTasks = false;
    this.timerIdsToSkip = [];
    this.backoff = new ExponentialBackoff(
      this,
      "async_queue_retry"
      /* TimerId.AsyncQueueRetry */
    );
    this.visibilityHandler = () => {
      this.backoff.skipBackoff();
    };
    this.tail = tail;
  }
  get isShuttingDown() {
    return this._isShuttingDown;
  }
  /**
   * Adds a new operation to the queue without waiting for it to complete (i.e.
   * we ignore the Promise result).
   */
  enqueueAndForget(op) {
    this.enqueue(op);
  }
  enqueueAndForgetEvenWhileRestricted(op) {
    this.verifyNotFailed();
    this.enqueueInternal(op);
  }
  enterRestrictedMode(purgeExistingTasks) {
    if (!this._isShuttingDown) {
      this._isShuttingDown = true;
      this.skipNonRestrictedTasks = purgeExistingTasks || false;
    }
  }
  enqueue(op) {
    this.verifyNotFailed();
    if (this._isShuttingDown) {
      return new Promise(() => {
      });
    }
    const task = new Deferred2();
    return this.enqueueInternal(() => {
      if (this._isShuttingDown && this.skipNonRestrictedTasks) {
        return Promise.resolve();
      }
      op().then(task.resolve, task.reject);
      return task.promise;
    }).then(() => task.promise);
  }
  enqueueRetryable(op) {
    this.enqueueAndForget(() => {
      this.retryableOps.push(op);
      return this.retryNextOp();
    });
  }
  /**
   * Runs the next operation from the retryable queue. If the operation fails,
   * reschedules with backoff.
   */
  async retryNextOp() {
    if (this.retryableOps.length === 0) {
      return;
    }
    try {
      await this.retryableOps[0]();
      this.retryableOps.shift();
      this.backoff.reset();
    } catch (e10) {
      if (isIndexedDbTransactionError(e10)) {
        logDebug(LOG_TAG, "Operation failed with retryable error: " + e10);
      } else {
        throw e10;
      }
    }
    if (this.retryableOps.length > 0) {
      this.backoff.backoffAndRun(() => this.retryNextOp());
    }
  }
  enqueueInternal(op) {
    const newTail = this.tail.then(() => {
      this.operationInProgress = true;
      return op().catch((error) => {
        this.failure = error;
        this.operationInProgress = false;
        const message = getMessageOrStack(error);
        logError("INTERNAL UNHANDLED ERROR: ", message);
        throw error;
      }).then((result) => {
        this.operationInProgress = false;
        return result;
      });
    });
    this.tail = newTail;
    return newTail;
  }
  enqueueAfterDelay(timerId, delayMs, op) {
    this.verifyNotFailed();
    if (this.timerIdsToSkip.indexOf(timerId) > -1) {
      delayMs = 0;
    }
    const delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, (removedOp) => this.removeDelayedOperation(removedOp));
    this.delayedOperations.push(delayedOp);
    return delayedOp;
  }
  verifyNotFailed() {
    if (this.failure) {
      fail(47125, {
        messageOrStack: getMessageOrStack(this.failure)
      });
    }
  }
  verifyOperationInProgress() {
  }
  /**
   * Waits until all currently queued tasks are finished executing. Delayed
   * operations are not run.
   */
  async drain() {
    let currentTail;
    do {
      currentTail = this.tail;
      await currentTail;
    } while (currentTail !== this.tail);
  }
  /**
   * For Tests: Determine if a delayed operation with a particular TimerId
   * exists.
   */
  containsDelayedOperation(timerId) {
    for (const op of this.delayedOperations) {
      if (op.timerId === timerId) {
        return true;
      }
    }
    return false;
  }
  /**
   * For Tests: Runs some or all delayed operations early.
   *
   * @param lastTimerId - Delayed operations up to and including this TimerId
   * will be drained. Pass TimerId.All to run all delayed operations.
   * @returns a Promise that resolves once all operations have been run.
   */
  runAllDelayedOperationsUntil(lastTimerId) {
    return this.drain().then(() => {
      this.delayedOperations.sort((a22, b7) => a22.targetTimeMs - b7.targetTimeMs);
      for (const op of this.delayedOperations) {
        op.skipDelay();
        if (lastTimerId !== "all" && op.timerId === lastTimerId) {
          break;
        }
      }
      return this.drain();
    });
  }
  /**
   * For Tests: Skip all subsequent delays for a timer id.
   */
  skipDelaysForTimerId(timerId) {
    this.timerIdsToSkip.push(timerId);
  }
  /** Called once a DelayedOperation is run or canceled. */
  removeDelayedOperation(op) {
    const index = this.delayedOperations.indexOf(op);
    this.delayedOperations.splice(index, 1);
  }
};
function newAsyncQueue() {
  return new AsyncQueueImpl();
}
__name(newAsyncQueue, "newAsyncQueue");
function getMessageOrStack(error) {
  let message = error.message || "";
  if (error.stack) {
    if (error.stack.includes(error.message)) {
      message = error.stack;
    } else {
      message = error.message + "\n" + error.stack;
    }
  }
  return message;
}
__name(getMessageOrStack, "getMessageOrStack");
var Transaction = class {
  static {
    __name(this, "Transaction");
  }
  /** @hideconstructor */
  constructor(_firestore, _transaction) {
    this._firestore = _firestore;
    this._transaction = _transaction;
    this._dataReader = newUserDataReader(_firestore);
  }
  /**
   * Reads the document referenced by the provided {@link DocumentReference}.
   *
   * @param documentRef - A reference to the document to be read.
   * @returns A `DocumentSnapshot` with the read data.
   */
  get(documentRef) {
    const ref = validateReference(documentRef, this._firestore);
    const userDataWriter = new LiteUserDataWriter(this._firestore);
    return this._transaction.lookup([ref._key]).then((docs) => {
      if (!docs || docs.length !== 1) {
        return fail(24041);
      }
      const doc2 = docs[0];
      if (doc2.isFoundDocument()) {
        return new DocumentSnapshot(this._firestore, userDataWriter, doc2.key, doc2, ref.converter);
      } else if (doc2.isNoDocument()) {
        return new DocumentSnapshot(this._firestore, userDataWriter, ref._key, null, ref.converter);
      } else {
        throw fail(18433, {
          doc: doc2
        });
      }
    });
  }
  set(documentRef, value, options) {
    const ref = validateReference(documentRef, this._firestore);
    const convertedValue = applyFirestoreDataConverter(ref.converter, value, options);
    const parsed = parseSetData(this._dataReader, "Transaction.set", ref._key, convertedValue, ref.converter !== null, options);
    this._transaction.set(ref._key, parsed);
    return this;
  }
  update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {
    const ref = validateReference(documentRef, this._firestore);
    fieldOrUpdateData = getModularInstance(fieldOrUpdateData);
    let parsed;
    if (typeof fieldOrUpdateData === "string" || fieldOrUpdateData instanceof FieldPath) {
      parsed = parseUpdateVarargs(this._dataReader, "Transaction.update", ref._key, fieldOrUpdateData, value, moreFieldsAndValues);
    } else {
      parsed = parseUpdateData(this._dataReader, "Transaction.update", ref._key, fieldOrUpdateData);
    }
    this._transaction.update(ref._key, parsed);
    return this;
  }
  /**
   * Deletes the document referred to by the provided {@link DocumentReference}.
   *
   * @param documentRef - A reference to the document to be deleted.
   * @returns This `Transaction` instance. Used for chaining method calls.
   */
  delete(documentRef) {
    const ref = validateReference(documentRef, this._firestore);
    this._transaction.delete(ref._key);
    return this;
  }
};
function runTransaction(firestore, updateFunction, options) {
  firestore = cast(firestore, Firestore);
  const datastore = getDatastore(firestore);
  const optionsWithDefaults = Object.assign(Object.assign({}, DEFAULT_TRANSACTION_OPTIONS), options);
  validateTransactionOptions(optionsWithDefaults);
  const deferred = new Deferred2();
  new TransactionRunner(newAsyncQueue(), datastore, optionsWithDefaults, (internalTransaction) => updateFunction(new Transaction(firestore, internalTransaction)), deferred).run();
  return deferred.promise;
}
__name(runTransaction, "runTransaction");
registerFirestore();

// node_modules/@mahindar5/common-lib/dist/chunk-KK3BJ3KY.js
var o6 = j(() => {
  try {
    return getApp();
  } catch {
    return initializeApp(a13);
  }
}, "getFirebaseApp"), s8 = o6(), A = getFirestore(s8);

// node_modules/@mahindar5/common-lib/dist/chunk-DFTPVKTA.js
var h6 = class {
  static {
    __name(this, "h");
  }
  static {
    j(this, "ShawMonitorJob");
  }
  configData = { displayName: "MonitorJob", isEnabled: false, inputs: { usernameAndPassword: "", intervalInSeconds: 100 } };
  async run(t11, e10) {
    if (!t11.inputs?.usernameAndPassword) throw new Error("ShawMonitorJob usernameAndPassword not found in extensionData");
    let n11 = { "content-type": "application/x-www-form-urlencoded", Cookie: "DUKSID=sess8800024879071832" };
    await fetch(new Request("http://10.0.0.1/check.jst"), { headers: n11, body: t11.inputs.usernameAndPassword, method: "post" });
    let o21 = await (await fetch(new Request("http://10.0.0.1/connected_devices_computers.jst"), { headers: n11 })).text(), a22 = this.parseMacData(o21);
    a22.timestamp = (/* @__PURE__ */ new Date()).toISOString();
    let i18 = "previousMacEntry", c21 = await a12.getItem(i18) || {};
    if (e10 || this.hasChanges(c21, a22)) {
      let { macInOuts: m18, version: r9 } = await this.generateOutput(a22), u20 = this.getDeviceNames(a22);
      await this.storeOutput(m18, a22, u20, r9), await a12.setItem(i18, a22);
    }
  }
  getDeviceNames(t11) {
    let e10 = j((o21, a22) => o21.reduce((i18, c21, m18) => (i18[c21] = a22[m18], i18), {}), "mapMacToHostName"), n11 = e10(t11.onlineHostMAC, t11.onlineHostNameArr), s18 = e10(t11.offlineHostMAC, t11.offlineHostNameArr);
    return { ...n11, ...s18 };
  }
  parseMacData(t11) {
    let e10 = t11.indexOf("var onlineDeviceNum"), n11 = t11.indexOf("$(document).ready", e10);
    return t11.slice(e10, n11).replaceAll(";", "").split(`
`).map((o21) => o21.split("var")[1]?.split("=")).filter(Boolean).reduce((o21, [a22, i18]) => (o21[a22.trim()] = JSON.parse(i18.trim()), o21), {});
  }
  hasChanges(t11, e10) {
    let n11 = j((s18, o21) => !!(s18?.length !== o21?.length || s18?.length && JSON.stringify(s18.sort()) !== JSON.stringify(o21.sort())), "compareArrays");
    return n11(t11?.onlineHostMAC, e10?.onlineHostMAC) || n11(t11?.offlineHostMAC, e10?.offlineHostMAC);
  }
  async generateOutput(t11) {
    let e10 = await this.getData(), n11 = e10?.data?.macInOutsJson || {}, s18 = e10?.data?.prevShawHttpRes || {}, o21 = e10?.data?.version || 0, a22 = j((i18, c21, m18) => {
      i18.forEach((r9) => {
        if (!c21?.includes(r9)) {
          n11[r9] ??= [];
          let u20 = n11[r9][0], w4 = (/* @__PURE__ */ new Date()).toISOString();
          (!u20 || u20.type !== m18) && (u20 && (u20.endTimestamp = w4), n11[r9].unshift({ type: m18, timestamp: w4 }), n11[r9] = n11[r9].slice(0, 200));
        }
      });
    }, "processMacEntries");
    return a22(t11.onlineHostMAC, s18?.onlineHostMAC, "added"), a22(s18?.onlineHostMAC || [], t11.onlineHostMAC, "removed"), { macInOuts: n11, version: o21 };
  }
  async getData() {
    let t11 = doc(A, "CacheServiceData", "ShawDataNewFormat2"), e10 = await getDoc(t11);
    return { id: e10.id, data: e10.data() };
  }
  async storeOutput(t11, e10, n11, s18) {
    let o21 = doc(A, "CacheServiceData", "ShawDataDeviceNames");
    await setDoc(o21, { deviceNames: n11, timestamp: (/* @__PURE__ */ new Date()).toISOString() }, { merge: true }), await runTransaction(A, async (a22) => {
      let i18 = doc(A, "CacheServiceData", "ShawDataNewFormat2"), c21 = await a22.get(i18);
      if (c21.exists() && c21.data().version !== s18) throw new Error("Document version mismatch");
      let m18 = { macInOutsJson: t11, prevShawHttpRes: e10, timestamp: (/* @__PURE__ */ new Date()).toISOString(), version: Date.now() };
      a22.set(i18, m18, { merge: true });
    });
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-DB5WQN6V.js
var t4 = class {
  static {
    __name(this, "t");
  }
  static {
    j(this, "Tab3MonitorJob");
  }
  configData = { displayName: "Tab3MonitorJob", isEnabled: false, inputs: { intervalInSeconds: 50, midEncr: "", passwordEncr: "" } };
  async run(n11, s18) {
    if (!n11.inputs?.midEncr || !n11.inputs?.passwordEncr) throw new Error("jobConfigData: MIDEncr or MIDPasswordEncr not found in extension data");
    fetch("https://api.bharatmatrimony.com/applogin/loginwithdet.php", { body: `ID=${n11.inputs.midEncr}&PASSWORD=${n11.inputs.passwordEncr}&FRMLOGIN=1&ltype=1&APPTYPE=300`, headers: { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" }, method: "Post" });
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-WJIGYJAW.js
var i6 = class {
  static {
    __name(this, "i");
  }
  static {
    j(this, "TeamsReloadJob");
  }
  configData = { displayName: "TeamsOnlineJob", isEnabled: false, inputs: { intervalInSeconds: 240 } };
  async run(e10, s18) {
    let a22 = await this.getTeamsTabs();
    a22.length === 0 ? await this.openTeamsTab() : a22.length === 1 ? a22[0].id && await chrome.tabs.reload(a22[0].id) : (await this.closeExtraTeamsTabs(a22, true), a22[0].id && await chrome.tabs.reload(a22[0].id));
  }
  async stop(e10) {
    let s18 = await this.getTeamsTabs();
    s18.length !== 0 && await this.closeExtraTeamsTabs(s18);
  }
  async getEligibility(e10) {
    if (!chrome?.tabs) throw new Error("Chrome tabs not available");
    return true;
  }
  async getTeamsTabs() {
    return (await chrome.tabs.query({})).filter((s18) => s18.url?.includes("teams.cloud.microsoft"));
  }
  async openTeamsTab() {
    await chrome.tabs.create({ url: "https://teams.cloud.microsoft" });
  }
  async closeExtraTeamsTabs(e10, s18 = false) {
    s18 && (e10 = e10.slice(1));
    let a22 = e10.map((t11) => {
      if (t11.id) return chrome.tabs.remove(t11.id);
    });
    await Promise.all(a22);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-MI7GEP3L.js
var u7 = { "x-requested-with": "XMLHttpRequest" }, d5 = class {
  static {
    __name(this, "d");
  }
  static {
    j(this, "USVisaDatesMonitorJob");
  }
  userEmail = "";
  userPassword = "";
  url = "";
  scheduleNumber = "";
  centerNumber = "";
  desiredDate = "";
  monitorTimesEnabled = false;
  configData = { displayName: "USVisaDatesMonitorJob", isEnabled: false, inputs: { intervalInSeconds: 0, userEmail: "", userPassword: "", url: "", scheduleNumber: "", centerNumber: "", desiredDate: "", webhookUrl: "", monitorTimesEnabled: false } };
  constructor() {
  }
  setInputData(t11) {
    let { userEmail: i18, userPassword: s18, url: n11, scheduleNumber: a22, centerNumber: e10, desiredDate: r9, monitorTimesEnabled: o21 } = t11.inputs;
    this.userEmail = i18, this.userPassword = s18, this.url = n11, this.scheduleNumber = a22, this.centerNumber = e10, this.desiredDate = r9 || "2025-12-31", this.monitorTimesEnabled = o21;
  }
  async run(t11, i18) {
    this.setInputData(t11);
    let s18 = await this.getDays();
    if (s18.error && (await this.signIn(), s18 = await this.getDays(), s18.error)) throw new Error(s18.error);
    console.log(`${(/* @__PURE__ */ new Date()).toLocaleString()}: Dates: ${s18.map((e10) => e10.date).join(",")}`);
    let n11 = s18.filter((e10) => e10.date < this.desiredDate).sort((e10, r9) => e10.date - r9.date), a22 = n11.length > 0 ? n11[0].date : null;
    if (a22) {
      if (!this.monitorTimesEnabled) return { message: `Earliest date: ${a22}
Available dates: ${n11.map((c21) => c21.date).join(", ")}` };
      let e10 = await this.getTimes(a22);
      if (e10.error && (await this.signIn(), e10 = await this.getTimes(a22), e10.error)) throw new Error(e10.error);
      let { available_times: r9, business_times: o21 } = e10;
      if (r9.length > 0) return { message: `Earliest date: ${a22}
Available dates: ${n11.map((c21) => c21.date).join(", ")}
Available times: ${r9.join(", ")}` };
    }
  }
  async signIn() {
    let t11 = `${this.url}/en-ca/niv/users/sign_in`, n11 = (await (await fetch(t11)).text()).match(/<meta[^>]*name="csrf-token"[^>]*content="([^"]*)"[^>]*>/)?.[1], a22 = new URLSearchParams({ "user[email]": this.userEmail, "user[password]": this.userPassword, policy_confirmed: "1", commit: "Sign In" }).toString(), { headers: e10 } = await fetch(t11, { headers: { "content-type": "application/x-www-form-urlencoded; charset=UTF-8", "x-requested-with": "XMLHttpRequest", "x-csrf-token": n11 || "" }, body: a22, method: "POST" }), r9 = e10.get("Session-Id"), o21 = e10.get("X-Yatri-Email");
    return r9 && o21 ? (console.log(`${(/* @__PURE__ */ new Date()).toLocaleString()}: Sign in successful`), true) : false;
  }
  async fetchEndpoint(t11) {
    let i18 = `${this.url}${t11}`;
    return await (await fetch(i18, { headers: u7 })).json();
  }
  async getTimes(t11) {
    let i18 = `/en-ca/niv/schedule/${this.scheduleNumber}/appointment/times/${this.centerNumber}.json?date=${t11}&appointments[expedite]=false`;
    return await this.fetchEndpoint(i18);
  }
  async getDays() {
    let t11 = `/en-ca/niv/schedule/${this.scheduleNumber}/appointment/days/${this.centerNumber}.json?appointments[expedite]=false`;
    return await this.fetchEndpoint(t11);
  }
  async signOut() {
    await fetch(`${this.url}/en-ca/niv/users/sign_out`);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-LW6CDDCU.js
var f9 = class {
  static {
    __name(this, "f");
  }
  static {
    j(this, "ICBCServicesJob");
  }
  configData = { displayName: "ICBCServicesJob", isEnabled: false, inputs: { intervalInSeconds: 60, dates: "20250215", slotTimes: "1400,1420,1430,1450", webhookUrl: "" } };
  async run(a22, t11) {
    let { dates: n11, slotTimes: e10, intervalInSeconds: i18 } = a22.inputs, c21 = await (await fetch("https://reservations.icbc.com/icbc/appointments/ReserveTime/TimeSelection?pageId=fa153f42-4646-40fc-98ed-aa395009644b&buttonId=e0a5a46a-f1f5-468b-95a1-a2c41997428d&culture=en")).text(), o21 = this.extractAndFilterSlots(c21, n11, e10);
    if (Object.keys(o21).length > 0) return { message: Object.entries(o21).map(([l14, r9]) => `${l14}: ${r9.join(", ")}`).join(`
`) };
  }
  extractAndFilterSlots(a22, t11, n11) {
    let e10 = {}, i18 = {}, m18 = /<span class="header-text">(.*?)<\/span>/g, c21 = /<span class="mdc-button__label available-time">(.*?)<\/span>/g, o21, s18 = null, l14 = a22.split(`
`);
    for (let r9 of l14) {
      o21 = m18.exec(r9), o21 && (s18 = this.formatDateToYYYYMMDD(o21[1]), s18 && (i18[s18] = []));
      let p15 = c21.exec(r9);
      if (p15 && s18) {
        let g10 = this.convertICBCTimeToHHMM(p15[1]);
        if (i18[s18].push(g10), t11 && n11) {
          let u20 = t11.includes(s18), b7 = n11.includes(g10);
          u20 && b7 && (e10[s18] ||= []).push(g10);
        }
      }
    }
    return console.log("All slots:", i18), t11 && n11 ? e10 : i18;
  }
  convertICBCTimeToHHMM(a22) {
    let [t11, n11] = a22.split(" "), [e10, i18] = t11.split(":").map(Number);
    return n11.toUpperCase() === "PM" && e10 !== 12 && (e10 += 12), n11.toUpperCase() === "AM" && e10 === 12 && (e10 = 0), `${String(e10).padStart(2, "0")}${String(i18).padStart(2, "0")}`;
  }
  formatDateToYYYYMMDD(a22) {
    let t11 = new Date(a22);
    return isNaN(t11.getTime()) ? null : `${t11.getFullYear()}${String(t11.getMonth() + 1).padStart(2, "0")}${String(t11.getDate()).padStart(2, "0")}`;
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-Q2KIIN7G.js
var c6 = c2(l5), o7 = c2(g2), D4 = class {
  static {
    __name(this, "D");
  }
  static {
    j(this, "IcmMonitorJob");
  }
  successfullyAssignedIds = /* @__PURE__ */ new Set();
  jobConfigData = null;
  constructor() {
    globalThis.assignIncidents = this.assignIncidents.bind(this), globalThis.assignIncidentsWithAlias = this.assignIncidentsWithAlias.bind(this);
  }
  configData = { displayName: "IcmMonitorJob", isEnabled: false, inputs: { intervalInMinutes: 5, aliasesCommentFilter: "", enableAutoAcknowledge: false, acknowledgeIfOwnerAlias: "", assignmentAliasSystem: "", assignmentAliasRegular: "", startDate: "20250526", endDate: "20250601", startTimeOfDay: "09:00", endTimeOfDay: "15:00", webhookUrl: "" } };
  async run(s18, t11) {
    this.jobConfigData = s18;
    let e10 = await c6.fetchAccessToken();
    if (!e10) throw new Error("Failed to fetch access token");
    let a22 = (await c6.getApiData(e10, null, "icmCount"))?.data?.value;
    if (a22) {
      let n11 = await this.fetchIncidentDetails(e10);
      console.log("Incident details:", n11);
      let d15 = null;
      try {
        await Promise.all(n11.outageDetails?.map(async (g10) => {
          let l14 = n11.incidents?.data?.value?.find((y12) => y12.Id === g10?.incidentId), h12 = o7.isSystemIcm(l14);
          if (o7.shouldAcknowledgeIncident(l14, s18.inputs) && (await c6.acknowledgeIncident(e10, l14.Id), o7.shouldAssignIncident(l14, s18.inputs, h12, this.successfullyAssignedIds))) {
            let y12 = h12 ? s18.inputs.assignmentAliasSystem : s18.inputs.assignmentAliasRegular, w4 = o7.customAlias(l14);
            y12 && await c6.assignIncident(e10, l14.Id, w4 || y12);
          }
        }) || []);
      } catch (g10) {
        d15 = g10, console.error("Error processing incidents:", g10);
      }
      let r9 = o7.generateOutageDetails(n11.outageDetails, n11.incidents?.data?.value), u20 = o7.formatOutageMessage(r9), m18 = o7.formatDetailedOutageMessage(r9);
      return console.log(m18), d15 && (u20 = u20 + `

Error processing incidents: ` + d15.message), { title: "Acknowledge Count: " + a22, message: u20 };
    }
  }
  async getFullIncidentDetails(s18, t11) {
    return await c6.getFullIncidentDetails(s18, t11);
  }
  async fetchIncidentDetails(s18) {
    let t11 = await c6.getApiData(s18, null, "incidents"), e10 = t11?.data?.value?.map((a22) => a22.Id), i18 = await Promise.all([this.fetchData(s18, "outageDetails", e10)]);
    return { incidents: t11, outageDetails: i18[0] || [], incidentHistoryEntries: [], incidentDescriptionEntries: [] };
  }
  async fetchData(s18, t11, e10 = []) {
    return Promise.all(e10.map((i18) => c6.getApiData(s18, i18, t11)));
  }
  async assignIncidents(s18) {
    let t11 = this.jobConfigData;
    if (!t11) {
      console.error("Error");
      return;
    }
    let e10 = await c6.fetchAccessToken();
    if (!e10) throw new Error("Failed to fetch access token");
    let i18 = [], a22 = null;
    try {
      await Promise.all(s18.map(async (n11) => {
        try {
          let r9 = (await c6.getApiData(e10, n11, "incidentDetails"))?.data;
          if (!r9) {
            i18.push({ incidentId: n11, status: "not found" });
            return;
          }
          let u20 = o7.isSystemIcm(r9), m18 = [];
          if (o7.shouldAssignIncident(r9, t11.inputs, u20, this.successfullyAssignedIds)) {
            let g10 = u20 ? t11.inputs.assignmentAliasSystem : t11.inputs.assignmentAliasRegular, l14 = o7.customAlias(r9);
            g10 && (await c6.assignIncident(e10, r9.Id, l14 || g10), m18.push("assigned"));
          }
          i18.push({ incidentId: n11, status: "processed", actions: m18.length > 0 ? m18 : ["no action needed"], isSystemIcm: u20 });
        } catch (d15) {
          console.error(`Error processing incident ${n11}:`, d15), i18.push({ incidentId: n11, status: "error", error: d15?.message });
        }
      }));
    } catch (n11) {
      a22 = n11, console.error("Error processing incidents:", n11);
    }
    return { processedIncidents: i18, totalProcessed: i18.length, error: a22?.message };
  }
  async assignIncidentsWithAlias(s18, t11) {
    let e10 = await c6.fetchAccessToken();
    if (!e10) throw new Error("Failed to fetch access token");
    let i18 = s18.map((a22) => typeof a22 == "string" ? Number(a22) : a22);
    return Promise.all(i18.map((a22) => c6.assignIncident(e10, a22, t11)));
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-KZWI36A6.js
function n5() {
  return typeof window < "u" && typeof window.document < "u";
}
__name(n5, "n");
j(n5, "isBrowser");
function t5() {
  return typeof process < "u" && process.versions != null && process.versions.node != null;
}
__name(t5, "t");
j(t5, "isNode");
function s9() {
  return typeof chrome < "u" && chrome?.runtime?.id != null;
}
__name(s9, "s");
j(s9, "isChromeExtension");
function i7() {
  return n5() && !!window.__MY_EXTENSION__;
}
__name(i7, "i");
j(i7, "isExtensionInstalled");
async function c7(r9) {
  if (n5()) return window.location.href = r9, { redirected: true, environment: "browser" };
  throw new Error("Cannot redirect in Node.js environment. Please provide a response object or onRedirect callback.");
}
__name(c7, "c");
j(c7, "handleRedirect");
function d6(r9) {
  if (n5()) return { queryParams: new URLSearchParams(window.location.search), hashParams: new URLSearchParams(window.location.hash.substring(1)) };
  if (r9) {
    let o21 = new URLSearchParams(r9.url?.split("?")[1] || ""), a22 = new URLSearchParams();
    return { queryParams: o21, hashParams: a22 };
  } else return { queryParams: new URLSearchParams(), hashParams: new URLSearchParams() };
}
__name(d6, "d");
j(d6, "getCurrentUrlParams");

// node_modules/@mahindar5/common-lib/dist/chunk-2VCQPIGM.js
var t6 = class {
  static {
    __name(this, "t");
  }
  static {
    j(this, "KeepAwakeJob");
  }
  isActivated = false;
  configData = { displayName: "KeepAwakeJob", isEnabled: false, inputs: { level: "", intervalInSeconds: 60 } };
  async run(i18, r9) {
    if (chrome?.power && !this.isActivated) {
      let e10 = i18.inputs?.level || "display";
      ["display", "system"].includes(e10) || (e10 = "display"), await chrome.power.requestKeepAwake(e10), this.isActivated = true;
    }
  }
  async getEligibility() {
    if (!chrome?.power) throw new Error("Chrome power not available");
    return true;
  }
  async stop(i18) {
    s9() && chrome?.power && (await chrome.power.releaseKeepAwake(), this.isActivated = false);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-AF67D6EQ.js
var p8 = class {
  static {
    __name(this, "p");
  }
  static {
    j(this, "PCExpressProductMonitorJob");
  }
  configData = { displayName: "PCExpressProductMonitorJob", isEnabled: false, inputs: { intervalInSeconds: 3600, towns: "Abbotsford,Vancouver,Surrey,Delta,West Vancouver,Coquitlam,Maple Ridge,Langley,North Vancouver,Burnaby,Richmond,Port Coquitlam,Pitt Meadows", productUrl: "https://api.pcexpress.ca/pcx-bff/api/v1/products/21614304_EA", webhookUrl: "" } };
  async run(n11, c21) {
    let s18 = n11.inputs?.towns?.split(",").map((e10) => e10.trim()).filter(Boolean) || [], i18 = n11.inputs?.productUrl || "", o21 = await this.checkStoreUrls(await this.getStores(s18, "https://www.realcanadiansuperstore.ca/api/pickup-locations"), i18);
    if (o21.length > 0) {
      let e10 = o21.map((r9) => `${r9.storeName} (${r9.town})`).join(", "), a22 = o21.map((r9) => `${r9.storeId} (${r9.town}) ${r9.storeName}`).join(`
`);
      return console.log(`Product available at: ${a22}`, o21), { message: `Product available at: ${e10}` };
    }
  }
  async getStores(n11, c21) {
    try {
      let i18 = await (await fetch(c21)).json(), t11 = [], o21 = /* @__PURE__ */ new Set();
      return i18.filter((e10) => e10.address.region === "British Columbia" && n11.includes(e10.address.town)).forEach((e10) => {
        let a22 = `${e10.storeId}_${e10.address.town}-${e10.storeBannerName}`;
        o21.has(a22) || (o21.add(a22), t11.push({ town: e10.address.town, storeName: e10.storeBannerId, storeId: e10.storeId }));
      }), t11.sort((e10, a22) => e10.town < a22.town ? -1 : e10.town > a22.town ? 1 : e10.storeName < a22.storeName ? -1 : e10.storeName > a22.storeName ? 1 : 0);
    } catch (s18) {
      return console.error("Error fetching stores:", s18?.message), [];
    }
  }
  async checkStoreUrls(n11, c21) {
    let s18 = [];
    for (let i18 = 0; i18 < n11.length; i18++) {
      let t11 = n11[i18], o21 = /* @__PURE__ */ new Date(), e10 = `${o21.getDate().toString().padStart(2, "0")}${(o21.getMonth() + 1).toString().padStart(2, "0")}${o21.getFullYear()}`, a22 = `${c21}?lang=en&date=${e10}&pickupType=STORE&storeId=${t11.storeId}&banner=${t11.storeName}`;
      try {
        (await fetch(a22, { method: "GET", headers: { "x-apikey": "C1xujSegT5j3ap3yexJjqhOfELwGKYvz" } })).status === 200 ? (s18.push(t11), console.log(`available at Store: ${t11.storeName} (${t11.town})`)) : console.log(`not available at Store: ${t11.storeName} (${t11.town})`);
      } catch (r9) {
        console.error(`Error checking store ${t11.storeId}:`, r9?.message);
      }
      await new Promise((r9) => setTimeout(r9, 100));
    }
    return s18;
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-BPIAVP5T.js
var n6 = "CacheServiceData", s10 = class {
  static {
    __name(this, "s");
  }
  static {
    j(this, "FirestoreCacheService");
  }
  async setItem(e10, t11) {
    let r9 = doc(A, n6, e10);
    await setDoc(r9, { value: t11 });
  }
  async removeItem(e10) {
    let t11 = doc(A, n6, e10);
    await deleteDoc(t11);
  }
  async getItem(e10) {
    let t11 = doc(A, n6, e10), r9 = await getDoc(t11);
    return r9.exists() && r9.data().value || null;
  }
}, u8 = c2(c3, [c2(s10)], "firestoreService");
function y7(m18) {
  return g3({ ...m18, cacheService: u8 });
}
__name(y7, "y");
j(y7, "FirestoreCacheLoader");

// node_modules/@mahindar5/common-lib/dist/chunk-L2GO4QT4.js
var o8 = class {
  static {
    __name(this, "o");
  }
  static {
    j(this, "SessionStorageCacheService");
  }
  async setItem(e10, c21) {
    sessionStorage.setItem(e10, c21);
  }
  async removeItem(e10) {
    sessionStorage.removeItem(e10);
  }
  async getItem(e10) {
    return sessionStorage.getItem(e10);
  }
}, m11 = c2(c3, [c2(o8)], "sessionStorageService");
function S(s18) {
  return g3({ ...s18, cacheService: m11 });
}
__name(S, "S");
j(S, "SessionStorageCacheLoader");

// node_modules/@mahindar5/common-lib/dist/chunk-WOBZT5ML.js
var i8 = class {
  static {
    __name(this, "i");
  }
  static {
    j(this, "InMemoryCacheService");
  }
  cache = /* @__PURE__ */ new Map();
  async setItem(e10, s18) {
    this.cache.set(e10, s18);
  }
  async removeItem(e10) {
    this.cache.delete(e10);
  }
  async getItem(e10) {
    return this.cache.get(e10) ?? null;
  }
}, a14 = c2(c3, [c2(i8)], "inMemoryService");
function v4(c21) {
  return g3({ ...c21, cacheService: a14 });
}
__name(v4, "v");
j(v4, "InMemoryCacheLoader");

// node_modules/@mahindar5/common-lib/dist/chunk-CR7XCY5F.js
function a15() {
  let e10 = globalThis.exec, o21 = globalThis.createServer, t11 = globalThis.parse;
  return { exec: e10, createServer: o21, parse: t11 };
}
__name(a15, "a");
j(a15, "loadHttpModulesFromGlobal");
function r4() {
  let e10 = globalThis.fs, o21 = globalThis.os, t11 = globalThis.path;
  return { fs: e10, os: o21, path: t11 };
}
__name(r4, "r");
j(r4, "loadFileSystemModulesFromGlobal");

// node_modules/@mahindar5/common-lib/dist/chunk-M4Y665S4.js
var c8 = class r5 {
  static {
    __name(this, "r");
  }
  static {
    j(this, "LocalFileSystemCacheService");
  }
  data = {};
  storagePath = "";
  lockPath = "";
  initialized = false;
  async initialize() {
    if (this.initialized) return;
    let { fs: t11, os: i18, path: e10 } = r4(), m18 = r5.name, s18 = e10.join(i18.homedir(), `.${m18}`);
    this.storagePath = e10.join(s18, "storage.json"), this.lockPath = this.storagePath + ".lock", t11.existsSync(s18) || t11.mkdirSync(s18, { recursive: true }), t11.existsSync(this.storagePath) || t11.writeFileSync(this.storagePath, JSON.stringify({}), "utf8");
    try {
      let d15 = t11.readFileSync(this.storagePath, "utf8");
      this.data = JSON.parse(d15);
    } catch {
      this.data = {};
    }
    this.initialized = true;
  }
  async persist() {
    let { fs: t11 } = r4();
    this.acquireLock(t11);
    try {
      t11.writeFileSync(this.storagePath, JSON.stringify(this.data, null, 2), "utf8");
    } finally {
      this.releaseLock(t11);
    }
  }
  acquireLock(t11) {
    let i18 = 0;
    for (; t11.existsSync(this.lockPath); ) {
      if (i18++ > 20) throw new Error("Could not acquire lock");
      Atomics.wait(new Int32Array(new SharedArrayBuffer(4)), 0, 0, 50);
    }
    t11.writeFileSync(this.lockPath, "locked");
  }
  releaseLock(t11) {
    t11.existsSync(this.lockPath) && t11.unlinkSync(this.lockPath);
  }
  async getItem(t11) {
    await this.initialize();
    let { fs: i18 } = r4();
    try {
      let e10 = i18.readFileSync(this.storagePath, "utf8");
      this.data = JSON.parse(e10);
    } catch {
      this.data = {};
    }
    return this.data[t11] ?? null;
  }
  async setItem(t11, i18) {
    await this.initialize(), this.data[t11] = i18, await this.persist();
  }
  async removeItem(t11) {
    await this.initialize(), delete this.data[t11], await this.persist();
  }
}, y8 = c2(c3, [c2(c8)], "localFileSystemService");
function u9(r9) {
  return g3({ ...r9, cacheService: y8 });
}
__name(u9, "u");
j(u9, "LocalFileSystemCacheLoader");

// node_modules/@mahindar5/common-lib/dist/chunk-GJSJZ4PO.js
var b3 = s9() ? a12 : a14, p9 = n5() ? n2 : a14, y9 = n5() ? m11 : a14, d7 = n5() ? D2 : a14, v5 = t5() ? y8 : a14, O2 = j((e10) => g3({ ...e10, cacheService: b3 }), "ChromeOrInMemoryFallbackCacheLoader"), C = j((e10) => g3({ ...e10, cacheService: p9 }), "LocalStorageOrInMemoryFallbackCacheLoader"), L = j((e10) => g3({ ...e10, cacheService: y9 }), "SessionStorageOrInMemoryFallbackCacheLoader"), N = j((e10) => g3({ ...e10, cacheService: d7 }), "IndexedDbOrInMemoryFallbackCacheLoader"), u10 = j((e10) => g3({ ...e10, cacheService: v5 }), "LocalFileSystemOrInMemoryFallbackCacheLoader");

// node_modules/@mahindar5/common-lib/dist/chunk-MA2M5TPK.js
var e = "DeviceRegistrationService";

// node_modules/@mahindar5/common-lib/dist/chunk-OTPEGE7I.js
var c9 = "device_mappings", n7 = class {
  static {
    __name(this, "n");
  }
  static {
    j(this, "SchedulerExtStorage");
  }
  cacheService = u8;
  deviceRegistrationService = o(e);
  async getDeviceConfigId() {
    let e10 = await this.deviceRegistrationService.getDeviceId(), t11 = await this.cacheService.getItem(c9) || [], i18 = t11.find((a22) => a22.deviceId === e10);
    if (!i18) {
      let a22 = { deviceId: e10, status: "unmapped", registeredAt: (/* @__PURE__ */ new Date()).toISOString(), configId: null };
      t11.push(a22), await this.cacheService.setItem(c9, t11), i18 = a22;
    }
    if (!i18?.configId) throw new Error("Device has no config assigned");
    return i18.configId;
  }
  async getAllData() {
    let e10 = await this.getDeviceConfigId();
    if (e10) {
      let t11 = await this.getConfigItem(e10);
      if (t11) return t11;
    }
    return { jobsConfigData: {}, jobsRunData: {}, historicalRuns: {}, jobsUnknownData: {} };
  }
  async getConfigItem(e10) {
    return await this.cacheService.getItem(e10) || null;
  }
  async saveAllData(e10) {
    let t11 = await this.getDeviceConfigId(), i18 = await this.getAllData(), a22 = { jobsConfigData: e10.jobsConfigData ?? i18.jobsConfigData, jobsRunData: e10.jobsRunData ?? i18.jobsRunData, historicalRuns: e10.historicalRuns ?? i18.historicalRuns, jobsUnknownData: e10.jobsUnknownData ?? i18.jobsUnknownData };
    await this.cacheService.setItem(t11, a22);
  }
};
l([O2({ keyName: c9, ttl: 1e4 })], n7.prototype, "getDeviceConfigId", 1), l([O2({ ttl: 1e4 }), m(0, t)], n7.prototype, "getConfigItem", 1);

// node_modules/@mahindar5/common-lib/dist/chunk-S3J74CBV.js
var n8 = null, i9 = /* @__PURE__ */ new Map();
async function f10(e10) {
  let r9 = chrome.runtime.getURL(e10);
  (await chrome.runtime.getContexts({ contextTypes: [chrome.runtime.ContextType.OFFSCREEN_DOCUMENT], documentUrls: [r9] })).length === 0 && (n8 ? await n8 : (n8 = chrome.offscreen.createDocument({ url: e10, reasons: [chrome.offscreen.Reason.DOM_PARSER], justification: "RPC communication with offscreen document" }), await n8, n8 = null));
}
__name(f10, "f");
j(f10, "ensureOffscreenDocumentExists");
var m12 = j((e10 = "offscreen-document/offscreen-document.html") => async (r9, o21) => {
  await f10(e10);
  let c21 = await chrome.runtime.sendMessage({ ...r9, target: "offscreen" });
  if (chrome.runtime.lastError) throw new Error(chrome.runtime.lastError.message);
  return c21 || { requestId: r9.requestId, success: false, error: "No response received" };
}, "createChromeOffscreenTransport");
function l9(e10, r9 = "offscreen-document/offscreen-document.html", o21 = "offscreen") {
  return m2(m12(r9), i9, e10, o21);
}
__name(l9, "l");
j(l9, "resolveChromeOffscreenRpc");

// node_modules/@mahindar5/common-lib/dist/chunk-U3UNYNNS.js
var c10 = class {
  static {
    __name(this, "c");
  }
  static {
    j(this, "NotificationHelper");
  }
  offscreenDocumentHelper = l9("OffscreenDocumentHelper");
  async sendDiscordNotification(o21, t11) {
    try {
      let r9 = await fetch(o21, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(typeof t11 == "string" ? { content: t11 } : t11) });
      if (!r9.ok) throw new Error(`HTTP error! status: ${r9.status}`);
    } catch (e10) {
      console.error("Error sending webhook:", e10);
    }
  }
  async notifyWithSoundAndWebhook(o21, t11, e10, r9) {
    if (e10) {
      let f13 = { username: r9, embeds: [{ title: t11, description: o21, color: 65280, timestamp: (/* @__PURE__ */ new Date()).toISOString(), footer: { text: "Chrome Extension Notification" } }] };
      await this.sendDiscordNotification(e10, f13);
    }
    s9() && (this.sendChromeNotificationSound(), this.sendChromeNotification(t11, o21));
  }
  sendChromeNotificationSound() {
    s9() && this.offscreenDocumentHelper.playAudio("../assets/audio/Default.mp3");
  }
  sendChromeNotification(o21, t11) {
    s9() && chrome.notifications.create({ type: "basic", title: o21, message: typeof t11 == "string" ? t11 : "", iconUrl: "../assets/img/noteImage.png", items: Array.isArray(t11) ? t11 : void 0 });
  }
};

// node_modules/tslib/tslib.es6.mjs
var extendStatics = /* @__PURE__ */ __name(function(d15, b7) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d16, b8) {
    d16.__proto__ = b8;
  } || function(d16, b8) {
    for (var p15 in b8) if (Object.prototype.hasOwnProperty.call(b8, p15)) d16[p15] = b8[p15];
  };
  return extendStatics(d15, b7);
}, "extendStatics");
function __extends(d15, b7) {
  if (typeof b7 !== "function" && b7 !== null)
    throw new TypeError("Class extends value " + String(b7) + " is not a constructor or null");
  extendStatics(d15, b7);
  function __() {
    this.constructor = d15;
  }
  __name(__, "__");
  d15.prototype = b7 === null ? Object.create(b7) : (__.prototype = b7.prototype, new __());
}
__name(__extends, "__extends");
var __assign = /* @__PURE__ */ __name(function() {
  __assign = Object.assign || /* @__PURE__ */ __name(function __assign2(t11) {
    for (var s18, i18 = 1, n11 = arguments.length; i18 < n11; i18++) {
      s18 = arguments[i18];
      for (var p15 in s18) if (Object.prototype.hasOwnProperty.call(s18, p15)) t11[p15] = s18[p15];
    }
    return t11;
  }, "__assign");
  return __assign.apply(this, arguments);
}, "__assign");
function __rest(s18, e10) {
  var t11 = {};
  for (var p15 in s18) if (Object.prototype.hasOwnProperty.call(s18, p15) && e10.indexOf(p15) < 0)
    t11[p15] = s18[p15];
  if (s18 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i18 = 0, p15 = Object.getOwnPropertySymbols(s18); i18 < p15.length; i18++) {
      if (e10.indexOf(p15[i18]) < 0 && Object.prototype.propertyIsEnumerable.call(s18, p15[i18]))
        t11[p15[i18]] = s18[p15[i18]];
    }
  return t11;
}
__name(__rest, "__rest");
function __decorate(decorators, target, key, desc) {
  var c21 = arguments.length, r9 = c21 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d15;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
  else for (var i18 = decorators.length - 1; i18 >= 0; i18--) if (d15 = decorators[i18]) r9 = (c21 < 3 ? d15(r9) : c21 > 3 ? d15(target, key, r9) : d15(target, key)) || r9;
  return c21 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
}
__name(__decorate, "__decorate");
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
__name(__param, "__param");
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f13) {
    if (f13 !== void 0 && typeof f13 !== "function") throw new TypeError("Function expected");
    return f13;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i18 = decorators.length - 1; i18 >= 0; i18--) {
    var context2 = {};
    for (var p15 in contextIn) context2[p15] = p15 === "access" ? {} : contextIn[p15];
    for (var p15 in contextIn.access) context2.access[p15] = contextIn.access[p15];
    context2.addInitializer = function(f13) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f13 || null));
    };
    var result = (0, decorators[i18])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
__name(__esDecorate, "__esDecorate");
;
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i18 = 0; i18 < initializers.length; i18++) {
    value = useValue ? initializers[i18].call(thisArg, value) : initializers[i18].call(thisArg);
  }
  return useValue ? value : void 0;
}
__name(__runInitializers, "__runInitializers");
;
function __propKey(x3) {
  return typeof x3 === "symbol" ? x3 : "".concat(x3);
}
__name(__propKey, "__propKey");
;
function __setFunctionName(f13, name4, prefix) {
  if (typeof name4 === "symbol") name4 = name4.description ? "[".concat(name4.description, "]") : "";
  return Object.defineProperty(f13, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name4) : name4 });
}
__name(__setFunctionName, "__setFunctionName");
;
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
__name(__metadata, "__metadata");
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e10) {
        reject(e10);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e10) {
        reject(e10);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
__name(__awaiter, "__awaiter");
function __generator(thisArg, body) {
  var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
    if (t11[0] & 1) throw t11[1];
    return t11[1];
  }, "sent"), trys: [], ops: [] }, f13, y12, t11, g10;
  return g10 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g10[Symbol.iterator] = function() {
    return this;
  }), g10;
  function verb(n11) {
    return function(v8) {
      return step([n11, v8]);
    };
  }
  __name(verb, "verb");
  function step(op) {
    if (f13) throw new TypeError("Generator is already executing.");
    while (g10 && (g10 = 0, op[0] && (_ = 0)), _) try {
      if (f13 = 1, y12 && (t11 = op[0] & 2 ? y12["return"] : op[0] ? y12["throw"] || ((t11 = y12["return"]) && t11.call(y12), 0) : y12.next) && !(t11 = t11.call(y12, op[1])).done) return t11;
      if (y12 = 0, t11) op = [op[0] & 2, t11.value];
      switch (op[0]) {
        case 0:
        case 1:
          t11 = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y12 = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t11 = _.trys, t11 = t11.length > 0 && t11[t11.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t11 || op[1] > t11[0] && op[1] < t11[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t11[1]) {
            _.label = t11[1];
            t11 = op;
            break;
          }
          if (t11 && _.label < t11[2]) {
            _.label = t11[2];
            _.ops.push(op);
            break;
          }
          if (t11[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e10) {
      op = [6, e10];
      y12 = 0;
    } finally {
      f13 = t11 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
  __name(step, "step");
}
__name(__generator, "__generator");
var __createBinding = Object.create ? function(o21, m18, k5, k22) {
  if (k22 === void 0) k22 = k5;
  var desc = Object.getOwnPropertyDescriptor(m18, k5);
  if (!desc || ("get" in desc ? !m18.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return m18[k5];
    }, "get") };
  }
  Object.defineProperty(o21, k22, desc);
} : function(o21, m18, k5, k22) {
  if (k22 === void 0) k22 = k5;
  o21[k22] = m18[k5];
};
function __exportStar(m18, o21) {
  for (var p15 in m18) if (p15 !== "default" && !Object.prototype.hasOwnProperty.call(o21, p15)) __createBinding(o21, m18, p15);
}
__name(__exportStar, "__exportStar");
function __values(o21) {
  var s18 = typeof Symbol === "function" && Symbol.iterator, m18 = s18 && o21[s18], i18 = 0;
  if (m18) return m18.call(o21);
  if (o21 && typeof o21.length === "number") return {
    next: /* @__PURE__ */ __name(function() {
      if (o21 && i18 >= o21.length) o21 = void 0;
      return { value: o21 && o21[i18++], done: !o21 };
    }, "next")
  };
  throw new TypeError(s18 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
__name(__values, "__values");
function __read(o21, n11) {
  var m18 = typeof Symbol === "function" && o21[Symbol.iterator];
  if (!m18) return o21;
  var i18 = m18.call(o21), r9, ar = [], e10;
  try {
    while ((n11 === void 0 || n11-- > 0) && !(r9 = i18.next()).done) ar.push(r9.value);
  } catch (error) {
    e10 = { error };
  } finally {
    try {
      if (r9 && !r9.done && (m18 = i18["return"])) m18.call(i18);
    } finally {
      if (e10) throw e10.error;
    }
  }
  return ar;
}
__name(__read, "__read");
function __spread() {
  for (var ar = [], i18 = 0; i18 < arguments.length; i18++)
    ar = ar.concat(__read(arguments[i18]));
  return ar;
}
__name(__spread, "__spread");
function __spreadArrays() {
  for (var s18 = 0, i18 = 0, il = arguments.length; i18 < il; i18++) s18 += arguments[i18].length;
  for (var r9 = Array(s18), k5 = 0, i18 = 0; i18 < il; i18++)
    for (var a22 = arguments[i18], j2 = 0, jl = a22.length; j2 < jl; j2++, k5++)
      r9[k5] = a22[j2];
  return r9;
}
__name(__spreadArrays, "__spreadArrays");
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i18 = 0, l14 = from.length, ar; i18 < l14; i18++) {
    if (ar || !(i18 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i18);
      ar[i18] = from[i18];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
__name(__spreadArray, "__spreadArray");
function __await(v8) {
  return this instanceof __await ? (this.v = v8, this) : new __await(v8);
}
__name(__await, "__await");
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g10 = generator.apply(thisArg, _arguments || []), i18, q = [];
  return i18 = {}, verb("next"), verb("throw"), verb("return"), i18[Symbol.asyncIterator] = function() {
    return this;
  }, i18;
  function verb(n11) {
    if (g10[n11]) i18[n11] = function(v8) {
      return new Promise(function(a22, b7) {
        q.push([n11, v8, a22, b7]) > 1 || resume(n11, v8);
      });
    };
  }
  __name(verb, "verb");
  function resume(n11, v8) {
    try {
      step(g10[n11](v8));
    } catch (e10) {
      settle(q[0][3], e10);
    }
  }
  __name(resume, "resume");
  function step(r9) {
    r9.value instanceof __await ? Promise.resolve(r9.value.v).then(fulfill, reject) : settle(q[0][2], r9);
  }
  __name(step, "step");
  function fulfill(value) {
    resume("next", value);
  }
  __name(fulfill, "fulfill");
  function reject(value) {
    resume("throw", value);
  }
  __name(reject, "reject");
  function settle(f13, v8) {
    if (f13(v8), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
  __name(settle, "settle");
}
__name(__asyncGenerator, "__asyncGenerator");
function __asyncDelegator(o21) {
  var i18, p15;
  return i18 = {}, verb("next"), verb("throw", function(e10) {
    throw e10;
  }), verb("return"), i18[Symbol.iterator] = function() {
    return this;
  }, i18;
  function verb(n11, f13) {
    i18[n11] = o21[n11] ? function(v8) {
      return (p15 = !p15) ? { value: __await(o21[n11](v8)), done: false } : f13 ? f13(v8) : v8;
    } : f13;
  }
  __name(verb, "verb");
}
__name(__asyncDelegator, "__asyncDelegator");
function __asyncValues(o21) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m18 = o21[Symbol.asyncIterator], i18;
  return m18 ? m18.call(o21) : (o21 = typeof __values === "function" ? __values(o21) : o21[Symbol.iterator](), i18 = {}, verb("next"), verb("throw"), verb("return"), i18[Symbol.asyncIterator] = function() {
    return this;
  }, i18);
  function verb(n11) {
    i18[n11] = o21[n11] && function(v8) {
      return new Promise(function(resolve, reject) {
        v8 = o21[n11](v8), settle(resolve, reject, v8.done, v8.value);
      });
    };
  }
  __name(verb, "verb");
  function settle(resolve, reject, d15, v8) {
    Promise.resolve(v8).then(function(v9) {
      resolve({ value: v9, done: d15 });
    }, reject);
  }
  __name(settle, "settle");
}
__name(__asyncValues, "__asyncValues");
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
__name(__makeTemplateObject, "__makeTemplateObject");
;
var __setModuleDefault = Object.create ? function(o21, v8) {
  Object.defineProperty(o21, "default", { enumerable: true, value: v8 });
} : function(o21, v8) {
  o21["default"] = v8;
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k5 in mod) if (k5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k5)) __createBinding(result, mod, k5);
  }
  __setModuleDefault(result, mod);
  return result;
}
__name(__importStar, "__importStar");
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
__name(__importDefault, "__importDefault");
function __classPrivateFieldGet(receiver, state, kind, f13) {
  if (kind === "a" && !f13) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f13 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f13 : kind === "a" ? f13.call(receiver) : f13 ? f13.value : state.get(receiver);
}
__name(__classPrivateFieldGet, "__classPrivateFieldGet");
function __classPrivateFieldSet(receiver, state, value, kind, f13) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f13) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f13 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f13.call(receiver, value) : f13 ? f13.value = value : state.set(receiver, value), value;
}
__name(__classPrivateFieldSet, "__classPrivateFieldSet");
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
__name(__classPrivateFieldIn, "__classPrivateFieldIn");
function __addDisposableResource(env, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env.stack.push({ async: true });
  }
  return value;
}
__name(__addDisposableResource, "__addDisposableResource");
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e10 = new Error(message);
  return e10.name = "SuppressedError", e10.error = error, e10.suppressed = suppressed, e10;
};
function __disposeResources(env) {
  function fail3(e10) {
    env.error = env.hasError ? new _SuppressedError(e10, env.error, "An error was suppressed during disposal.") : e10;
    env.hasError = true;
  }
  __name(fail3, "fail");
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async) return Promise.resolve(result).then(next, function(e10) {
          fail3(e10);
          return next();
        });
      } catch (e10) {
        fail3(e10);
      }
    }
    if (env.hasError) throw env.error;
  }
  __name(next, "next");
  return next();
}
__name(__disposeResources, "__disposeResources");
var tslib_es6_default = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources
};

// node_modules/@firebase/auth/dist/node-esm/totp-18137433.js
var FactorId = {
  /** Phone as second factor */
  PHONE: "phone",
  TOTP: "totp"
};
var ProviderId = {
  /** Facebook provider ID */
  FACEBOOK: "facebook.com",
  /** GitHub provider ID */
  GITHUB: "github.com",
  /** Google provider ID */
  GOOGLE: "google.com",
  /** Password provider */
  PASSWORD: "password",
  /** Phone provider */
  PHONE: "phone",
  /** Twitter provider ID */
  TWITTER: "twitter.com"
};
var SignInMethod = {
  /** Email link sign in method */
  EMAIL_LINK: "emailLink",
  /** Email/password sign in method */
  EMAIL_PASSWORD: "password",
  /** Facebook sign in method */
  FACEBOOK: "facebook.com",
  /** GitHub sign in method */
  GITHUB: "github.com",
  /** Google sign in method */
  GOOGLE: "google.com",
  /** Phone sign in method */
  PHONE: "phone",
  /** Twitter sign in method */
  TWITTER: "twitter.com"
};
var OperationType = {
  /** Operation involving linking an additional provider to an already signed-in user. */
  LINK: "link",
  /** Operation involving using a provider to reauthenticate an already signed-in user. */
  REAUTHENTICATE: "reauthenticate",
  /** Operation involving signing in a user. */
  SIGN_IN: "signIn"
};
var ActionCodeOperation = {
  /** The email link sign-in action. */
  EMAIL_SIGNIN: "EMAIL_SIGNIN",
  /** The password reset action. */
  PASSWORD_RESET: "PASSWORD_RESET",
  /** The email revocation action. */
  RECOVER_EMAIL: "RECOVER_EMAIL",
  /** The revert second factor addition email action. */
  REVERT_SECOND_FACTOR_ADDITION: "REVERT_SECOND_FACTOR_ADDITION",
  /** The revert second factor addition email action. */
  VERIFY_AND_CHANGE_EMAIL: "VERIFY_AND_CHANGE_EMAIL",
  /** The email verification action. */
  VERIFY_EMAIL: "VERIFY_EMAIL"
};
function _debugErrorMap() {
  return {
    [
      "admin-restricted-operation"
      /* AuthErrorCode.ADMIN_ONLY_OPERATION */
    ]: "This operation is restricted to administrators only.",
    [
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    ]: "",
    [
      "app-not-authorized"
      /* AuthErrorCode.APP_NOT_AUTHORIZED */
    ]: "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.",
    [
      "app-not-installed"
      /* AuthErrorCode.APP_NOT_INSTALLED */
    ]: "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.",
    [
      "captcha-check-failed"
      /* AuthErrorCode.CAPTCHA_CHECK_FAILED */
    ]: "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.",
    [
      "code-expired"
      /* AuthErrorCode.CODE_EXPIRED */
    ]: "The SMS code has expired. Please re-send the verification code to try again.",
    [
      "cordova-not-ready"
      /* AuthErrorCode.CORDOVA_NOT_READY */
    ]: "Cordova framework is not ready.",
    [
      "cors-unsupported"
      /* AuthErrorCode.CORS_UNSUPPORTED */
    ]: "This browser is not supported.",
    [
      "credential-already-in-use"
      /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */
    ]: "This credential is already associated with a different user account.",
    [
      "custom-token-mismatch"
      /* AuthErrorCode.CREDENTIAL_MISMATCH */
    ]: "The custom token corresponds to a different audience.",
    [
      "requires-recent-login"
      /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */
    ]: "This operation is sensitive and requires recent authentication. Log in again before retrying this request.",
    [
      "dependent-sdk-initialized-before-auth"
      /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */
    ]: "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK.",
    [
      "dynamic-link-not-activated"
      /* AuthErrorCode.DYNAMIC_LINK_NOT_ACTIVATED */
    ]: "Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.",
    [
      "email-change-needs-verification"
      /* AuthErrorCode.EMAIL_CHANGE_NEEDS_VERIFICATION */
    ]: "Multi-factor users must always have a verified email.",
    [
      "email-already-in-use"
      /* AuthErrorCode.EMAIL_EXISTS */
    ]: "The email address is already in use by another account.",
    [
      "emulator-config-failed"
      /* AuthErrorCode.EMULATOR_CONFIG_FAILED */
    ]: 'Auth instance has already been used to make a network call. Auth can no longer be configured to use the emulator. Try calling "connectAuthEmulator()" sooner.',
    [
      "expired-action-code"
      /* AuthErrorCode.EXPIRED_OOB_CODE */
    ]: "The action code has expired.",
    [
      "cancelled-popup-request"
      /* AuthErrorCode.EXPIRED_POPUP_REQUEST */
    ]: "This operation has been cancelled due to another conflicting popup being opened.",
    [
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    ]: "An internal AuthError has occurred.",
    [
      "invalid-app-credential"
      /* AuthErrorCode.INVALID_APP_CREDENTIAL */
    ]: "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.",
    [
      "invalid-app-id"
      /* AuthErrorCode.INVALID_APP_ID */
    ]: "The mobile app identifier is not registered for the current project.",
    [
      "invalid-user-token"
      /* AuthErrorCode.INVALID_AUTH */
    ]: "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.",
    [
      "invalid-auth-event"
      /* AuthErrorCode.INVALID_AUTH_EVENT */
    ]: "An internal AuthError has occurred.",
    [
      "invalid-verification-code"
      /* AuthErrorCode.INVALID_CODE */
    ]: "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure to use the verification code provided by the user.",
    [
      "invalid-continue-uri"
      /* AuthErrorCode.INVALID_CONTINUE_URI */
    ]: "The continue URL provided in the request is invalid.",
    [
      "invalid-cordova-configuration"
      /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */
    ]: "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.",
    [
      "invalid-custom-token"
      /* AuthErrorCode.INVALID_CUSTOM_TOKEN */
    ]: "The custom token format is incorrect. Please check the documentation.",
    [
      "invalid-dynamic-link-domain"
      /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */
    ]: "The provided dynamic link domain is not configured or authorized for the current project.",
    [
      "invalid-email"
      /* AuthErrorCode.INVALID_EMAIL */
    ]: "The email address is badly formatted.",
    [
      "invalid-emulator-scheme"
      /* AuthErrorCode.INVALID_EMULATOR_SCHEME */
    ]: "Emulator URL must start with a valid scheme (http:// or https://).",
    [
      "invalid-api-key"
      /* AuthErrorCode.INVALID_API_KEY */
    ]: "Your API key is invalid, please check you have copied it correctly.",
    [
      "invalid-cert-hash"
      /* AuthErrorCode.INVALID_CERT_HASH */
    ]: "The SHA-1 certificate hash provided is invalid.",
    [
      "invalid-credential"
      /* AuthErrorCode.INVALID_CREDENTIAL */
    ]: "The supplied auth credential is incorrect, malformed or has expired.",
    [
      "invalid-message-payload"
      /* AuthErrorCode.INVALID_MESSAGE_PAYLOAD */
    ]: "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.",
    [
      "invalid-multi-factor-session"
      /* AuthErrorCode.INVALID_MFA_SESSION */
    ]: "The request does not contain a valid proof of first factor successful sign-in.",
    [
      "invalid-oauth-provider"
      /* AuthErrorCode.INVALID_OAUTH_PROVIDER */
    ]: "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.",
    [
      "invalid-oauth-client-id"
      /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */
    ]: "The OAuth client ID provided is either invalid or does not match the specified API key.",
    [
      "unauthorized-domain"
      /* AuthErrorCode.INVALID_ORIGIN */
    ]: "This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.",
    [
      "invalid-action-code"
      /* AuthErrorCode.INVALID_OOB_CODE */
    ]: "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.",
    [
      "wrong-password"
      /* AuthErrorCode.INVALID_PASSWORD */
    ]: "The password is invalid or the user does not have a password.",
    [
      "invalid-persistence-type"
      /* AuthErrorCode.INVALID_PERSISTENCE */
    ]: "The specified persistence type is invalid. It can only be local, session or none.",
    [
      "invalid-phone-number"
      /* AuthErrorCode.INVALID_PHONE_NUMBER */
    ]: "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].",
    [
      "invalid-provider-id"
      /* AuthErrorCode.INVALID_PROVIDER_ID */
    ]: "The specified provider ID is invalid.",
    [
      "invalid-recipient-email"
      /* AuthErrorCode.INVALID_RECIPIENT_EMAIL */
    ]: "The email corresponding to this action failed to send as the provided recipient email address is invalid.",
    [
      "invalid-sender"
      /* AuthErrorCode.INVALID_SENDER */
    ]: "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.",
    [
      "invalid-verification-id"
      /* AuthErrorCode.INVALID_SESSION_INFO */
    ]: "The verification ID used to create the phone auth credential is invalid.",
    [
      "invalid-tenant-id"
      /* AuthErrorCode.INVALID_TENANT_ID */
    ]: "The Auth instance's tenant ID is invalid.",
    [
      "login-blocked"
      /* AuthErrorCode.LOGIN_BLOCKED */
    ]: "Login blocked by user-provided method: {$originalMessage}",
    [
      "missing-android-pkg-name"
      /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */
    ]: "An Android Package Name must be provided if the Android App is required to be installed.",
    [
      "auth-domain-config-required"
      /* AuthErrorCode.MISSING_AUTH_DOMAIN */
    ]: "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.",
    [
      "missing-app-credential"
      /* AuthErrorCode.MISSING_APP_CREDENTIAL */
    ]: "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.",
    [
      "missing-verification-code"
      /* AuthErrorCode.MISSING_CODE */
    ]: "The phone auth credential was created with an empty SMS verification code.",
    [
      "missing-continue-uri"
      /* AuthErrorCode.MISSING_CONTINUE_URI */
    ]: "A continue URL must be provided in the request.",
    [
      "missing-iframe-start"
      /* AuthErrorCode.MISSING_IFRAME_START */
    ]: "An internal AuthError has occurred.",
    [
      "missing-ios-bundle-id"
      /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */
    ]: "An iOS Bundle ID must be provided if an App Store ID is provided.",
    [
      "missing-or-invalid-nonce"
      /* AuthErrorCode.MISSING_OR_INVALID_NONCE */
    ]: "The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.",
    [
      "missing-password"
      /* AuthErrorCode.MISSING_PASSWORD */
    ]: "A non-empty password must be provided",
    [
      "missing-multi-factor-info"
      /* AuthErrorCode.MISSING_MFA_INFO */
    ]: "No second factor identifier is provided.",
    [
      "missing-multi-factor-session"
      /* AuthErrorCode.MISSING_MFA_SESSION */
    ]: "The request is missing proof of first factor successful sign-in.",
    [
      "missing-phone-number"
      /* AuthErrorCode.MISSING_PHONE_NUMBER */
    ]: "To send verification codes, provide a phone number for the recipient.",
    [
      "missing-verification-id"
      /* AuthErrorCode.MISSING_SESSION_INFO */
    ]: "The phone auth credential was created with an empty verification ID.",
    [
      "app-deleted"
      /* AuthErrorCode.MODULE_DESTROYED */
    ]: "This instance of FirebaseApp has been deleted.",
    [
      "multi-factor-info-not-found"
      /* AuthErrorCode.MFA_INFO_NOT_FOUND */
    ]: "The user does not have a second factor matching the identifier provided.",
    [
      "multi-factor-auth-required"
      /* AuthErrorCode.MFA_REQUIRED */
    ]: "Proof of ownership of a second factor is required to complete sign-in.",
    [
      "account-exists-with-different-credential"
      /* AuthErrorCode.NEED_CONFIRMATION */
    ]: "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
    [
      "network-request-failed"
      /* AuthErrorCode.NETWORK_REQUEST_FAILED */
    ]: "A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.",
    [
      "no-auth-event"
      /* AuthErrorCode.NO_AUTH_EVENT */
    ]: "An internal AuthError has occurred.",
    [
      "no-such-provider"
      /* AuthErrorCode.NO_SUCH_PROVIDER */
    ]: "User was not linked to an account with the given provider.",
    [
      "null-user"
      /* AuthErrorCode.NULL_USER */
    ]: "A null user object was provided as the argument for an operation which requires a non-null user object.",
    [
      "operation-not-allowed"
      /* AuthErrorCode.OPERATION_NOT_ALLOWED */
    ]: "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.",
    [
      "operation-not-supported-in-this-environment"
      /* AuthErrorCode.OPERATION_NOT_SUPPORTED */
    ]: 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.',
    [
      "popup-blocked"
      /* AuthErrorCode.POPUP_BLOCKED */
    ]: "Unable to establish a connection with the popup. It may have been blocked by the browser.",
    [
      "popup-closed-by-user"
      /* AuthErrorCode.POPUP_CLOSED_BY_USER */
    ]: "The popup has been closed by the user before finalizing the operation.",
    [
      "provider-already-linked"
      /* AuthErrorCode.PROVIDER_ALREADY_LINKED */
    ]: "User can only be linked to one identity for the given provider.",
    [
      "quota-exceeded"
      /* AuthErrorCode.QUOTA_EXCEEDED */
    ]: "The project's quota for this operation has been exceeded.",
    [
      "redirect-cancelled-by-user"
      /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */
    ]: "The redirect operation has been cancelled by the user before finalizing.",
    [
      "redirect-operation-pending"
      /* AuthErrorCode.REDIRECT_OPERATION_PENDING */
    ]: "A redirect sign-in operation is already pending.",
    [
      "rejected-credential"
      /* AuthErrorCode.REJECTED_CREDENTIAL */
    ]: "The request contains malformed or mismatching credentials.",
    [
      "second-factor-already-in-use"
      /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */
    ]: "The second factor is already enrolled on this account.",
    [
      "maximum-second-factor-count-exceeded"
      /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */
    ]: "The maximum allowed number of second factors on a user has been exceeded.",
    [
      "tenant-id-mismatch"
      /* AuthErrorCode.TENANT_ID_MISMATCH */
    ]: "The provided tenant ID does not match the Auth instance's tenant ID",
    [
      "timeout"
      /* AuthErrorCode.TIMEOUT */
    ]: "The operation has timed out.",
    [
      "user-token-expired"
      /* AuthErrorCode.TOKEN_EXPIRED */
    ]: "The user's credential is no longer valid. The user must sign in again.",
    [
      "too-many-requests"
      /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */
    ]: "We have blocked all requests from this device due to unusual activity. Try again later.",
    [
      "unauthorized-continue-uri"
      /* AuthErrorCode.UNAUTHORIZED_DOMAIN */
    ]: "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.",
    [
      "unsupported-first-factor"
      /* AuthErrorCode.UNSUPPORTED_FIRST_FACTOR */
    ]: "Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.",
    [
      "unsupported-persistence-type"
      /* AuthErrorCode.UNSUPPORTED_PERSISTENCE */
    ]: "The current environment does not support the specified persistence type.",
    [
      "unsupported-tenant-operation"
      /* AuthErrorCode.UNSUPPORTED_TENANT_OPERATION */
    ]: "This operation is not supported in a multi-tenant context.",
    [
      "unverified-email"
      /* AuthErrorCode.UNVERIFIED_EMAIL */
    ]: "The operation requires a verified email.",
    [
      "user-cancelled"
      /* AuthErrorCode.USER_CANCELLED */
    ]: "The user did not grant your application the permissions it requested.",
    [
      "user-not-found"
      /* AuthErrorCode.USER_DELETED */
    ]: "There is no user record corresponding to this identifier. The user may have been deleted.",
    [
      "user-disabled"
      /* AuthErrorCode.USER_DISABLED */
    ]: "The user account has been disabled by an administrator.",
    [
      "user-mismatch"
      /* AuthErrorCode.USER_MISMATCH */
    ]: "The supplied credentials do not correspond to the previously signed in user.",
    [
      "user-signed-out"
      /* AuthErrorCode.USER_SIGNED_OUT */
    ]: "",
    [
      "weak-password"
      /* AuthErrorCode.WEAK_PASSWORD */
    ]: "The password must be 6 characters long or more.",
    [
      "web-storage-unsupported"
      /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */
    ]: "This browser is not supported or 3rd party cookies and data may be disabled.",
    [
      "already-initialized"
      /* AuthErrorCode.ALREADY_INITIALIZED */
    ]: "initializeAuth() has already been called with different options. To avoid this error, call initializeAuth() with the same options as when it was originally called, or call getAuth() to return the already initialized instance.",
    [
      "missing-recaptcha-token"
      /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */
    ]: "The reCAPTCHA token is missing when sending request to the backend.",
    [
      "invalid-recaptcha-token"
      /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */
    ]: "The reCAPTCHA token is invalid when sending request to the backend.",
    [
      "invalid-recaptcha-action"
      /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */
    ]: "The reCAPTCHA action is invalid when sending request to the backend.",
    [
      "recaptcha-not-enabled"
      /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */
    ]: "reCAPTCHA Enterprise integration is not enabled for this project.",
    [
      "missing-client-type"
      /* AuthErrorCode.MISSING_CLIENT_TYPE */
    ]: "The reCAPTCHA client type is missing when sending request to the backend.",
    [
      "missing-recaptcha-version"
      /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */
    ]: "The reCAPTCHA version is missing when sending request to the backend.",
    [
      "invalid-req-type"
      /* AuthErrorCode.INVALID_REQ_TYPE */
    ]: "Invalid request parameters.",
    [
      "invalid-recaptcha-version"
      /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */
    ]: "The reCAPTCHA version is invalid when sending request to the backend.",
    [
      "unsupported-password-policy-schema-version"
      /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */
    ]: "The password policy received from the backend uses a schema version that is not supported by this version of the Firebase SDK.",
    [
      "password-does-not-meet-requirements"
      /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */
    ]: "The password does not meet the requirements.",
    [
      "invalid-hosting-link-domain"
      /* AuthErrorCode.INVALID_HOSTING_LINK_DOMAIN */
    ]: "The provided Hosting link domain is not configured in Firebase Hosting or is not owned by the current project. This cannot be a default Hosting domain (`web.app` or `firebaseapp.com`)."
  };
}
__name(_debugErrorMap, "_debugErrorMap");
function _prodErrorMap() {
  return {
    [
      "dependent-sdk-initialized-before-auth"
      /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */
    ]: "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
  };
}
__name(_prodErrorMap, "_prodErrorMap");
var debugErrorMap = _debugErrorMap;
var prodErrorMap = _prodErrorMap;
var _DEFAULT_AUTH_ERROR_FACTORY = new ErrorFactory("auth", "Firebase", _prodErrorMap());
var AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = {
  ADMIN_ONLY_OPERATION: "auth/admin-restricted-operation",
  ARGUMENT_ERROR: "auth/argument-error",
  APP_NOT_AUTHORIZED: "auth/app-not-authorized",
  APP_NOT_INSTALLED: "auth/app-not-installed",
  CAPTCHA_CHECK_FAILED: "auth/captcha-check-failed",
  CODE_EXPIRED: "auth/code-expired",
  CORDOVA_NOT_READY: "auth/cordova-not-ready",
  CORS_UNSUPPORTED: "auth/cors-unsupported",
  CREDENTIAL_ALREADY_IN_USE: "auth/credential-already-in-use",
  CREDENTIAL_MISMATCH: "auth/custom-token-mismatch",
  CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "auth/requires-recent-login",
  DEPENDENT_SDK_INIT_BEFORE_AUTH: "auth/dependent-sdk-initialized-before-auth",
  DYNAMIC_LINK_NOT_ACTIVATED: "auth/dynamic-link-not-activated",
  EMAIL_CHANGE_NEEDS_VERIFICATION: "auth/email-change-needs-verification",
  EMAIL_EXISTS: "auth/email-already-in-use",
  EMULATOR_CONFIG_FAILED: "auth/emulator-config-failed",
  EXPIRED_OOB_CODE: "auth/expired-action-code",
  EXPIRED_POPUP_REQUEST: "auth/cancelled-popup-request",
  INTERNAL_ERROR: "auth/internal-error",
  INVALID_API_KEY: "auth/invalid-api-key",
  INVALID_APP_CREDENTIAL: "auth/invalid-app-credential",
  INVALID_APP_ID: "auth/invalid-app-id",
  INVALID_AUTH: "auth/invalid-user-token",
  INVALID_AUTH_EVENT: "auth/invalid-auth-event",
  INVALID_CERT_HASH: "auth/invalid-cert-hash",
  INVALID_CODE: "auth/invalid-verification-code",
  INVALID_CONTINUE_URI: "auth/invalid-continue-uri",
  INVALID_CORDOVA_CONFIGURATION: "auth/invalid-cordova-configuration",
  INVALID_CUSTOM_TOKEN: "auth/invalid-custom-token",
  INVALID_DYNAMIC_LINK_DOMAIN: "auth/invalid-dynamic-link-domain",
  INVALID_EMAIL: "auth/invalid-email",
  INVALID_EMULATOR_SCHEME: "auth/invalid-emulator-scheme",
  INVALID_IDP_RESPONSE: "auth/invalid-credential",
  INVALID_LOGIN_CREDENTIALS: "auth/invalid-credential",
  INVALID_MESSAGE_PAYLOAD: "auth/invalid-message-payload",
  INVALID_MFA_SESSION: "auth/invalid-multi-factor-session",
  INVALID_OAUTH_CLIENT_ID: "auth/invalid-oauth-client-id",
  INVALID_OAUTH_PROVIDER: "auth/invalid-oauth-provider",
  INVALID_OOB_CODE: "auth/invalid-action-code",
  INVALID_ORIGIN: "auth/unauthorized-domain",
  INVALID_PASSWORD: "auth/wrong-password",
  INVALID_PERSISTENCE: "auth/invalid-persistence-type",
  INVALID_PHONE_NUMBER: "auth/invalid-phone-number",
  INVALID_PROVIDER_ID: "auth/invalid-provider-id",
  INVALID_RECIPIENT_EMAIL: "auth/invalid-recipient-email",
  INVALID_SENDER: "auth/invalid-sender",
  INVALID_SESSION_INFO: "auth/invalid-verification-id",
  INVALID_TENANT_ID: "auth/invalid-tenant-id",
  MFA_INFO_NOT_FOUND: "auth/multi-factor-info-not-found",
  MFA_REQUIRED: "auth/multi-factor-auth-required",
  MISSING_ANDROID_PACKAGE_NAME: "auth/missing-android-pkg-name",
  MISSING_APP_CREDENTIAL: "auth/missing-app-credential",
  MISSING_AUTH_DOMAIN: "auth/auth-domain-config-required",
  MISSING_CODE: "auth/missing-verification-code",
  MISSING_CONTINUE_URI: "auth/missing-continue-uri",
  MISSING_IFRAME_START: "auth/missing-iframe-start",
  MISSING_IOS_BUNDLE_ID: "auth/missing-ios-bundle-id",
  MISSING_OR_INVALID_NONCE: "auth/missing-or-invalid-nonce",
  MISSING_MFA_INFO: "auth/missing-multi-factor-info",
  MISSING_MFA_SESSION: "auth/missing-multi-factor-session",
  MISSING_PHONE_NUMBER: "auth/missing-phone-number",
  MISSING_SESSION_INFO: "auth/missing-verification-id",
  MODULE_DESTROYED: "auth/app-deleted",
  NEED_CONFIRMATION: "auth/account-exists-with-different-credential",
  NETWORK_REQUEST_FAILED: "auth/network-request-failed",
  NULL_USER: "auth/null-user",
  NO_AUTH_EVENT: "auth/no-auth-event",
  NO_SUCH_PROVIDER: "auth/no-such-provider",
  OPERATION_NOT_ALLOWED: "auth/operation-not-allowed",
  OPERATION_NOT_SUPPORTED: "auth/operation-not-supported-in-this-environment",
  POPUP_BLOCKED: "auth/popup-blocked",
  POPUP_CLOSED_BY_USER: "auth/popup-closed-by-user",
  PROVIDER_ALREADY_LINKED: "auth/provider-already-linked",
  QUOTA_EXCEEDED: "auth/quota-exceeded",
  REDIRECT_CANCELLED_BY_USER: "auth/redirect-cancelled-by-user",
  REDIRECT_OPERATION_PENDING: "auth/redirect-operation-pending",
  REJECTED_CREDENTIAL: "auth/rejected-credential",
  SECOND_FACTOR_ALREADY_ENROLLED: "auth/second-factor-already-in-use",
  SECOND_FACTOR_LIMIT_EXCEEDED: "auth/maximum-second-factor-count-exceeded",
  TENANT_ID_MISMATCH: "auth/tenant-id-mismatch",
  TIMEOUT: "auth/timeout",
  TOKEN_EXPIRED: "auth/user-token-expired",
  TOO_MANY_ATTEMPTS_TRY_LATER: "auth/too-many-requests",
  UNAUTHORIZED_DOMAIN: "auth/unauthorized-continue-uri",
  UNSUPPORTED_FIRST_FACTOR: "auth/unsupported-first-factor",
  UNSUPPORTED_PERSISTENCE: "auth/unsupported-persistence-type",
  UNSUPPORTED_TENANT_OPERATION: "auth/unsupported-tenant-operation",
  UNVERIFIED_EMAIL: "auth/unverified-email",
  USER_CANCELLED: "auth/user-cancelled",
  USER_DELETED: "auth/user-not-found",
  USER_DISABLED: "auth/user-disabled",
  USER_MISMATCH: "auth/user-mismatch",
  USER_SIGNED_OUT: "auth/user-signed-out",
  WEAK_PASSWORD: "auth/weak-password",
  WEB_STORAGE_UNSUPPORTED: "auth/web-storage-unsupported",
  ALREADY_INITIALIZED: "auth/already-initialized",
  RECAPTCHA_NOT_ENABLED: "auth/recaptcha-not-enabled",
  MISSING_RECAPTCHA_TOKEN: "auth/missing-recaptcha-token",
  INVALID_RECAPTCHA_TOKEN: "auth/invalid-recaptcha-token",
  INVALID_RECAPTCHA_ACTION: "auth/invalid-recaptcha-action",
  MISSING_CLIENT_TYPE: "auth/missing-client-type",
  MISSING_RECAPTCHA_VERSION: "auth/missing-recaptcha-version",
  INVALID_RECAPTCHA_VERSION: "auth/invalid-recaptcha-version",
  INVALID_REQ_TYPE: "auth/invalid-req-type",
  INVALID_HOSTING_LINK_DOMAIN: "auth/invalid-hosting-link-domain"
};
var logClient2 = new Logger("@firebase/auth");
function _logWarn(msg, ...args) {
  if (logClient2.logLevel <= LogLevel.WARN) {
    logClient2.warn(`Auth (${SDK_VERSION}): ${msg}`, ...args);
  }
}
__name(_logWarn, "_logWarn");
function _logError(msg, ...args) {
  if (logClient2.logLevel <= LogLevel.ERROR) {
    logClient2.error(`Auth (${SDK_VERSION}): ${msg}`, ...args);
  }
}
__name(_logError, "_logError");
function _fail2(authOrCode, ...rest) {
  throw createErrorInternal(authOrCode, ...rest);
}
__name(_fail2, "_fail");
function _createError(authOrCode, ...rest) {
  return createErrorInternal(authOrCode, ...rest);
}
__name(_createError, "_createError");
function _errorWithCustomMessage(auth, code, message) {
  const errorMap = Object.assign(Object.assign({}, prodErrorMap()), { [code]: message });
  const factory = new ErrorFactory("auth", "Firebase", errorMap);
  return factory.create(code, {
    appName: auth.name
  });
}
__name(_errorWithCustomMessage, "_errorWithCustomMessage");
function _serverAppCurrentUserOperationNotSupportedError(auth) {
  return _errorWithCustomMessage(auth, "operation-not-supported-in-this-environment", "Operations that alter the current user are not supported in conjunction with FirebaseServerApp");
}
__name(_serverAppCurrentUserOperationNotSupportedError, "_serverAppCurrentUserOperationNotSupportedError");
function createErrorInternal(authOrCode, ...rest) {
  if (typeof authOrCode !== "string") {
    const code = rest[0];
    const fullParams = [...rest.slice(1)];
    if (fullParams[0]) {
      fullParams[0].appName = authOrCode.name;
    }
    return authOrCode._errorFactory.create(code, ...fullParams);
  }
  return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);
}
__name(createErrorInternal, "createErrorInternal");
function _assert(assertion, authOrCode, ...rest) {
  if (!assertion) {
    throw createErrorInternal(authOrCode, ...rest);
  }
}
__name(_assert, "_assert");
function debugFail(failure) {
  const message = `INTERNAL ASSERTION FAILED: ` + failure;
  _logError(message);
  throw new Error(message);
}
__name(debugFail, "debugFail");
function debugAssert(assertion, message) {
  if (!assertion) {
    debugFail(message);
  }
}
__name(debugAssert, "debugAssert");
function _getCurrentUrl() {
  var _a;
  return typeof self !== "undefined" && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.href) || "";
}
__name(_getCurrentUrl, "_getCurrentUrl");
function _isHttpOrHttps() {
  return _getCurrentScheme() === "http:" || _getCurrentScheme() === "https:";
}
__name(_isHttpOrHttps, "_isHttpOrHttps");
function _getCurrentScheme() {
  var _a;
  return typeof self !== "undefined" && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.protocol) || null;
}
__name(_getCurrentScheme, "_getCurrentScheme");
function _isOnline() {
  if (typeof navigator !== "undefined" && navigator && "onLine" in navigator && typeof navigator.onLine === "boolean" && // Apply only for traditional web apps and Chrome extensions.
  // This is especially true for Cordova apps which have unreliable
  // navigator.onLine behavior unless cordova-plugin-network-information is
  // installed which overwrites the native navigator.onLine value and
  // defines navigator.connection.
  (_isHttpOrHttps() || isBrowserExtension() || "connection" in navigator)) {
    return navigator.onLine;
  }
  return true;
}
__name(_isOnline, "_isOnline");
function _getUserLanguage() {
  if (typeof navigator === "undefined") {
    return null;
  }
  const navigatorLanguage = navigator;
  return (
    // Most reliable, but only supported in Chrome/Firefox.
    navigatorLanguage.languages && navigatorLanguage.languages[0] || // Supported in most browsers, but returns the language of the browser
    // UI, not the language set in browser settings.
    navigatorLanguage.language || // Couldn't determine language.
    null
  );
}
__name(_getUserLanguage, "_getUserLanguage");
var Delay = class {
  static {
    __name(this, "Delay");
  }
  constructor(shortDelay, longDelay) {
    this.shortDelay = shortDelay;
    this.longDelay = longDelay;
    debugAssert(longDelay > shortDelay, "Short delay should be less than long delay!");
    this.isMobile = isMobileCordova() || isReactNative();
  }
  get() {
    if (!_isOnline()) {
      return Math.min(5e3, this.shortDelay);
    }
    return this.isMobile ? this.longDelay : this.shortDelay;
  }
};
function _emulatorUrl(config, path) {
  debugAssert(config.emulator, "Emulator should always be set here");
  const { url } = config.emulator;
  if (!path) {
    return url;
  }
  return `${url}${path.startsWith("/") ? path.slice(1) : path}`;
}
__name(_emulatorUrl, "_emulatorUrl");
var FetchProvider = class {
  static {
    __name(this, "FetchProvider");
  }
  static initialize(fetchImpl, headersImpl, responseImpl) {
    this.fetchImpl = fetchImpl;
    if (headersImpl) {
      this.headersImpl = headersImpl;
    }
    if (responseImpl) {
      this.responseImpl = responseImpl;
    }
  }
  static fetch() {
    if (this.fetchImpl) {
      return this.fetchImpl;
    }
    if (typeof self !== "undefined" && "fetch" in self) {
      return self.fetch;
    }
    if (typeof globalThis !== "undefined" && globalThis.fetch) {
      return globalThis.fetch;
    }
    if (typeof fetch !== "undefined") {
      return fetch;
    }
    debugFail("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static headers() {
    if (this.headersImpl) {
      return this.headersImpl;
    }
    if (typeof self !== "undefined" && "Headers" in self) {
      return self.Headers;
    }
    if (typeof globalThis !== "undefined" && globalThis.Headers) {
      return globalThis.Headers;
    }
    if (typeof Headers !== "undefined") {
      return Headers;
    }
    debugFail("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static response() {
    if (this.responseImpl) {
      return this.responseImpl;
    }
    if (typeof self !== "undefined" && "Response" in self) {
      return self.Response;
    }
    if (typeof globalThis !== "undefined" && globalThis.Response) {
      return globalThis.Response;
    }
    if (typeof Response !== "undefined") {
      return Response;
    }
    debugFail("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
};
var SERVER_ERROR_MAP = {
  // Custom token errors.
  [
    "CREDENTIAL_MISMATCH"
    /* ServerError.CREDENTIAL_MISMATCH */
  ]: "custom-token-mismatch",
  // This can only happen if the SDK sends a bad request.
  [
    "MISSING_CUSTOM_TOKEN"
    /* ServerError.MISSING_CUSTOM_TOKEN */
  ]: "internal-error",
  // Create Auth URI errors.
  [
    "INVALID_IDENTIFIER"
    /* ServerError.INVALID_IDENTIFIER */
  ]: "invalid-email",
  // This can only happen if the SDK sends a bad request.
  [
    "MISSING_CONTINUE_URI"
    /* ServerError.MISSING_CONTINUE_URI */
  ]: "internal-error",
  // Sign in with email and password errors (some apply to sign up too).
  [
    "INVALID_PASSWORD"
    /* ServerError.INVALID_PASSWORD */
  ]: "wrong-password",
  // This can only happen if the SDK sends a bad request.
  [
    "MISSING_PASSWORD"
    /* ServerError.MISSING_PASSWORD */
  ]: "missing-password",
  // Thrown if Email Enumeration Protection is enabled in the project and the email or password is
  // invalid.
  [
    "INVALID_LOGIN_CREDENTIALS"
    /* ServerError.INVALID_LOGIN_CREDENTIALS */
  ]: "invalid-credential",
  // Sign up with email and password errors.
  [
    "EMAIL_EXISTS"
    /* ServerError.EMAIL_EXISTS */
  ]: "email-already-in-use",
  [
    "PASSWORD_LOGIN_DISABLED"
    /* ServerError.PASSWORD_LOGIN_DISABLED */
  ]: "operation-not-allowed",
  // Verify assertion for sign in with credential errors:
  [
    "INVALID_IDP_RESPONSE"
    /* ServerError.INVALID_IDP_RESPONSE */
  ]: "invalid-credential",
  [
    "INVALID_PENDING_TOKEN"
    /* ServerError.INVALID_PENDING_TOKEN */
  ]: "invalid-credential",
  [
    "FEDERATED_USER_ID_ALREADY_LINKED"
    /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */
  ]: "credential-already-in-use",
  // This can only happen if the SDK sends a bad request.
  [
    "MISSING_REQ_TYPE"
    /* ServerError.MISSING_REQ_TYPE */
  ]: "internal-error",
  // Send Password reset email errors:
  [
    "EMAIL_NOT_FOUND"
    /* ServerError.EMAIL_NOT_FOUND */
  ]: "user-not-found",
  [
    "RESET_PASSWORD_EXCEED_LIMIT"
    /* ServerError.RESET_PASSWORD_EXCEED_LIMIT */
  ]: "too-many-requests",
  [
    "EXPIRED_OOB_CODE"
    /* ServerError.EXPIRED_OOB_CODE */
  ]: "expired-action-code",
  [
    "INVALID_OOB_CODE"
    /* ServerError.INVALID_OOB_CODE */
  ]: "invalid-action-code",
  // This can only happen if the SDK sends a bad request.
  [
    "MISSING_OOB_CODE"
    /* ServerError.MISSING_OOB_CODE */
  ]: "internal-error",
  // Operations that require ID token in request:
  [
    "CREDENTIAL_TOO_OLD_LOGIN_AGAIN"
    /* ServerError.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */
  ]: "requires-recent-login",
  [
    "INVALID_ID_TOKEN"
    /* ServerError.INVALID_ID_TOKEN */
  ]: "invalid-user-token",
  [
    "TOKEN_EXPIRED"
    /* ServerError.TOKEN_EXPIRED */
  ]: "user-token-expired",
  [
    "USER_NOT_FOUND"
    /* ServerError.USER_NOT_FOUND */
  ]: "user-token-expired",
  // Other errors.
  [
    "TOO_MANY_ATTEMPTS_TRY_LATER"
    /* ServerError.TOO_MANY_ATTEMPTS_TRY_LATER */
  ]: "too-many-requests",
  [
    "PASSWORD_DOES_NOT_MEET_REQUIREMENTS"
    /* ServerError.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */
  ]: "password-does-not-meet-requirements",
  // Phone Auth related errors.
  [
    "INVALID_CODE"
    /* ServerError.INVALID_CODE */
  ]: "invalid-verification-code",
  [
    "INVALID_SESSION_INFO"
    /* ServerError.INVALID_SESSION_INFO */
  ]: "invalid-verification-id",
  [
    "INVALID_TEMPORARY_PROOF"
    /* ServerError.INVALID_TEMPORARY_PROOF */
  ]: "invalid-credential",
  [
    "MISSING_SESSION_INFO"
    /* ServerError.MISSING_SESSION_INFO */
  ]: "missing-verification-id",
  [
    "SESSION_EXPIRED"
    /* ServerError.SESSION_EXPIRED */
  ]: "code-expired",
  // Other action code errors when additional settings passed.
  // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.
  // This is OK as this error will be caught by client side validation.
  [
    "MISSING_ANDROID_PACKAGE_NAME"
    /* ServerError.MISSING_ANDROID_PACKAGE_NAME */
  ]: "missing-android-pkg-name",
  [
    "UNAUTHORIZED_DOMAIN"
    /* ServerError.UNAUTHORIZED_DOMAIN */
  ]: "unauthorized-continue-uri",
  // getProjectConfig errors when clientId is passed.
  [
    "INVALID_OAUTH_CLIENT_ID"
    /* ServerError.INVALID_OAUTH_CLIENT_ID */
  ]: "invalid-oauth-client-id",
  // User actions (sign-up or deletion) disabled errors.
  [
    "ADMIN_ONLY_OPERATION"
    /* ServerError.ADMIN_ONLY_OPERATION */
  ]: "admin-restricted-operation",
  // Multi factor related errors.
  [
    "INVALID_MFA_PENDING_CREDENTIAL"
    /* ServerError.INVALID_MFA_PENDING_CREDENTIAL */
  ]: "invalid-multi-factor-session",
  [
    "MFA_ENROLLMENT_NOT_FOUND"
    /* ServerError.MFA_ENROLLMENT_NOT_FOUND */
  ]: "multi-factor-info-not-found",
  [
    "MISSING_MFA_ENROLLMENT_ID"
    /* ServerError.MISSING_MFA_ENROLLMENT_ID */
  ]: "missing-multi-factor-info",
  [
    "MISSING_MFA_PENDING_CREDENTIAL"
    /* ServerError.MISSING_MFA_PENDING_CREDENTIAL */
  ]: "missing-multi-factor-session",
  [
    "SECOND_FACTOR_EXISTS"
    /* ServerError.SECOND_FACTOR_EXISTS */
  ]: "second-factor-already-in-use",
  [
    "SECOND_FACTOR_LIMIT_EXCEEDED"
    /* ServerError.SECOND_FACTOR_LIMIT_EXCEEDED */
  ]: "maximum-second-factor-count-exceeded",
  // Blocking functions related errors.
  [
    "BLOCKING_FUNCTION_ERROR_RESPONSE"
    /* ServerError.BLOCKING_FUNCTION_ERROR_RESPONSE */
  ]: "internal-error",
  // Recaptcha related errors.
  [
    "RECAPTCHA_NOT_ENABLED"
    /* ServerError.RECAPTCHA_NOT_ENABLED */
  ]: "recaptcha-not-enabled",
  [
    "MISSING_RECAPTCHA_TOKEN"
    /* ServerError.MISSING_RECAPTCHA_TOKEN */
  ]: "missing-recaptcha-token",
  [
    "INVALID_RECAPTCHA_TOKEN"
    /* ServerError.INVALID_RECAPTCHA_TOKEN */
  ]: "invalid-recaptcha-token",
  [
    "INVALID_RECAPTCHA_ACTION"
    /* ServerError.INVALID_RECAPTCHA_ACTION */
  ]: "invalid-recaptcha-action",
  [
    "MISSING_CLIENT_TYPE"
    /* ServerError.MISSING_CLIENT_TYPE */
  ]: "missing-client-type",
  [
    "MISSING_RECAPTCHA_VERSION"
    /* ServerError.MISSING_RECAPTCHA_VERSION */
  ]: "missing-recaptcha-version",
  [
    "INVALID_RECAPTCHA_VERSION"
    /* ServerError.INVALID_RECAPTCHA_VERSION */
  ]: "invalid-recaptcha-version",
  [
    "INVALID_REQ_TYPE"
    /* ServerError.INVALID_REQ_TYPE */
  ]: "invalid-req-type"
  /* AuthErrorCode.INVALID_REQ_TYPE */
};
var CookieAuthProxiedEndpoints = [
  "/v1/accounts:signInWithCustomToken",
  "/v1/accounts:signInWithEmailLink",
  "/v1/accounts:signInWithIdp",
  "/v1/accounts:signInWithPassword",
  "/v1/accounts:signInWithPhoneNumber",
  "/v1/token"
  /* Endpoint.TOKEN */
];
var DEFAULT_API_TIMEOUT_MS = new Delay(3e4, 6e4);
function _addTidIfNecessary(auth, request) {
  if (auth.tenantId && !request.tenantId) {
    return Object.assign(Object.assign({}, request), { tenantId: auth.tenantId });
  }
  return request;
}
__name(_addTidIfNecessary, "_addTidIfNecessary");
async function _performApiRequest(auth, method, path, request, customErrorMap = {}) {
  return _performFetchWithErrorHandling(auth, customErrorMap, async () => {
    let body = {};
    let params = {};
    if (request) {
      if (method === "GET") {
        params = request;
      } else {
        body = {
          body: JSON.stringify(request)
        };
      }
    }
    const query2 = querystring(Object.assign({ key: auth.config.apiKey }, params)).slice(1);
    const headers = await auth._getAdditionalHeaders();
    headers[
      "Content-Type"
      /* HttpHeader.CONTENT_TYPE */
    ] = "application/json";
    if (auth.languageCode) {
      headers[
        "X-Firebase-Locale"
        /* HttpHeader.X_FIREBASE_LOCALE */
      ] = auth.languageCode;
    }
    const fetchArgs = Object.assign({
      method,
      headers
    }, body);
    if (!isCloudflareWorker()) {
      fetchArgs.referrerPolicy = "no-referrer";
    }
    if (auth.emulatorConfig && isCloudWorkstation(auth.emulatorConfig.host)) {
      fetchArgs.credentials = "include";
    }
    return FetchProvider.fetch()(await _getFinalTarget(auth, auth.config.apiHost, path, query2), fetchArgs);
  });
}
__name(_performApiRequest, "_performApiRequest");
async function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {
  auth._canInitEmulator = false;
  const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);
  try {
    const networkTimeout = new NetworkTimeout(auth);
    const response = await Promise.race([
      fetchFn(),
      networkTimeout.promise
    ]);
    networkTimeout.clearNetworkTimeout();
    const json = await response.json();
    if ("needConfirmation" in json) {
      throw _makeTaggedError(auth, "account-exists-with-different-credential", json);
    }
    if (response.ok && !("errorMessage" in json)) {
      return json;
    } else {
      const errorMessage = response.ok ? json.errorMessage : json.error.message;
      const [serverErrorCode, serverErrorMessage] = errorMessage.split(" : ");
      if (serverErrorCode === "FEDERATED_USER_ID_ALREADY_LINKED") {
        throw _makeTaggedError(auth, "credential-already-in-use", json);
      } else if (serverErrorCode === "EMAIL_EXISTS") {
        throw _makeTaggedError(auth, "email-already-in-use", json);
      } else if (serverErrorCode === "USER_DISABLED") {
        throw _makeTaggedError(auth, "user-disabled", json);
      }
      const authError = errorMap[serverErrorCode] || serverErrorCode.toLowerCase().replace(/[_\s]+/g, "-");
      if (serverErrorMessage) {
        throw _errorWithCustomMessage(auth, authError, serverErrorMessage);
      } else {
        _fail2(auth, authError);
      }
    }
  } catch (e10) {
    if (e10 instanceof FirebaseError) {
      throw e10;
    }
    _fail2(auth, "network-request-failed", { "message": String(e10) });
  }
}
__name(_performFetchWithErrorHandling, "_performFetchWithErrorHandling");
async function _performSignInRequest(auth, method, path, request, customErrorMap = {}) {
  const serverResponse = await _performApiRequest(auth, method, path, request, customErrorMap);
  if ("mfaPendingCredential" in serverResponse) {
    _fail2(auth, "multi-factor-auth-required", {
      _serverResponse: serverResponse
    });
  }
  return serverResponse;
}
__name(_performSignInRequest, "_performSignInRequest");
async function _getFinalTarget(auth, host, path, query2) {
  const base = `${host}${path}?${query2}`;
  const authInternal = auth;
  const finalTarget = authInternal.config.emulator ? _emulatorUrl(auth.config, base) : `${auth.config.apiScheme}://${base}`;
  if (CookieAuthProxiedEndpoints.includes(path)) {
    await authInternal._persistenceManagerAvailable;
    if (authInternal._getPersistenceType() === "COOKIE") {
      const cookiePersistence = authInternal._getPersistence();
      return cookiePersistence._getFinalTarget(finalTarget).toString();
    }
  }
  return finalTarget;
}
__name(_getFinalTarget, "_getFinalTarget");
function _parseEnforcementState(enforcementStateStr) {
  switch (enforcementStateStr) {
    case "ENFORCE":
      return "ENFORCE";
    case "AUDIT":
      return "AUDIT";
    case "OFF":
      return "OFF";
    default:
      return "ENFORCEMENT_STATE_UNSPECIFIED";
  }
}
__name(_parseEnforcementState, "_parseEnforcementState");
var NetworkTimeout = class {
  static {
    __name(this, "NetworkTimeout");
  }
  clearNetworkTimeout() {
    clearTimeout(this.timer);
  }
  constructor(auth) {
    this.auth = auth;
    this.timer = null;
    this.promise = new Promise((_, reject) => {
      this.timer = setTimeout(() => {
        return reject(_createError(
          this.auth,
          "network-request-failed"
          /* AuthErrorCode.NETWORK_REQUEST_FAILED */
        ));
      }, DEFAULT_API_TIMEOUT_MS.get());
    });
  }
};
function _makeTaggedError(auth, code, response) {
  const errorParams = {
    appName: auth.name
  };
  if (response.email) {
    errorParams.email = response.email;
  }
  if (response.phoneNumber) {
    errorParams.phoneNumber = response.phoneNumber;
  }
  const error = _createError(auth, code, errorParams);
  error.customData._tokenResponse = response;
  return error;
}
__name(_makeTaggedError, "_makeTaggedError");
function isEnterprise(grecaptcha) {
  return grecaptcha !== void 0 && grecaptcha.enterprise !== void 0;
}
__name(isEnterprise, "isEnterprise");
var RecaptchaConfig = class {
  static {
    __name(this, "RecaptchaConfig");
  }
  constructor(response) {
    this.siteKey = "";
    this.recaptchaEnforcementState = [];
    if (response.recaptchaKey === void 0) {
      throw new Error("recaptchaKey undefined");
    }
    this.siteKey = response.recaptchaKey.split("/")[3];
    this.recaptchaEnforcementState = response.recaptchaEnforcementState;
  }
  /**
   * Returns the reCAPTCHA Enterprise enforcement state for the given provider.
   *
   * @param providerStr - The provider whose enforcement state is to be returned.
   * @returns The reCAPTCHA Enterprise enforcement state for the given provider.
   */
  getProviderEnforcementState(providerStr) {
    if (!this.recaptchaEnforcementState || this.recaptchaEnforcementState.length === 0) {
      return null;
    }
    for (const recaptchaEnforcementState of this.recaptchaEnforcementState) {
      if (recaptchaEnforcementState.provider && recaptchaEnforcementState.provider === providerStr) {
        return _parseEnforcementState(recaptchaEnforcementState.enforcementState);
      }
    }
    return null;
  }
  /**
   * Returns true if the reCAPTCHA Enterprise enforcement state for the provider is set to ENFORCE or AUDIT.
   *
   * @param providerStr - The provider whose enablement state is to be returned.
   * @returns Whether or not reCAPTCHA Enterprise protection is enabled for the given provider.
   */
  isProviderEnabled(providerStr) {
    return this.getProviderEnforcementState(providerStr) === "ENFORCE" || this.getProviderEnforcementState(providerStr) === "AUDIT";
  }
  /**
   * Returns true if reCAPTCHA Enterprise protection is enabled in at least one provider, otherwise
   * returns false.
   *
   * @returns Whether or not reCAPTCHA Enterprise protection is enabled for at least one provider.
   */
  isAnyProviderEnabled() {
    return this.isProviderEnabled(
      "EMAIL_PASSWORD_PROVIDER"
      /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */
    ) || this.isProviderEnabled(
      "PHONE_PROVIDER"
      /* RecaptchaAuthProvider.PHONE_PROVIDER */
    );
  }
};
async function getRecaptchaConfig(auth, request) {
  return _performApiRequest(auth, "GET", "/v2/recaptchaConfig", _addTidIfNecessary(auth, request));
}
__name(getRecaptchaConfig, "getRecaptchaConfig");
async function deleteAccount(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:delete", request);
}
__name(deleteAccount, "deleteAccount");
async function deleteLinkedAccounts(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:update", request);
}
__name(deleteLinkedAccounts, "deleteLinkedAccounts");
async function getAccountInfo(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:lookup", request);
}
__name(getAccountInfo, "getAccountInfo");
function utcTimestampToDateString(utcTimestamp) {
  if (!utcTimestamp) {
    return void 0;
  }
  try {
    const date = new Date(Number(utcTimestamp));
    if (!isNaN(date.getTime())) {
      return date.toUTCString();
    }
  } catch (e10) {
  }
  return void 0;
}
__name(utcTimestampToDateString, "utcTimestampToDateString");
function getIdToken(user, forceRefresh = false) {
  return getModularInstance(user).getIdToken(forceRefresh);
}
__name(getIdToken, "getIdToken");
async function getIdTokenResult(user, forceRefresh = false) {
  const userInternal = getModularInstance(user);
  const token = await userInternal.getIdToken(forceRefresh);
  const claims = _parseToken(token);
  _assert(
    claims && claims.exp && claims.auth_time && claims.iat,
    userInternal.auth,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  const firebase = typeof claims.firebase === "object" ? claims.firebase : void 0;
  const signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase["sign_in_provider"];
  return {
    claims,
    token,
    authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),
    issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),
    expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),
    signInProvider: signInProvider || null,
    signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase["sign_in_second_factor"]) || null
  };
}
__name(getIdTokenResult, "getIdTokenResult");
function secondsStringToMilliseconds(seconds) {
  return Number(seconds) * 1e3;
}
__name(secondsStringToMilliseconds, "secondsStringToMilliseconds");
function _parseToken(token) {
  const [algorithm, payload, signature] = token.split(".");
  if (algorithm === void 0 || payload === void 0 || signature === void 0) {
    _logError("JWT malformed, contained fewer than 3 sections");
    return null;
  }
  try {
    const decoded = base64Decode(payload);
    if (!decoded) {
      _logError("Failed to decode base64 JWT payload");
      return null;
    }
    return JSON.parse(decoded);
  } catch (e10) {
    _logError("Caught error parsing JWT payload as JSON", e10 === null || e10 === void 0 ? void 0 : e10.toString());
    return null;
  }
}
__name(_parseToken, "_parseToken");
function _tokenExpiresIn(token) {
  const parsedToken = _parseToken(token);
  _assert(
    parsedToken,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  _assert(
    typeof parsedToken.exp !== "undefined",
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  _assert(
    typeof parsedToken.iat !== "undefined",
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  return Number(parsedToken.exp) - Number(parsedToken.iat);
}
__name(_tokenExpiresIn, "_tokenExpiresIn");
async function _logoutIfInvalidated(user, promise, bypassAuthState = false) {
  if (bypassAuthState) {
    return promise;
  }
  try {
    return await promise;
  } catch (e10) {
    if (e10 instanceof FirebaseError && isUserInvalidated(e10)) {
      if (user.auth.currentUser === user) {
        await user.auth.signOut();
      }
    }
    throw e10;
  }
}
__name(_logoutIfInvalidated, "_logoutIfInvalidated");
function isUserInvalidated({ code }) {
  return code === `auth/${"user-disabled"}` || code === `auth/${"user-token-expired"}`;
}
__name(isUserInvalidated, "isUserInvalidated");
var ProactiveRefresh = class {
  static {
    __name(this, "ProactiveRefresh");
  }
  constructor(user) {
    this.user = user;
    this.isRunning = false;
    this.timerId = null;
    this.errorBackoff = 3e4;
  }
  _start() {
    if (this.isRunning) {
      return;
    }
    this.isRunning = true;
    this.schedule();
  }
  _stop() {
    if (!this.isRunning) {
      return;
    }
    this.isRunning = false;
    if (this.timerId !== null) {
      clearTimeout(this.timerId);
    }
  }
  getInterval(wasError) {
    var _a;
    if (wasError) {
      const interval = this.errorBackoff;
      this.errorBackoff = Math.min(
        this.errorBackoff * 2,
        96e4
        /* Duration.RETRY_BACKOFF_MAX */
      );
      return interval;
    } else {
      this.errorBackoff = 3e4;
      const expTime = (_a = this.user.stsTokenManager.expirationTime) !== null && _a !== void 0 ? _a : 0;
      const interval = expTime - Date.now() - 3e5;
      return Math.max(0, interval);
    }
  }
  schedule(wasError = false) {
    if (!this.isRunning) {
      return;
    }
    const interval = this.getInterval(wasError);
    this.timerId = setTimeout(async () => {
      await this.iteration();
    }, interval);
  }
  async iteration() {
    try {
      await this.user.getIdToken(true);
    } catch (e10) {
      if ((e10 === null || e10 === void 0 ? void 0 : e10.code) === `auth/${"network-request-failed"}`) {
        this.schedule(
          /* wasError */
          true
        );
      }
      return;
    }
    this.schedule();
  }
};
var UserMetadata = class {
  static {
    __name(this, "UserMetadata");
  }
  constructor(createdAt, lastLoginAt) {
    this.createdAt = createdAt;
    this.lastLoginAt = lastLoginAt;
    this._initializeTime();
  }
  _initializeTime() {
    this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);
    this.creationTime = utcTimestampToDateString(this.createdAt);
  }
  _copy(metadata) {
    this.createdAt = metadata.createdAt;
    this.lastLoginAt = metadata.lastLoginAt;
    this._initializeTime();
  }
  toJSON() {
    return {
      createdAt: this.createdAt,
      lastLoginAt: this.lastLoginAt
    };
  }
};
async function _reloadWithoutSaving(user) {
  var _a;
  const auth = user.auth;
  const idToken = await user.getIdToken();
  const response = await _logoutIfInvalidated(user, getAccountInfo(auth, { idToken }));
  _assert(
    response === null || response === void 0 ? void 0 : response.users.length,
    auth,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  const coreAccount = response.users[0];
  user._notifyReloadListener(coreAccount);
  const newProviderData = ((_a = coreAccount.providerUserInfo) === null || _a === void 0 ? void 0 : _a.length) ? extractProviderData(coreAccount.providerUserInfo) : [];
  const providerData = mergeProviderData(user.providerData, newProviderData);
  const oldIsAnonymous = user.isAnonymous;
  const newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);
  const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;
  const updates = {
    uid: coreAccount.localId,
    displayName: coreAccount.displayName || null,
    photoURL: coreAccount.photoUrl || null,
    email: coreAccount.email || null,
    emailVerified: coreAccount.emailVerified || false,
    phoneNumber: coreAccount.phoneNumber || null,
    tenantId: coreAccount.tenantId || null,
    providerData,
    metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),
    isAnonymous
  };
  Object.assign(user, updates);
}
__name(_reloadWithoutSaving, "_reloadWithoutSaving");
async function reload(user) {
  const userInternal = getModularInstance(user);
  await _reloadWithoutSaving(userInternal);
  await userInternal.auth._persistUserIfCurrent(userInternal);
  userInternal.auth._notifyListenersIfCurrent(userInternal);
}
__name(reload, "reload");
function mergeProviderData(original, newData) {
  const deduped = original.filter((o21) => !newData.some((n11) => n11.providerId === o21.providerId));
  return [...deduped, ...newData];
}
__name(mergeProviderData, "mergeProviderData");
function extractProviderData(providers) {
  return providers.map((_a) => {
    var { providerId } = _a, provider = __rest(_a, ["providerId"]);
    return {
      providerId,
      uid: provider.rawId || "",
      displayName: provider.displayName || null,
      email: provider.email || null,
      phoneNumber: provider.phoneNumber || null,
      photoURL: provider.photoUrl || null
    };
  });
}
__name(extractProviderData, "extractProviderData");
async function requestStsToken(auth, refreshToken) {
  const response = await _performFetchWithErrorHandling(auth, {}, async () => {
    const body = querystring({
      "grant_type": "refresh_token",
      "refresh_token": refreshToken
    }).slice(1);
    const { tokenApiHost, apiKey } = auth.config;
    const url = await _getFinalTarget(auth, tokenApiHost, "/v1/token", `key=${apiKey}`);
    const headers = await auth._getAdditionalHeaders();
    headers[
      "Content-Type"
      /* HttpHeader.CONTENT_TYPE */
    ] = "application/x-www-form-urlencoded";
    const options = {
      method: "POST",
      headers,
      body
    };
    if (auth.emulatorConfig && isCloudWorkstation(auth.emulatorConfig.host)) {
      options.credentials = "include";
    }
    return FetchProvider.fetch()(url, options);
  });
  return {
    accessToken: response.access_token,
    expiresIn: response.expires_in,
    refreshToken: response.refresh_token
  };
}
__name(requestStsToken, "requestStsToken");
async function revokeToken(auth, request) {
  return _performApiRequest(auth, "POST", "/v2/accounts:revokeToken", _addTidIfNecessary(auth, request));
}
__name(revokeToken, "revokeToken");
var StsTokenManager = class _StsTokenManager {
  static {
    __name(this, "StsTokenManager");
  }
  constructor() {
    this.refreshToken = null;
    this.accessToken = null;
    this.expirationTime = null;
  }
  get isExpired() {
    return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
  }
  updateFromServerResponse(response) {
    _assert(
      response.idToken,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    _assert(
      typeof response.idToken !== "undefined",
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    _assert(
      typeof response.refreshToken !== "undefined",
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const expiresIn = "expiresIn" in response && typeof response.expiresIn !== "undefined" ? Number(response.expiresIn) : _tokenExpiresIn(response.idToken);
    this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);
  }
  updateFromIdToken(idToken) {
    _assert(
      idToken.length !== 0,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const expiresIn = _tokenExpiresIn(idToken);
    this.updateTokensAndExpiration(idToken, null, expiresIn);
  }
  async getToken(auth, forceRefresh = false) {
    if (!forceRefresh && this.accessToken && !this.isExpired) {
      return this.accessToken;
    }
    _assert(
      this.refreshToken,
      auth,
      "user-token-expired"
      /* AuthErrorCode.TOKEN_EXPIRED */
    );
    if (this.refreshToken) {
      await this.refresh(auth, this.refreshToken);
      return this.accessToken;
    }
    return null;
  }
  clearRefreshToken() {
    this.refreshToken = null;
  }
  async refresh(auth, oldToken) {
    const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth, oldToken);
    this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));
  }
  updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {
    this.refreshToken = refreshToken || null;
    this.accessToken = accessToken || null;
    this.expirationTime = Date.now() + expiresInSec * 1e3;
  }
  static fromJSON(appName, object) {
    const { refreshToken, accessToken, expirationTime } = object;
    const manager = new _StsTokenManager();
    if (refreshToken) {
      _assert(typeof refreshToken === "string", "internal-error", {
        appName
      });
      manager.refreshToken = refreshToken;
    }
    if (accessToken) {
      _assert(typeof accessToken === "string", "internal-error", {
        appName
      });
      manager.accessToken = accessToken;
    }
    if (expirationTime) {
      _assert(typeof expirationTime === "number", "internal-error", {
        appName
      });
      manager.expirationTime = expirationTime;
    }
    return manager;
  }
  toJSON() {
    return {
      refreshToken: this.refreshToken,
      accessToken: this.accessToken,
      expirationTime: this.expirationTime
    };
  }
  _assign(stsTokenManager) {
    this.accessToken = stsTokenManager.accessToken;
    this.refreshToken = stsTokenManager.refreshToken;
    this.expirationTime = stsTokenManager.expirationTime;
  }
  _clone() {
    return Object.assign(new _StsTokenManager(), this.toJSON());
  }
  _performRefresh() {
    return debugFail("not implemented");
  }
};
function assertStringOrUndefined(assertion, appName) {
  _assert(typeof assertion === "string" || typeof assertion === "undefined", "internal-error", { appName });
}
__name(assertStringOrUndefined, "assertStringOrUndefined");
var UserImpl = class _UserImpl {
  static {
    __name(this, "UserImpl");
  }
  constructor(_a) {
    var { uid, auth, stsTokenManager } = _a, opt = __rest(_a, ["uid", "auth", "stsTokenManager"]);
    this.providerId = "firebase";
    this.proactiveRefresh = new ProactiveRefresh(this);
    this.reloadUserInfo = null;
    this.reloadListener = null;
    this.uid = uid;
    this.auth = auth;
    this.stsTokenManager = stsTokenManager;
    this.accessToken = stsTokenManager.accessToken;
    this.displayName = opt.displayName || null;
    this.email = opt.email || null;
    this.emailVerified = opt.emailVerified || false;
    this.phoneNumber = opt.phoneNumber || null;
    this.photoURL = opt.photoURL || null;
    this.isAnonymous = opt.isAnonymous || false;
    this.tenantId = opt.tenantId || null;
    this.providerData = opt.providerData ? [...opt.providerData] : [];
    this.metadata = new UserMetadata(opt.createdAt || void 0, opt.lastLoginAt || void 0);
  }
  async getIdToken(forceRefresh) {
    const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));
    _assert(
      accessToken,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    if (this.accessToken !== accessToken) {
      this.accessToken = accessToken;
      await this.auth._persistUserIfCurrent(this);
      this.auth._notifyListenersIfCurrent(this);
    }
    return accessToken;
  }
  getIdTokenResult(forceRefresh) {
    return getIdTokenResult(this, forceRefresh);
  }
  reload() {
    return reload(this);
  }
  _assign(user) {
    if (this === user) {
      return;
    }
    _assert(
      this.uid === user.uid,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    this.displayName = user.displayName;
    this.photoURL = user.photoURL;
    this.email = user.email;
    this.emailVerified = user.emailVerified;
    this.phoneNumber = user.phoneNumber;
    this.isAnonymous = user.isAnonymous;
    this.tenantId = user.tenantId;
    this.providerData = user.providerData.map((userInfo) => Object.assign({}, userInfo));
    this.metadata._copy(user.metadata);
    this.stsTokenManager._assign(user.stsTokenManager);
  }
  _clone(auth) {
    const newUser = new _UserImpl(Object.assign(Object.assign({}, this), { auth, stsTokenManager: this.stsTokenManager._clone() }));
    newUser.metadata._copy(this.metadata);
    return newUser;
  }
  _onReload(callback) {
    _assert(
      !this.reloadListener,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    this.reloadListener = callback;
    if (this.reloadUserInfo) {
      this._notifyReloadListener(this.reloadUserInfo);
      this.reloadUserInfo = null;
    }
  }
  _notifyReloadListener(userInfo) {
    if (this.reloadListener) {
      this.reloadListener(userInfo);
    } else {
      this.reloadUserInfo = userInfo;
    }
  }
  _startProactiveRefresh() {
    this.proactiveRefresh._start();
  }
  _stopProactiveRefresh() {
    this.proactiveRefresh._stop();
  }
  async _updateTokensIfNecessary(response, reload2 = false) {
    let tokensRefreshed = false;
    if (response.idToken && response.idToken !== this.stsTokenManager.accessToken) {
      this.stsTokenManager.updateFromServerResponse(response);
      tokensRefreshed = true;
    }
    if (reload2) {
      await _reloadWithoutSaving(this);
    }
    await this.auth._persistUserIfCurrent(this);
    if (tokensRefreshed) {
      this.auth._notifyListenersIfCurrent(this);
    }
  }
  async delete() {
    if (_isFirebaseServerApp(this.auth.app)) {
      return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this.auth));
    }
    const idToken = await this.getIdToken();
    await _logoutIfInvalidated(this, deleteAccount(this.auth, { idToken }));
    this.stsTokenManager.clearRefreshToken();
    return this.auth.signOut();
  }
  toJSON() {
    return Object.assign(Object.assign({
      uid: this.uid,
      email: this.email || void 0,
      emailVerified: this.emailVerified,
      displayName: this.displayName || void 0,
      isAnonymous: this.isAnonymous,
      photoURL: this.photoURL || void 0,
      phoneNumber: this.phoneNumber || void 0,
      tenantId: this.tenantId || void 0,
      providerData: this.providerData.map((userInfo) => Object.assign({}, userInfo)),
      stsTokenManager: this.stsTokenManager.toJSON(),
      // Redirect event ID must be maintained in case there is a pending
      // redirect event.
      _redirectEventId: this._redirectEventId
    }, this.metadata.toJSON()), {
      // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):
      apiKey: this.auth.config.apiKey,
      appName: this.auth.name
    });
  }
  get refreshToken() {
    return this.stsTokenManager.refreshToken || "";
  }
  static _fromJSON(auth, object) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : void 0;
    const email = (_b = object.email) !== null && _b !== void 0 ? _b : void 0;
    const phoneNumber = (_c = object.phoneNumber) !== null && _c !== void 0 ? _c : void 0;
    const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : void 0;
    const tenantId = (_e = object.tenantId) !== null && _e !== void 0 ? _e : void 0;
    const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : void 0;
    const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : void 0;
    const lastLoginAt = (_h = object.lastLoginAt) !== null && _h !== void 0 ? _h : void 0;
    const { uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;
    _assert(
      uid && plainObjectTokenManager,
      auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);
    _assert(
      typeof uid === "string",
      auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    assertStringOrUndefined(displayName, auth.name);
    assertStringOrUndefined(email, auth.name);
    _assert(
      typeof emailVerified === "boolean",
      auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    _assert(
      typeof isAnonymous === "boolean",
      auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    assertStringOrUndefined(phoneNumber, auth.name);
    assertStringOrUndefined(photoURL, auth.name);
    assertStringOrUndefined(tenantId, auth.name);
    assertStringOrUndefined(_redirectEventId, auth.name);
    assertStringOrUndefined(createdAt, auth.name);
    assertStringOrUndefined(lastLoginAt, auth.name);
    const user = new _UserImpl({
      uid,
      auth,
      email,
      emailVerified,
      displayName,
      isAnonymous,
      photoURL,
      phoneNumber,
      tenantId,
      stsTokenManager,
      createdAt,
      lastLoginAt
    });
    if (providerData && Array.isArray(providerData)) {
      user.providerData = providerData.map((userInfo) => Object.assign({}, userInfo));
    }
    if (_redirectEventId) {
      user._redirectEventId = _redirectEventId;
    }
    return user;
  }
  /**
   * Initialize a User from an idToken server response
   * @param auth
   * @param idTokenResponse
   */
  static async _fromIdTokenResponse(auth, idTokenResponse, isAnonymous = false) {
    const stsTokenManager = new StsTokenManager();
    stsTokenManager.updateFromServerResponse(idTokenResponse);
    const user = new _UserImpl({
      uid: idTokenResponse.localId,
      auth,
      stsTokenManager,
      isAnonymous
    });
    await _reloadWithoutSaving(user);
    return user;
  }
  /**
   * Initialize a User from an idToken server response
   * @param auth
   * @param idTokenResponse
   */
  static async _fromGetAccountInfoResponse(auth, response, idToken) {
    const coreAccount = response.users[0];
    _assert(
      coreAccount.localId !== void 0,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const providerData = coreAccount.providerUserInfo !== void 0 ? extractProviderData(coreAccount.providerUserInfo) : [];
    const isAnonymous = !(coreAccount.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);
    const stsTokenManager = new StsTokenManager();
    stsTokenManager.updateFromIdToken(idToken);
    const user = new _UserImpl({
      uid: coreAccount.localId,
      auth,
      stsTokenManager,
      isAnonymous
    });
    const updates = {
      uid: coreAccount.localId,
      displayName: coreAccount.displayName || null,
      photoURL: coreAccount.photoUrl || null,
      email: coreAccount.email || null,
      emailVerified: coreAccount.emailVerified || false,
      phoneNumber: coreAccount.phoneNumber || null,
      tenantId: coreAccount.tenantId || null,
      providerData,
      metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),
      isAnonymous: !(coreAccount.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length)
    };
    Object.assign(user, updates);
    return user;
  }
};
var instanceCache = /* @__PURE__ */ new Map();
function _getInstance(cls) {
  debugAssert(cls instanceof Function, "Expected a class definition");
  let instance = instanceCache.get(cls);
  if (instance) {
    debugAssert(instance instanceof cls, "Instance stored in cache mismatched with class");
    return instance;
  }
  instance = new cls();
  instanceCache.set(cls, instance);
  return instance;
}
__name(_getInstance, "_getInstance");
var InMemoryPersistence = class {
  static {
    __name(this, "InMemoryPersistence");
  }
  constructor() {
    this.type = "NONE";
    this.storage = {};
  }
  async _isAvailable() {
    return true;
  }
  async _set(key, value) {
    this.storage[key] = value;
  }
  async _get(key) {
    const value = this.storage[key];
    return value === void 0 ? null : value;
  }
  async _remove(key) {
    delete this.storage[key];
  }
  _addListener(_key, _listener) {
    return;
  }
  _removeListener(_key, _listener) {
    return;
  }
};
InMemoryPersistence.type = "NONE";
var inMemoryPersistence = InMemoryPersistence;
function _persistenceKeyName(key, apiKey, appName) {
  return `${"firebase"}:${key}:${apiKey}:${appName}`;
}
__name(_persistenceKeyName, "_persistenceKeyName");
var PersistenceUserManager = class _PersistenceUserManager {
  static {
    __name(this, "PersistenceUserManager");
  }
  constructor(persistence, auth, userKey) {
    this.persistence = persistence;
    this.auth = auth;
    this.userKey = userKey;
    const { config, name: name4 } = this.auth;
    this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name4);
    this.fullPersistenceKey = _persistenceKeyName("persistence", config.apiKey, name4);
    this.boundEventHandler = auth._onStorageEvent.bind(auth);
    this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
  }
  setCurrentUser(user) {
    return this.persistence._set(this.fullUserKey, user.toJSON());
  }
  async getCurrentUser() {
    const blob = await this.persistence._get(this.fullUserKey);
    if (!blob) {
      return null;
    }
    if (typeof blob === "string") {
      const response = await getAccountInfo(this.auth, { idToken: blob }).catch(() => void 0);
      if (!response) {
        return null;
      }
      return UserImpl._fromGetAccountInfoResponse(this.auth, response, blob);
    }
    return UserImpl._fromJSON(this.auth, blob);
  }
  removeCurrentUser() {
    return this.persistence._remove(this.fullUserKey);
  }
  savePersistenceForRedirect() {
    return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
  }
  async setPersistence(newPersistence) {
    if (this.persistence === newPersistence) {
      return;
    }
    const currentUser = await this.getCurrentUser();
    await this.removeCurrentUser();
    this.persistence = newPersistence;
    if (currentUser) {
      return this.setCurrentUser(currentUser);
    }
  }
  delete() {
    this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
  }
  static async create(auth, persistenceHierarchy, userKey = "authUser") {
    if (!persistenceHierarchy.length) {
      return new _PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey);
    }
    const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence) => {
      if (await persistence._isAvailable()) {
        return persistence;
      }
      return void 0;
    }))).filter((persistence) => persistence);
    let selectedPersistence = availablePersistences[0] || _getInstance(inMemoryPersistence);
    const key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);
    let userToMigrate = null;
    for (const persistence of persistenceHierarchy) {
      try {
        const blob = await persistence._get(key);
        if (blob) {
          let user;
          if (typeof blob === "string") {
            const response = await getAccountInfo(auth, {
              idToken: blob
            }).catch(() => void 0);
            if (!response) {
              break;
            }
            user = await UserImpl._fromGetAccountInfoResponse(auth, response, blob);
          } else {
            user = UserImpl._fromJSON(auth, blob);
          }
          if (persistence !== selectedPersistence) {
            userToMigrate = user;
          }
          selectedPersistence = persistence;
          break;
        }
      } catch (_a) {
      }
    }
    const migrationHierarchy = availablePersistences.filter((p15) => p15._shouldAllowMigration);
    if (!selectedPersistence._shouldAllowMigration || !migrationHierarchy.length) {
      return new _PersistenceUserManager(selectedPersistence, auth, userKey);
    }
    selectedPersistence = migrationHierarchy[0];
    if (userToMigrate) {
      await selectedPersistence._set(key, userToMigrate.toJSON());
    }
    await Promise.all(persistenceHierarchy.map(async (persistence) => {
      if (persistence !== selectedPersistence) {
        try {
          await persistence._remove(key);
        } catch (_a) {
        }
      }
    }));
    return new _PersistenceUserManager(selectedPersistence, auth, userKey);
  }
};
function _getBrowserName(userAgent) {
  const ua = userAgent.toLowerCase();
  if (ua.includes("opera/") || ua.includes("opr/") || ua.includes("opios/")) {
    return "Opera";
  } else if (_isIEMobile(ua)) {
    return "IEMobile";
  } else if (ua.includes("msie") || ua.includes("trident/")) {
    return "IE";
  } else if (ua.includes("edge/")) {
    return "Edge";
  } else if (_isFirefox(ua)) {
    return "Firefox";
  } else if (ua.includes("silk/")) {
    return "Silk";
  } else if (_isBlackBerry(ua)) {
    return "Blackberry";
  } else if (_isWebOS(ua)) {
    return "Webos";
  } else if (_isSafari(ua)) {
    return "Safari";
  } else if ((ua.includes("chrome/") || _isChromeIOS(ua)) && !ua.includes("edge/")) {
    return "Chrome";
  } else if (_isAndroid(ua)) {
    return "Android";
  } else {
    const re2 = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/;
    const matches = userAgent.match(re2);
    if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {
      return matches[1];
    }
  }
  return "Other";
}
__name(_getBrowserName, "_getBrowserName");
function _isFirefox(ua = getUA()) {
  return /firefox\//i.test(ua);
}
__name(_isFirefox, "_isFirefox");
function _isSafari(userAgent = getUA()) {
  const ua = userAgent.toLowerCase();
  return ua.includes("safari/") && !ua.includes("chrome/") && !ua.includes("crios/") && !ua.includes("android");
}
__name(_isSafari, "_isSafari");
function _isChromeIOS(ua = getUA()) {
  return /crios\//i.test(ua);
}
__name(_isChromeIOS, "_isChromeIOS");
function _isIEMobile(ua = getUA()) {
  return /iemobile/i.test(ua);
}
__name(_isIEMobile, "_isIEMobile");
function _isAndroid(ua = getUA()) {
  return /android/i.test(ua);
}
__name(_isAndroid, "_isAndroid");
function _isBlackBerry(ua = getUA()) {
  return /blackberry/i.test(ua);
}
__name(_isBlackBerry, "_isBlackBerry");
function _isWebOS(ua = getUA()) {
  return /webos/i.test(ua);
}
__name(_isWebOS, "_isWebOS");
function _isIOS(ua = getUA()) {
  return /iphone|ipad|ipod/i.test(ua) || /macintosh/i.test(ua) && /mobile/i.test(ua);
}
__name(_isIOS, "_isIOS");
function _isIOS7Or8(ua = getUA()) {
  return /(iPad|iPhone|iPod).*OS 7_\d/i.test(ua) || /(iPad|iPhone|iPod).*OS 8_\d/i.test(ua);
}
__name(_isIOS7Or8, "_isIOS7Or8");
function _isIE10() {
  return isIE() && document.documentMode === 10;
}
__name(_isIE10, "_isIE10");
function _isMobileBrowser(ua = getUA()) {
  return _isIOS(ua) || _isAndroid(ua) || _isWebOS(ua) || _isBlackBerry(ua) || /windows phone/i.test(ua) || _isIEMobile(ua);
}
__name(_isMobileBrowser, "_isMobileBrowser");
function _getClientVersion(clientPlatform, frameworks = []) {
  let reportedPlatform;
  switch (clientPlatform) {
    case "Browser":
      reportedPlatform = _getBrowserName(getUA());
      break;
    case "Worker":
      reportedPlatform = `${_getBrowserName(getUA())}-${clientPlatform}`;
      break;
    default:
      reportedPlatform = clientPlatform;
  }
  const reportedFrameworks = frameworks.length ? frameworks.join(",") : "FirebaseCore-web";
  return `${reportedPlatform}/${"JsCore"}/${SDK_VERSION}/${reportedFrameworks}`;
}
__name(_getClientVersion, "_getClientVersion");
var AuthMiddlewareQueue = class {
  static {
    __name(this, "AuthMiddlewareQueue");
  }
  constructor(auth) {
    this.auth = auth;
    this.queue = [];
  }
  pushCallback(callback, onAbort) {
    const wrappedCallback = /* @__PURE__ */ __name((user) => new Promise((resolve, reject) => {
      try {
        const result = callback(user);
        resolve(result);
      } catch (e10) {
        reject(e10);
      }
    }), "wrappedCallback");
    wrappedCallback.onAbort = onAbort;
    this.queue.push(wrappedCallback);
    const index = this.queue.length - 1;
    return () => {
      this.queue[index] = () => Promise.resolve();
    };
  }
  async runMiddleware(nextUser) {
    if (this.auth.currentUser === nextUser) {
      return;
    }
    const onAbortStack = [];
    try {
      for (const beforeStateCallback of this.queue) {
        await beforeStateCallback(nextUser);
        if (beforeStateCallback.onAbort) {
          onAbortStack.push(beforeStateCallback.onAbort);
        }
      }
    } catch (e10) {
      onAbortStack.reverse();
      for (const onAbort of onAbortStack) {
        try {
          onAbort();
        } catch (_) {
        }
      }
      throw this.auth._errorFactory.create("login-blocked", {
        originalMessage: e10 === null || e10 === void 0 ? void 0 : e10.message
      });
    }
  }
};
async function _getPasswordPolicy(auth, request = {}) {
  return _performApiRequest(auth, "GET", "/v2/passwordPolicy", _addTidIfNecessary(auth, request));
}
__name(_getPasswordPolicy, "_getPasswordPolicy");
var MINIMUM_MIN_PASSWORD_LENGTH = 6;
var PasswordPolicyImpl = class {
  static {
    __name(this, "PasswordPolicyImpl");
  }
  constructor(response) {
    var _a, _b, _c, _d;
    const responseOptions = response.customStrengthOptions;
    this.customStrengthOptions = {};
    this.customStrengthOptions.minPasswordLength = (_a = responseOptions.minPasswordLength) !== null && _a !== void 0 ? _a : MINIMUM_MIN_PASSWORD_LENGTH;
    if (responseOptions.maxPasswordLength) {
      this.customStrengthOptions.maxPasswordLength = responseOptions.maxPasswordLength;
    }
    if (responseOptions.containsLowercaseCharacter !== void 0) {
      this.customStrengthOptions.containsLowercaseLetter = responseOptions.containsLowercaseCharacter;
    }
    if (responseOptions.containsUppercaseCharacter !== void 0) {
      this.customStrengthOptions.containsUppercaseLetter = responseOptions.containsUppercaseCharacter;
    }
    if (responseOptions.containsNumericCharacter !== void 0) {
      this.customStrengthOptions.containsNumericCharacter = responseOptions.containsNumericCharacter;
    }
    if (responseOptions.containsNonAlphanumericCharacter !== void 0) {
      this.customStrengthOptions.containsNonAlphanumericCharacter = responseOptions.containsNonAlphanumericCharacter;
    }
    this.enforcementState = response.enforcementState;
    if (this.enforcementState === "ENFORCEMENT_STATE_UNSPECIFIED") {
      this.enforcementState = "OFF";
    }
    this.allowedNonAlphanumericCharacters = (_c = (_b = response.allowedNonAlphanumericCharacters) === null || _b === void 0 ? void 0 : _b.join("")) !== null && _c !== void 0 ? _c : "";
    this.forceUpgradeOnSignin = (_d = response.forceUpgradeOnSignin) !== null && _d !== void 0 ? _d : false;
    this.schemaVersion = response.schemaVersion;
  }
  validatePassword(password) {
    var _a, _b, _c, _d, _e, _f;
    const status = {
      isValid: true,
      passwordPolicy: this
    };
    this.validatePasswordLengthOptions(password, status);
    this.validatePasswordCharacterOptions(password, status);
    status.isValid && (status.isValid = (_a = status.meetsMinPasswordLength) !== null && _a !== void 0 ? _a : true);
    status.isValid && (status.isValid = (_b = status.meetsMaxPasswordLength) !== null && _b !== void 0 ? _b : true);
    status.isValid && (status.isValid = (_c = status.containsLowercaseLetter) !== null && _c !== void 0 ? _c : true);
    status.isValid && (status.isValid = (_d = status.containsUppercaseLetter) !== null && _d !== void 0 ? _d : true);
    status.isValid && (status.isValid = (_e = status.containsNumericCharacter) !== null && _e !== void 0 ? _e : true);
    status.isValid && (status.isValid = (_f = status.containsNonAlphanumericCharacter) !== null && _f !== void 0 ? _f : true);
    return status;
  }
  /**
   * Validates that the password meets the length options for the policy.
   *
   * @param password Password to validate.
   * @param status Validation status.
   */
  validatePasswordLengthOptions(password, status) {
    const minPasswordLength = this.customStrengthOptions.minPasswordLength;
    const maxPasswordLength = this.customStrengthOptions.maxPasswordLength;
    if (minPasswordLength) {
      status.meetsMinPasswordLength = password.length >= minPasswordLength;
    }
    if (maxPasswordLength) {
      status.meetsMaxPasswordLength = password.length <= maxPasswordLength;
    }
  }
  /**
   * Validates that the password meets the character options for the policy.
   *
   * @param password Password to validate.
   * @param status Validation status.
   */
  validatePasswordCharacterOptions(password, status) {
    this.updatePasswordCharacterOptionsStatuses(
      status,
      /* containsLowercaseCharacter= */
      false,
      /* containsUppercaseCharacter= */
      false,
      /* containsNumericCharacter= */
      false,
      /* containsNonAlphanumericCharacter= */
      false
    );
    let passwordChar;
    for (let i18 = 0; i18 < password.length; i18++) {
      passwordChar = password.charAt(i18);
      this.updatePasswordCharacterOptionsStatuses(
        status,
        /* containsLowercaseCharacter= */
        passwordChar >= "a" && passwordChar <= "z",
        /* containsUppercaseCharacter= */
        passwordChar >= "A" && passwordChar <= "Z",
        /* containsNumericCharacter= */
        passwordChar >= "0" && passwordChar <= "9",
        /* containsNonAlphanumericCharacter= */
        this.allowedNonAlphanumericCharacters.includes(passwordChar)
      );
    }
  }
  /**
   * Updates the running validation status with the statuses for the character options.
   * Expected to be called each time a character is processed to update each option status
   * based on the current character.
   *
   * @param status Validation status.
   * @param containsLowercaseCharacter Whether the character is a lowercase letter.
   * @param containsUppercaseCharacter Whether the character is an uppercase letter.
   * @param containsNumericCharacter Whether the character is a numeric character.
   * @param containsNonAlphanumericCharacter Whether the character is a non-alphanumeric character.
   */
  updatePasswordCharacterOptionsStatuses(status, containsLowercaseCharacter, containsUppercaseCharacter, containsNumericCharacter, containsNonAlphanumericCharacter) {
    if (this.customStrengthOptions.containsLowercaseLetter) {
      status.containsLowercaseLetter || (status.containsLowercaseLetter = containsLowercaseCharacter);
    }
    if (this.customStrengthOptions.containsUppercaseLetter) {
      status.containsUppercaseLetter || (status.containsUppercaseLetter = containsUppercaseCharacter);
    }
    if (this.customStrengthOptions.containsNumericCharacter) {
      status.containsNumericCharacter || (status.containsNumericCharacter = containsNumericCharacter);
    }
    if (this.customStrengthOptions.containsNonAlphanumericCharacter) {
      status.containsNonAlphanumericCharacter || (status.containsNonAlphanumericCharacter = containsNonAlphanumericCharacter);
    }
  }
};
var AuthImpl = class {
  static {
    __name(this, "AuthImpl");
  }
  constructor(app, heartbeatServiceProvider, appCheckServiceProvider, config) {
    this.app = app;
    this.heartbeatServiceProvider = heartbeatServiceProvider;
    this.appCheckServiceProvider = appCheckServiceProvider;
    this.config = config;
    this.currentUser = null;
    this.emulatorConfig = null;
    this.operations = Promise.resolve();
    this.authStateSubscription = new Subscription(this);
    this.idTokenSubscription = new Subscription(this);
    this.beforeStateQueue = new AuthMiddlewareQueue(this);
    this.redirectUser = null;
    this.isProactiveRefreshEnabled = false;
    this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1;
    this._canInitEmulator = true;
    this._isInitialized = false;
    this._deleted = false;
    this._initializationPromise = null;
    this._popupRedirectResolver = null;
    this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;
    this._agentRecaptchaConfig = null;
    this._tenantRecaptchaConfigs = {};
    this._projectPasswordPolicy = null;
    this._tenantPasswordPolicies = {};
    this._resolvePersistenceManagerAvailable = void 0;
    this.lastNotifiedUid = void 0;
    this.languageCode = null;
    this.tenantId = null;
    this.settings = { appVerificationDisabledForTesting: false };
    this.frameworks = [];
    this.name = app.name;
    this.clientVersion = config.sdkClientVersion;
    this._persistenceManagerAvailable = new Promise((resolve) => this._resolvePersistenceManagerAvailable = resolve);
  }
  _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {
    if (popupRedirectResolver) {
      this._popupRedirectResolver = _getInstance(popupRedirectResolver);
    }
    this._initializationPromise = this.queue(async () => {
      var _a, _b, _c;
      if (this._deleted) {
        return;
      }
      this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);
      (_a = this._resolvePersistenceManagerAvailable) === null || _a === void 0 ? void 0 : _a.call(this);
      if (this._deleted) {
        return;
      }
      if ((_b = this._popupRedirectResolver) === null || _b === void 0 ? void 0 : _b._shouldInitProactively) {
        try {
          await this._popupRedirectResolver._initialize(this);
        } catch (e10) {
        }
      }
      await this.initializeCurrentUser(popupRedirectResolver);
      this.lastNotifiedUid = ((_c = this.currentUser) === null || _c === void 0 ? void 0 : _c.uid) || null;
      if (this._deleted) {
        return;
      }
      this._isInitialized = true;
    });
    return this._initializationPromise;
  }
  /**
   * If the persistence is changed in another window, the user manager will let us know
   */
  async _onStorageEvent() {
    if (this._deleted) {
      return;
    }
    const user = await this.assertedPersistence.getCurrentUser();
    if (!this.currentUser && !user) {
      return;
    }
    if (this.currentUser && user && this.currentUser.uid === user.uid) {
      this._currentUser._assign(user);
      await this.currentUser.getIdToken();
      return;
    }
    await this._updateCurrentUser(
      user,
      /* skipBeforeStateCallbacks */
      true
    );
  }
  async initializeCurrentUserFromIdToken(idToken) {
    try {
      const response = await getAccountInfo(this, { idToken });
      const user = await UserImpl._fromGetAccountInfoResponse(this, response, idToken);
      await this.directlySetCurrentUser(user);
    } catch (err) {
      console.warn("FirebaseServerApp could not login user with provided authIdToken: ", err);
      await this.directlySetCurrentUser(null);
    }
  }
  async initializeCurrentUser(popupRedirectResolver) {
    var _a;
    if (_isFirebaseServerApp(this.app)) {
      const idToken = this.app.settings.authIdToken;
      if (idToken) {
        return new Promise((resolve) => {
          setTimeout(() => this.initializeCurrentUserFromIdToken(idToken).then(resolve, resolve));
        });
      } else {
        return this.directlySetCurrentUser(null);
      }
    }
    const previouslyStoredUser = await this.assertedPersistence.getCurrentUser();
    let futureCurrentUser = previouslyStoredUser;
    let needsTocheckMiddleware = false;
    if (popupRedirectResolver && this.config.authDomain) {
      await this.getOrInitRedirectPersistenceManager();
      const redirectUserEventId = (_a = this.redirectUser) === null || _a === void 0 ? void 0 : _a._redirectEventId;
      const storedUserEventId = futureCurrentUser === null || futureCurrentUser === void 0 ? void 0 : futureCurrentUser._redirectEventId;
      const result = await this.tryRedirectSignIn(popupRedirectResolver);
      if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) && (result === null || result === void 0 ? void 0 : result.user)) {
        futureCurrentUser = result.user;
        needsTocheckMiddleware = true;
      }
    }
    if (!futureCurrentUser) {
      return this.directlySetCurrentUser(null);
    }
    if (!futureCurrentUser._redirectEventId) {
      if (needsTocheckMiddleware) {
        try {
          await this.beforeStateQueue.runMiddleware(futureCurrentUser);
        } catch (e10) {
          futureCurrentUser = previouslyStoredUser;
          this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(e10));
        }
      }
      if (futureCurrentUser) {
        return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);
      } else {
        return this.directlySetCurrentUser(null);
      }
    }
    _assert(
      this._popupRedirectResolver,
      this,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    );
    await this.getOrInitRedirectPersistenceManager();
    if (this.redirectUser && this.redirectUser._redirectEventId === futureCurrentUser._redirectEventId) {
      return this.directlySetCurrentUser(futureCurrentUser);
    }
    return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);
  }
  async tryRedirectSignIn(redirectResolver) {
    let result = null;
    try {
      result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);
    } catch (e10) {
      await this._setRedirectUser(null);
    }
    return result;
  }
  async reloadAndSetCurrentUserOrClear(user) {
    try {
      await _reloadWithoutSaving(user);
    } catch (e10) {
      if ((e10 === null || e10 === void 0 ? void 0 : e10.code) !== `auth/${"network-request-failed"}`) {
        return this.directlySetCurrentUser(null);
      }
    }
    return this.directlySetCurrentUser(user);
  }
  useDeviceLanguage() {
    this.languageCode = _getUserLanguage();
  }
  async _delete() {
    this._deleted = true;
  }
  async updateCurrentUser(userExtern) {
    if (_isFirebaseServerApp(this.app)) {
      return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));
    }
    const user = userExtern ? getModularInstance(userExtern) : null;
    if (user) {
      _assert(
        user.auth.config.apiKey === this.config.apiKey,
        this,
        "invalid-user-token"
        /* AuthErrorCode.INVALID_AUTH */
      );
    }
    return this._updateCurrentUser(user && user._clone(this));
  }
  async _updateCurrentUser(user, skipBeforeStateCallbacks = false) {
    if (this._deleted) {
      return;
    }
    if (user) {
      _assert(
        this.tenantId === user.tenantId,
        this,
        "tenant-id-mismatch"
        /* AuthErrorCode.TENANT_ID_MISMATCH */
      );
    }
    if (!skipBeforeStateCallbacks) {
      await this.beforeStateQueue.runMiddleware(user);
    }
    return this.queue(async () => {
      await this.directlySetCurrentUser(user);
      this.notifyAuthListeners();
    });
  }
  async signOut() {
    if (_isFirebaseServerApp(this.app)) {
      return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));
    }
    await this.beforeStateQueue.runMiddleware(null);
    if (this.redirectPersistenceManager || this._popupRedirectResolver) {
      await this._setRedirectUser(null);
    }
    return this._updateCurrentUser(
      null,
      /* skipBeforeStateCallbacks */
      true
    );
  }
  setPersistence(persistence) {
    if (_isFirebaseServerApp(this.app)) {
      return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));
    }
    return this.queue(async () => {
      await this.assertedPersistence.setPersistence(_getInstance(persistence));
    });
  }
  _getRecaptchaConfig() {
    if (this.tenantId == null) {
      return this._agentRecaptchaConfig;
    } else {
      return this._tenantRecaptchaConfigs[this.tenantId];
    }
  }
  async validatePassword(password) {
    if (!this._getPasswordPolicyInternal()) {
      await this._updatePasswordPolicy();
    }
    const passwordPolicy = this._getPasswordPolicyInternal();
    if (passwordPolicy.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION) {
      return Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version", {}));
    }
    return passwordPolicy.validatePassword(password);
  }
  _getPasswordPolicyInternal() {
    if (this.tenantId === null) {
      return this._projectPasswordPolicy;
    } else {
      return this._tenantPasswordPolicies[this.tenantId];
    }
  }
  async _updatePasswordPolicy() {
    const response = await _getPasswordPolicy(this);
    const passwordPolicy = new PasswordPolicyImpl(response);
    if (this.tenantId === null) {
      this._projectPasswordPolicy = passwordPolicy;
    } else {
      this._tenantPasswordPolicies[this.tenantId] = passwordPolicy;
    }
  }
  _getPersistenceType() {
    return this.assertedPersistence.persistence.type;
  }
  _getPersistence() {
    return this.assertedPersistence.persistence;
  }
  _updateErrorMap(errorMap) {
    this._errorFactory = new ErrorFactory("auth", "Firebase", errorMap());
  }
  onAuthStateChanged(nextOrObserver, error, completed) {
    return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);
  }
  beforeAuthStateChanged(callback, onAbort) {
    return this.beforeStateQueue.pushCallback(callback, onAbort);
  }
  onIdTokenChanged(nextOrObserver, error, completed) {
    return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);
  }
  authStateReady() {
    return new Promise((resolve, reject) => {
      if (this.currentUser) {
        resolve();
      } else {
        const unsubscribe = this.onAuthStateChanged(() => {
          unsubscribe();
          resolve();
        }, reject);
      }
    });
  }
  /**
   * Revokes the given access token. Currently only supports Apple OAuth access tokens.
   */
  async revokeAccessToken(token) {
    if (this.currentUser) {
      const idToken = await this.currentUser.getIdToken();
      const request = {
        providerId: "apple.com",
        tokenType: "ACCESS_TOKEN",
        token,
        idToken
      };
      if (this.tenantId != null) {
        request.tenantId = this.tenantId;
      }
      await revokeToken(this, request);
    }
  }
  toJSON() {
    var _a;
    return {
      apiKey: this.config.apiKey,
      authDomain: this.config.authDomain,
      appName: this.name,
      currentUser: (_a = this._currentUser) === null || _a === void 0 ? void 0 : _a.toJSON()
    };
  }
  async _setRedirectUser(user, popupRedirectResolver) {
    const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);
    return user === null ? redirectManager.removeCurrentUser() : redirectManager.setCurrentUser(user);
  }
  async getOrInitRedirectPersistenceManager(popupRedirectResolver) {
    if (!this.redirectPersistenceManager) {
      const resolver = popupRedirectResolver && _getInstance(popupRedirectResolver) || this._popupRedirectResolver;
      _assert(
        resolver,
        this,
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      );
      this.redirectPersistenceManager = await PersistenceUserManager.create(
        this,
        [_getInstance(resolver._redirectPersistence)],
        "redirectUser"
        /* KeyName.REDIRECT_USER */
      );
      this.redirectUser = await this.redirectPersistenceManager.getCurrentUser();
    }
    return this.redirectPersistenceManager;
  }
  async _redirectUserForId(id) {
    var _a, _b;
    if (this._isInitialized) {
      await this.queue(async () => {
      });
    }
    if (((_a = this._currentUser) === null || _a === void 0 ? void 0 : _a._redirectEventId) === id) {
      return this._currentUser;
    }
    if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id) {
      return this.redirectUser;
    }
    return null;
  }
  async _persistUserIfCurrent(user) {
    if (user === this.currentUser) {
      return this.queue(async () => this.directlySetCurrentUser(user));
    }
  }
  /** Notifies listeners only if the user is current */
  _notifyListenersIfCurrent(user) {
    if (user === this.currentUser) {
      this.notifyAuthListeners();
    }
  }
  _key() {
    return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
  }
  _startProactiveRefresh() {
    this.isProactiveRefreshEnabled = true;
    if (this.currentUser) {
      this._currentUser._startProactiveRefresh();
    }
  }
  _stopProactiveRefresh() {
    this.isProactiveRefreshEnabled = false;
    if (this.currentUser) {
      this._currentUser._stopProactiveRefresh();
    }
  }
  /** Returns the current user cast as the internal type */
  get _currentUser() {
    return this.currentUser;
  }
  notifyAuthListeners() {
    var _a, _b;
    if (!this._isInitialized) {
      return;
    }
    this.idTokenSubscription.next(this.currentUser);
    const currentUid = (_b = (_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.uid) !== null && _b !== void 0 ? _b : null;
    if (this.lastNotifiedUid !== currentUid) {
      this.lastNotifiedUid = currentUid;
      this.authStateSubscription.next(this.currentUser);
    }
  }
  registerStateListener(subscription, nextOrObserver, error, completed) {
    if (this._deleted) {
      return () => {
      };
    }
    const cb = typeof nextOrObserver === "function" ? nextOrObserver : nextOrObserver.next.bind(nextOrObserver);
    let isUnsubscribed = false;
    const promise = this._isInitialized ? Promise.resolve() : this._initializationPromise;
    _assert(
      promise,
      this,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    promise.then(() => {
      if (isUnsubscribed) {
        return;
      }
      cb(this.currentUser);
    });
    if (typeof nextOrObserver === "function") {
      const unsubscribe = subscription.addObserver(nextOrObserver, error, completed);
      return () => {
        isUnsubscribed = true;
        unsubscribe();
      };
    } else {
      const unsubscribe = subscription.addObserver(nextOrObserver);
      return () => {
        isUnsubscribed = true;
        unsubscribe();
      };
    }
  }
  /**
   * Unprotected (from race conditions) method to set the current user. This
   * should only be called from within a queued callback. This is necessary
   * because the queue shouldn't rely on another queued callback.
   */
  async directlySetCurrentUser(user) {
    if (this.currentUser && this.currentUser !== user) {
      this._currentUser._stopProactiveRefresh();
    }
    if (user && this.isProactiveRefreshEnabled) {
      user._startProactiveRefresh();
    }
    this.currentUser = user;
    if (user) {
      await this.assertedPersistence.setCurrentUser(user);
    } else {
      await this.assertedPersistence.removeCurrentUser();
    }
  }
  queue(action) {
    this.operations = this.operations.then(action, action);
    return this.operations;
  }
  get assertedPersistence() {
    _assert(
      this.persistenceManager,
      this,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    return this.persistenceManager;
  }
  _logFramework(framework) {
    if (!framework || this.frameworks.includes(framework)) {
      return;
    }
    this.frameworks.push(framework);
    this.frameworks.sort();
    this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());
  }
  _getFrameworks() {
    return this.frameworks;
  }
  async _getAdditionalHeaders() {
    var _a;
    const headers = {
      [
        "X-Client-Version"
        /* HttpHeader.X_CLIENT_VERSION */
      ]: this.clientVersion
    };
    if (this.app.options.appId) {
      headers[
        "X-Firebase-gmpid"
        /* HttpHeader.X_FIREBASE_GMPID */
      ] = this.app.options.appId;
    }
    const heartbeatsHeader = await ((_a = this.heartbeatServiceProvider.getImmediate({
      optional: true
    })) === null || _a === void 0 ? void 0 : _a.getHeartbeatsHeader());
    if (heartbeatsHeader) {
      headers[
        "X-Firebase-Client"
        /* HttpHeader.X_FIREBASE_CLIENT */
      ] = heartbeatsHeader;
    }
    const appCheckToken = await this._getAppCheckToken();
    if (appCheckToken) {
      headers[
        "X-Firebase-AppCheck"
        /* HttpHeader.X_FIREBASE_APP_CHECK */
      ] = appCheckToken;
    }
    return headers;
  }
  async _getAppCheckToken() {
    var _a;
    if (_isFirebaseServerApp(this.app) && this.app.settings.appCheckToken) {
      return this.app.settings.appCheckToken;
    }
    const appCheckTokenResult = await ((_a = this.appCheckServiceProvider.getImmediate({ optional: true })) === null || _a === void 0 ? void 0 : _a.getToken());
    if (appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.error) {
      _logWarn(`Error while retrieving App Check token: ${appCheckTokenResult.error}`);
    }
    return appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.token;
  }
};
function _castAuth(auth) {
  return getModularInstance(auth);
}
__name(_castAuth, "_castAuth");
var Subscription = class {
  static {
    __name(this, "Subscription");
  }
  constructor(auth) {
    this.auth = auth;
    this.observer = null;
    this.addObserver = createSubscribe((observer) => this.observer = observer);
  }
  get next() {
    _assert(
      this.observer,
      this.auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    return this.observer.next.bind(this.observer);
  }
};
var externalJSProvider = {
  async loadJS() {
    throw new Error("Unable to load external scripts");
  },
  recaptchaV2Script: "",
  recaptchaEnterpriseScript: "",
  gapiScript: ""
};
function _loadJS(url) {
  return externalJSProvider.loadJS(url);
}
__name(_loadJS, "_loadJS");
function _recaptchaEnterpriseScriptUrl() {
  return externalJSProvider.recaptchaEnterpriseScript;
}
__name(_recaptchaEnterpriseScriptUrl, "_recaptchaEnterpriseScriptUrl");
var MockGreCAPTCHATopLevel = class {
  static {
    __name(this, "MockGreCAPTCHATopLevel");
  }
  constructor() {
    this.enterprise = new MockGreCAPTCHA();
  }
  ready(callback) {
    callback();
  }
  execute(_siteKey, _options) {
    return Promise.resolve("token");
  }
  render(_container, _parameters) {
    return "";
  }
};
var MockGreCAPTCHA = class {
  static {
    __name(this, "MockGreCAPTCHA");
  }
  ready(callback) {
    callback();
  }
  execute(_siteKey, _options) {
    return Promise.resolve("token");
  }
  render(_container, _parameters) {
    return "";
  }
};
var RECAPTCHA_ENTERPRISE_VERIFIER_TYPE = "recaptcha-enterprise";
var FAKE_TOKEN = "NO_RECAPTCHA";
var RecaptchaEnterpriseVerifier = class {
  static {
    __name(this, "RecaptchaEnterpriseVerifier");
  }
  /**
   *
   * @param authExtern - The corresponding Firebase {@link Auth} instance.
   *
   */
  constructor(authExtern) {
    this.type = RECAPTCHA_ENTERPRISE_VERIFIER_TYPE;
    this.auth = _castAuth(authExtern);
  }
  /**
   * Executes the verification process.
   *
   * @returns A Promise for a token that can be used to assert the validity of a request.
   */
  async verify(action = "verify", forceRefresh = false) {
    async function retrieveSiteKey(auth) {
      if (!forceRefresh) {
        if (auth.tenantId == null && auth._agentRecaptchaConfig != null) {
          return auth._agentRecaptchaConfig.siteKey;
        }
        if (auth.tenantId != null && auth._tenantRecaptchaConfigs[auth.tenantId] !== void 0) {
          return auth._tenantRecaptchaConfigs[auth.tenantId].siteKey;
        }
      }
      return new Promise(async (resolve, reject) => {
        getRecaptchaConfig(auth, {
          clientType: "CLIENT_TYPE_WEB",
          version: "RECAPTCHA_ENTERPRISE"
          /* RecaptchaVersion.ENTERPRISE */
        }).then((response) => {
          if (response.recaptchaKey === void 0) {
            reject(new Error("recaptcha Enterprise site key undefined"));
          } else {
            const config = new RecaptchaConfig(response);
            if (auth.tenantId == null) {
              auth._agentRecaptchaConfig = config;
            } else {
              auth._tenantRecaptchaConfigs[auth.tenantId] = config;
            }
            return resolve(config.siteKey);
          }
        }).catch((error) => {
          reject(error);
        });
      });
    }
    __name(retrieveSiteKey, "retrieveSiteKey");
    function retrieveRecaptchaToken(siteKey, resolve, reject) {
      const grecaptcha = window.grecaptcha;
      if (isEnterprise(grecaptcha)) {
        grecaptcha.enterprise.ready(() => {
          grecaptcha.enterprise.execute(siteKey, { action }).then((token) => {
            resolve(token);
          }).catch(() => {
            resolve(FAKE_TOKEN);
          });
        });
      } else {
        reject(Error("No reCAPTCHA enterprise script loaded."));
      }
    }
    __name(retrieveRecaptchaToken, "retrieveRecaptchaToken");
    if (this.auth.settings.appVerificationDisabledForTesting) {
      const mockRecaptcha = new MockGreCAPTCHATopLevel();
      return mockRecaptcha.execute("siteKey", { action: "verify" });
    }
    return new Promise((resolve, reject) => {
      retrieveSiteKey(this.auth).then((siteKey) => {
        if (!forceRefresh && isEnterprise(window.grecaptcha)) {
          retrieveRecaptchaToken(siteKey, resolve, reject);
        } else {
          if (typeof window === "undefined") {
            reject(new Error("RecaptchaVerifier is only supported in browser"));
            return;
          }
          let url = _recaptchaEnterpriseScriptUrl();
          if (url.length !== 0) {
            url += siteKey;
          }
          _loadJS(url).then(() => {
            retrieveRecaptchaToken(siteKey, resolve, reject);
          }).catch((error) => {
            reject(error);
          });
        }
      }).catch((error) => {
        reject(error);
      });
    });
  }
};
async function injectRecaptchaFields(auth, request, action, isCaptchaResp = false, isFakeToken = false) {
  const verifier = new RecaptchaEnterpriseVerifier(auth);
  let captchaResponse;
  if (isFakeToken) {
    captchaResponse = FAKE_TOKEN;
  } else {
    try {
      captchaResponse = await verifier.verify(action);
    } catch (error) {
      captchaResponse = await verifier.verify(action, true);
    }
  }
  const newRequest = Object.assign({}, request);
  if (action === "mfaSmsEnrollment" || action === "mfaSmsSignIn") {
    if ("phoneEnrollmentInfo" in newRequest) {
      const phoneNumber = newRequest.phoneEnrollmentInfo.phoneNumber;
      const recaptchaToken = newRequest.phoneEnrollmentInfo.recaptchaToken;
      Object.assign(newRequest, {
        "phoneEnrollmentInfo": {
          phoneNumber,
          recaptchaToken,
          captchaResponse,
          "clientType": "CLIENT_TYPE_WEB",
          "recaptchaVersion": "RECAPTCHA_ENTERPRISE"
          /* RecaptchaVersion.ENTERPRISE */
        }
      });
    } else if ("phoneSignInInfo" in newRequest) {
      const recaptchaToken = newRequest.phoneSignInInfo.recaptchaToken;
      Object.assign(newRequest, {
        "phoneSignInInfo": {
          recaptchaToken,
          captchaResponse,
          "clientType": "CLIENT_TYPE_WEB",
          "recaptchaVersion": "RECAPTCHA_ENTERPRISE"
          /* RecaptchaVersion.ENTERPRISE */
        }
      });
    }
    return newRequest;
  }
  if (!isCaptchaResp) {
    Object.assign(newRequest, { captchaResponse });
  } else {
    Object.assign(newRequest, { "captchaResp": captchaResponse });
  }
  Object.assign(newRequest, {
    "clientType": "CLIENT_TYPE_WEB"
    /* RecaptchaClientType.WEB */
  });
  Object.assign(newRequest, {
    "recaptchaVersion": "RECAPTCHA_ENTERPRISE"
    /* RecaptchaVersion.ENTERPRISE */
  });
  return newRequest;
}
__name(injectRecaptchaFields, "injectRecaptchaFields");
async function handleRecaptchaFlow(authInstance, request, actionName, actionMethod, recaptchaAuthProvider) {
  var _a, _b;
  if (recaptchaAuthProvider === "EMAIL_PASSWORD_PROVIDER") {
    if ((_a = authInstance._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.isProviderEnabled(
      "EMAIL_PASSWORD_PROVIDER"
      /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */
    )) {
      const requestWithRecaptcha = await injectRecaptchaFields(
        authInstance,
        request,
        actionName,
        actionName === "getOobCode"
        /* RecaptchaActionName.GET_OOB_CODE */
      );
      return actionMethod(authInstance, requestWithRecaptcha);
    } else {
      return actionMethod(authInstance, request).catch(async (error) => {
        if (error.code === `auth/${"missing-recaptcha-token"}`) {
          console.log(`${actionName} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);
          const requestWithRecaptcha = await injectRecaptchaFields(
            authInstance,
            request,
            actionName,
            actionName === "getOobCode"
            /* RecaptchaActionName.GET_OOB_CODE */
          );
          return actionMethod(authInstance, requestWithRecaptcha);
        } else {
          return Promise.reject(error);
        }
      });
    }
  } else if (recaptchaAuthProvider === "PHONE_PROVIDER") {
    if ((_b = authInstance._getRecaptchaConfig()) === null || _b === void 0 ? void 0 : _b.isProviderEnabled(
      "PHONE_PROVIDER"
      /* RecaptchaAuthProvider.PHONE_PROVIDER */
    )) {
      const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName);
      return actionMethod(authInstance, requestWithRecaptcha).catch(async (error) => {
        var _a2;
        if (((_a2 = authInstance._getRecaptchaConfig()) === null || _a2 === void 0 ? void 0 : _a2.getProviderEnforcementState(
          "PHONE_PROVIDER"
          /* RecaptchaAuthProvider.PHONE_PROVIDER */
        )) === "AUDIT") {
          if (error.code === `auth/${"missing-recaptcha-token"}` || error.code === `auth/${"invalid-app-credential"}`) {
            console.log(`Failed to verify with reCAPTCHA Enterprise. Automatically triggering the reCAPTCHA v2 flow to complete the ${actionName} flow.`);
            const requestWithRecaptchaFields = await injectRecaptchaFields(
              authInstance,
              request,
              actionName,
              false,
              // isCaptchaResp
              true
              // isFakeToken
            );
            return actionMethod(authInstance, requestWithRecaptchaFields);
          }
        }
        return Promise.reject(error);
      });
    } else {
      const requestWithRecaptchaFields = await injectRecaptchaFields(
        authInstance,
        request,
        actionName,
        false,
        // isCaptchaResp
        true
        // isFakeToken
      );
      return actionMethod(authInstance, requestWithRecaptchaFields);
    }
  } else {
    return Promise.reject(recaptchaAuthProvider + " provider is not supported.");
  }
}
__name(handleRecaptchaFlow, "handleRecaptchaFlow");
async function _initializeRecaptchaConfig(auth) {
  const authInternal = _castAuth(auth);
  const response = await getRecaptchaConfig(authInternal, {
    clientType: "CLIENT_TYPE_WEB",
    version: "RECAPTCHA_ENTERPRISE"
    /* RecaptchaVersion.ENTERPRISE */
  });
  const config = new RecaptchaConfig(response);
  if (authInternal.tenantId == null) {
    authInternal._agentRecaptchaConfig = config;
  } else {
    authInternal._tenantRecaptchaConfigs[authInternal.tenantId] = config;
  }
  if (config.isAnyProviderEnabled()) {
    const verifier = new RecaptchaEnterpriseVerifier(authInternal);
    void verifier.verify();
  }
}
__name(_initializeRecaptchaConfig, "_initializeRecaptchaConfig");
function initializeAuth(app, deps) {
  const provider = _getProvider(app, "auth");
  if (provider.isInitialized()) {
    const auth2 = provider.getImmediate();
    const initialOptions = provider.getOptions();
    if (deepEqual(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {
      return auth2;
    } else {
      _fail2(
        auth2,
        "already-initialized"
        /* AuthErrorCode.ALREADY_INITIALIZED */
      );
    }
  }
  const auth = provider.initialize({ options: deps });
  return auth;
}
__name(initializeAuth, "initializeAuth");
function _initializeAuthInstance(auth, deps) {
  const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];
  const hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);
  if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {
    auth._updateErrorMap(deps.errorMap);
  }
  auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);
}
__name(_initializeAuthInstance, "_initializeAuthInstance");
function connectAuthEmulator(auth, url, options) {
  const authInternal = _castAuth(auth);
  _assert(
    /^https?:\/\//.test(url),
    authInternal,
    "invalid-emulator-scheme"
    /* AuthErrorCode.INVALID_EMULATOR_SCHEME */
  );
  const disableWarnings = !!(options === null || options === void 0 ? void 0 : options.disableWarnings);
  const protocol = extractProtocol(url);
  const { host, port: port2 } = extractHostAndPort(url);
  const portStr = port2 === null ? "" : `:${port2}`;
  const emulator = { url: `${protocol}//${host}${portStr}/` };
  const emulatorConfig = Object.freeze({
    host,
    port: port2,
    protocol: protocol.replace(":", ""),
    options: Object.freeze({ disableWarnings })
  });
  if (!authInternal._canInitEmulator) {
    _assert(
      authInternal.config.emulator && authInternal.emulatorConfig,
      authInternal,
      "emulator-config-failed"
      /* AuthErrorCode.EMULATOR_CONFIG_FAILED */
    );
    _assert(
      deepEqual(emulator, authInternal.config.emulator) && deepEqual(emulatorConfig, authInternal.emulatorConfig),
      authInternal,
      "emulator-config-failed"
      /* AuthErrorCode.EMULATOR_CONFIG_FAILED */
    );
    return;
  }
  authInternal.config.emulator = emulator;
  authInternal.emulatorConfig = emulatorConfig;
  authInternal.settings.appVerificationDisabledForTesting = true;
  if (isCloudWorkstation(host)) {
    void pingServer(`${protocol}//${host}${portStr}`);
    updateEmulatorBanner("Auth", true);
  } else if (!disableWarnings) {
    emitEmulatorWarning();
  }
}
__name(connectAuthEmulator, "connectAuthEmulator");
function extractProtocol(url) {
  const protocolEnd = url.indexOf(":");
  return protocolEnd < 0 ? "" : url.substr(0, protocolEnd + 1);
}
__name(extractProtocol, "extractProtocol");
function extractHostAndPort(url) {
  const protocol = extractProtocol(url);
  const authority = /(\/\/)?([^?#/]+)/.exec(url.substr(protocol.length));
  if (!authority) {
    return { host: "", port: null };
  }
  const hostAndPort = authority[2].split("@").pop() || "";
  const bracketedIPv6 = /^(\[[^\]]+\])(:|$)/.exec(hostAndPort);
  if (bracketedIPv6) {
    const host = bracketedIPv6[1];
    return { host, port: parsePort(hostAndPort.substr(host.length + 1)) };
  } else {
    const [host, port2] = hostAndPort.split(":");
    return { host, port: parsePort(port2) };
  }
}
__name(extractHostAndPort, "extractHostAndPort");
function parsePort(portStr) {
  if (!portStr) {
    return null;
  }
  const port2 = Number(portStr);
  if (isNaN(port2)) {
    return null;
  }
  return port2;
}
__name(parsePort, "parsePort");
function emitEmulatorWarning() {
  function attachBanner() {
    const el = document.createElement("p");
    const sty = el.style;
    el.innerText = "Running in emulator mode. Do not use with production credentials.";
    sty.position = "fixed";
    sty.width = "100%";
    sty.backgroundColor = "#ffffff";
    sty.border = ".1em solid #000000";
    sty.color = "#b50000";
    sty.bottom = "0px";
    sty.left = "0px";
    sty.margin = "0px";
    sty.zIndex = "10000";
    sty.textAlign = "center";
    el.classList.add("firebase-emulator-warning");
    document.body.appendChild(el);
  }
  __name(attachBanner, "attachBanner");
  if (typeof console !== "undefined" && typeof console.info === "function") {
    console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");
  }
  if (typeof window !== "undefined" && typeof document !== "undefined") {
    if (document.readyState === "loading") {
      window.addEventListener("DOMContentLoaded", attachBanner);
    } else {
      attachBanner();
    }
  }
}
__name(emitEmulatorWarning, "emitEmulatorWarning");
var AuthCredential = class {
  static {
    __name(this, "AuthCredential");
  }
  /** @internal */
  constructor(providerId, signInMethod) {
    this.providerId = providerId;
    this.signInMethod = signInMethod;
  }
  /**
   * Returns a JSON-serializable representation of this object.
   *
   * @returns a JSON-serializable representation of this object.
   */
  toJSON() {
    return debugFail("not implemented");
  }
  /** @internal */
  _getIdTokenResponse(_auth) {
    return debugFail("not implemented");
  }
  /** @internal */
  _linkToIdToken(_auth, _idToken) {
    return debugFail("not implemented");
  }
  /** @internal */
  _getReauthenticationResolver(_auth) {
    return debugFail("not implemented");
  }
};
async function resetPassword(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:resetPassword", _addTidIfNecessary(auth, request));
}
__name(resetPassword, "resetPassword");
async function updateEmailPassword(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:update", request);
}
__name(updateEmailPassword, "updateEmailPassword");
async function linkEmailPassword(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:signUp", request);
}
__name(linkEmailPassword, "linkEmailPassword");
async function applyActionCode$1(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:update", _addTidIfNecessary(auth, request));
}
__name(applyActionCode$1, "applyActionCode$1");
async function signInWithPassword(auth, request) {
  return _performSignInRequest(auth, "POST", "/v1/accounts:signInWithPassword", _addTidIfNecessary(auth, request));
}
__name(signInWithPassword, "signInWithPassword");
async function sendOobCode(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:sendOobCode", _addTidIfNecessary(auth, request));
}
__name(sendOobCode, "sendOobCode");
async function sendEmailVerification$1(auth, request) {
  return sendOobCode(auth, request);
}
__name(sendEmailVerification$1, "sendEmailVerification$1");
async function sendPasswordResetEmail$1(auth, request) {
  return sendOobCode(auth, request);
}
__name(sendPasswordResetEmail$1, "sendPasswordResetEmail$1");
async function sendSignInLinkToEmail$1(auth, request) {
  return sendOobCode(auth, request);
}
__name(sendSignInLinkToEmail$1, "sendSignInLinkToEmail$1");
async function verifyAndChangeEmail(auth, request) {
  return sendOobCode(auth, request);
}
__name(verifyAndChangeEmail, "verifyAndChangeEmail");
async function signInWithEmailLink$1(auth, request) {
  return _performSignInRequest(auth, "POST", "/v1/accounts:signInWithEmailLink", _addTidIfNecessary(auth, request));
}
__name(signInWithEmailLink$1, "signInWithEmailLink$1");
async function signInWithEmailLinkForLinking(auth, request) {
  return _performSignInRequest(auth, "POST", "/v1/accounts:signInWithEmailLink", _addTidIfNecessary(auth, request));
}
__name(signInWithEmailLinkForLinking, "signInWithEmailLinkForLinking");
var EmailAuthCredential = class _EmailAuthCredential extends AuthCredential {
  static {
    __name(this, "EmailAuthCredential");
  }
  /** @internal */
  constructor(_email, _password, signInMethod, _tenantId = null) {
    super("password", signInMethod);
    this._email = _email;
    this._password = _password;
    this._tenantId = _tenantId;
  }
  /** @internal */
  static _fromEmailAndPassword(email, password) {
    return new _EmailAuthCredential(
      email,
      password,
      "password"
      /* SignInMethod.EMAIL_PASSWORD */
    );
  }
  /** @internal */
  static _fromEmailAndCode(email, oobCode, tenantId = null) {
    return new _EmailAuthCredential(email, oobCode, "emailLink", tenantId);
  }
  /** {@inheritdoc AuthCredential.toJSON} */
  toJSON() {
    return {
      email: this._email,
      password: this._password,
      signInMethod: this.signInMethod,
      tenantId: this._tenantId
    };
  }
  /**
   * Static method to deserialize a JSON representation of an object into an {@link  AuthCredential}.
   *
   * @param json - Either `object` or the stringified representation of the object. When string is
   * provided, `JSON.parse` would be called first.
   *
   * @returns If the JSON input does not represent an {@link AuthCredential}, null is returned.
   */
  static fromJSON(json) {
    const obj = typeof json === "string" ? JSON.parse(json) : json;
    if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {
      if (obj.signInMethod === "password") {
        return this._fromEmailAndPassword(obj.email, obj.password);
      } else if (obj.signInMethod === "emailLink") {
        return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);
      }
    }
    return null;
  }
  /** @internal */
  async _getIdTokenResponse(auth) {
    switch (this.signInMethod) {
      case "password":
        const request = {
          returnSecureToken: true,
          email: this._email,
          password: this._password,
          clientType: "CLIENT_TYPE_WEB"
          /* RecaptchaClientType.WEB */
        };
        return handleRecaptchaFlow(
          auth,
          request,
          "signInWithPassword",
          signInWithPassword,
          "EMAIL_PASSWORD_PROVIDER"
          /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */
        );
      case "emailLink":
        return signInWithEmailLink$1(auth, {
          email: this._email,
          oobCode: this._password
        });
      default:
        _fail2(
          auth,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
    }
  }
  /** @internal */
  async _linkToIdToken(auth, idToken) {
    switch (this.signInMethod) {
      case "password":
        const request = {
          idToken,
          returnSecureToken: true,
          email: this._email,
          password: this._password,
          clientType: "CLIENT_TYPE_WEB"
          /* RecaptchaClientType.WEB */
        };
        return handleRecaptchaFlow(
          auth,
          request,
          "signUpPassword",
          linkEmailPassword,
          "EMAIL_PASSWORD_PROVIDER"
          /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */
        );
      case "emailLink":
        return signInWithEmailLinkForLinking(auth, {
          idToken,
          email: this._email,
          oobCode: this._password
        });
      default:
        _fail2(
          auth,
          "internal-error"
          /* AuthErrorCode.INTERNAL_ERROR */
        );
    }
  }
  /** @internal */
  _getReauthenticationResolver(auth) {
    return this._getIdTokenResponse(auth);
  }
};
async function signInWithIdp(auth, request) {
  return _performSignInRequest(auth, "POST", "/v1/accounts:signInWithIdp", _addTidIfNecessary(auth, request));
}
__name(signInWithIdp, "signInWithIdp");
var IDP_REQUEST_URI$1 = "http://localhost";
var OAuthCredential = class _OAuthCredential extends AuthCredential {
  static {
    __name(this, "OAuthCredential");
  }
  constructor() {
    super(...arguments);
    this.pendingToken = null;
  }
  /** @internal */
  static _fromParams(params) {
    const cred = new _OAuthCredential(params.providerId, params.signInMethod);
    if (params.idToken || params.accessToken) {
      if (params.idToken) {
        cred.idToken = params.idToken;
      }
      if (params.accessToken) {
        cred.accessToken = params.accessToken;
      }
      if (params.nonce && !params.pendingToken) {
        cred.nonce = params.nonce;
      }
      if (params.pendingToken) {
        cred.pendingToken = params.pendingToken;
      }
    } else if (params.oauthToken && params.oauthTokenSecret) {
      cred.accessToken = params.oauthToken;
      cred.secret = params.oauthTokenSecret;
    } else {
      _fail2(
        "argument-error"
        /* AuthErrorCode.ARGUMENT_ERROR */
      );
    }
    return cred;
  }
  /** {@inheritdoc AuthCredential.toJSON}  */
  toJSON() {
    return {
      idToken: this.idToken,
      accessToken: this.accessToken,
      secret: this.secret,
      nonce: this.nonce,
      pendingToken: this.pendingToken,
      providerId: this.providerId,
      signInMethod: this.signInMethod
    };
  }
  /**
   * Static method to deserialize a JSON representation of an object into an
   * {@link  AuthCredential}.
   *
   * @param json - Input can be either Object or the stringified representation of the object.
   * When string is provided, JSON.parse would be called first.
   *
   * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.
   */
  static fromJSON(json) {
    const obj = typeof json === "string" ? JSON.parse(json) : json;
    const { providerId, signInMethod } = obj, rest = __rest(obj, ["providerId", "signInMethod"]);
    if (!providerId || !signInMethod) {
      return null;
    }
    const cred = new _OAuthCredential(providerId, signInMethod);
    cred.idToken = rest.idToken || void 0;
    cred.accessToken = rest.accessToken || void 0;
    cred.secret = rest.secret;
    cred.nonce = rest.nonce;
    cred.pendingToken = rest.pendingToken || null;
    return cred;
  }
  /** @internal */
  _getIdTokenResponse(auth) {
    const request = this.buildRequest();
    return signInWithIdp(auth, request);
  }
  /** @internal */
  _linkToIdToken(auth, idToken) {
    const request = this.buildRequest();
    request.idToken = idToken;
    return signInWithIdp(auth, request);
  }
  /** @internal */
  _getReauthenticationResolver(auth) {
    const request = this.buildRequest();
    request.autoCreate = false;
    return signInWithIdp(auth, request);
  }
  buildRequest() {
    const request = {
      requestUri: IDP_REQUEST_URI$1,
      returnSecureToken: true
    };
    if (this.pendingToken) {
      request.pendingToken = this.pendingToken;
    } else {
      const postBody = {};
      if (this.idToken) {
        postBody["id_token"] = this.idToken;
      }
      if (this.accessToken) {
        postBody["access_token"] = this.accessToken;
      }
      if (this.secret) {
        postBody["oauth_token_secret"] = this.secret;
      }
      postBody["providerId"] = this.providerId;
      if (this.nonce && !this.pendingToken) {
        postBody["nonce"] = this.nonce;
      }
      request.postBody = querystring(postBody);
    }
    return request;
  }
};
async function signInWithPhoneNumber$1(auth, request) {
  return _performSignInRequest(auth, "POST", "/v1/accounts:signInWithPhoneNumber", _addTidIfNecessary(auth, request));
}
__name(signInWithPhoneNumber$1, "signInWithPhoneNumber$1");
async function linkWithPhoneNumber$1(auth, request) {
  const response = await _performSignInRequest(auth, "POST", "/v1/accounts:signInWithPhoneNumber", _addTidIfNecessary(auth, request));
  if (response.temporaryProof) {
    throw _makeTaggedError(auth, "account-exists-with-different-credential", response);
  }
  return response;
}
__name(linkWithPhoneNumber$1, "linkWithPhoneNumber$1");
var VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_ = {
  [
    "USER_NOT_FOUND"
    /* ServerError.USER_NOT_FOUND */
  ]: "user-not-found"
  /* AuthErrorCode.USER_DELETED */
};
async function verifyPhoneNumberForExisting(auth, request) {
  const apiRequest = Object.assign(Object.assign({}, request), { operation: "REAUTH" });
  return _performSignInRequest(auth, "POST", "/v1/accounts:signInWithPhoneNumber", _addTidIfNecessary(auth, apiRequest), VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_);
}
__name(verifyPhoneNumberForExisting, "verifyPhoneNumberForExisting");
var PhoneAuthCredential = class _PhoneAuthCredential extends AuthCredential {
  static {
    __name(this, "PhoneAuthCredential");
  }
  constructor(params) {
    super(
      "phone",
      "phone"
      /* SignInMethod.PHONE */
    );
    this.params = params;
  }
  /** @internal */
  static _fromVerification(verificationId, verificationCode) {
    return new _PhoneAuthCredential({ verificationId, verificationCode });
  }
  /** @internal */
  static _fromTokenResponse(phoneNumber, temporaryProof) {
    return new _PhoneAuthCredential({ phoneNumber, temporaryProof });
  }
  /** @internal */
  _getIdTokenResponse(auth) {
    return signInWithPhoneNumber$1(auth, this._makeVerificationRequest());
  }
  /** @internal */
  _linkToIdToken(auth, idToken) {
    return linkWithPhoneNumber$1(auth, Object.assign({ idToken }, this._makeVerificationRequest()));
  }
  /** @internal */
  _getReauthenticationResolver(auth) {
    return verifyPhoneNumberForExisting(auth, this._makeVerificationRequest());
  }
  /** @internal */
  _makeVerificationRequest() {
    const { temporaryProof, phoneNumber, verificationId, verificationCode } = this.params;
    if (temporaryProof && phoneNumber) {
      return { temporaryProof, phoneNumber };
    }
    return {
      sessionInfo: verificationId,
      code: verificationCode
    };
  }
  /** {@inheritdoc AuthCredential.toJSON} */
  toJSON() {
    const obj = {
      providerId: this.providerId
    };
    if (this.params.phoneNumber) {
      obj.phoneNumber = this.params.phoneNumber;
    }
    if (this.params.temporaryProof) {
      obj.temporaryProof = this.params.temporaryProof;
    }
    if (this.params.verificationCode) {
      obj.verificationCode = this.params.verificationCode;
    }
    if (this.params.verificationId) {
      obj.verificationId = this.params.verificationId;
    }
    return obj;
  }
  /** Generates a phone credential based on a plain object or a JSON string. */
  static fromJSON(json) {
    if (typeof json === "string") {
      json = JSON.parse(json);
    }
    const { verificationId, verificationCode, phoneNumber, temporaryProof } = json;
    if (!verificationCode && !verificationId && !phoneNumber && !temporaryProof) {
      return null;
    }
    return new _PhoneAuthCredential({
      verificationId,
      verificationCode,
      phoneNumber,
      temporaryProof
    });
  }
};
function parseMode(mode) {
  switch (mode) {
    case "recoverEmail":
      return "RECOVER_EMAIL";
    case "resetPassword":
      return "PASSWORD_RESET";
    case "signIn":
      return "EMAIL_SIGNIN";
    case "verifyEmail":
      return "VERIFY_EMAIL";
    case "verifyAndChangeEmail":
      return "VERIFY_AND_CHANGE_EMAIL";
    case "revertSecondFactorAddition":
      return "REVERT_SECOND_FACTOR_ADDITION";
    default:
      return null;
  }
}
__name(parseMode, "parseMode");
function parseDeepLink(url) {
  const link = querystringDecode(extractQuerystring(url))["link"];
  const doubleDeepLink = link ? querystringDecode(extractQuerystring(link))["deep_link_id"] : null;
  const iOSDeepLink = querystringDecode(extractQuerystring(url))["deep_link_id"];
  const iOSDoubleDeepLink = iOSDeepLink ? querystringDecode(extractQuerystring(iOSDeepLink))["link"] : null;
  return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
}
__name(parseDeepLink, "parseDeepLink");
var ActionCodeURL = class _ActionCodeURL {
  static {
    __name(this, "ActionCodeURL");
  }
  /**
   * @param actionLink - The link from which to extract the URL.
   * @returns The {@link ActionCodeURL} object, or null if the link is invalid.
   *
   * @internal
   */
  constructor(actionLink) {
    var _a, _b, _c, _d, _e, _f;
    const searchParams = querystringDecode(extractQuerystring(actionLink));
    const apiKey = (_a = searchParams[
      "apiKey"
      /* QueryField.API_KEY */
    ]) !== null && _a !== void 0 ? _a : null;
    const code = (_b = searchParams[
      "oobCode"
      /* QueryField.CODE */
    ]) !== null && _b !== void 0 ? _b : null;
    const operation = parseMode((_c = searchParams[
      "mode"
      /* QueryField.MODE */
    ]) !== null && _c !== void 0 ? _c : null);
    _assert(
      apiKey && code && operation,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    );
    this.apiKey = apiKey;
    this.operation = operation;
    this.code = code;
    this.continueUrl = (_d = searchParams[
      "continueUrl"
      /* QueryField.CONTINUE_URL */
    ]) !== null && _d !== void 0 ? _d : null;
    this.languageCode = (_e = searchParams[
      "lang"
      /* QueryField.LANGUAGE_CODE */
    ]) !== null && _e !== void 0 ? _e : null;
    this.tenantId = (_f = searchParams[
      "tenantId"
      /* QueryField.TENANT_ID */
    ]) !== null && _f !== void 0 ? _f : null;
  }
  /**
   * Parses the email action link string and returns an {@link ActionCodeURL} if the link is valid,
   * otherwise returns null.
   *
   * @param link  - The email action link string.
   * @returns The {@link ActionCodeURL} object, or null if the link is invalid.
   *
   * @public
   */
  static parseLink(link) {
    const actionLink = parseDeepLink(link);
    try {
      return new _ActionCodeURL(actionLink);
    } catch (_a) {
      return null;
    }
  }
};
function parseActionCodeURL(link) {
  return ActionCodeURL.parseLink(link);
}
__name(parseActionCodeURL, "parseActionCodeURL");
var EmailAuthProvider = class _EmailAuthProvider {
  static {
    __name(this, "EmailAuthProvider");
  }
  constructor() {
    this.providerId = _EmailAuthProvider.PROVIDER_ID;
  }
  /**
   * Initialize an {@link AuthCredential} using an email and password.
   *
   * @example
   * ```javascript
   * const authCredential = EmailAuthProvider.credential(email, password);
   * const userCredential = await signInWithCredential(auth, authCredential);
   * ```
   *
   * @example
   * ```javascript
   * const userCredential = await signInWithEmailAndPassword(auth, email, password);
   * ```
   *
   * @param email - Email address.
   * @param password - User account password.
   * @returns The auth provider credential.
   */
  static credential(email, password) {
    return EmailAuthCredential._fromEmailAndPassword(email, password);
  }
  /**
   * Initialize an {@link AuthCredential} using an email and an email link after a sign in with
   * email link operation.
   *
   * @example
   * ```javascript
   * const authCredential = EmailAuthProvider.credentialWithLink(auth, email, emailLink);
   * const userCredential = await signInWithCredential(auth, authCredential);
   * ```
   *
   * @example
   * ```javascript
   * await sendSignInLinkToEmail(auth, email);
   * // Obtain emailLink from user.
   * const userCredential = await signInWithEmailLink(auth, email, emailLink);
   * ```
   *
   * @param auth - The {@link Auth} instance used to verify the link.
   * @param email - Email address.
   * @param emailLink - Sign-in email link.
   * @returns - The auth provider credential.
   */
  static credentialWithLink(email, emailLink) {
    const actionCodeUrl = ActionCodeURL.parseLink(emailLink);
    _assert(
      actionCodeUrl,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    );
    return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);
  }
};
EmailAuthProvider.PROVIDER_ID = "password";
EmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = "password";
EmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";
var FederatedAuthProvider = class {
  static {
    __name(this, "FederatedAuthProvider");
  }
  /**
   * Constructor for generic OAuth providers.
   *
   * @param providerId - Provider for which credentials should be generated.
   */
  constructor(providerId) {
    this.providerId = providerId;
    this.defaultLanguageCode = null;
    this.customParameters = {};
  }
  /**
   * Set the language gode.
   *
   * @param languageCode - language code
   */
  setDefaultLanguage(languageCode) {
    this.defaultLanguageCode = languageCode;
  }
  /**
   * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in
   * operations.
   *
   * @remarks
   * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,
   * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.
   *
   * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.
   */
  setCustomParameters(customOAuthParameters) {
    this.customParameters = customOAuthParameters;
    return this;
  }
  /**
   * Retrieve the current list of {@link CustomParameters}.
   */
  getCustomParameters() {
    return this.customParameters;
  }
};
var BaseOAuthProvider = class extends FederatedAuthProvider {
  static {
    __name(this, "BaseOAuthProvider");
  }
  constructor() {
    super(...arguments);
    this.scopes = [];
  }
  /**
   * Add an OAuth scope to the credential.
   *
   * @param scope - Provider OAuth scope to add.
   */
  addScope(scope) {
    if (!this.scopes.includes(scope)) {
      this.scopes.push(scope);
    }
    return this;
  }
  /**
   * Retrieve the current list of OAuth scopes.
   */
  getScopes() {
    return [...this.scopes];
  }
};
var OAuthProvider = class _OAuthProvider extends BaseOAuthProvider {
  static {
    __name(this, "OAuthProvider");
  }
  /**
   * Creates an {@link OAuthCredential} from a JSON string or a plain object.
   * @param json - A plain object or a JSON string
   */
  static credentialFromJSON(json) {
    const obj = typeof json === "string" ? JSON.parse(json) : json;
    _assert(
      "providerId" in obj && "signInMethod" in obj,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    );
    return OAuthCredential._fromParams(obj);
  }
  /**
   * Creates a {@link OAuthCredential} from a generic OAuth provider's access token or ID token.
   *
   * @remarks
   * The raw nonce is required when an ID token with a nonce field is provided. The SHA-256 hash of
   * the raw nonce must match the nonce field in the ID token.
   *
   * @example
   * ```javascript
   * // `googleUser` from the onsuccess Google Sign In callback.
   * // Initialize a generate OAuth provider with a `google.com` providerId.
   * const provider = new OAuthProvider('google.com');
   * const credential = provider.credential({
   *   idToken: googleUser.getAuthResponse().id_token,
   * });
   * const result = await signInWithCredential(credential);
   * ```
   *
   * @param params - Either the options object containing the ID token, access token and raw nonce
   * or the ID token string.
   */
  credential(params) {
    return this._credential(Object.assign(Object.assign({}, params), { nonce: params.rawNonce }));
  }
  /** An internal credential method that accepts more permissive options */
  _credential(params) {
    _assert(
      params.idToken || params.accessToken,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    );
    return OAuthCredential._fromParams(Object.assign(Object.assign({}, params), { providerId: this.providerId, signInMethod: this.providerId }));
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(userCredential) {
    return _OAuthProvider.oauthCredentialFromTaggedObject(userCredential);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(error) {
    return _OAuthProvider.oauthCredentialFromTaggedObject(error.customData || {});
  }
  static oauthCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse) {
      return null;
    }
    const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce, providerId } = tokenResponse;
    if (!oauthAccessToken && !oauthTokenSecret && !oauthIdToken && !pendingToken) {
      return null;
    }
    if (!providerId) {
      return null;
    }
    try {
      return new _OAuthProvider(providerId)._credential({
        idToken: oauthIdToken,
        accessToken: oauthAccessToken,
        nonce,
        pendingToken
      });
    } catch (e10) {
      return null;
    }
  }
};
var FacebookAuthProvider = class _FacebookAuthProvider extends BaseOAuthProvider {
  static {
    __name(this, "FacebookAuthProvider");
  }
  constructor() {
    super(
      "facebook.com"
      /* ProviderId.FACEBOOK */
    );
  }
  /**
   * Creates a credential for Facebook.
   *
   * @example
   * ```javascript
   * // `event` from the Facebook auth.authResponseChange callback.
   * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);
   * const result = await signInWithCredential(credential);
   * ```
   *
   * @param accessToken - Facebook access token.
   */
  static credential(accessToken) {
    return OAuthCredential._fromParams({
      providerId: _FacebookAuthProvider.PROVIDER_ID,
      signInMethod: _FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,
      accessToken
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(userCredential) {
    return _FacebookAuthProvider.credentialFromTaggedObject(userCredential);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(error) {
    return _FacebookAuthProvider.credentialFromTaggedObject(error.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse || !("oauthAccessToken" in tokenResponse)) {
      return null;
    }
    if (!tokenResponse.oauthAccessToken) {
      return null;
    }
    try {
      return _FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);
    } catch (_a) {
      return null;
    }
  }
};
FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
FacebookAuthProvider.PROVIDER_ID = "facebook.com";
var GoogleAuthProvider = class _GoogleAuthProvider extends BaseOAuthProvider {
  static {
    __name(this, "GoogleAuthProvider");
  }
  constructor() {
    super(
      "google.com"
      /* ProviderId.GOOGLE */
    );
    this.addScope("profile");
  }
  /**
   * Creates a credential for Google. At least one of ID token and access token is required.
   *
   * @example
   * ```javascript
   * // \`googleUser\` from the onsuccess Google Sign In callback.
   * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);
   * const result = await signInWithCredential(credential);
   * ```
   *
   * @param idToken - Google ID token.
   * @param accessToken - Google access token.
   */
  static credential(idToken, accessToken) {
    return OAuthCredential._fromParams({
      providerId: _GoogleAuthProvider.PROVIDER_ID,
      signInMethod: _GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,
      idToken,
      accessToken
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(userCredential) {
    return _GoogleAuthProvider.credentialFromTaggedObject(userCredential);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(error) {
    return _GoogleAuthProvider.credentialFromTaggedObject(error.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse) {
      return null;
    }
    const { oauthIdToken, oauthAccessToken } = tokenResponse;
    if (!oauthIdToken && !oauthAccessToken) {
      return null;
    }
    try {
      return _GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);
    } catch (_a) {
      return null;
    }
  }
};
GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = "google.com";
GoogleAuthProvider.PROVIDER_ID = "google.com";
var GithubAuthProvider = class _GithubAuthProvider extends BaseOAuthProvider {
  static {
    __name(this, "GithubAuthProvider");
  }
  constructor() {
    super(
      "github.com"
      /* ProviderId.GITHUB */
    );
  }
  /**
   * Creates a credential for GitHub.
   *
   * @param accessToken - GitHub access token.
   */
  static credential(accessToken) {
    return OAuthCredential._fromParams({
      providerId: _GithubAuthProvider.PROVIDER_ID,
      signInMethod: _GithubAuthProvider.GITHUB_SIGN_IN_METHOD,
      accessToken
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(userCredential) {
    return _GithubAuthProvider.credentialFromTaggedObject(userCredential);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(error) {
    return _GithubAuthProvider.credentialFromTaggedObject(error.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse || !("oauthAccessToken" in tokenResponse)) {
      return null;
    }
    if (!tokenResponse.oauthAccessToken) {
      return null;
    }
    try {
      return _GithubAuthProvider.credential(tokenResponse.oauthAccessToken);
    } catch (_a) {
      return null;
    }
  }
};
GithubAuthProvider.GITHUB_SIGN_IN_METHOD = "github.com";
GithubAuthProvider.PROVIDER_ID = "github.com";
var IDP_REQUEST_URI = "http://localhost";
var SAMLAuthCredential = class _SAMLAuthCredential extends AuthCredential {
  static {
    __name(this, "SAMLAuthCredential");
  }
  /** @internal */
  constructor(providerId, pendingToken) {
    super(providerId, providerId);
    this.pendingToken = pendingToken;
  }
  /** @internal */
  _getIdTokenResponse(auth) {
    const request = this.buildRequest();
    return signInWithIdp(auth, request);
  }
  /** @internal */
  _linkToIdToken(auth, idToken) {
    const request = this.buildRequest();
    request.idToken = idToken;
    return signInWithIdp(auth, request);
  }
  /** @internal */
  _getReauthenticationResolver(auth) {
    const request = this.buildRequest();
    request.autoCreate = false;
    return signInWithIdp(auth, request);
  }
  /** {@inheritdoc AuthCredential.toJSON}  */
  toJSON() {
    return {
      signInMethod: this.signInMethod,
      providerId: this.providerId,
      pendingToken: this.pendingToken
    };
  }
  /**
   * Static method to deserialize a JSON representation of an object into an
   * {@link  AuthCredential}.
   *
   * @param json - Input can be either Object or the stringified representation of the object.
   * When string is provided, JSON.parse would be called first.
   *
   * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.
   */
  static fromJSON(json) {
    const obj = typeof json === "string" ? JSON.parse(json) : json;
    const { providerId, signInMethod, pendingToken } = obj;
    if (!providerId || !signInMethod || !pendingToken || providerId !== signInMethod) {
      return null;
    }
    return new _SAMLAuthCredential(providerId, pendingToken);
  }
  /**
   * Helper static method to avoid exposing the constructor to end users.
   *
   * @internal
   */
  static _create(providerId, pendingToken) {
    return new _SAMLAuthCredential(providerId, pendingToken);
  }
  buildRequest() {
    return {
      requestUri: IDP_REQUEST_URI,
      returnSecureToken: true,
      pendingToken: this.pendingToken
    };
  }
};
var SAML_PROVIDER_PREFIX = "saml.";
var SAMLAuthProvider = class _SAMLAuthProvider extends FederatedAuthProvider {
  static {
    __name(this, "SAMLAuthProvider");
  }
  /**
   * Constructor. The providerId must start with "saml."
   * @param providerId - SAML provider ID.
   */
  constructor(providerId) {
    _assert(
      providerId.startsWith(SAML_PROVIDER_PREFIX),
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    );
    super(providerId);
  }
  /**
   * Generates an {@link AuthCredential} from a {@link UserCredential} after a
   * successful SAML flow completes.
   *
   * @remarks
   *
   * For example, to get an {@link AuthCredential}, you could write the
   * following code:
   *
   * ```js
   * const userCredential = await signInWithPopup(auth, samlProvider);
   * const credential = SAMLAuthProvider.credentialFromResult(userCredential);
   * ```
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(userCredential) {
    return _SAMLAuthProvider.samlCredentialFromTaggedObject(userCredential);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(error) {
    return _SAMLAuthProvider.samlCredentialFromTaggedObject(error.customData || {});
  }
  /**
   * Creates an {@link AuthCredential} from a JSON string or a plain object.
   * @param json - A plain object or a JSON string
   */
  static credentialFromJSON(json) {
    const credential = SAMLAuthCredential.fromJSON(json);
    _assert(
      credential,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    );
    return credential;
  }
  static samlCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse) {
      return null;
    }
    const { pendingToken, providerId } = tokenResponse;
    if (!pendingToken || !providerId) {
      return null;
    }
    try {
      return SAMLAuthCredential._create(providerId, pendingToken);
    } catch (e10) {
      return null;
    }
  }
};
var TwitterAuthProvider = class _TwitterAuthProvider extends BaseOAuthProvider {
  static {
    __name(this, "TwitterAuthProvider");
  }
  constructor() {
    super(
      "twitter.com"
      /* ProviderId.TWITTER */
    );
  }
  /**
   * Creates a credential for Twitter.
   *
   * @param token - Twitter access token.
   * @param secret - Twitter secret.
   */
  static credential(token, secret) {
    return OAuthCredential._fromParams({
      providerId: _TwitterAuthProvider.PROVIDER_ID,
      signInMethod: _TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,
      oauthToken: token,
      oauthTokenSecret: secret
    });
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromResult(userCredential) {
    return _TwitterAuthProvider.credentialFromTaggedObject(userCredential);
  }
  /**
   * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was
   * thrown during a sign-in, link, or reauthenticate operation.
   *
   * @param userCredential - The user credential.
   */
  static credentialFromError(error) {
    return _TwitterAuthProvider.credentialFromTaggedObject(error.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse) {
      return null;
    }
    const { oauthAccessToken, oauthTokenSecret } = tokenResponse;
    if (!oauthAccessToken || !oauthTokenSecret) {
      return null;
    }
    try {
      return _TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);
    } catch (_a) {
      return null;
    }
  }
};
TwitterAuthProvider.TWITTER_SIGN_IN_METHOD = "twitter.com";
TwitterAuthProvider.PROVIDER_ID = "twitter.com";
async function signUp(auth, request) {
  return _performSignInRequest(auth, "POST", "/v1/accounts:signUp", _addTidIfNecessary(auth, request));
}
__name(signUp, "signUp");
var UserCredentialImpl = class _UserCredentialImpl {
  static {
    __name(this, "UserCredentialImpl");
  }
  constructor(params) {
    this.user = params.user;
    this.providerId = params.providerId;
    this._tokenResponse = params._tokenResponse;
    this.operationType = params.operationType;
  }
  static async _fromIdTokenResponse(auth, operationType, idTokenResponse, isAnonymous = false) {
    const user = await UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous);
    const providerId = providerIdForResponse(idTokenResponse);
    const userCred = new _UserCredentialImpl({
      user,
      providerId,
      _tokenResponse: idTokenResponse,
      operationType
    });
    return userCred;
  }
  static async _forOperation(user, operationType, response) {
    await user._updateTokensIfNecessary(
      response,
      /* reload */
      true
    );
    const providerId = providerIdForResponse(response);
    return new _UserCredentialImpl({
      user,
      providerId,
      _tokenResponse: response,
      operationType
    });
  }
};
function providerIdForResponse(response) {
  if (response.providerId) {
    return response.providerId;
  }
  if ("phoneNumber" in response) {
    return "phone";
  }
  return null;
}
__name(providerIdForResponse, "providerIdForResponse");
async function signInAnonymously(auth) {
  var _a;
  if (_isFirebaseServerApp(auth.app)) {
    return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));
  }
  const authInternal = _castAuth(auth);
  await authInternal._initializationPromise;
  if ((_a = authInternal.currentUser) === null || _a === void 0 ? void 0 : _a.isAnonymous) {
    return new UserCredentialImpl({
      user: authInternal.currentUser,
      providerId: null,
      operationType: "signIn"
      /* OperationType.SIGN_IN */
    });
  }
  const response = await signUp(authInternal, {
    returnSecureToken: true
  });
  const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn", response, true);
  await authInternal._updateCurrentUser(userCredential.user);
  return userCredential;
}
__name(signInAnonymously, "signInAnonymously");
var MultiFactorError = class _MultiFactorError extends FirebaseError {
  static {
    __name(this, "MultiFactorError");
  }
  constructor(auth, error, operationType, user) {
    var _a;
    super(error.code, error.message);
    this.operationType = operationType;
    this.user = user;
    Object.setPrototypeOf(this, _MultiFactorError.prototype);
    this.customData = {
      appName: auth.name,
      tenantId: (_a = auth.tenantId) !== null && _a !== void 0 ? _a : void 0,
      _serverResponse: error.customData._serverResponse,
      operationType
    };
  }
  static _fromErrorAndOperation(auth, error, operationType, user) {
    return new _MultiFactorError(auth, error, operationType, user);
  }
};
function _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {
  const idTokenProvider = operationType === "reauthenticate" ? credential._getReauthenticationResolver(auth) : credential._getIdTokenResponse(auth);
  return idTokenProvider.catch((error) => {
    if (error.code === `auth/${"multi-factor-auth-required"}`) {
      throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);
    }
    throw error;
  });
}
__name(_processCredentialSavingMfaContextIfNecessary, "_processCredentialSavingMfaContextIfNecessary");
function providerDataAsNames(providerData) {
  return new Set(providerData.map(({ providerId }) => providerId).filter((pid) => !!pid));
}
__name(providerDataAsNames, "providerDataAsNames");
async function unlink(user, providerId) {
  const userInternal = getModularInstance(user);
  await _assertLinkedStatus(true, userInternal, providerId);
  const { providerUserInfo } = await deleteLinkedAccounts(userInternal.auth, {
    idToken: await userInternal.getIdToken(),
    deleteProvider: [providerId]
  });
  const providersLeft = providerDataAsNames(providerUserInfo || []);
  userInternal.providerData = userInternal.providerData.filter((pd) => providersLeft.has(pd.providerId));
  if (!providersLeft.has(
    "phone"
    /* ProviderId.PHONE */
  )) {
    userInternal.phoneNumber = null;
  }
  await userInternal.auth._persistUserIfCurrent(userInternal);
  return userInternal;
}
__name(unlink, "unlink");
async function _link(user, credential, bypassAuthState = false) {
  const response = await _logoutIfInvalidated(user, credential._linkToIdToken(user.auth, await user.getIdToken()), bypassAuthState);
  return UserCredentialImpl._forOperation(user, "link", response);
}
__name(_link, "_link");
async function _assertLinkedStatus(expected, user, provider) {
  await _reloadWithoutSaving(user);
  const providerIds = providerDataAsNames(user.providerData);
  const code = expected === false ? "provider-already-linked" : "no-such-provider";
  _assert(providerIds.has(provider) === expected, user.auth, code);
}
__name(_assertLinkedStatus, "_assertLinkedStatus");
async function _reauthenticate(user, credential, bypassAuthState = false) {
  const { auth } = user;
  if (_isFirebaseServerApp(auth.app)) {
    return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));
  }
  const operationType = "reauthenticate";
  try {
    const response = await _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState);
    _assert(
      response.idToken,
      auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const parsed = _parseToken(response.idToken);
    _assert(
      parsed,
      auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const { sub: localId } = parsed;
    _assert(
      user.uid === localId,
      auth,
      "user-mismatch"
      /* AuthErrorCode.USER_MISMATCH */
    );
    return UserCredentialImpl._forOperation(user, operationType, response);
  } catch (e10) {
    if ((e10 === null || e10 === void 0 ? void 0 : e10.code) === `auth/${"user-not-found"}`) {
      _fail2(
        auth,
        "user-mismatch"
        /* AuthErrorCode.USER_MISMATCH */
      );
    }
    throw e10;
  }
}
__name(_reauthenticate, "_reauthenticate");
async function _signInWithCredential(auth, credential, bypassAuthState = false) {
  if (_isFirebaseServerApp(auth.app)) {
    return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));
  }
  const operationType = "signIn";
  const response = await _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential);
  const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, operationType, response);
  if (!bypassAuthState) {
    await auth._updateCurrentUser(userCredential.user);
  }
  return userCredential;
}
__name(_signInWithCredential, "_signInWithCredential");
async function signInWithCredential(auth, credential) {
  return _signInWithCredential(_castAuth(auth), credential);
}
__name(signInWithCredential, "signInWithCredential");
async function linkWithCredential(user, credential) {
  const userInternal = getModularInstance(user);
  await _assertLinkedStatus(false, userInternal, credential.providerId);
  return _link(userInternal, credential);
}
__name(linkWithCredential, "linkWithCredential");
async function reauthenticateWithCredential(user, credential) {
  return _reauthenticate(getModularInstance(user), credential);
}
__name(reauthenticateWithCredential, "reauthenticateWithCredential");
async function signInWithCustomToken$1(auth, request) {
  return _performSignInRequest(auth, "POST", "/v1/accounts:signInWithCustomToken", _addTidIfNecessary(auth, request));
}
__name(signInWithCustomToken$1, "signInWithCustomToken$1");
async function signInWithCustomToken(auth, customToken) {
  if (_isFirebaseServerApp(auth.app)) {
    return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));
  }
  const authInternal = _castAuth(auth);
  const response = await signInWithCustomToken$1(authInternal, {
    token: customToken,
    returnSecureToken: true
  });
  const cred = await UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn", response);
  await authInternal._updateCurrentUser(cred.user);
  return cred;
}
__name(signInWithCustomToken, "signInWithCustomToken");
var MultiFactorInfoImpl = class {
  static {
    __name(this, "MultiFactorInfoImpl");
  }
  constructor(factorId, response) {
    this.factorId = factorId;
    this.uid = response.mfaEnrollmentId;
    this.enrollmentTime = new Date(response.enrolledAt).toUTCString();
    this.displayName = response.displayName;
  }
  static _fromServerResponse(auth, enrollment) {
    if ("phoneInfo" in enrollment) {
      return PhoneMultiFactorInfoImpl._fromServerResponse(auth, enrollment);
    } else if ("totpInfo" in enrollment) {
      return TotpMultiFactorInfoImpl._fromServerResponse(auth, enrollment);
    }
    return _fail2(
      auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
  }
};
var PhoneMultiFactorInfoImpl = class _PhoneMultiFactorInfoImpl extends MultiFactorInfoImpl {
  static {
    __name(this, "PhoneMultiFactorInfoImpl");
  }
  constructor(response) {
    super("phone", response);
    this.phoneNumber = response.phoneInfo;
  }
  static _fromServerResponse(_auth, enrollment) {
    return new _PhoneMultiFactorInfoImpl(enrollment);
  }
};
var TotpMultiFactorInfoImpl = class _TotpMultiFactorInfoImpl extends MultiFactorInfoImpl {
  static {
    __name(this, "TotpMultiFactorInfoImpl");
  }
  constructor(response) {
    super("totp", response);
  }
  static _fromServerResponse(_auth, enrollment) {
    return new _TotpMultiFactorInfoImpl(enrollment);
  }
};
function _setActionCodeSettingsOnRequest(auth, request, actionCodeSettings) {
  var _a;
  _assert(
    ((_a = actionCodeSettings.url) === null || _a === void 0 ? void 0 : _a.length) > 0,
    auth,
    "invalid-continue-uri"
    /* AuthErrorCode.INVALID_CONTINUE_URI */
  );
  _assert(
    typeof actionCodeSettings.dynamicLinkDomain === "undefined" || actionCodeSettings.dynamicLinkDomain.length > 0,
    auth,
    "invalid-dynamic-link-domain"
    /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */
  );
  _assert(
    typeof actionCodeSettings.linkDomain === "undefined" || actionCodeSettings.linkDomain.length > 0,
    auth,
    "invalid-hosting-link-domain"
    /* AuthErrorCode.INVALID_HOSTING_LINK_DOMAIN */
  );
  request.continueUrl = actionCodeSettings.url;
  request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;
  request.linkDomain = actionCodeSettings.linkDomain;
  request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;
  if (actionCodeSettings.iOS) {
    _assert(
      actionCodeSettings.iOS.bundleId.length > 0,
      auth,
      "missing-ios-bundle-id"
      /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */
    );
    request.iOSBundleId = actionCodeSettings.iOS.bundleId;
  }
  if (actionCodeSettings.android) {
    _assert(
      actionCodeSettings.android.packageName.length > 0,
      auth,
      "missing-android-pkg-name"
      /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */
    );
    request.androidInstallApp = actionCodeSettings.android.installApp;
    request.androidMinimumVersionCode = actionCodeSettings.android.minimumVersion;
    request.androidPackageName = actionCodeSettings.android.packageName;
  }
}
__name(_setActionCodeSettingsOnRequest, "_setActionCodeSettingsOnRequest");
async function recachePasswordPolicy(auth) {
  const authInternal = _castAuth(auth);
  if (authInternal._getPasswordPolicyInternal()) {
    await authInternal._updatePasswordPolicy();
  }
}
__name(recachePasswordPolicy, "recachePasswordPolicy");
async function sendPasswordResetEmail(auth, email, actionCodeSettings) {
  const authInternal = _castAuth(auth);
  const request = {
    requestType: "PASSWORD_RESET",
    email,
    clientType: "CLIENT_TYPE_WEB"
    /* RecaptchaClientType.WEB */
  };
  if (actionCodeSettings) {
    _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);
  }
  await handleRecaptchaFlow(
    authInternal,
    request,
    "getOobCode",
    sendPasswordResetEmail$1,
    "EMAIL_PASSWORD_PROVIDER"
    /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */
  );
}
__name(sendPasswordResetEmail, "sendPasswordResetEmail");
async function confirmPasswordReset(auth, oobCode, newPassword) {
  await resetPassword(getModularInstance(auth), {
    oobCode,
    newPassword
  }).catch(async (error) => {
    if (error.code === `auth/${"password-does-not-meet-requirements"}`) {
      void recachePasswordPolicy(auth);
    }
    throw error;
  });
}
__name(confirmPasswordReset, "confirmPasswordReset");
async function applyActionCode(auth, oobCode) {
  await applyActionCode$1(getModularInstance(auth), { oobCode });
}
__name(applyActionCode, "applyActionCode");
async function checkActionCode(auth, oobCode) {
  const authModular = getModularInstance(auth);
  const response = await resetPassword(authModular, { oobCode });
  const operation = response.requestType;
  _assert(
    operation,
    authModular,
    "internal-error"
    /* AuthErrorCode.INTERNAL_ERROR */
  );
  switch (operation) {
    case "EMAIL_SIGNIN":
      break;
    case "VERIFY_AND_CHANGE_EMAIL":
      _assert(
        response.newEmail,
        authModular,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
      break;
    case "REVERT_SECOND_FACTOR_ADDITION":
      _assert(
        response.mfaInfo,
        authModular,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
    // fall through
    default:
      _assert(
        response.email,
        authModular,
        "internal-error"
        /* AuthErrorCode.INTERNAL_ERROR */
      );
  }
  let multiFactorInfo = null;
  if (response.mfaInfo) {
    multiFactorInfo = MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular), response.mfaInfo);
  }
  return {
    data: {
      email: (response.requestType === "VERIFY_AND_CHANGE_EMAIL" ? response.newEmail : response.email) || null,
      previousEmail: (response.requestType === "VERIFY_AND_CHANGE_EMAIL" ? response.email : response.newEmail) || null,
      multiFactorInfo
    },
    operation
  };
}
__name(checkActionCode, "checkActionCode");
async function verifyPasswordResetCode(auth, code) {
  const { data } = await checkActionCode(getModularInstance(auth), code);
  return data.email;
}
__name(verifyPasswordResetCode, "verifyPasswordResetCode");
async function createUserWithEmailAndPassword(auth, email, password) {
  if (_isFirebaseServerApp(auth.app)) {
    return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));
  }
  const authInternal = _castAuth(auth);
  const request = {
    returnSecureToken: true,
    email,
    password,
    clientType: "CLIENT_TYPE_WEB"
    /* RecaptchaClientType.WEB */
  };
  const signUpResponse = handleRecaptchaFlow(
    authInternal,
    request,
    "signUpPassword",
    signUp,
    "EMAIL_PASSWORD_PROVIDER"
    /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */
  );
  const response = await signUpResponse.catch((error) => {
    if (error.code === `auth/${"password-does-not-meet-requirements"}`) {
      void recachePasswordPolicy(auth);
    }
    throw error;
  });
  const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, "signIn", response);
  await authInternal._updateCurrentUser(userCredential.user);
  return userCredential;
}
__name(createUserWithEmailAndPassword, "createUserWithEmailAndPassword");
function signInWithEmailAndPassword(auth, email, password) {
  if (_isFirebaseServerApp(auth.app)) {
    return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));
  }
  return signInWithCredential(getModularInstance(auth), EmailAuthProvider.credential(email, password)).catch(async (error) => {
    if (error.code === `auth/${"password-does-not-meet-requirements"}`) {
      void recachePasswordPolicy(auth);
    }
    throw error;
  });
}
__name(signInWithEmailAndPassword, "signInWithEmailAndPassword");
async function sendSignInLinkToEmail(auth, email, actionCodeSettings) {
  const authInternal = _castAuth(auth);
  const request = {
    requestType: "EMAIL_SIGNIN",
    email,
    clientType: "CLIENT_TYPE_WEB"
    /* RecaptchaClientType.WEB */
  };
  function setActionCodeSettings(request2, actionCodeSettings2) {
    _assert(
      actionCodeSettings2.handleCodeInApp,
      authInternal,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    );
    if (actionCodeSettings2) {
      _setActionCodeSettingsOnRequest(authInternal, request2, actionCodeSettings2);
    }
  }
  __name(setActionCodeSettings, "setActionCodeSettings");
  setActionCodeSettings(request, actionCodeSettings);
  await handleRecaptchaFlow(
    authInternal,
    request,
    "getOobCode",
    sendSignInLinkToEmail$1,
    "EMAIL_PASSWORD_PROVIDER"
    /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */
  );
}
__name(sendSignInLinkToEmail, "sendSignInLinkToEmail");
function isSignInWithEmailLink(auth, emailLink) {
  const actionCodeUrl = ActionCodeURL.parseLink(emailLink);
  return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === "EMAIL_SIGNIN";
}
__name(isSignInWithEmailLink, "isSignInWithEmailLink");
async function signInWithEmailLink(auth, email, emailLink) {
  if (_isFirebaseServerApp(auth.app)) {
    return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));
  }
  const authModular = getModularInstance(auth);
  const credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl());
  _assert(
    credential._tenantId === (authModular.tenantId || null),
    authModular,
    "tenant-id-mismatch"
    /* AuthErrorCode.TENANT_ID_MISMATCH */
  );
  return signInWithCredential(authModular, credential);
}
__name(signInWithEmailLink, "signInWithEmailLink");
async function createAuthUri(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:createAuthUri", _addTidIfNecessary(auth, request));
}
__name(createAuthUri, "createAuthUri");
async function fetchSignInMethodsForEmail(auth, email) {
  const continueUri = _isHttpOrHttps() ? _getCurrentUrl() : "http://localhost";
  const request = {
    identifier: email,
    continueUri
  };
  const { signinMethods } = await createAuthUri(getModularInstance(auth), request);
  return signinMethods || [];
}
__name(fetchSignInMethodsForEmail, "fetchSignInMethodsForEmail");
async function sendEmailVerification(user, actionCodeSettings) {
  const userInternal = getModularInstance(user);
  const idToken = await user.getIdToken();
  const request = {
    requestType: "VERIFY_EMAIL",
    idToken
  };
  if (actionCodeSettings) {
    _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);
  }
  const { email } = await sendEmailVerification$1(userInternal.auth, request);
  if (email !== user.email) {
    await user.reload();
  }
}
__name(sendEmailVerification, "sendEmailVerification");
async function verifyBeforeUpdateEmail(user, newEmail, actionCodeSettings) {
  const userInternal = getModularInstance(user);
  const idToken = await user.getIdToken();
  const request = {
    requestType: "VERIFY_AND_CHANGE_EMAIL",
    idToken,
    newEmail
  };
  if (actionCodeSettings) {
    _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);
  }
  const { email } = await verifyAndChangeEmail(userInternal.auth, request);
  if (email !== user.email) {
    await user.reload();
  }
}
__name(verifyBeforeUpdateEmail, "verifyBeforeUpdateEmail");
async function updateProfile$1(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:update", request);
}
__name(updateProfile$1, "updateProfile$1");
async function updateProfile(user, { displayName, photoURL: photoUrl }) {
  if (displayName === void 0 && photoUrl === void 0) {
    return;
  }
  const userInternal = getModularInstance(user);
  const idToken = await userInternal.getIdToken();
  const profileRequest = {
    idToken,
    displayName,
    photoUrl,
    returnSecureToken: true
  };
  const response = await _logoutIfInvalidated(userInternal, updateProfile$1(userInternal.auth, profileRequest));
  userInternal.displayName = response.displayName || null;
  userInternal.photoURL = response.photoUrl || null;
  const passwordProvider = userInternal.providerData.find(
    ({ providerId }) => providerId === "password"
    /* ProviderId.PASSWORD */
  );
  if (passwordProvider) {
    passwordProvider.displayName = userInternal.displayName;
    passwordProvider.photoURL = userInternal.photoURL;
  }
  await userInternal._updateTokensIfNecessary(response);
}
__name(updateProfile, "updateProfile");
function updateEmail(user, newEmail) {
  const userInternal = getModularInstance(user);
  if (_isFirebaseServerApp(userInternal.auth.app)) {
    return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(userInternal.auth));
  }
  return updateEmailOrPassword(userInternal, newEmail, null);
}
__name(updateEmail, "updateEmail");
function updatePassword(user, newPassword) {
  return updateEmailOrPassword(getModularInstance(user), null, newPassword);
}
__name(updatePassword, "updatePassword");
async function updateEmailOrPassword(user, email, password) {
  const { auth } = user;
  const idToken = await user.getIdToken();
  const request = {
    idToken,
    returnSecureToken: true
  };
  if (email) {
    request.email = email;
  }
  if (password) {
    request.password = password;
  }
  const response = await _logoutIfInvalidated(user, updateEmailPassword(auth, request));
  await user._updateTokensIfNecessary(
    response,
    /* reload */
    true
  );
}
__name(updateEmailOrPassword, "updateEmailOrPassword");
function _fromIdTokenResponse(idTokenResponse) {
  var _a, _b;
  if (!idTokenResponse) {
    return null;
  }
  const { providerId } = idTokenResponse;
  const profile = idTokenResponse.rawUserInfo ? JSON.parse(idTokenResponse.rawUserInfo) : {};
  const isNewUser = idTokenResponse.isNewUser || idTokenResponse.kind === "identitytoolkit#SignupNewUserResponse";
  if (!providerId && (idTokenResponse === null || idTokenResponse === void 0 ? void 0 : idTokenResponse.idToken)) {
    const signInProvider = (_b = (_a = _parseToken(idTokenResponse.idToken)) === null || _a === void 0 ? void 0 : _a.firebase) === null || _b === void 0 ? void 0 : _b["sign_in_provider"];
    if (signInProvider) {
      const filteredProviderId = signInProvider !== "anonymous" && signInProvider !== "custom" ? signInProvider : null;
      return new GenericAdditionalUserInfo(isNewUser, filteredProviderId);
    }
  }
  if (!providerId) {
    return null;
  }
  switch (providerId) {
    case "facebook.com":
      return new FacebookAdditionalUserInfo(isNewUser, profile);
    case "github.com":
      return new GithubAdditionalUserInfo(isNewUser, profile);
    case "google.com":
      return new GoogleAdditionalUserInfo(isNewUser, profile);
    case "twitter.com":
      return new TwitterAdditionalUserInfo(isNewUser, profile, idTokenResponse.screenName || null);
    case "custom":
    case "anonymous":
      return new GenericAdditionalUserInfo(isNewUser, null);
    default:
      return new GenericAdditionalUserInfo(isNewUser, providerId, profile);
  }
}
__name(_fromIdTokenResponse, "_fromIdTokenResponse");
var GenericAdditionalUserInfo = class {
  static {
    __name(this, "GenericAdditionalUserInfo");
  }
  constructor(isNewUser, providerId, profile = {}) {
    this.isNewUser = isNewUser;
    this.providerId = providerId;
    this.profile = profile;
  }
};
var FederatedAdditionalUserInfoWithUsername = class extends GenericAdditionalUserInfo {
  static {
    __name(this, "FederatedAdditionalUserInfoWithUsername");
  }
  constructor(isNewUser, providerId, profile, username) {
    super(isNewUser, providerId, profile);
    this.username = username;
  }
};
var FacebookAdditionalUserInfo = class extends GenericAdditionalUserInfo {
  static {
    __name(this, "FacebookAdditionalUserInfo");
  }
  constructor(isNewUser, profile) {
    super(isNewUser, "facebook.com", profile);
  }
};
var GithubAdditionalUserInfo = class extends FederatedAdditionalUserInfoWithUsername {
  static {
    __name(this, "GithubAdditionalUserInfo");
  }
  constructor(isNewUser, profile) {
    super(isNewUser, "github.com", profile, typeof (profile === null || profile === void 0 ? void 0 : profile.login) === "string" ? profile === null || profile === void 0 ? void 0 : profile.login : null);
  }
};
var GoogleAdditionalUserInfo = class extends GenericAdditionalUserInfo {
  static {
    __name(this, "GoogleAdditionalUserInfo");
  }
  constructor(isNewUser, profile) {
    super(isNewUser, "google.com", profile);
  }
};
var TwitterAdditionalUserInfo = class extends FederatedAdditionalUserInfoWithUsername {
  static {
    __name(this, "TwitterAdditionalUserInfo");
  }
  constructor(isNewUser, profile, screenName) {
    super(isNewUser, "twitter.com", profile, screenName);
  }
};
function getAdditionalUserInfo(userCredential) {
  const { user, _tokenResponse } = userCredential;
  if (user.isAnonymous && !_tokenResponse) {
    return {
      providerId: null,
      isNewUser: false,
      profile: null
    };
  }
  return _fromIdTokenResponse(_tokenResponse);
}
__name(getAdditionalUserInfo, "getAdditionalUserInfo");
function setPersistence(auth, persistence) {
  return getModularInstance(auth).setPersistence(persistence);
}
__name(setPersistence, "setPersistence");
function initializeRecaptchaConfig(auth) {
  return _initializeRecaptchaConfig(auth);
}
__name(initializeRecaptchaConfig, "initializeRecaptchaConfig");
async function validatePassword(auth, password) {
  const authInternal = _castAuth(auth);
  return authInternal.validatePassword(password);
}
__name(validatePassword, "validatePassword");
function onIdTokenChanged(auth, nextOrObserver, error, completed) {
  return getModularInstance(auth).onIdTokenChanged(nextOrObserver, error, completed);
}
__name(onIdTokenChanged, "onIdTokenChanged");
function beforeAuthStateChanged(auth, callback, onAbort) {
  return getModularInstance(auth).beforeAuthStateChanged(callback, onAbort);
}
__name(beforeAuthStateChanged, "beforeAuthStateChanged");
function onAuthStateChanged(auth, nextOrObserver, error, completed) {
  return getModularInstance(auth).onAuthStateChanged(nextOrObserver, error, completed);
}
__name(onAuthStateChanged, "onAuthStateChanged");
function useDeviceLanguage(auth) {
  getModularInstance(auth).useDeviceLanguage();
}
__name(useDeviceLanguage, "useDeviceLanguage");
function updateCurrentUser(auth, user) {
  return getModularInstance(auth).updateCurrentUser(user);
}
__name(updateCurrentUser, "updateCurrentUser");
function signOut(auth) {
  return getModularInstance(auth).signOut();
}
__name(signOut, "signOut");
function revokeAccessToken(auth, token) {
  const authInternal = _castAuth(auth);
  return authInternal.revokeAccessToken(token);
}
__name(revokeAccessToken, "revokeAccessToken");
async function deleteUser(user) {
  return getModularInstance(user).delete();
}
__name(deleteUser, "deleteUser");
var MultiFactorSessionImpl = class _MultiFactorSessionImpl {
  static {
    __name(this, "MultiFactorSessionImpl");
  }
  constructor(type, credential, user) {
    this.type = type;
    this.credential = credential;
    this.user = user;
  }
  static _fromIdtoken(idToken, user) {
    return new _MultiFactorSessionImpl("enroll", idToken, user);
  }
  static _fromMfaPendingCredential(mfaPendingCredential) {
    return new _MultiFactorSessionImpl("signin", mfaPendingCredential);
  }
  toJSON() {
    const key = this.type === "enroll" ? "idToken" : "pendingCredential";
    return {
      multiFactorSession: {
        [key]: this.credential
      }
    };
  }
  static fromJSON(obj) {
    var _a, _b;
    if (obj === null || obj === void 0 ? void 0 : obj.multiFactorSession) {
      if ((_a = obj.multiFactorSession) === null || _a === void 0 ? void 0 : _a.pendingCredential) {
        return _MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);
      } else if ((_b = obj.multiFactorSession) === null || _b === void 0 ? void 0 : _b.idToken) {
        return _MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken);
      }
    }
    return null;
  }
};
var MultiFactorResolverImpl = class _MultiFactorResolverImpl {
  static {
    __name(this, "MultiFactorResolverImpl");
  }
  constructor(session, hints, signInResolver) {
    this.session = session;
    this.hints = hints;
    this.signInResolver = signInResolver;
  }
  /** @internal */
  static _fromError(authExtern, error) {
    const auth = _castAuth(authExtern);
    const serverResponse = error.customData._serverResponse;
    const hints = (serverResponse.mfaInfo || []).map((enrollment) => MultiFactorInfoImpl._fromServerResponse(auth, enrollment));
    _assert(
      serverResponse.mfaPendingCredential,
      auth,
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const session = MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);
    return new _MultiFactorResolverImpl(session, hints, async (assertion) => {
      const mfaResponse = await assertion._process(auth, session);
      delete serverResponse.mfaInfo;
      delete serverResponse.mfaPendingCredential;
      const idTokenResponse = Object.assign(Object.assign({}, serverResponse), { idToken: mfaResponse.idToken, refreshToken: mfaResponse.refreshToken });
      switch (error.operationType) {
        case "signIn":
          const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, error.operationType, idTokenResponse);
          await auth._updateCurrentUser(userCredential.user);
          return userCredential;
        case "reauthenticate":
          _assert(
            error.user,
            auth,
            "internal-error"
            /* AuthErrorCode.INTERNAL_ERROR */
          );
          return UserCredentialImpl._forOperation(error.user, error.operationType, idTokenResponse);
        default:
          _fail2(
            auth,
            "internal-error"
            /* AuthErrorCode.INTERNAL_ERROR */
          );
      }
    });
  }
  async resolveSignIn(assertionExtern) {
    const assertion = assertionExtern;
    return this.signInResolver(assertion);
  }
};
function getMultiFactorResolver(auth, error) {
  var _a;
  const authModular = getModularInstance(auth);
  const errorInternal = error;
  _assert(
    error.customData.operationType,
    authModular,
    "argument-error"
    /* AuthErrorCode.ARGUMENT_ERROR */
  );
  _assert(
    (_a = errorInternal.customData._serverResponse) === null || _a === void 0 ? void 0 : _a.mfaPendingCredential,
    authModular,
    "argument-error"
    /* AuthErrorCode.ARGUMENT_ERROR */
  );
  return MultiFactorResolverImpl._fromError(authModular, errorInternal);
}
__name(getMultiFactorResolver, "getMultiFactorResolver");
function startEnrollTotpMfa(auth, request) {
  return _performApiRequest(auth, "POST", "/v2/accounts/mfaEnrollment:start", _addTidIfNecessary(auth, request));
}
__name(startEnrollTotpMfa, "startEnrollTotpMfa");
function finalizeEnrollTotpMfa(auth, request) {
  return _performApiRequest(auth, "POST", "/v2/accounts/mfaEnrollment:finalize", _addTidIfNecessary(auth, request));
}
__name(finalizeEnrollTotpMfa, "finalizeEnrollTotpMfa");
function withdrawMfa(auth, request) {
  return _performApiRequest(auth, "POST", "/v2/accounts/mfaEnrollment:withdraw", _addTidIfNecessary(auth, request));
}
__name(withdrawMfa, "withdrawMfa");
var MultiFactorUserImpl = class _MultiFactorUserImpl {
  static {
    __name(this, "MultiFactorUserImpl");
  }
  constructor(user) {
    this.user = user;
    this.enrolledFactors = [];
    user._onReload((userInfo) => {
      if (userInfo.mfaInfo) {
        this.enrolledFactors = userInfo.mfaInfo.map((enrollment) => MultiFactorInfoImpl._fromServerResponse(user.auth, enrollment));
      }
    });
  }
  static _fromUser(user) {
    return new _MultiFactorUserImpl(user);
  }
  async getSession() {
    return MultiFactorSessionImpl._fromIdtoken(await this.user.getIdToken(), this.user);
  }
  async enroll(assertionExtern, displayName) {
    const assertion = assertionExtern;
    const session = await this.getSession();
    const finalizeMfaResponse = await _logoutIfInvalidated(this.user, assertion._process(this.user.auth, session, displayName));
    await this.user._updateTokensIfNecessary(finalizeMfaResponse);
    return this.user.reload();
  }
  async unenroll(infoOrUid) {
    const mfaEnrollmentId = typeof infoOrUid === "string" ? infoOrUid : infoOrUid.uid;
    const idToken = await this.user.getIdToken();
    try {
      const idTokenResponse = await _logoutIfInvalidated(this.user, withdrawMfa(this.user.auth, {
        idToken,
        mfaEnrollmentId
      }));
      this.enrolledFactors = this.enrolledFactors.filter(({ uid }) => uid !== mfaEnrollmentId);
      await this.user._updateTokensIfNecessary(idTokenResponse);
      await this.user.reload();
    } catch (e10) {
      throw e10;
    }
  }
};
var multiFactorUserCache = /* @__PURE__ */ new WeakMap();
function multiFactor(user) {
  const userModular = getModularInstance(user);
  if (!multiFactorUserCache.has(userModular)) {
    multiFactorUserCache.set(userModular, MultiFactorUserImpl._fromUser(userModular));
  }
  return multiFactorUserCache.get(userModular);
}
__name(multiFactor, "multiFactor");
var name3 = "@firebase/auth";
var version4 = "1.10.7";
var AuthInterop = class {
  static {
    __name(this, "AuthInterop");
  }
  constructor(auth) {
    this.auth = auth;
    this.internalListeners = /* @__PURE__ */ new Map();
  }
  getUid() {
    var _a;
    this.assertAuthConfigured();
    return ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.uid) || null;
  }
  async getToken(forceRefresh) {
    this.assertAuthConfigured();
    await this.auth._initializationPromise;
    if (!this.auth.currentUser) {
      return null;
    }
    const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);
    return { accessToken };
  }
  addAuthTokenListener(listener) {
    this.assertAuthConfigured();
    if (this.internalListeners.has(listener)) {
      return;
    }
    const unsubscribe = this.auth.onIdTokenChanged((user) => {
      listener((user === null || user === void 0 ? void 0 : user.stsTokenManager.accessToken) || null);
    });
    this.internalListeners.set(listener, unsubscribe);
    this.updateProactiveRefresh();
  }
  removeAuthTokenListener(listener) {
    this.assertAuthConfigured();
    const unsubscribe = this.internalListeners.get(listener);
    if (!unsubscribe) {
      return;
    }
    this.internalListeners.delete(listener);
    unsubscribe();
    this.updateProactiveRefresh();
  }
  assertAuthConfigured() {
    _assert(
      this.auth._initializationPromise,
      "dependent-sdk-initialized-before-auth"
      /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */
    );
  }
  updateProactiveRefresh() {
    if (this.internalListeners.size > 0) {
      this.auth._startProactiveRefresh();
    } else {
      this.auth._stopProactiveRefresh();
    }
  }
};
function getVersionForPlatform(clientPlatform) {
  switch (clientPlatform) {
    case "Node":
      return "node";
    case "ReactNative":
      return "rn";
    case "Worker":
      return "webworker";
    case "Cordova":
      return "cordova";
    case "WebExtension":
      return "web-extension";
    default:
      return void 0;
  }
}
__name(getVersionForPlatform, "getVersionForPlatform");
function registerAuth(clientPlatform) {
  _registerComponent(new Component(
    "auth",
    (container, { options: deps }) => {
      const app = container.getProvider("app").getImmediate();
      const heartbeatServiceProvider = container.getProvider("heartbeat");
      const appCheckServiceProvider = container.getProvider("app-check-internal");
      const { apiKey, authDomain } = app.options;
      _assert(apiKey && !apiKey.includes(":"), "invalid-api-key", { appName: app.name });
      const config = {
        apiKey,
        authDomain,
        clientPlatform,
        apiHost: "identitytoolkit.googleapis.com",
        tokenApiHost: "securetoken.googleapis.com",
        apiScheme: "https",
        sdkClientVersion: _getClientVersion(clientPlatform)
      };
      const authInstance = new AuthImpl(app, heartbeatServiceProvider, appCheckServiceProvider, config);
      _initializeAuthInstance(authInstance, deps);
      return authInstance;
    },
    "PUBLIC"
    /* ComponentType.PUBLIC */
  ).setInstantiationMode(
    "EXPLICIT"
    /* InstantiationMode.EXPLICIT */
  ).setInstanceCreatedCallback((container, _instanceIdentifier, _instance) => {
    const authInternalProvider = container.getProvider(
      "auth-internal"
      /* _ComponentName.AUTH_INTERNAL */
    );
    authInternalProvider.initialize();
  }));
  _registerComponent(new Component(
    "auth-internal",
    (container) => {
      const auth = _castAuth(container.getProvider(
        "auth"
        /* _ComponentName.AUTH */
      ).getImmediate());
      return ((auth2) => new AuthInterop(auth2))(auth);
    },
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ).setInstantiationMode(
    "EXPLICIT"
    /* InstantiationMode.EXPLICIT */
  ));
  registerVersion(name3, version4, getVersionForPlatform(clientPlatform));
  registerVersion(name3, version4, "esm2017");
}
__name(registerAuth, "registerAuth");
FetchProvider.initialize(fetch, Headers, Response);
function getAuth(app = getApp()) {
  const provider = _getProvider(app, "auth");
  if (provider.isInitialized()) {
    return provider.getImmediate();
  }
  const auth = initializeAuth(app);
  const authEmulatorHost = getDefaultEmulatorHost("auth");
  if (authEmulatorHost) {
    connectAuthEmulator(auth, `http://${authEmulatorHost}`);
  }
  return auth;
}
__name(getAuth, "getAuth");
registerAuth(
  "Node"
  /* ClientPlatform.NODE */
);
var NOT_AVAILABLE_ERROR = _createError(
  "operation-not-supported-in-this-environment"
  /* AuthErrorCode.OPERATION_NOT_SUPPORTED */
);
async function fail2() {
  throw NOT_AVAILABLE_ERROR;
}
__name(fail2, "fail");
var FailClass = class {
  static {
    __name(this, "FailClass");
  }
  constructor() {
    throw NOT_AVAILABLE_ERROR;
  }
};
var browserLocalPersistence = inMemoryPersistence;
var browserSessionPersistence = inMemoryPersistence;
var browserCookiePersistence = inMemoryPersistence;
var indexedDBLocalPersistence = inMemoryPersistence;
var browserPopupRedirectResolver = NOT_AVAILABLE_ERROR;
var PhoneAuthProvider = FailClass;
var signInWithPhoneNumber = fail2;
var linkWithPhoneNumber = fail2;
var reauthenticateWithPhoneNumber = fail2;
var updatePhoneNumber = fail2;
var signInWithPopup = fail2;
var linkWithPopup = fail2;
var reauthenticateWithPopup = fail2;
var signInWithRedirect = fail2;
var linkWithRedirect = fail2;
var reauthenticateWithRedirect = fail2;
var getRedirectResult = fail2;
var RecaptchaVerifier = FailClass;
var PhoneMultiFactorGenerator = class {
  static {
    __name(this, "PhoneMultiFactorGenerator");
  }
  static assertion() {
    throw NOT_AVAILABLE_ERROR;
  }
};
AuthImpl.prototype.setPersistence = async () => {
};
function finalizeSignInTotpMfa(auth, request) {
  return _performApiRequest(auth, "POST", "/v2/accounts/mfaSignIn:finalize", _addTidIfNecessary(auth, request));
}
__name(finalizeSignInTotpMfa, "finalizeSignInTotpMfa");
var MultiFactorAssertionImpl = class {
  static {
    __name(this, "MultiFactorAssertionImpl");
  }
  constructor(factorId) {
    this.factorId = factorId;
  }
  _process(auth, session, displayName) {
    switch (session.type) {
      case "enroll":
        return this._finalizeEnroll(auth, session.credential, displayName);
      case "signin":
        return this._finalizeSignIn(auth, session.credential);
      default:
        return debugFail("unexpected MultiFactorSessionType");
    }
  }
};
var TotpMultiFactorGenerator = class {
  static {
    __name(this, "TotpMultiFactorGenerator");
  }
  /**
   * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of
   * the TOTP (time-based one-time password) second factor.
   * This assertion is used to complete enrollment in TOTP second factor.
   *
   * @param secret A {@link TotpSecret} containing the shared secret key and other TOTP parameters.
   * @param oneTimePassword One-time password from TOTP App.
   * @returns A {@link TotpMultiFactorAssertion} which can be used with
   * {@link MultiFactorUser.enroll}.
   */
  static assertionForEnrollment(secret, oneTimePassword) {
    return TotpMultiFactorAssertionImpl._fromSecret(secret, oneTimePassword);
  }
  /**
   * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of the TOTP second factor.
   * This assertion is used to complete signIn with TOTP as the second factor.
   *
   * @param enrollmentId identifies the enrolled TOTP second factor.
   * @param oneTimePassword One-time password from TOTP App.
   * @returns A {@link TotpMultiFactorAssertion} which can be used with
   * {@link MultiFactorResolver.resolveSignIn}.
   */
  static assertionForSignIn(enrollmentId, oneTimePassword) {
    return TotpMultiFactorAssertionImpl._fromEnrollmentId(enrollmentId, oneTimePassword);
  }
  /**
   * Returns a promise to {@link TotpSecret} which contains the TOTP shared secret key and other parameters.
   * Creates a TOTP secret as part of enrolling a TOTP second factor.
   * Used for generating a QR code URL or inputting into a TOTP app.
   * This method uses the auth instance corresponding to the user in the multiFactorSession.
   *
   * @param session The {@link MultiFactorSession} that the user is part of.
   * @returns A promise to {@link TotpSecret}.
   */
  static async generateSecret(session) {
    var _a;
    const mfaSession = session;
    _assert(
      typeof ((_a = mfaSession.user) === null || _a === void 0 ? void 0 : _a.auth) !== "undefined",
      "internal-error"
      /* AuthErrorCode.INTERNAL_ERROR */
    );
    const response = await startEnrollTotpMfa(mfaSession.user.auth, {
      idToken: mfaSession.credential,
      totpEnrollmentInfo: {}
    });
    return TotpSecret._fromStartTotpMfaEnrollmentResponse(response, mfaSession.user.auth);
  }
};
TotpMultiFactorGenerator.FACTOR_ID = "totp";
var TotpMultiFactorAssertionImpl = class _TotpMultiFactorAssertionImpl extends MultiFactorAssertionImpl {
  static {
    __name(this, "TotpMultiFactorAssertionImpl");
  }
  constructor(otp, enrollmentId, secret) {
    super(
      "totp"
      /* FactorId.TOTP */
    );
    this.otp = otp;
    this.enrollmentId = enrollmentId;
    this.secret = secret;
  }
  /** @internal */
  static _fromSecret(secret, otp) {
    return new _TotpMultiFactorAssertionImpl(otp, void 0, secret);
  }
  /** @internal */
  static _fromEnrollmentId(enrollmentId, otp) {
    return new _TotpMultiFactorAssertionImpl(otp, enrollmentId);
  }
  /** @internal */
  async _finalizeEnroll(auth, idToken, displayName) {
    _assert(
      typeof this.secret !== "undefined",
      auth,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    );
    return finalizeEnrollTotpMfa(auth, {
      idToken,
      displayName,
      totpVerificationInfo: this.secret._makeTotpVerificationInfo(this.otp)
    });
  }
  /** @internal */
  async _finalizeSignIn(auth, mfaPendingCredential) {
    _assert(
      this.enrollmentId !== void 0 && this.otp !== void 0,
      auth,
      "argument-error"
      /* AuthErrorCode.ARGUMENT_ERROR */
    );
    const totpVerificationInfo = { verificationCode: this.otp };
    return finalizeSignInTotpMfa(auth, {
      mfaPendingCredential,
      mfaEnrollmentId: this.enrollmentId,
      totpVerificationInfo
    });
  }
};
var TotpSecret = class _TotpSecret {
  static {
    __name(this, "TotpSecret");
  }
  // The public members are declared outside the constructor so the docs can be generated.
  constructor(secretKey, hashingAlgorithm, codeLength, codeIntervalSeconds, enrollmentCompletionDeadline, sessionInfo, auth) {
    this.sessionInfo = sessionInfo;
    this.auth = auth;
    this.secretKey = secretKey;
    this.hashingAlgorithm = hashingAlgorithm;
    this.codeLength = codeLength;
    this.codeIntervalSeconds = codeIntervalSeconds;
    this.enrollmentCompletionDeadline = enrollmentCompletionDeadline;
  }
  /** @internal */
  static _fromStartTotpMfaEnrollmentResponse(response, auth) {
    return new _TotpSecret(response.totpSessionInfo.sharedSecretKey, response.totpSessionInfo.hashingAlgorithm, response.totpSessionInfo.verificationCodeLength, response.totpSessionInfo.periodSec, new Date(response.totpSessionInfo.finalizeEnrollmentTime).toUTCString(), response.totpSessionInfo.sessionInfo, auth);
  }
  /** @internal */
  _makeTotpVerificationInfo(otp) {
    return { sessionInfo: this.sessionInfo, verificationCode: otp };
  }
  /**
   * Returns a QR code URL as described in
   * https://github.com/google/google-authenticator/wiki/Key-Uri-Format
   * This can be displayed to the user as a QR code to be scanned into a TOTP app like Google Authenticator.
   * If the optional parameters are unspecified, an accountName of <userEmail> and issuer of <firebaseAppName> are used.
   *
   * @param accountName the name of the account/app along with a user identifier.
   * @param issuer issuer of the TOTP (likely the app name).
   * @returns A QR code URL string.
   */
  generateQrCodeUrl(accountName, issuer) {
    var _a;
    let useDefaults = false;
    if (_isEmptyString(accountName) || _isEmptyString(issuer)) {
      useDefaults = true;
    }
    if (useDefaults) {
      if (_isEmptyString(accountName)) {
        accountName = ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.email) || "unknownuser";
      }
      if (_isEmptyString(issuer)) {
        issuer = this.auth.name;
      }
    }
    return `otpauth://totp/${issuer}:${accountName}?secret=${this.secretKey}&issuer=${issuer}&algorithm=${this.hashingAlgorithm}&digits=${this.codeLength}`;
  }
};
function _isEmptyString(input) {
  return typeof input === "undefined" || (input === null || input === void 0 ? void 0 : input.length) === 0;
}
__name(_isEmptyString, "_isEmptyString");

// node_modules/@mahindar5/common-lib/dist/chunk-UNB2PGZX.js
var i10 = class {
  static {
    __name(this, "i");
  }
  static {
    j(this, "AuthService");
  }
  authReady = false;
  readyPromise = new Promise((t11) => onAuthStateChanged(getAuth(s8), () => {
    this.authReady = true, t11();
  }));
  async isLoggedIn() {
    return this.authReady || await this.readyPromise, !!getAuth(s8).currentUser;
  }
  async loginWithEmailPassword(t11, s18) {
    return await this.isLoggedIn() || await signInWithEmailAndPassword(getAuth(s8), t11, s18), true;
  }
  async getCurrentUserEmail() {
    return getAuth(s8).currentUser?.email || null;
  }
  async logout() {
    return await signOut(getAuth(s8)), true;
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-ILV34OP7.js
var I = class {
  static {
    __name(this, "I");
  }
  static {
    j(this, "Scheduler");
  }
  configData = { displayName: "Scheduler", inputs: { intervalInSeconds: 30, alarmEnabled: false, authToken: "", xApiKey: "" } };
  succeededJobs = [];
  failedJobs = [];
  notificationHelper = c2(c10);
  schedulerExtStorage = c2(n7);
  authService = c2(i10);
  jobNames;
  schedulerInterval;
  currentTime;
  constructor() {
    this.jobNames = f().filter((t11) => t11.endsWith("Job")), this.startScheduler();
  }
  async startScheduler() {
    if (setTimeout(() => this.startScheduler(), this.schedulerInterval || this.configData.inputs.intervalInSeconds * 1e3), !await this.authService.isLoggedIn()) {
      console.warn("\u26A0\uFE0F Scheduler: Extension not authenticated. Please login from webapp to continue.");
      return;
    }
    this.currentTime = /* @__PURE__ */ new Date();
    try {
      let { jobsConfigData: t11, jobsRunData: s18 } = await this.getJobsConfig();
      if (!t11 || Object.keys(t11).length === 0) {
        console.warn("Scheduler: No config data received, device may not be mapped, waiting for next schedule");
        return;
      }
      this.schedulerInterval = this.getSchedulerInterval(t11), this.succeededJobs = [], this.failedJobs = [], await Promise.all(this.jobNames.map((e10) => this.executeJob(e10, t11[e10], s18[e10]))), await this.saveLatestRunData(t11, s18);
    } catch (t11) {
      console.warn(`\u26A0\uFE0F Scheduler errors: ${t11?.message || t11}`, t11?.stack || t11, t11);
    }
  }
  async saveLatestRunData(t11, s18) {
    let e10 = Date.now();
    s18.Scheduler.lastRunTime = e10, s18.Scheduler.lastRunTimeObj = e10 ? new Date(e10) : null;
    let n11 = await this.calcHistoricalRuns();
    await this.schedulerExtStorage.saveAllData({ jobsConfigData: t11, jobsRunData: s18, historicalRuns: n11 });
  }
  async calcHistoricalRuns() {
    if (!this.currentTime) return {};
    let s18 = (await this.schedulerExtStorage.getAllData()).historicalRuns || {}, e10 = { ...this.succeededJobs.length && { succeededJobs: this.succeededJobs }, ...this.failedJobs.length && { failedJobs: this.failedJobs } };
    s18[this.currentTime.toISOString()] = e10;
    let n11 = Date.now() - 6048e5;
    return Object.keys(s18).forEach((r9) => {
      new Date(r9).getTime() < n11 && delete s18[r9];
    }), globalThis.historicalRuns0 = s18, s18;
  }
  async getJobsConfig() {
    let t11 = await this.schedulerExtStorage.getAllData(), { jobsConfigData: s18, jobsRunData: e10, historicalRuns: n11, jobsUnknownData: r9 } = t11, i18 = { jobsConfigData: {}, jobsRunData: {}, jobsUnknownData: {}, historicalRuns: n11 || {} }, l14 = this.getSchedulerInterval(s18);
    for (let a22 of [...this.jobNames, "Scheduler"]) {
      let c21 = o(a22).configData, d15 = s18[a22] || {}, u20 = e10[a22] || {}, { intervalInMinutes: T6 = 0, intervalInSeconds: x3 = 0 } = { ...c21.inputs, ...d15.inputs }, f13 = (T6 * 60 + x3) * 1e3 || 5 * 60 * 1e3;
      f13 = Math.ceil(f13 / l14) * l14;
      let h12 = u20.lastRunTime, m18 = c21.inputs, R6 = d15.inputs || {}, p15 = {}, w4 = {}, k5 = Object.keys(m18);
      Object.keys({ ...m18, ...R6 }).forEach((g10) => {
        let C3 = R6[g10] ?? m18[g10];
        (k5.includes(g10) ? p15 : w4)[g10] = C3;
      }), i18.jobsRunData[a22] = { lastRunTime: h12 ?? null, lastRunTimeObj: h12 ? new Date(h12) : null, nextRunTimeObj: d15.isEnabled && h12 ? new Date(h12 + f13) : null, interval: f13, lastError: u20.lastError ?? null, isRunning: u20.isRunning ?? null, wasEnabled: u20.wasEnabled ?? false, lastRuns: u20.lastRuns ?? [] }, i18.jobsConfigData[a22] = { isEnabled: d15.isEnabled ?? c21.isEnabled, displayName: c21.displayName, inputs: p15 }, Object.keys(w4).length && (i18.jobsUnknownData[a22] = { inputs: w4 });
    }
    return i18;
  }
  async sendNotification(t11, s18, e10) {
    if (!t11?.title && !t11?.message && !t11?.items?.length) return;
    let n11 = t11.message || (t11.items ? JSON.stringify(t11.items) : ""), r9 = t11.title || s18, i18 = e10.inputs.webhookUrl || "";
    await this.notificationHelper.notifyWithSoundAndWebhook(n11, r9, i18, s18);
  }
  shouldRunJob(t11, s18) {
    let e10 = t11.lastRunTime ? s18 - t11.lastRunTime : Number.MAX_SAFE_INTEGER;
    return (!t11.lastRunTime || e10 >= t11.interval - 1e3) && (!t11.isRunning || e10 >= t11.interval * 4);
  }
  getSchedulerInterval(t11) {
    return (t11.Scheduler?.inputs?.intervalInSeconds || this.configData.inputs.intervalInSeconds) * 1e3;
  }
  updateLastRuns(t11, s18, e10) {
    t11.lastRuns = t11.lastRuns || [], t11.lastRuns.unshift(`${s18}:${e10}`), t11.lastRuns = t11.lastRuns.slice(0, 10);
  }
  async executeJob(t11, s18, e10, n11 = false, r9 = false) {
    let i18 = Date.now(), l14 = o(t11), a22 = s18.isEnabled && (!l14.getEligibility || await l14.getEligibility(s18));
    if (n11 && (a22 = true, !r9 && !this.shouldRunJob(e10, i18))) {
      let o21 = e10.lastRunTime ? e10.lastRunTime + e10.interval : Date.now();
      throw new Error(`Job "${t11}" not ready until ${new Date(o21).toLocaleString()}`);
    }
    if (a22 && (r9 || this.shouldRunJob(e10, i18))) try {
      e10.isRunning = true;
      let o21 = await l14.run(s18, r9);
      return this.succeededJobs.push(t11), e10.lastRunTime = i18, this.updateLastRuns(e10, "success", i18), await this.sendNotification(o21, t11, s18), o21;
    } catch (o21) {
      this.failedJobs.push(t11), e10.lastError = o21.message || o21, this.updateLastRuns(e10, "failed", i18);
      let c21 = `Failed to execute job "${t11}": ${o21?.message || o21}`;
      if (n11) throw new Error(c21);
      console.error(c21, o21);
    } finally {
      e10.isRunning = false;
    }
    else e10.wasEnabled && !a22 && l14.stop && await l14.stop(s18);
    e10.wasEnabled = a22;
  }
  async forceExecuteJob(t11, s18 = false) {
    if (!this.jobNames.includes(t11)) throw new Error(`Job "${t11}" not found`);
    let { jobsConfigData: e10, jobsRunData: n11 } = await this.getJobsConfig();
    await this.executeJob(t11, e10[t11], n11[t11], true, s18), await this.saveLatestRunData(e10, n11);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-4GLDUGPY.js
var o9 = class {
  static {
    __name(this, "o");
  }
  static {
    j(this, "BCParksJob");
  }
  configData = { displayName: "BCParksJob", isEnabled: false, inputs: { intervalInSeconds: 30, checkDates: "2024-09-15", url: "https://jd7n1axqh0.execute-api.ca-central-1.amazonaws.com/api/reservation?facility=Rubble%20Creek&park=0007", webhookUrl: "https://discord.com/api/webhooks/1279236242357358776/c_IfDOl9oVmTNrNrThwnS_0JwRagY4zxsGp0CWmrnegsgtNO2DuqWESOf6I0z2Tn9Rhb" } };
  async run(s18, p15) {
    let r9 = s18.inputs?.url || "https://jd7n1axqh0.execute-api.ca-central-1.amazonaws.com/api/reservation?facility=Joffre%20Lakes&park=0363", e10 = await fetch(r9);
    if (!e10.ok) throw new Error(`Failed to fetch reservation data: ${e10.statusText || e10.status}`);
    let c21 = await e10.json(), n11 = s18.inputs?.checkDates?.split(",").map((a22) => a22.trim()).filter(Boolean) || [];
    return { message: Object.entries(c21).filter(([a22, t11]) => (!n11.length || n11.includes(a22)) && t11?.DAY?.capacity?.toLowerCase() !== "full").map(([a22, t11]) => `${a22}: ${t11?.DAY?.capacity} - ${t11?.DAY?.max}`).join(`
`) };
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-OVLZGBK4.js
var u11 = class {
  static {
    __name(this, "u");
  }
  static {
    j(this, "HttpJob");
  }
  configData = { displayName: "HttpJob", isEnabled: false, inputs: { intervalInSeconds: 60, requestString: "" } };
  async run(l14, d15) {
    let s18 = l14.inputs?.requestString || globalThis.requestString;
    if (s18) try {
      let f13 = JSON.parse(s18).map((g10) => {
        let { url: r9, method: o21 = "GET", headers: m18 = {}, body: e10 } = g10, a22 = { method: o21, headers: m18 };
        return e10 && ["POST", "PUT", "PATCH"].includes(o21.toUpperCase()) && (a22.body = typeof e10 == "string" ? e10 : JSON.stringify(e10)), fetch(r9, a22).then((t11) => {
          if (t11.ok) {
            let i18 = t11.headers.get("Content-Type");
            return i18 && i18.includes("application/json") ? t11.json() : t11.text();
          } else return Promise.reject(`Failed with status: ${t11.status}`);
        }).catch((t11) => (console.error(`Request to ${r9} failed:`, t11), { error: t11.message }));
      }), p15 = await Promise.all(f13);
    } catch (n11) {
      console.error("Error submitting requests:", n11);
    }
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-EPYPIVVR.js
var e2 = class {
  static {
    __name(this, "e");
  }
  static {
    j(this, "HydrationReminderJob");
  }
  configData = { displayName: "HydrationReminderJob", isEnabled: false, inputs: { intervalInMinutes: 40, webhookUrl: "" } };
  async run(o21, t11) {
    return { message: "It's time to hydrate!" };
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-Z4FFF3WF.js
var o10 = class {
  static {
    __name(this, "o");
  }
  static {
    j(this, "ICBCMonitorJob");
  }
  configData = { displayName: "ICBCMonitorJob", isEnabled: false, inputs: { intervalInSeconds: 0, dates: "", slotTimes: "", afterTime: "", webhookUrl: "" } };
  async run(e10, d15) {
    let c21 = e10.inputs?.dates.split(","), t11 = e10.inputs?.slotTimes.split(","), f13 = e10.inputs?.afterTime || "00:00";
    for (let m18 of c21) {
      let r9 = `https://onlinebusiness.icbc.com/qmaticwebbooking/rest/schedule/branches/fa5672274270f9fe51b9f3daf8eb6f7a4284306bbbb08a7685c765f2e872393e/dates/${m18}/times;servicePublicId=ae16803089ddd4dad7a74a9f51f36489479f1277b9a0c2462cb4eb946eb1ff14;customSlotLength=35`, a22 = await (await fetch(r9)).json(), n11 = a22.filter((s18) => t11 ? t11.includes(s18.time) : s18.time > f13);
      if (a22.length > 0) return { message: `${n11[0].date}  ${n11.map((b7) => b7.time).join(", ")}` };
    }
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-PPFTQ2GA.js
var i11 = class {
  static {
    __name(this, "i");
  }
  static {
    j(this, "ChromeDeviceRegistrationService");
  }
  deviceId = null;
  async getDeviceId() {
    return this.deviceId ? this.deviceId : (this.deviceId = await this.generateDeviceId(), this.deviceId);
  }
  async generateDeviceId() {
    let [e10, r9, s18] = await Promise.all([chrome.system.cpu.getInfo(), chrome.system.memory.getInfo(), chrome.system.display.getInfo()]), a22 = navigator.userAgent.includes("Edg/") ? "Edge" : navigator.userAgent.includes("Chrome/") ? "Chrome" : "Unknown", o21 = navigator.userAgentData?.platform || navigator.userAgent.match(/\(([^)]+)\)/)?.[1]?.split(";")[0] || "Unknown", c21 = e10.model || e10.modelName || e10.archName || "unknown", m18 = String(r9.capacity).slice(0, 5), t11 = s18.find((g10) => g10.isPrimary) || s18[0], d15 = `${t11.bounds.width}x${t11.bounds.height}`;
    return [o21, a22, c21, e10.numOfProcessors, m18, d15].join("|");
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-HAET6G6D.js
var t7 = class {
  static {
    __name(this, "t");
  }
  static {
    j(this, "BackgroundExternalListener");
  }
  chromeTabHelper = c2(r);
  constructor() {
    this.onMessageExternal(), this.onConnectExternal();
  }
  onMessageExternal() {
    chrome.runtime.onMessageExternal.addListener((n11, a22, s18) => (this.chromeTabHelper.handleMessage(n11, a22, s18, "background"), true));
  }
  onConnectExternal() {
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-A62SZZW3.js
var c11 = class {
  static {
    __name(this, "c");
  }
  static {
    j(this, "FetchHelper");
  }
  constructor() {
  }
  async convertToBase64(s18) {
    if (s18 instanceof ArrayBuffer) {
      let t11 = new Uint8Array(s18), e10 = "";
      for (let r9 = 0; r9 < t11.byteLength; r9++) e10 += String.fromCharCode(t11[r9]);
      return btoa(e10);
    } else return new Promise((t11, e10) => {
      let r9 = new FileReader();
      r9.onload = () => t11(r9.result.split(",")[1]), r9.onerror = e10, r9.readAsDataURL(s18);
    });
  }
  async fetch(s18, t11 = {}) {
    if (t11 && t11.headers) {
      for (let [e10, r9] of Object.entries(t11.headers)) if (r9 && e10.toLowerCase() === "cookie") {
        let a22 = r9.split("=");
        chrome.cookies.set({ url: s18, name: a22[0], value: a22[1] });
      }
    }
    try {
      let e10 = await fetch(s18, t11), r9 = e10.headers.get("Content-Type") || e10.headers.get("content-type"), a22 = { "application/json": "json", "text/html": "text", "application/octet-stream": "arraybuffer", "multipart/form-data": "blob" };
      !t11.responseType && r9 && (t11.responseType = Object.entries(a22).find(([o21]) => r9.startsWith(o21))?.[1] || "text");
      let n11;
      if (t11.responseType === "arraybuffer" || t11.responseType === "blob") {
        let o21 = await e10[t11.responseType || "arrayBuffer"]();
        n11 = await this.convertToBase64(o21);
      } else n11 = await e10[t11.responseType || "text"]();
      return { ok: e10.ok, redirected: e10.redirected, status: e10.status, statusText: e10.statusText, type: e10.type, url: e10.url, headers: Object.fromEntries(e10.headers.entries()), body: n11 };
    } catch (e10) {
      throw e10;
    }
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-FMKVIMW7.js
var o11 = ["https://img1.shaadi.com", "https://t-imgs.matrimonycdn.com", "https://imagecdn.jeevansathi.com", "https://www.onlinejyotish.com", "https://i.redd.it", "https://v.redd.it", "https://thumbs.gfycat.com", "https://gfycat.com", "https://www.redditmedia.com", "https://i.imgur.com", "https://imgur.com", "https://www.jiomart.com", "https://profile.telugumatrimony.com", "https://www.flipkart.com", "http://192.168.100.1/", "http://192.168.0.15:8080/", "http://192.168.0.2:8080"], h7 = ["https://img1.shaadi.com", "https://t-imgs.matrimonycdn.com", "https://imagecdn.jeevansathi.com"], m13 = ["https://ascloud.astrosage.com", "https://www.fido.ca"], R4 = ["https://ascloud.astrosage.com"], v6 = ["https://vision.googleapis.com"];
var p10 = class {
  static {
    __name(this, "p");
  }
  static {
    j(this, "BackgroundListener");
  }
  chromeTabHelper = c2(r);
  offscreenDocumentHelper = l9("OffscreenDocumentHelper");
  constructor() {
    this.onMessage(), this.onConnect(), this.onInstalled(), this.onAlarm(), this.onClicked(), this.onCommand(), this.onBeforeSendHeaders(), this.declarativeNetRequest(), this.onHeadersReceived();
  }
  onMessage() {
    chrome.runtime.onMessage.addListener((e10, t11, r9) => (this.chromeTabHelper.handleMessage(e10, t11, r9, "background"), true));
  }
  onConnect() {
  }
  onCommand() {
  }
  onStartup() {
  }
  async onInstalled() {
    chrome.runtime.onInstalled.addListener(() => {
    });
  }
  onAlarm() {
  }
  onClicked() {
    let e10 = 0;
    chrome.action.onClicked.addListener(async () => {
      if (e10) try {
        await chrome.windows.update(e10, { focused: true });
        return;
      } catch {
        e10 = 0;
      }
      let t11 = await this.offscreenDocumentHelper.getViewportSize();
      e10 = (await chrome.windows.create({ url: "https://mahindar5.github.io/ng-ion-app/dashboard", width: 800, height: 710, top: t11.top, left: t11.left, type: "popup", focused: true })).id || 0;
    });
  }
  declarativeNetRequest() {
    let e10 = o11.map((t11) => `*://*.${t11}/*`).join("|");
    chrome.declarativeNetRequest.updateDynamicRules({ addRules: [{ id: 1, priority: 1, action: { type: chrome.declarativeNetRequest.RuleActionType.MODIFY_HEADERS, requestHeaders: [{ header: "Origin", operation: chrome.declarativeNetRequest.HeaderOperation.SET, value: "https://ais.usvisa-info.com" }] }, condition: { urlFilter: "https://ais.usvisa-info.com/en-ca/niv/users/sign_in", resourceTypes: [chrome.declarativeNetRequest.ResourceType.XMLHTTPREQUEST, chrome.declarativeNetRequest.ResourceType.MAIN_FRAME] } }, { id: 2, priority: 1, action: { type: chrome.declarativeNetRequest.RuleActionType.MODIFY_HEADERS, requestHeaders: [{ header: "Origin", operation: chrome.declarativeNetRequest.HeaderOperation.SET, value: "https://my.wealthsimple.com" }] }, condition: { urlFilter: "https://api.production.wealthsimple.com/v1/oauth/v2/token*", resourceTypes: [chrome.declarativeNetRequest.ResourceType.XMLHTTPREQUEST, chrome.declarativeNetRequest.ResourceType.MAIN_FRAME] } }, { id: 3, priority: 1, action: { type: chrome.declarativeNetRequest.RuleActionType.REDIRECT, redirect: { url: "https://my.shaadi.com/profile/discovery" } }, condition: { urlFilter: "*://my.shaadi.com/profile/daily-recommendations*", resourceTypes: [chrome.declarativeNetRequest.ResourceType.MAIN_FRAME] } }, { id: 4, priority: 1, action: { type: chrome.declarativeNetRequest.RuleActionType.MODIFY_HEADERS, requestHeaders: [{ header: "Origin", operation: chrome.declarativeNetRequest.HeaderOperation.SET, value: "https://ascloud.astrosage.com" }, { header: "Referer", operation: chrome.declarativeNetRequest.HeaderOperation.SET, value: "https://ascloud.astrosage.com" }] }, condition: { urlFilter: "https://ascloud.astrosage.com*", resourceTypes: [chrome.declarativeNetRequest.ResourceType.XMLHTTPREQUEST, chrome.declarativeNetRequest.ResourceType.MAIN_FRAME] } }, { id: 5, priority: 1, action: { type: chrome.declarativeNetRequest.RuleActionType.MODIFY_HEADERS, responseHeaders: [{ header: "Access-Control-Allow-Origin", operation: chrome.declarativeNetRequest.HeaderOperation.SET, value: "*" }, { header: "Access-Control-Allow-Methods", operation: chrome.declarativeNetRequest.HeaderOperation.SET, value: "*" }, { header: "Access-Control-Allow-Headers", operation: chrome.declarativeNetRequest.HeaderOperation.SET, value: "*" }] }, condition: { urlFilter: e10, resourceTypes: [chrome.declarativeNetRequest.ResourceType.XMLHTTPREQUEST, chrome.declarativeNetRequest.ResourceType.MAIN_FRAME] } }, { id: 6, priority: 1, action: { type: chrome.declarativeNetRequest.RuleActionType.BLOCK }, condition: { urlFilter: "*://www.jeevansathi.com/api/v1/profile/trackProfileView*", resourceTypes: [chrome.declarativeNetRequest.ResourceType.XMLHTTPREQUEST, chrome.declarativeNetRequest.ResourceType.MAIN_FRAME] } }, { id: 7, priority: 1, action: { type: chrome.declarativeNetRequest.RuleActionType.BLOCK }, condition: { urlFilter: "*://*.shaadi.com/api/track*", resourceTypes: [chrome.declarativeNetRequest.ResourceType.XMLHTTPREQUEST, chrome.declarativeNetRequest.ResourceType.MAIN_FRAME] } }], removeRuleIds: [1, 2, 3, 4, 5, 6, 7] });
  }
  updateHeaders(e10, t11, r9, s18, a22) {
    if (e10?.some((i18) => t11?.includes(i18) && s18 && a22)) {
      let i18 = r9?.find((l14) => l14.name.toLowerCase() === s18.toLowerCase());
      i18 ? i18.value = a22 : r9.push({ name: s18, value: a22 });
    }
  }
  onBeforeRequest() {
  }
  onBeforeSendHeaders() {
    chrome.webRequest.onBeforeSendHeaders.addListener((e10) => {
      if (e10?.url?.includes("https://my.shaadi.com/profile/daily-recommendations") && (e10.url = "https://my.shaadi.com/profile/discovery"), e10?.url?.includes("https://www.fido.ca") && (e10.url = "https://www.fido.ca"), this.updateHeaders(R4, e10?.url, e10?.requestHeaders || [], "Referer", e10?.url), this.updateHeaders(v6, e10?.url, e10?.requestHeaders || [], "Referer", "https://brandfolder.com/"), this.updateHeaders(m13, e10?.url, e10?.requestHeaders || [], "Origin", e10?.url), e10.method == "POST" && e10.url.includes("https://ais.usvisa-info.com/en-ca/niv/users/sign_in") && (e10.requestHeaders = e10.requestHeaders || [], e10.requestHeaders.push({ name: "Origin", value: "https://ais.usvisa-info.com" }), e10.requestHeaders.push({ name: "Sec-Fetch-Site", value: "same-origin" })), o11.some((t11) => e10.url.includes(t11))) {
        let t11 = e10.requestHeaders?.find((r9) => r9.name.toLowerCase() === "Accept-Language".toLowerCase());
        if (t11 && t11?.value?.includes("custom-cookie-headers")) {
          let [r9, s18, a22] = t11?.value?.split(";");
          this.updateHeaders(o11, e10?.url, e10?.requestHeaders || [], s18, a22);
        }
      }
      return { requestHeaders: e10.requestHeaders };
    }, { urls: ["<all_urls>"] }, ["requestHeaders", "extraHeaders"]);
  }
  onHeadersReceived() {
    chrome.webRequest.onHeadersReceived.addListener((e10) => (this.updateHeaders(o11, e10?.url, e10?.responseHeaders || [], "Access-Control-Allow-Origin", "*"), this.updateHeaders(o11, e10?.url, e10?.responseHeaders || [], "Access-Control-Allow-Methods", "*"), this.updateHeaders(o11, e10?.url, e10?.responseHeaders || [], "Access-Control-Allow-Headers", "*"), this.updateHeaders(h7, e10?.url, e10?.responseHeaders || [], "cache-control", "public, max-age=31556952000"), { responseHeaders: e10.responseHeaders }), { urls: ["<all_urls>"] }, ["responseHeaders", "extraHeaders"]);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-7QSC42US.js
var e3 = `query FetchActivityFeedItems($first: Int, $cursor: Cursor, $condition: ActivityCondition, $orderBy: [ActivitiesOrderBy!] = OCCURRED_AT_DESC) {
				activityFeedItems(
					first: $first
					after: $cursor
					condition: $condition
					orderBy: $orderBy
				) {
					edges {
						node {
							accountId
							aftOriginatorName
							aftTransactionCategory
							aftTransactionType
							amount
							amountSign
							assetQuantity
							assetSymbol
							canonicalId
							currency
							eTransferEmail
							eTransferName
							externalCanonicalId
							identityId
							institutionName
							occurredAt
							p2pHandle
							p2pMessage
							spendMerchant
							securityId
							billPayCompanyName
							billPayPayeeNickname
							redactedExternalAccountNumber
							opposingAccountId
							status
							subType
							type
							strikePrice
							contractType
							expiryDate
							chequeNumber
							provisionalCreditAmount
							primaryBlocker
							interestRate
							frequency
							counterAssetSymbol
							rewardProgram
							counterPartyCurrency
							counterPartyCurrencyAmount
							counterPartyName
							fxRate
							fees
							reference
							transferType
							__typename
						}
						__typename
					}
					pageInfo {
						hasNextPage
						endCursor
						__typename
					}
					__typename
				}
			}`, t8 = `query FetchWatchlist($identityId: ID!, $first: Int, $after: String, $sort: WatchedSecuritySort) {
                identity(id: $identityId) {
                  watchedSecurities(first: $first, after: $after, sort: $sort) {
                    totalCount
                    edges {
                      node {
                        id
                        active
                        activeDate
                        allowedOrderSubtypes
                        buyable
                        sellable
                        currency
                        depositEligible
                        inactiveDate
                        historicalQuotes(timeRange: "1d") {
                          adjustedPrice
                          currency
                          date
                          securityId
                          time
                          __typename
                        }
                        quote {
                          amount
                          currency
                          last
                          open
                          previousClose
                          securityId
                          __typename
                        }
                        securityType
                        status
                        stock {
                          description
                          name
                          primaryMic
                          symbol
                          ipoState
                          primaryExchange
                          usPtp
                          __typename
                        }
                        wsTradeEligible
                        wsTradeIneligibilityReason
                        optionsEligible
                        __typename
                      }
                      __typename
                    }
                    __typename
                  }
                  __typename
                }
              }`;

// node_modules/@mahindar5/common-lib/dist/chunk-5N5NP6WF.js
function u12(r9, t11 = 2) {
  let n11 = parseFloat(r9?.toFixed(t11));
  return isNaN(n11) || !isFinite(n11) ? null : n11;
}
__name(u12, "u");
j(u12, "formatNumber");
function o12(r9, t11) {
  return r9.toString().padStart(t11, "0");
}
__name(o12, "o");
j(o12, "padNumber");

// node_modules/@mahindar5/common-lib/dist/chunk-4RF7ODUB.js
var d8 = class {
  static {
    __name(this, "d");
  }
  static {
    j(this, "WealthSimpleService");
  }
  baseUrl = "https://trade-service.wealthsimple.com";
  tokenUrl = "https://api.production.wealthsimple.com/v1/oauth/v2/token";
  yahooApiV7 = "https://query2.finance.yahoo.com/v7";
  yahooApiV11 = "https://query2.finance.yahoo.com/v11";
  graphqlUrl = "https://my.wealthsimple.com/graphql";
  tokenKey = "WealthSimpleTokenKey";
  refreshTokenKey = `${this.tokenKey}Refresh`;
  crumbKey = "YahooCrumbKey";
  shortExpiry = 55 * 60 * 1e3;
  clientId = "4da53ac2b03225bed1550eba8e4611e086c7b905a3855e6ed12ea08c246758fa";
  async sendRequest(e10, r9, t11 = null, o21 = {}) {
    let c21 = { "Content-Type": o21.responseType === "text" ? "text/plain" : "application/json", "my-org-extension": "true", ...o21.headers }, i18 = await fetch(r9, { method: e10, headers: c21, body: t11 ? JSON.stringify(t11) : null });
    if (i18.status === 401) throw r9.includes(this.yahooApiV7) ? n2.removeItem(this.crumbKey) : n2.removeItem(this.tokenKey), new Error("Unauthorized");
    if (!i18.ok) throw new Error(`HTTP error ${i18.status}`);
    return o21.responseType === "text" ? i18.text() : i18.json();
  }
  async getCachedToken() {
    return await n2.getItem(this.tokenKey) || await this.authenticate();
  }
  async authenticate(e10) {
    let r9 = await n2.getItem(this.refreshTokenKey), t11 = !!r9 && !e10, o21;
    if (t11) o21 = { grant_type: "refresh_token", refresh_token: r9, client_id: this.clientId };
    else {
      if (!e10 || !e10.email || !e10.password) throw new Error("Credentials are required for password authentication");
      o21 = { grant_type: "password", username: e10.email, password: e10.password, skip_provision: true, otp_claim: null, scope: "invest.read invest.write trade.read trade.write tax.read tax.write", client_id: this.clientId };
    }
    let c21 = { "Content-Type": "application/json" };
    !t11 && e10 && e10.otp && (c21["x-wealthsimple-otp"] = `${e10.otp};remember=true`);
    let i18 = await this.sendRequest("POST", this.tokenUrl, o21, { headers: c21 });
    if (i18.error) throw new Error(i18.error);
    return await n2.setItem(this.tokenKey, i18.access_token, this.shortExpiry), await n2.setItem(this.refreshTokenKey, i18.refresh_token), i18.access_token;
  }
  clearTokens() {
    n2.removeItem(this.tokenKey), n2.removeItem(this.refreshTokenKey);
  }
  async fetchGraphql(e10, r9) {
    let t11 = await this.getCachedToken();
    return this.sendRequest("POST", this.graphqlUrl, { query: e10, variables: r9 }, { headers: { Authorization: `Bearer ${t11}` } });
  }
  async fetchYahoo(e10, r9, t11 = false) {
    let o21 = `${e10}?${new URLSearchParams(r9).toString()}`;
    return this.sendRequest("GET", o21, null, { responseType: t11 ? "text" : "json" });
  }
  async loginUser(e10) {
    return this.authenticate(e10);
  }
  async checkLogin() {
    let e10 = await n2.getItem(this.tokenKey), r9 = await n2.getItem(this.refreshTokenKey);
    return !!(e10 || r9);
  }
  async logout() {
    this.clearTokens();
  }
  async initialize() {
    let e10 = await this.checkLogin();
    if (!e10) return { loggedIn: e10, accounts: [], selectedAccount: null };
    let t11 = (await this.getAccountList()).results.sort((i18, h12) => h12.net_deposits.amount - i18.net_deposits.amount), o21 = localStorage.getItem("selectedAccount"), c21 = o21 ? t11.find((i18) => i18.id === JSON.parse(o21).id) : t11.find((i18) => i18.account_type === "ca_non_registered");
    return { loggedIn: e10, accounts: t11, selectedAccount: c21 || t11[0] };
  }
  storeSelectedAccount(e10) {
    localStorage.setItem("selectedAccount", JSON.stringify(e10));
  }
  async getAccountList() {
    let e10 = await this.getCachedToken();
    return this.sendRequest("GET", `${this.baseUrl}/account/list`, null, { headers: { Authorization: `Bearer ${e10}` } });
  }
  async getPositions() {
    let e10 = await this.getCachedToken();
    return this.sendRequest("GET", `${this.baseUrl}/account/positions`, null, { headers: { Authorization: `Bearer ${e10}` } });
  }
  async deleteOrder(e10) {
    let r9 = await this.getCachedToken();
    return this.sendRequest("DELETE", `${this.baseUrl}/orders/${e10}`, null, { headers: { Authorization: `Bearer ${r9}` } });
  }
  async createQuote(e10, r9, t11, o21) {
    if (!e10.position.id || e10.quantity < 1 || e10.price <= 0) throw new Error("Invalid inputs");
    let c21 = await this.getCachedToken(), i18 = { account_id: t11, order_type: o21, order_sub_type: "limit", security_id: e10.position.id, quantity: Number(e10.quantity), limit_price: Number(e10.price), ...r9 && { time_in_force: "until_cancel" } };
    return this.sendRequest("POST", `${this.baseUrl}/orders`, i18, { headers: { Authorization: `Bearer ${c21}` } });
  }
  async getYahooQuotes(e10) {
    let r9 = await this.getCrumb();
    return this.fetchYahoo(`${this.yahooApiV7}/finance/quote`, { symbols: e10.join(","), crumb: r9 });
  }
  async getYahooQuoteDetails(e10) {
    return this.fetchYahoo(`${this.yahooApiV11}/finance/quoteSummary/${e10}`, { modules: "summaryProfile,financialData,defaultKeyStatistics" });
  }
  async getWatchlist() {
    let r9 = (await this.fetchGraphql(t8, { identityId: "identity-ev8V2eR3e4CuR33YGKfZQDuByxZ" })).data.identity.watchedSecurities.edges.map((t11) => t11.node);
    return { crypto_securities: [], securities: r9 };
  }
  async getScheduledActivities(e10) {
    let r9 = (/* @__PURE__ */ new Date()).toISOString(), t11 = { orderBy: ["OCCURRED_AT_ASC"], first: 50, condition: { accountIds: e10, types: ["DIY_BUY"], unifiedStatuses: ["PENDING"], startDate: r9 } };
    return (await this.fetchGraphql(e3, t11)).data.activityFeedItems.edges.map((c21) => c21.node);
  }
  async getActivities(e10, r9, t11) {
    return [];
  }
  async fetchPortfolio(e10) {
    let [r9, t11, o21] = await Promise.all([this.getPositions(), this.getActivities(50, [e10]), this.getWatchlist()]), c21 = r9.results.filter((n11) => n11.account_id === e10), i18 = [...o21.securities], h12 = [...c21, ...i18.filter((n11) => !c21.some((w4) => w4.stock.symbol === n11.stock.symbol))], y12 = f8(t11.filter((n11) => n11.object === "order" && ["posted", "submitted"].includes(n11.status)), ["symbol", "status", "order_type"]), s18 = h12.map((n11) => this.buildPosition(n11, y12[n11.stock.symbol] || {}));
    (await this.getYahooQuotes(s18.map((n11) => n11.yahooStockSymbol))).quoteResponse.result.forEach((n11) => (n11.regularMarketChangePercent = u12(n11.regularMarketChangePercent), n11.dayReturnOnAvgPercent = u12(n11.dayReturnOnAvgPercent), n11.yesterdaysReturnPercent = u12(n11.yesterdaysReturnPercent), n11.fiftyDayAverageChangePercent = u12(n11.fiftyDayAverageChangePercent), n11.twoHundredDayAverageChangePercent = u12(n11.twoHundredDayAverageChangePercent), n11.regularMarketChange = u12(n11.regularMarketChange), Object.assign(p7(s18, ["yahooStockSymbol"]).get(n11.symbol)?.[0] || {}, n11)));
    let p15 = this.calculateSummary(s18);
    return s18.forEach((n11) => n11.holdingPerct = u12(Number(n11.totalPurchasedCurrent) / p15.total * 100)), { positions: s18, summary: p15 };
  }
  buildPosition(e10, r9) {
    let t11 = { id: e10.id, stockSymbol: e10.stock.symbol, quantity: e10.quantity, currentPriceWS: u12(e10.quote?.last * 1), averagePrice: u12(e10.book_value?.amount / e10.quantity), totalPurchased: u12(e10.book_value?.amount), totalPurchasedCurrentWS: u12(e10.quote?.last * e10.quantity), totalDifferenceWS: u12(e10.quote?.last * e10.quantity - e10.book_value?.amount), differenceWS: u12(e10.quote?.last - e10.book_value?.amount / e10.quantity), stockName: e10.stock.name, stockPrimaryExchange: e10.stock.primary_exchange || e10.stock.primaryExchange, currency: e10.quote?.currency, previousClose: e10.quote?.previous_close || e10.quote?.previousClose };
    return t11.yahooStockSymbol = `${t11.stockSymbol.replace(".", "-")}${t11.stockPrimaryExchange?.includes("TSX-V") ? ".V" : t11.stockPrimaryExchange?.includes("TSX") ? ".TO" : ""}`, t11.yahooStockSymbol === "BTC" && (t11.yahooStockSymbol = "BTC-USD"), r9 && this.addOrderDetails(t11, r9), t11;
  }
  calculateSummary(e10) {
    let r9 = { gain: 0, loss: 0, gainWS: 0, lossWS: 0, totalPurchased: 0, total: 0, totalWS: 0, todaysReturnAllShares: 0, todaysReturnAllSharesWS: 0 };
    return e10.forEach((t11) => {
      t11.hasOrders && this.calculateOrderDependentFields(t11), this.calculateCommonFields(t11), t11.totalPurchased > 0 && (r9.totalPurchased += t11.totalPurchased, r9.total += t11.totalPurchasedCurrent, r9.totalWS += t11.totalPurchasedCurrentWS, r9.gain += t11.totalDifference > 0 ? t11.totalDifference : 0, r9.loss += t11.totalDifference < 0 ? t11.totalDifference : 0, r9.gainWS += t11.totalDifferenceWS > 0 ? t11.totalDifferenceWS : 0, r9.lossWS += t11.totalDifferenceWS < 0 ? t11.totalDifferenceWS : 0, r9.todaysReturnAllShares += t11.todaysReturnAllShares, r9.todaysReturnAllSharesWS += (t11.currentPriceWS - t11.previousClose) * t11.quantity);
    }), r9;
  }
  addOrderDetails(e10, r9) {
    e10.pending = r9.submitted?.buy_quantity || [];
    let t11 = e10.pending.map((s18) => s18.limit_price);
    e10.lastPendingPurchasePrice = u12(t11.at(0)), e10.minPendingPurchasePrice = u12(t11.sort((s18, u20) => s18 - u20).at(0));
    let o21 = r9.posted?.buy_quantity?.map((s18) => s18.market_value / s18.quantity) || [];
    e10.lastPurchasePrice = u12(o21.at(0));
    let c21 = o21.sort((s18, u20) => s18 - u20);
    e10.min = u12(c21.at(0)), e10.max = u12(c21.at(-1)), e10.pendingSell = r9.submitted?.sell_quantity || [];
    let i18 = e10.pendingSell.map((s18) => s18.limit_price);
    e10.lastPendingPurchasePriceSell = u12(i18.at(0)), e10.minPendingPurchasePriceSell = u12(i18.sort((s18, u20) => s18 - u20).at(0)), e10.maxPendingPurchasePriceSell = u12(i18.sort((s18, u20) => s18 - u20).at(-1));
    let h12 = r9.posted?.sell_quantity?.map((s18) => s18.market_value / s18.quantity) || [];
    e10.lastPurchasePriceSell = u12(h12.at(0));
    let y12 = h12.sort((s18, u20) => s18 - u20);
    e10.minSell = u12(y12.at(0)), e10.maxSell = u12(y12.at(-1)), e10.hasOrders = true;
  }
  calculateCommonFields(e10) {
    e10.totalPurchasedCurrent = u12(e10.regularMarketPrice * e10.quantity), e10.totalDifference = u12(e10.totalPurchasedCurrent - e10.totalPurchased), e10.difference = u12(e10.regularMarketPrice - e10.averagePrice), e10.dayLowDiff = u12(e10.regularMarketPrice - e10.regularMarketDayLow), e10.dayLowDiffPerct = u12(e10.dayLowDiff / e10.regularMarketDayLow * 100), e10.dayHighDiff = u12(e10.regularMarketPrice - e10.regularMarketDayHigh), e10.dayHighDiffPerct = u12(e10.dayHighDiff / e10.regularMarketDayHigh * 100), e10.dayRangePos = u12((e10.regularMarketPrice - e10.regularMarketDayLow) / (e10.regularMarketDayHigh - e10.regularMarketDayLow) * 100), e10.fiftyTwoWeekRangePos = u12((e10.regularMarketPrice - e10.fiftyTwoWeekLow) / (e10.fiftyTwoWeekHigh - e10.fiftyTwoWeekLow) * 100), e10.todaysReturnAllShares = u12(e10.regularMarketChange * e10.quantity), e10.dayReturnOnAvgPercent = u12(e10.regularMarketChange / e10.averagePrice * 100), e10.yesterdaysReturnPercent = u12((e10.regularMarketPreviousClose / e10.averagePrice - 1) * 100), e10.returnPercent = u12((e10.totalPurchasedCurrent / e10.totalPurchased - 1) * 100);
    let r9 = e10.totalPurchased * (e10.returnPercent / -15 - 1) / e10.regularMarketPrice;
    e10.return15 = r9 > 0 ? Math.ceil(r9) : Math.floor(r9), e10.fiftyDayAverageChangePercent *= 100, e10.twoHundredDayAverageChangePercent *= 100, e10.fiftyTwoWeekHighChangePercent *= 100, e10.fiftyTwoWeekLowChangePercent *= 100;
  }
  calculateOrderDependentFields(e10) {
    e10.currMinDiff = u12(e10.regularMarketPrice - e10.min), e10.currMinDiffPerct = u12(e10.currMinDiff / e10.min * 100), e10.minMaxRange = `${e10.min} - ${e10.max}`, e10.currMaxDiff = u12(e10.regularMarketPrice - e10.max), e10.currMaxDiffPerct = u12(e10.currMaxDiff / e10.max * 100), e10.maxAvgPerct = u12((e10.max - e10.averagePrice) / e10.max * 100), e10.avgMinPerct = u12((e10.averagePrice - e10.min) / e10.min * 100), e10.minMaxPerct = u12((e10.min / e10.max - 1) * 100);
  }
  sortPositions(e10, r9, t11 = false) {
    if (!r9?.prop || r9.disabled) return e10;
    let o21 = r9.prop, c21 = t11 ? -1 : 1;
    return e10.sort((i18, h12) => {
      let [y12, s18] = [i18[o21], h12[o21]];
      return y12 === void 0 ? 1 : s18 === void 0 ? -1 : !!i18.totalPurchased != !!h12.totalPurchased ? i18.totalPurchased ? -1 : 1 : (y12 > s18 ? 1 : y12 < s18 ? -1 : 0) * c21;
    });
  }
  setChecked(e10, r9) {
    e10.forEach((t11) => t11.selected = r9);
  }
  toggleSelectAll(e10) {
    this.setChecked(e10, e10.some((r9) => !r9.selected));
  }
  async getCrumb(e10 = false) {
    let r9 = await n2.getItem(this.crumbKey);
    if (r9 && !e10) return r9;
    let t11 = await this.fetchYahoo("https://query2.finance.yahoo.com/v1/test/getcrumb", {}, true);
    return await n2.setItem(this.crumbKey, t11), t11;
  }
};
l([v4({ keyName: "wealthsimple-positions", ttl: 5 * 60 * 1e3 })], d8.prototype, "getPositions", 1), l([v4({ keyName: "wealthsimple-getWatchlist", ttl: 5 * 60 * 1e3 })], d8.prototype, "getWatchlist", 1);

// node_modules/@mahindar5/common-lib/dist/chunk-H3RXW5PP.js
function a16(t11, e10, s18) {
  let i18 = e10.join(", "), n11 = s18.join(", ");
  return `Subreddit List: ${i18}.
		Do these subreddits belong in the custom feed "${t11}"?
		If not please categorize them accordingly.
		Here are some categories: ${n11}.`;
}
__name(a16, "a");
j(a16, "buildSubredditCategorizationMessage");
function d9(t11) {
  return t11.split(`
`).map((e10) => e10.split(",")).map(([e10, s18]) => ({ name: e10, suggestedname: s18 }));
}
__name(d9, "d");
j(d9, "parseRedditSubscriptionsCsv");
function u13(t11, e10, s18 = "name", i18 = "suggestedname") {
  return t11.map((n11) => {
    let g10 = e10.find((o21) => o21.name === n11[s18]);
    return g10?.suggestedname ? { ...n11, [i18]: g10.suggestedname } : n11;
  });
}
__name(u13, "u");
j(u13, "updateRedditSubscriptionsWithSuggestions");

// node_modules/@mahindar5/common-lib/dist/chunk-FAJT5A54.js
var u14 = class {
  static {
    __name(this, "u");
  }
  static {
    j(this, "BaseOAuthFlowService");
  }
  buildAuthUrl(e10, r9, i18) {
    let t11 = new URLSearchParams({ client_id: e10.clientId, redirect_uri: e10.calculateRedirectUri(), response_type: i18, scope: e10.scopes.join(" "), state: `${r9}:${e10.route}` });
    if (e10.duration && t11.append("duration", e10.duration), e10.extraParams) for (let [o21, a22] of Object.entries(e10.extraParams)) t11.append(o21, a22);
    return `${e10.authUrl}?${t11.toString()}`;
  }
  async requestToken(e10, r9, i18, t11, o21, a22) {
    if (r9.grant_type === "client_credentials" && !t11.clientSecret) throw new Error("Client secret is required for client credentials flow");
    let h12 = new URLSearchParams(r9), c21 = { "Content-Type": "application/x-www-form-urlencoded" };
    a22 || (c21.Authorization = `Basic ${btoa(`${t11.clientId}:${t11.clientSecret || ""}`)}`);
    let s18 = await fetch(e10, { method: "POST", headers: c21, body: h12.toString() });
    if (!s18.ok) throw new Error(`Token request failed: ${s18.status}`);
    let n11 = await s18.json();
    return o21 && (n11.refresh_token = n11.refresh_token || o21), await this.saveTokenToCache(i18, n11), n11;
  }
  async saveTokenToCache(e10, r9) {
    let i18 = t5() ? y8 : n2, t11 = { ...r9 };
    t11.timeExpires = Date.now() + r9.expires_in * 1e3 - 6e4, await i18.setItem(e10, t11);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-EKBEV6Y6.js
var o13 = class extends u14 {
  static {
    __name(this, "o");
  }
  static {
    j(this, "ClientCredentialsFlowService");
  }
  async authenticate(n11, e10) {
    if (!e10.tokenUrl) throw new Error("Missing token URL for client credentials flow");
    return this.requestToken(e10.tokenUrl, { grant_type: "client_credentials", scope: e10.scopes.join(" ") }, n11, e10);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-G4WWUWKU.js
var l10 = class extends u14 {
  static {
    __name(this, "l");
  }
  static {
    j(this, "ImplicitFlowService");
  }
  async authenticate(t11, i18) {
    let o21 = this.buildAuthUrl(i18, t11, "token");
    if (n5()) {
      let e10 = document.getElementById("silentAuthIframe");
      e10 || (e10 = document.createElement("iframe"), e10.id = "silentAuthIframe", e10.style.cssText = "position:absolute;width:0;height:0;border:0;", document.body.appendChild(e10)), e10.src = o21, await new Promise((d15) => setTimeout(d15, 3e3));
      let r9 = await n2.getItem(t11);
      if (r9?.access_token && Date.now() < r9.timeExpires) return r9;
    }
    return await c7(o21), null;
  }
  async handleCallback(t11, i18, o21) {
    t11.access_token && await this.saveTokenToCache(i18, t11);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-LBDQPIMF.js
var e4 = { clientId: "2cf47201933b48a498be147ab61a46ee", clientSecret: "", authUrl: "https://accounts.spotify.com/authorize", tokenUrl: "https://accounts.spotify.com/api/token", calculateRedirectUri: j(() => location.href.includes("spotify") ? location.href.replace("/spotify", "/token-callback").split("?")[0].split("#")[0] : "", "calculateRedirectUri"), route: "spotify", scopes: ["playlist-modify-public", "playlist-modify-private", "user-read-playback-position", "user-read-email", "user-library-read", "user-top-read", "ugc-image-upload", "user-follow-modify", "user-modify-playback-state", "user-read-recently-played", "user-read-currently-playing", "user-read-playback-state", "user-follow-read", "playlist-read-collaborative", "user-library-modify", "playlist-read-private", "user-read-private"] }, i12 = { reddit_cache_key: { clientId: "cOE9ZZmP0f5OMw", clientSecret: "", authUrl: "https://www.reddit.com/api/v1/authorize.compact", tokenUrl: "https://www.reddit.com/api/v1/access_token", scopes: ["identity", "edit", "flair", "history", "modconfig", "modflair", "modlog", "modposts", "modwiki", "mysubreddits", "privatemessages", "read", "report", "save", "submit", "subscribe", "vote", "wikiedit", "wikiread"], calculateRedirectUri: j(() => location.href.includes("reddit") ? location.href.replace("/reddit", "/token-callback").split("?")[0].split("#")[0] : "", "calculateRedirectUri"), route: "reddit", flowType: "authorization_code", local: { clientId: "Jw67D19qBRz8-g", clientSecret: "" } }, spotify_implicit_cache_key: { clientId: e4.clientId, authUrl: e4.authUrl, scopes: e4.scopes, calculateRedirectUri: e4.calculateRedirectUri, route: e4.route, flowType: "implicit" }, spotify_client_credentials_cache_key: { clientId: e4.clientId, clientSecret: e4.clientSecret, authUrl: "", tokenUrl: e4.tokenUrl, scopes: e4.scopes, calculateRedirectUri: e4.calculateRedirectUri, route: "", flowType: "client_credentials" }, spotify_authorization_code_cache_key: { clientId: e4.clientId, clientSecret: e4.clientSecret, authUrl: e4.authUrl, tokenUrl: e4.tokenUrl, scopes: e4.scopes, calculateRedirectUri: e4.calculateRedirectUri, route: e4.route, flowType: "authorization_code" }, spotify_authorization_code_pkce_cache_key: { clientId: e4.clientId, authUrl: e4.authUrl, tokenUrl: e4.tokenUrl, scopes: e4.scopes, calculateRedirectUri: e4.calculateRedirectUri, route: e4.route, flowType: "authorization_code_with_pkce" } };

// node_modules/@mahindar5/common-lib/dist/chunk-6V2PQCRW.js
var s11 = class extends u14 {
  static {
    __name(this, "s");
  }
  static {
    j(this, "AuthorizationCodeFlowService");
  }
  async authenticate(e10, t11) {
    let r9 = this.buildAuthUrl(t11, e10, "code");
    return await c7(r9), null;
  }
  async handleCallback(e10, t11, r9) {
    if (!e10.code || !r9.tokenUrl) throw new Error("Missing code or token URL");
    await this.requestToken(r9.tokenUrl, { grant_type: "authorization_code", code: e10.code, redirect_uri: r9.calculateRedirectUri() }, t11, r9);
  }
  async refreshToken(e10, t11, r9) {
    if (!r9.tokenUrl) throw new Error("Missing token URL");
    return this.requestToken(r9.tokenUrl, { grant_type: "refresh_token", refresh_token: e10 }, t11, r9, e10);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-WVNWOYJE.js
var l11 = class extends u14 {
  static {
    __name(this, "l");
  }
  static {
    j(this, "AuthorizationCodeWithPKCEFlowService");
  }
  codeVerifierKey = "oauth_pkce_code_verifier";
  generateCodeVerifier() {
    let e10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~", t11 = Math.floor(Math.random() * 86) + 43, r9 = "";
    for (let i18 = 0; i18 < t11; i18++) r9 += e10.charAt(Math.floor(Math.random() * e10.length));
    return r9;
  }
  async generateCodeChallenge(e10) {
    if (n5()) {
      let r9 = new TextEncoder().encode(e10), i18 = await crypto.subtle.digest("SHA-256", r9);
      return btoa(String.fromCharCode(...new Uint8Array(i18))).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    } else try {
      return (await import("crypto")).createHash("sha256").update(e10).digest().toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    } catch {
      throw new Error("PKCE requires Node.js crypto module in server environment");
    }
  }
  async authenticate(e10, t11) {
    let r9 = await this.buildAuthUrlAsync(t11, e10);
    return await c7(r9), null;
  }
  async buildAuthUrlAsync(e10, t11) {
    let r9 = this.generateCodeVerifier();
    await n2.setItem(`${t11}_${this.codeVerifierKey}`, r9, 5 * 60 * 1e3);
    let i18 = await this.generateCodeChallenge(r9), a22 = new URLSearchParams({ client_id: e10.clientId, redirect_uri: e10.calculateRedirectUri(), response_type: "code", scope: e10.scopes.join(" "), state: `${t11}:${e10.route}`, code_challenge: i18, code_challenge_method: "S256" });
    if (e10.duration && a22.append("duration", e10.duration), e10.extraParams) for (let [h12, u20] of Object.entries(e10.extraParams)) a22.append(h12, u20);
    return `${e10.authUrl}?${a22.toString()}`;
  }
  async handleCallback(e10, t11, r9) {
    if (!e10.code || !r9.tokenUrl) throw new Error("Missing code or token URL");
    let i18 = await n2.getItem(`${t11}_${this.codeVerifierKey}`);
    if (!i18) throw new Error("Code verifier not found");
    await n2.removeItem(`${t11}_${this.codeVerifierKey}`), await this.requestToken(r9.tokenUrl, { grant_type: "authorization_code", code: e10.code, redirect_uri: r9.calculateRedirectUri(), code_verifier: i18, client_id: r9.clientId }, t11, r9, void 0, true);
  }
  async refreshToken(e10, t11, r9) {
    if (!r9.tokenUrl) throw new Error("Missing token URL");
    return this.requestToken(r9.tokenUrl, { grant_type: "refresh_token", refresh_token: e10, client_id: r9.clientId }, t11, r9, e10, true);
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-XPLFLFDP.js
var F2 = class {
  static {
    __name(this, "F");
  }
  static {
    j(this, "OAuthService");
  }
  flowServices = { implicit: c2(l10), authorization_code: c2(s11), authorization_code_with_pkce: c2(l11), client_credentials: c2(o13) };
  localAuthServer = null;
  async authenticateForNode(t11) {
    let { exec: e10, createServer: r9, parse: o21 } = a15(), i18 = 8100, n11 = "/token-callback", l14 = `http://localhost:${i18}${n11}`, a22 = { ...this.getConfig(t11), redirectUri: l14 }, s18 = await this.fetchCachedItem(t11);
    if (s18?.access_token && Date.now() < s18.timeExpires) return s18;
    let c21 = this.flowServices[a22.flowType];
    if (s18?.refresh_token && typeof c21.refreshToken == "function" && ["authorization_code", "authorization_code_with_pkce"].includes(a22.flowType)) return c21.refreshToken(s18.refresh_token, t11, a22);
    let h12 = await this.buildAuthUrlForNode(c21, a22, t11), f13 = this.startLocalAuthServer({ createServer: r9, parseUrl: o21, port: i18, redirectPath: n11, providerKey: t11, config: a22, flow: c21 }), u20 = process.platform === "win32" ? `start "" "${h12}"` : process.platform === "darwin" ? `open "${h12}"` : `xdg-open "${h12}"`;
    return e10(u20), f13;
  }
  async getToken(t11) {
    if (t5()) return this.authenticateForNode(t11);
    let e10 = this.getConfig(t11), r9 = await this.fetchCachedItem(t11);
    if (r9?.access_token && Date.now() < r9.timeExpires) return r9;
    let o21 = this.flowServices[e10.flowType];
    return r9?.refresh_token && typeof o21.refreshToken == "function" && ["authorization_code", "authorization_code_with_pkce"].includes(e10.flowType) ? o21.refreshToken(r9.refresh_token, t11, e10) : o21.authenticate(t11, e10);
  }
  async fetchCachedItem(t11) {
    return await (t5() ? y8 : n2).getItem(t11);
  }
  async handleRedirectCallback() {
    let { result: t11, providerKey: e10, redirectPath: r9, config: o21, flow: i18 } = await this.parseOAuthResponse();
    (t11.access_token || t11.code) && i18.handleCallback && (await i18.handleCallback(t11, e10, o21), r9 && await c7(r9));
  }
  async parseOAuthResponse() {
    let { queryParams: t11, hashParams: e10 } = d6(), r9 = this.extractParametersFromUrl("", Object.fromEntries(t11.entries()), false);
    e10.forEach((a22, s18) => r9[s18] = a22);
    let [o21, i18] = r9.state?.split(":") ?? [];
    if (!o21) throw new Error("Invalid state parameter");
    let n11 = this.getConfig(o21), l14 = this.flowServices[n11.flowType];
    return { result: r9, providerKey: o21, redirectPath: i18, config: n11, flow: l14 };
  }
  getConfig(t11) {
    let e10 = i12[t11];
    if (!e10) throw new Error(`Unknown OAuth provider: ${t11}`);
    return (n5() ? window.location.hostname === "localhost" : false) && e10.local ? { ...e10, ...e10.local } : e10;
  }
  extractParametersFromUrl(t11, e10, r9 = true) {
    let o21 = {};
    if (Object.keys(e10 || {}).forEach((i18) => o21[i18] = String(e10[i18])), r9 && t11.includes("#")) {
      let i18 = t11.split("#")[1];
      if (i18) {
        let n11 = new URLSearchParams(i18);
        for (let [l14, a22] of n11.entries()) o21[l14] = a22;
      }
    }
    return o21;
  }
  async buildAuthUrlForNode(t11, e10, r9) {
    if (typeof t11.buildAuthUrlAsync == "function" && e10.flowType === "authorization_code_with_pkce") return t11.buildAuthUrlAsync(e10, r9);
    if (typeof t11.buildAuthUrl == "function" && ["authorization_code", "implicit"].includes(e10.flowType)) return t11.buildAuthUrl(e10, r9, e10.flowType === "implicit" ? "token" : "code");
    if (typeof t11.authenticate == "function" && e10.flowType === "client_credentials") {
      let o21 = await t11.authenticate(r9, e10);
      if (typeof o21 == "string") return o21;
      throw new Error("Could not determine auth URL");
    }
    throw new Error("OAuth flow service does not support URL generation");
  }
  async startLocalAuthServer({ createServer: t11, parseUrl: e10, port: r9, redirectPath: o21, providerKey: i18, config: n11, flow: l14 }) {
    return new Promise((a22, s18) => {
      if (this.localAuthServer) {
        console.log("Local auth server is already running, reusing existing instance");
        return;
      }
      this.localAuthServer = t11(async (c21, h12) => {
        if (c21.url.startsWith(o21)) try {
          let f13 = e10(c21.url, true), u20 = this.extractParametersFromUrl(c21.url, f13.query, c21.method === "GET");
          u20.state || (u20.state = `${i18}:${n11.route}`), (u20.access_token || u20.code) && l14.handleCallback && await l14.handleCallback(u20, i18, n11);
          let m18 = await this.fetchCachedItem(i18);
          if (!m18 || !m18.access_token) throw new Error("Token not found in cache");
          h12.writeHead(200, { "Content-Type": "text/html" }), h12.end("<html><body>Authentication successful. You can close this window</body></html>"), a22(m18);
        } catch (f13) {
          h12.writeHead(500, { "Content-Type": "text/html" }), h12.end("<html><body>Authentication failed.</body></html>"), s18(f13);
        } finally {
          setTimeout(() => {
            this.localAuthServer && (this.localAuthServer.close(), this.localAuthServer = null);
          }, 1e3);
        }
      }), this.localAuthServer.listen(r9);
    });
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-PA6OZQKP.js
var a17 = class {
  static {
    __name(this, "a");
  }
  static {
    j(this, "CustomLoadingHandler");
  }
  element = null;
  constructor(n11) {
    this.createLoadingElement(n11);
  }
  createLoadingElement(n11) {
    let s18 = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    this.element = document.createElement("div"), this.element.style.position = "fixed", this.element.style.top = "0", this.element.style.left = "0", this.element.style.width = "100%", this.element.style.height = "100%", this.element.style.backgroundColor = s18 ? "rgba(0, 0, 0, 0.2)" : "rgba(255, 255, 255, 0.8)", this.element.style.display = "flex", this.element.style.alignItems = "center", this.element.style.justifyContent = "center", this.element.style.zIndex = "9999";
    let e10 = document.createElement("div");
    e10.style.padding = "20px", e10.style.display = "flex", e10.style.flexDirection = "row", e10.style.alignItems = "center", e10.style.gap = "16px", e10.style.minWidth = "250px", e10.style.backgroundColor = s18 ? "#1e1e1e" : "#f0f0f0", e10.style.borderRadius = "8px";
    let t11 = document.createElement("div");
    t11.style.width = "32px", t11.style.height = "32px", t11.style.border = "4px solid rgba(0, 0, 0, 0.1)", t11.style.borderTopColor = "#3498db", t11.style.borderRadius = "50%", t11.style.animation = "spin 1s linear infinite";
    let i18 = document.createElement("style");
    i18.textContent = `
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    `, document.head.appendChild(i18);
    let r9 = document.createElement("div");
    r9.textContent = n11, r9.style.color = s18 ? "#c0c0c0" : "#404040", e10.appendChild(t11), e10.appendChild(r9), this.element.appendChild(e10);
  }
  async present() {
    this.element && document.body.appendChild(this.element);
  }
  async dismiss() {
    this.element && this.element.parentNode && (this.element.parentNode.removeChild(this.element), this.element = null);
  }
};
function u15(d15) {
  return function(n11, s18, e10) {
    let t11 = e10.value;
    return e10.value = async function(...i18) {
      let r9 = n11[u5.name]?.get(s18) || [], c21 = i18.filter((h12, y12) => r9?.includes(y12)).join(", "), p15 = `${d15.message} ${c21}`, l14 = new a17(p15);
      window.loading = l14, await l14.present();
      try {
        return await t11.call(this, ...i18);
      } finally {
        await l14.dismiss();
      }
    }, e10;
  };
}
__name(u15, "u");
j(u15, "LoadingDialogPromise");

// node_modules/@mahindar5/common-lib/dist/chunk-QQKSMP2F.js
var I2 = ((i18) => (i18.Create = "create", i18.Delete = "delete", i18.Add = "add", i18.Remove = "remove", i18.Get = "get", i18))(I2 || {}), o14 = class o15 {
  static {
    __name(this, "o");
  }
  static {
    j(this, "RedditService");
  }
  static USERNAME = "mahindar5";
  static MAX_LIMIT = 100;
  static API_BASE = "https://oauth.reddit.com";
  static CACHE_KEY = "reddit_cache_key";
  static SEEN_POSTS_KEY = "reddit_seen_posts";
  static MAX_SEEN_POSTS = 5e3;
  oauthService = c2(F2);
  async fetchWithCache(t11, a22, e10) {
    let s18 = await fetch(o15.API_BASE + t11, { headers: a22, credentials: "include" });
    if (s18.status === 401 || s18.status === 403) throw this.oauthService.getToken(o15.CACHE_KEY), new Error("401");
    return s18.json();
  }
  async getAllSaved(t11) {
    return this.fetchAllData(`/user/${o15.USERNAME}/saved`, (a22) => a22?.data?.children?.sort((e10, s18) => s18.created - e10.created), t11);
  }
  async fetchAllData(t11, a22, e10 = false) {
    let s18 = "", i18 = [];
    do {
      let d15 = await this.fetchData(t11, s18, e10);
      i18.push(...a22(d15)), s18 = d15?.data?.after || "";
    } while (s18);
    return i18;
  }
  async fetchData(t11, a22, e10 = false) {
    let s18 = `${t11}?limit=${o15.MAX_LIMIT}${a22 ? `&after=${a22}` : ""}`, i18 = await this.buildAuthHeaders();
    return this.fetchWithCache(s18, i18, e10);
  }
  async getMultiReddits(t11 = false) {
    return (await this.getAllMultireddits(t11)).map((e10) => ({ name: e10.name, numSubscribers: e10.num_subscribers, displayName: e10.display_name, subreddits: e10.subreddits.map((s18) => s18.name), visibility: e10.visibility }));
  }
  async getAllMultireddits(t11 = false) {
    let a22 = await this.buildAuthHeaders();
    return (await this.fetchWithCache("/api/multi/mine", a22, t11)).map((s18) => s18.data);
  }
  async manageMultiReddit(t11, a22, e10 = []) {
    let s18 = new URLSearchParams(), i18, d15 = "json";
    switch (t11) {
      case "create":
        s18.append("model", JSON.stringify({ display_name: a22, visibility: "private", subreddits: e10?.map((l14) => ({ name: l14 })) })), i18 = "POST";
        break;
      case "add":
      case "remove":
        s18.append("model", JSON.stringify({ subreddits: e10?.map((l14) => ({ name: l14 })) })), i18 = "PUT";
        break;
      case "delete":
        i18 = "DELETE", d15 = "text";
        break;
      case "get":
        i18 = "GET";
        break;
      default:
        throw new Error("Invalid action");
    }
    let c21 = await this.buildFormHeaders(), u20 = `${o15.API_BASE}/api/multi/user/${o15.USERNAME}/m/${a22}`, n11 = await fetch(u20, { method: i18, headers: c21, body: s18.toString() });
    return d15 === "json" ? n11.json() : n11.text();
  }
  async getAllSubscribedSubreddits(t11 = false) {
    return this.fetchAllData("/subreddits/mine/subscriber", this.extractData, t11);
  }
  async getSubscribedSubreddits(t11 = false) {
    return (await this.getAllSubscribedSubreddits(t11)).filter((e10) => e10.subreddit_type !== "user").map((e10) => ({ displayName: e10.display_name, notificationLevel: e10.notification_level, originalContentTagEnabled: e10.original_content_tag_enabled, over18: e10.over18, quarantine: e10.quarantine, subredditType: e10.subreddit_type, subscribers: e10.subscribers, hideAds: e10.hide_ads }));
  }
  async buildAuthHeaders() {
    return { Authorization: `Bearer ${(await this.oauthService.getToken(o15.CACHE_KEY)).access_token}`, "my-org-extension": "true" };
  }
  async buildFormHeaders() {
    let t11 = await this.buildAuthHeaders();
    return t11["Content-Type"] = "application/x-www-form-urlencoded", t11;
  }
  async postForm(t11, a22) {
    let e10 = await this.buildFormHeaders();
    return (await fetch(`${o15.API_BASE}${t11}`, { method: "POST", headers: e10, body: a22.toString() })).json();
  }
  async fetchPosts(t11, a22) {
    let e10 = new URLSearchParams();
    e10.append("after", a22 || ""), e10.append("limit", o15.MAX_LIMIT.toString()), e10.append("t", t11.top);
    let s18 = `/r/${t11.subRedditName}/top?${e10.toString()}`, i18 = o15.API_BASE, d15 = { headers: await this.buildAuthHeaders() };
    return (await fetch(i18 + s18, d15)).json();
  }
  async getPosts(t11, a22) {
    return this.fetchPosts(t11, a22);
  }
  async getAllPostsAnonymous(t11) {
    let a22 = "https://www.reddit.com", e10 = "", s18 = 0, i18 = [];
    for (; s18 < t11.noOfPosts; ) {
      let d15 = new URLSearchParams();
      d15.append("after", e10), d15.append("limit", "100"), d15.append("t", t11.top);
      let c21 = `/r/${t11.subRedditName}/top.json?${d15.toString()}`;
      t11.top === "hot" && (c21 = c21.replace("/top.json", "/hot.json"));
      let u20 = `${a22}${c21}`;
      try {
        let n11 = await fetch(u20);
        if (!n11.ok) break;
        let l14 = await n11.json(), g10 = (l14?.data?.children || []).filter((r9) => ["image", "rich:video", "link", "hosted:video"].includes(r9.data.post_hint));
        for (let r9 of g10) {
          if (s18 >= t11.noOfPosts) break;
          let p15 = r9.data.post_hint, _ = p15 === "image" ? r9.data.url : "", b7 = "";
          ["rich:video", "link"].includes(p15) ? b7 = r9.data.preview?.reddit_video_preview?.fallback_url || r9.data.url?.replace(".gifv", ".mp4") || "" : p15 === "hosted:video" && (b7 = r9.data?.media?.reddit_video?.fallback_url || r9.data.url?.replace(".gifv", ".mp4") || ""), i18.push({ videoUrl: b7, imageUrl: _, type: p15, id: r9.data.id, title: r9.data.title, numComments: r9.data.num_comments, numCrossposts: r9.data.num_crossposts, over_18: r9.data.over_18, score: r9.data.score, ups: r9.data.ups, downs: r9.data.downs, total_awards_received: r9.data.total_awards_received, category: t11.top, name: [t11.top, p15, r9.data.id, r9.data.ups, r9.data.score, r9.data.title].join("-"), url: r9.data.url }), s18++;
        }
        if (!l14?.data?.after) break;
        e10 = l14.data.after;
      } catch (n11) {
        console.error("Error fetching posts:", n11);
        break;
      }
    }
    return i18;
  }
  async savePost(t11) {
    return this.toggleSavePost(t11, true);
  }
  async unsavePost(t11) {
    return this.toggleSavePost(t11, false);
  }
  async toggleSavePost(t11, a22) {
    let e10 = new URLSearchParams();
    return e10.append("id", t11), this.postForm(`/api/${a22 ? "save" : "unsave"}`, e10);
  }
  extractData(t11) {
    return t11?.data?.children?.map((a22) => a22.data) || [];
  }
  async fetchSubredditPosts(t11, a22, e10 = "day") {
    let s18 = [], i18 = await this.getSeenPostIds(), d15 = [];
    try {
      let c21 = await this.fetchJson(`https://www.reddit.com/r/${t11}/top.json?limit=99&t=${e10}`), u20 = 0;
      for (let { data: n11 } of c21.data.children) {
        if (u20 >= a22) break;
        if (!i18.has(n11.id) && !(!n11.selftext && (n11.url.includes("redd.it") || n11.url.includes("reddit.com") || !n11.url))) try {
          let g10 = (await this.fetchJson(`https://www.reddit.com${n11.permalink}.json?depth=1&limit=10&sort=top`))[1]?.data?.children?.filter((r9) => r9.kind === "t1" && !r9.data.stickied).slice(0, 3).map((r9) => `${r9.data.author}: ${r9.data.body}`) || [];
          s18.push({ subreddit: t11, title: n11.title, body: n11.selftext || n11.url, numComments: n11.num_comments, upvotes: n11.ups, comments: g10 }), d15.push(n11.id), u20++;
        } catch (l14) {
          console.error(`Error fetching comments for ${n11.id}:`, l14);
        }
      }
      d15.length > 0 && await this.addSeenPostIds(d15);
    } catch (c21) {
      console.error(`Error fetching ${t11}:`, c21);
    }
    return s18;
  }
  async fetchJson(t11, a22 = 2) {
    let e10 = await fetch(t11, { headers: { "User-Agent": "reddit-tool", "my-org-extension": "true" } });
    if (e10.status === 429 && a22 > 0) {
      let s18 = +(e10.headers.get("x-ratelimit-reset") ?? "5") || 5;
      return await new Promise((i18) => setTimeout(i18, (s18 + 1) * 1e3)), this.fetchJson(t11, a22 - 1);
    }
    if (!e10.ok) throw new Error(`${e10.status}`);
    return e10.json();
  }
  async getSeenPostIds() {
    let t11 = await u8.getItem(o15.SEEN_POSTS_KEY);
    return t11 ? new Set(t11) : /* @__PURE__ */ new Set();
  }
  async addSeenPostIds(t11) {
    let a22 = await this.getSeenPostIds();
    t11.forEach((s18) => a22.add(s18));
    let e10 = a22.size > o15.MAX_SEEN_POSTS ? Array.from(a22).slice(-o15.MAX_SEEN_POSTS) : Array.from(a22);
    await u8.setItem(o15.SEEN_POSTS_KEY, e10);
  }
};
l([v2({ ttl: 30 * 60 * 1e3 }), m(0, t), m(2, y3)], o14.prototype, "fetchWithCache", 1), l([u15({ message: "Getting Saved Posts" })], o14.prototype, "getAllSaved", 1), l([u15({ message: "Getting MultiReddits" })], o14.prototype, "getMultiReddits", 1), l([u15({ message: "Getting Subscribed Subreddits" })], o14.prototype, "getSubscribedSubreddits", 1), l([u15({ message: "Getting Posts" })], o14.prototype, "getAllPostsAnonymous", 1);
var T4 = o14;

// node_modules/@mahindar5/common-lib/dist/chunk-363YMZJC.js
var I3 = "CACHESERVICE.SESSION_CACHE_ID", o16 = class extends n3 {
  static {
    __name(this, "o");
  }
  static {
    j(this, "IndexedDbSessionCacheService");
  }
  async getItem(t11) {
    let e10 = await super.getItem(t11), i18 = await this.getOrLoadSessionCacheId(), s18 = typeof e10 == "string";
    return s18 && (e10 = e10 ? JSON.parse(e10) : void 0), e10?.sessionCacheId !== i18 && (await this.removeItem(t11), e10 = void 0), s18 ? JSON.stringify(e10) : e10;
  }
  async setItem(t11, e10) {
    let i18 = await this.getOrLoadSessionCacheId(), s18 = typeof e10 == "string";
    s18 && (e10 = JSON.parse(e10)), i18 && (e10.sessionCacheId = i18), await super.setItem(t11, s18 ? JSON.stringify(e10) : e10);
  }
  async removeItem(t11) {
    await super.removeItem(t11);
  }
  async getAllKeys() {
    return super.getAllKeys();
  }
  getOrLoadSessionCacheId() {
    let t11 = sessionStorage.getItem(I3);
    return t11 || (t11 = Date.now().toString(), sessionStorage.setItem(I3, t11)), t11;
  }
}, S2 = c2(c3, [c2(o16)], "indexedDbSessionService");
function h8(a22) {
  return g3({ ...a22, cacheService: S2 });
}
__name(h8, "h");
j(h8, "IndexedDbSessionCacheLoader");

// node_modules/@mahindar5/common-lib/dist/chunk-M57NV3UM.js
var k2 = "https://api.spotify.com", x2 = "http://localhost:8087", $ = "spotify_authorization_code_pkce_cache_key", h9 = class {
  static {
    __name(this, "h");
  }
  static {
    j(this, "SpotifyApiService");
  }
  oauthService = c2(F2);
  async getToken() {
    return (await this.oauthService.getToken($)).access_token;
  }
  async fetchPagedItems(e10, n11, r9 = false) {
    if (!e10) return [];
    let s18 = [], o21 = e10;
    for (; o21; ) {
      let a22 = await this.sendApiRequest(o21, "GET", void 0, void 0, r9);
      a22.items && (s18 = s18.concat(a22.items)), o21 = a22.next;
    }
    return s18;
  }
  async sendApiRequest(e10, n11, r9, s18, o21) {
    let b7 = { Authorization: `Bearer ${await this.getToken()}`, "Content-Type": "application/json" }, w4 = s18 ? `?${new URLSearchParams(s18).toString()}` : "", t11 = await fetch(`${e10}${w4}`, { method: n11, headers: b7, body: r9 ? JSON.stringify(r9) : void 0 });
    if (!t11.ok) {
      let g10;
      try {
        g10 = await t11.json();
      } catch {
      }
      throw new Error(`Error: ${t11.status}, ResponseObject: ${JSON.stringify(g10)}`);
    }
    if (t11.status === 204) return {};
    let p15 = t11.headers.get("Content-Length") || t11.headers.get("content-length");
    if (p15 && parseInt(p15) === 0) return {};
    let i18 = t11.headers.get("Content-Type") || t11.headers.get("content-type") || "text/plain";
    return i18 && i18.includes("application/json") ? t11.json() : i18 && i18.includes("text/") ? t11.text() : {};
  }
  async fetchExternalData(e10) {
    let n11 = await fetch(`${x2}${e10}`, { method: "GET", headers: { "my-org-extension": "true" } });
    if (!n11.ok) throw new Error(`Error: ${n11.status}`);
    return n11.json();
  }
  async makeApiCall(e10, n11 = "GET", r9, s18, o21) {
    let a22 = e10.startsWith("http") ? e10 : `${k2}${e10}`;
    return this.sendApiRequest(a22, n11, r9, s18, o21);
  }
  getBaseUrl() {
    return k2;
  }
};
l([h8({ ttl: 1e3 * 60 * 60 * 24 * 1 }), m(0, t), m(4, y3)], h9.prototype, "sendApiRequest", 1);

// node_modules/@mahindar5/common-lib/dist/chunk-FYBDNECW.js
var w = "MoodGenreSampledData", d10 = class {
  static {
    __name(this, "d");
  }
  static {
    j(this, "SpotifyDataService");
  }
  spotifyApiService = c2(h9);
  async getPlayCountByArtist(e10, o21) {
    return this.spotifyApiService.fetchExternalData(`/artistInfo?artistid=${e10}`);
  }
  async getPlayCountByAlbum(e10, o21) {
    return this.spotifyApiService.fetchExternalData(`/albumPlayCount?albumid=${e10}`);
  }
  async fetchViewCount(e10, o21 = false, t11 = false) {
    let a22 = await Promise.all(e10.map(async (r9) => {
      try {
        let s18 = (await this.getPlayCountByAlbum(r9.albumId, t11))?.data?.discs?.flatMap((l14) => l14.tracks)?.find((l14) => l14.uri === r9.uri)?.playcount;
        return { [r9.trackId]: Number(s18) || 0 };
      } catch {
        return { [r9.trackId]: 0 };
      }
    }));
    return Object.assign({}, ...a22);
  }
  async exportAllTracksToCsvFile(e10) {
    let o21 = e10.map((t11) => ({ id: t11.trackId, title: t11.trackName, artist: t11.artistName, album: t11.albumName, snapshotId: t11.playlistSnapshotId, playlistId: t11.playlistId, playlistName: t11.playlistName, rank: t11.currentPlaylistRank, uri: t11.uri, index: t11.indexInPlaylist, length: t11.playlistLength }));
    D3(o21, "all_tracks.csv", 5);
  }
  async filterPropertiesByCategory(e10 = "") {
    let [o21, t11] = e10.split(":"), a22 = await this.uploadCsvFolderToLogJson(true);
    return [...new Set(a22.filter((r9) => r9.categories[o21].value.toLowerCase().includes(t11.toLowerCase())).map((r9) => r9.id))].join(",");
  }
  async saveSampledDataToCache() {
    let o21 = (await this.uploadCsvFolderToLogJson(true)).reduce((t11, a22) => (t11[a22.id] = a22.categories, t11), {});
    await D2.setItem(w, o21);
  }
  async uploadCsvFolderToLogJson(e10) {
    let t11 = (await b2(e10)).flatMap((r9) => r9).filter(Boolean);
    console.log(t11);
    let a22 = this.groupAndRankTopCategoryWithRatio(t11, ["mood", "genre"], "id");
    return console.log(a22), a22;
  }
  groupAndRankTopCategoryWithRatio(e10, o21, t11 = "title") {
    let a22 = {};
    return e10.forEach((i18) => {
      let s18 = i18[t11];
      a22[s18] || (a22[s18] = []), a22[s18].push(i18);
    }), Object.entries(a22).map(([i18, s18]) => {
      let l14 = s18.length, f13 = {};
      for (let b7 of o21) {
        let p15 = {};
        for (let c21 of s18) {
          let n11 = c21[b7];
          p15[n11] = (p15[n11] || 0) + 1;
        }
        let h12 = Object.entries(p15).sort((c21, n11) => n11[1] - c21[1])[0];
        if (h12) {
          let [c21, n11] = h12;
          f13[b7] = { value: c21, rank: `${n11}/${l14}` };
        }
      }
      return { [t11]: i18, categories: f13 };
    });
  }
};
l([v4({}), m(0, t), m(1, y3)], d10.prototype, "getPlayCountByArtist", 1), l([S({}), m(0, t), m(1, y3)], d10.prototype, "getPlayCountByAlbum", 1);

// node_modules/@mahindar5/common-lib/dist/chunk-JLUL6LD4.js
var c12 = "MoodGenreSampledData", u16 = class {
  static {
    __name(this, "u");
  }
  static {
    j(this, "SpotifyTrackPlaylistService");
  }
  spotifyApiService = c2(h9);
  filterCondition(e10, t11) {
    if (!e10 || !t11 || !e10.owner) return false;
    if (e10.trackId === t11.trackId) return true;
    let r9 = e10.trackName?.toLowerCase() || "", s18 = t11.trackName?.toLowerCase() || "";
    if (!(r9 === s18 || r9.substring(0, 5) === s18.substring(0, 5) && (r9.includes(s18) || s18.includes(r9)))) return false;
    let a22 = e10.albumId?.toLowerCase(), i18 = t11.albumId?.toLowerCase(), n11 = e10.albumName?.toLowerCase(), l14 = t11.albumName?.toLowerCase(), p15 = e10.artistId?.toLowerCase(), o21 = t11.artistId?.toLowerCase(), g10 = e10.artistName?.toLowerCase(), P2 = t11.artistName?.toLowerCase();
    return a22 === i18 || n11 === l14 || p15 === o21 || g10 === P2;
  }
  groupTracksBy(e10, t11) {
    let r9 = /* @__PURE__ */ new Map();
    for (let s18 of e10) {
      let a22 = t11(s18), i18 = r9.get(a22);
      i18 ? i18.push(s18) : r9.set(a22, [s18]);
    }
    return r9;
  }
  parsePlaylistName(e10) {
    let t11 = e10.match(/^(.*?)(?:#(\d+))?$/), r9 = t11?.[1].trim() || "";
    return { currentRank: Number(t11?.[2] || 1), baseName: r9 };
  }
  _updateRecentlyPlayedTracks(e10, t11) {
    t11?.forEach((r9, s18) => {
      let a22 = e10.find((i18) => i18.owner && i18.trackId === r9.trackId && i18.playlistId === r9.playlistId || this.filterCondition(i18, r9));
      a22?.type !== "Current" && (a22 ? (a22.recentlyPlayedIndex === 9999999 && (a22.recentlyPlayedIndex = s18 + 1), a22.type = "Recent") : (r9.recentlyPlayedIndex = s18 + 1, r9.type = "Recent", e10.push(r9)));
    });
  }
  _markDuplicates(e10) {
    for (let t11 of e10) if (!t11.duplicateCountMarked) {
      let r9 = e10.filter((s18) => this.filterCondition(t11, s18));
      if (r9.length > 1) for (let s18 of r9) s18.duplicateCount = r9.length, s18.duplicateCountMarked = true;
    }
  }
  async fetchTrackList(e10, t11) {
    let r9 = await this.fetchUserPlaylists(e10 || t11.length > 0);
    return (await Promise.all(r9.map((a22) => {
      let i18 = t11.find((l14) => l14.playlistId === a22.id), n11 = i18 ? i18.snapshot_id : a22.snapshot_id;
      return this.fetchPlaylistTracks({ ...a22, snapshot_id: n11 }, !!i18 || e10);
    }))).flat();
  }
  async saveUserTracks(e10) {
    if (e10.length > 50) throw new Error("A maximum of 50 items can be saved in one request.");
    if (!e10.length) throw new Error("No tracks to save.");
    return this.spotifyApiService.makeApiCall("/v1/me/tracks", "PUT", { ids: e10 }, void 0, true);
  }
  async batchDeletePlaylistTracks(e10) {
    let t11 = e10.filter((a22) => a22.owner);
    if (!t11.length) return [];
    let r9 = this.groupTracksBy(t11, (a22) => a22.playlistId), s18 = [];
    for (let [a22, i18] of r9.entries()) try {
      let n11 = await this.deleteTracksFromPlaylist(a22, i18);
      s18.push({ playlistId: a22, snapshot_id: n11.snapshot_id });
    } catch {
      s18.push({ playlistId: a22, snapshot_id: "ERROR" });
    }
    return s18;
  }
  async moveTracks(e10, t11, r9) {
    if (!e10.length) throw new Error("No tracks to move.");
    let s18 = await this.addTracksToPlaylist(e10.map((i18) => i18.uri), t11, r9), a22 = await this.batchDeletePlaylistTracks(e10);
    return [s18, ...a22];
  }
  async getMoodGenreSampledData() {
    let e10 = await D2.getItem(c12);
    if (e10) return e10;
    let t11 = await this.spotifyApiService.fetchExternalData("/spotify/genres-mood-sampled");
    return await D2.setItem(c12, t11, 48 * 60 * 60 * 1e3), t11;
  }
  updateCurrentTrack(e10, t11) {
    if (!t11) return;
    let r9 = e10.find((a22) => a22.type === "Current"), s18 = e10.find((a22) => a22.owner && a22.trackId === t11.trackId && a22.playlistId === t11.playlistId || this.filterCondition(a22, t11));
    s18 ? (s18.recentlyPlayedIndex = 0, s18.type = "Current", s18.isShuffleActive = t11.isShuffleActive) : (t11.recentlyPlayedIndex = 0, t11.type = "Current", e10.push(t11)), r9 && r9.trackId !== s18?.trackId && (r9.recentlyPlayedIndex = 9999999, r9.type = "Recent");
  }
  async searchTracks(e10, t11 = 20, r9 = 0) {
    return this.spotifyApiService.makeApiCall(`/v1/search?q=${encodeURIComponent(e10)}&type=track&limit=${t11}&offset=${r9}`);
  }
  async fetchUserPlaylists(e10) {
    let t11 = this.spotifyApiService.getBaseUrl();
    return this.spotifyApiService.fetchPagedItems(`${t11}/v1/me/playlists`, void 0, e10);
  }
  async fetchPlaylistById(e10, t11) {
    return this.spotifyApiService.makeApiCall(`/v1/playlists/${e10}`, "GET", void 0, void 0, t11);
  }
  async createUserPlaylist(e10) {
    return this.spotifyApiService.makeApiCall("/v1/users/mahindar5/playlists", "POST", { name: e10, public: true }, void 0, true);
  }
  async deletePlaylistTracksAll(e10) {
    return this.spotifyApiService.makeApiCall(`/v1/playlists/${e10}/tracks`, "DELETE", void 0, void 0, true);
  }
  async deleteTracksFromPlaylist(e10, t11) {
    return t11.length ? this.spotifyApiService.makeApiCall(`/v1/playlists/${e10}/tracks`, "DELETE", { tracks: t11.map((r9) => ({ uri: r9.uri })) }, void 0, true) : { snapshot_id: null };
  }
  async addTracksToPlaylist(e10, t11, r9 = null) {
    let s18 = { uris: e10 };
    return r9 != null && (s18.position = r9.toString()), this.spotifyApiService.makeApiCall(`/v1/playlists/${t11}/tracks`, "POST", s18, void 0, true).then((a22) => ({ playlistId: t11, snapshot_id: a22.snapshot_id }));
  }
  async reorderPlaylistTracks(e10, t11, r9 = 1) {
    if (e10.type == "Current" && !e10.isShuffleActive) throw new Error("Cannot reorder tracks when shuffle is not active. As it messes up the playing queue.");
    let s18 = e10.indexInPlaylist < t11 ? t11 + r9 - 1 : t11 - 1;
    return this.spotifyApiService.makeApiCall(`/v1/playlists/${e10.playlistId}/tracks`, "PUT", { snapshot_id: e10.playlistSnapshotId, insert_before: s18, range_start: e10.indexInPlaylist, range_length: r9 }, void 0, true);
  }
  async fetchPlaylistTracks(e10, t11) {
    let r9 = await this.spotifyApiService.fetchPagedItems(e10.tracks?.href, "snapshot_id_" + e10.snapshot_id, t11), s18 = await D2.getItem(c12) || {};
    return r9.map((a22, i18) => this.mapRawTrackToModel(a22, e10, i18, s18)).filter((a22) => !!a22);
  }
  mapRawPlaylistResponse(e10) {
    return { playlistId: e10.id, playlistName: e10.name, playlistLength: e10.tracks?.total || 0, playlistSnapshotId: e10.snapshot_id, duplicateCount: 1, recentlyPlayedIndex: 9999999, owner: e10.owner?.id === "mahindar5" };
  }
  mapRawTrackResponse(e10, t11, r9) {
    let s18 = e10.track;
    return { trackId: s18.id, trackName: s18.name, artistId: s18.artists?.[0]?.id || "", artistName: s18.artists?.map((a22) => a22.name).join(", ") || "", albumId: s18.album?.id || "", albumName: s18.album?.name || "", albumImage: s18.album?.images?.[0]?.url || "", uri: s18.uri, playlistId: t11.id, playlistName: t11.name, playlistLength: t11.tracks?.total || 0, playlistSnapshotId: t11.snapshot_id, indexInPlaylist: r9, currentPlaylistRank: 1, duplicateCount: 1, duplicateCountMarked: false, recentlyPlayedIndex: 9999999, checked: false, owner: t11.owner?.id === "mahindar5", addedAt: new Date(e10.added_at) };
  }
  async createPlaylist(e10) {
    let t11 = await this.createUserPlaylist(e10.name);
    if (e10.tracks.length > 0) {
      let r9 = e10.tracks.map((s18) => s18.uri);
      await this.addTracksToPlaylist(r9, t11.id);
    }
    return t11.id;
  }
  mapRawTrackToModel(e10, t11, r9, s18 = {}) {
    if (!e10?.track) return null;
    let a22 = e10.track, i18 = a22.album?.images || [];
    t11 = t11 || {};
    let n11 = t11.name || t11.uri?.split(":").pop() || "", { currentRank: l14, baseName: p15 } = this.parsePlaylistName(n11);
    return { trackId: a22.id, uri: a22.uri, trackName: a22.name, artistId: a22.artists?.map((o21) => o21.id).join(",") || "", artistName: a22.artists?.map((o21) => o21.name).join(",") || "", playlistId: t11.id || t11.uri?.split(":").pop(), playlistName: n11, currentPlaylistRank: l14, albumId: a22.album?.id, albumName: a22.album?.name, albumImage: i18[2]?.url || i18[1]?.url || i18[0]?.url, albumImageHD: i18[0]?.url || i18[1]?.url, indexInPlaylist: r9, playlistLength: t11.tracks?.total || 0, playlistSnapshotId: t11.snapshot_id, duplicateCount: 1, recentlyPlayedIndex: 9999999, owner: t11.owner?.id === "mahindar5", addedAt: e10.added_at ? new Date(e10.added_at) : void 0, isShuffleActive: e10.shuffle_state, type: e10.type, mood: s18[a22.id]?.mood?.value || "", moodRank: s18[a22.id]?.mood?.rank || "", genre: s18[a22.id]?.genre?.value || "", genreRank: s18[a22.id]?.genre?.rank || "" };
  }
  async fetchPlaylistWithAllTracks(e10, t11) {
    let r9 = await this.fetchPlaylistById(e10, t11), s18 = r9?.tracks?.items || [];
    if (r9?.tracks?.next) {
      let a22 = await this.spotifyApiService.fetchPagedItems(r9.tracks.next, void 0, t11);
      s18.push(...a22);
    }
    return s18.filter((a22) => a22.track).map((a22, i18) => this.mapRawTrackToModel(a22, r9, i18)).filter((a22) => !!a22);
  }
};
l([m(0, u5)], u16.prototype, "createUserPlaylist", 1);

// node_modules/@mahindar5/common-lib/dist/chunk-J3G35XX2.js
var m14 = "pjgheakmmcejmgdoojlnjbgbafjoiedg", n9 = /* @__PURE__ */ new Map(), i13 = j((t11) => (e10, o21) => new Promise((s18, r9) => {
  let a22 = { ...e10, target: "background", _routeToContent: true, _contentTabQuery: t11 };
  chrome.runtime.sendMessage(m14, a22, (u20) => {
    chrome.runtime.lastError ? r9(new Error(chrome.runtime.lastError.message)) : s18(u20 || { requestId: e10.requestId, success: false, error: "No response received" });
  });
}), "createWebToContentRpcTransport");
function h10(t11, e10) {
  let o21 = `${t11}_${JSON.stringify(e10)}`;
  if (n9.has(o21)) return n9.get(o21);
  let s18 = i13(e10), r9 = m2(s18, n9, t11, "contentscripts");
  return n9.set(o21, r9), r9;
}
__name(h10, "h");
j(h10, "resolveWebToContentRpc");

// node_modules/@mahindar5/common-lib/dist/chunk-QWUDE5WO.js
var c13 = class {
  static {
    __name(this, "c");
  }
  static {
    j(this, "SpotifyPlayerService");
  }
  spotifyApiService = c2(h9);
  spotifyTrackPlaylistService = c2(u16);
  async sendExtensionCommand(e10) {
    return h10("SpotifyHelper", { url: "https://open.spotify.com/*" }).command(e10);
  }
  async fetchCurrentUserPlayback() {
    let e10 = await this.spotifyApiService.makeApiCall("/v1/me/player", "GET", void 0, void 0, true);
    if (e10?.item) return this.spotifyTrackPlaylistService.mapRawTrackToModel({ track: e10.item, added_at: e10.timestamp, shuffle_state: e10.shuffle_state, type: "Current" }, e10.context, e10.item.track_number) || void 0;
  }
  async fetchRecentTracks() {
    return (await this.spotifyApiService.makeApiCall("/v1/me/player/recently-played", "GET", void 0, { offset: "0", limit: "50" }, true)).items?.map((t11, a22) => this.spotifyTrackPlaylistService.mapRawTrackToModel(t11, t11.context, a22)).filter((t11) => !!t11) || [];
  }
  async getRecentlyPlayedTracks(e10 = 50) {
    return (await this.spotifyApiService.makeApiCall("/v1/me/player/recently-played", "GET", void 0, { offset: "0", limit: e10.toString() }, true)).items?.map((a22, l14) => this.spotifyTrackPlaylistService.mapRawTrackToModel(a22, a22.context, l14)).filter((a22) => !!a22) || [];
  }
  async playPlaylistTrack(e10) {
    let t11 = await this.spotifyApiService.makeApiCall("/v1/me/player/play", "PUT", { context_uri: `spotify:playlist:${e10.playlistId}`, offset: { uri: e10.uri } });
    return t11.success ?? t11;
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-MDNZHX6I.js
var n10 = class {
  static {
    __name(this, "n");
  }
  static {
    j(this, "SpotifyCacheService");
  }
  spotifyTrackPlaylistService = c2(u16);
  spotifyPlayerService = c2(c13);
  spotifyDataService = c2(d10);
  async prepareTracks(y12, f13, d15, m18, w4, S7) {
    let u20 = await this.spotifyTrackPlaylistService.fetchTrackList(y12, f13), v8 = await this.spotifyPlayerService.fetchCurrentUserPlayback(), k5 = await this.spotifyPlayerService.fetchRecentTracks(), t11 = [...u20];
    if (this.spotifyTrackPlaylistService.updateCurrentTrack(t11, v8), this.spotifyTrackPlaylistService._updateRecentlyPlayedTracks(t11, k5), this.spotifyTrackPlaylistService._markDuplicates(t11), d15) {
      let i18 = t11.filter((r9) => !r9.playlistName?.startsWith("Sorted_On_")), a22 = await this.spotifyDataService.fetchViewCount(i18, false, false);
      t11.forEach((r9) => r9.playCount = a22[r9.trackId] || 0);
    }
    let h12 = m18.map((i18) => {
      let a22 = [...new Set(t11.map((e10) => e10[i18]))].filter(Boolean).map((e10) => String(e10)), r9 = S7.find((e10) => e10.property === i18);
      return { property: i18, label: i18, items: a22.sort((e10, P2) => String(e10).localeCompare(String(P2), void 0, { numeric: true })), selectedValues: r9?.selectedValues || [], isMultitple: true, strictFilter: r9?.strictFilter || false };
    });
    return { tracksInMemory: t11, dropdownFilterList: h12 };
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-S47I3LLY.js
var k3 = class {
  static {
    __name(this, "k");
  }
  static {
    j(this, "SpotifyUIService");
  }
  spotifyTrackPlaylistService = c2(u16);
  applyFiltersAndSort(a22, i18, s18, l14, e10, c21) {
    let p15 = s18?.toLowerCase() || "";
    return [...a22.filter((n11) => i18.every((r9) => {
      if (r9.selectedValues.length === 0) return true;
      let t11 = n11[r9.property];
      return t11 == null ? false : r9.selectedValues.includes(String(t11));
    }) && (!p15 || l14.some((r9) => {
      let t11 = n11[r9];
      return typeof t11 == "string" && t11.toLowerCase().includes(p15);
    })))].sort((n11, r9) => {
      let t11 = n11[e10] ?? "", o21 = r9[e10] ?? "", u20 = typeof t11 == "number" && typeof o21 == "number" ? t11 - o21 : t11 instanceof Date && o21 instanceof Date ? t11.getTime() - o21.getTime() : String(t11).localeCompare(String(o21));
      return c21 ? -u20 : u20;
    });
  }
  async getAvailablePlaylists(a22 = true) {
    return (await this.spotifyTrackPlaylistService.fetchUserPlaylists(a22)).map((s18) => ({ playlistId: s18.id, playlistName: s18.name, playlistSnapshotId: s18.snapshot_id, playlistLength: s18.tracks.total }));
  }
  async prepareDuplicatePlaylistData(a22, i18) {
    let s18 = /* @__PURE__ */ new Map(), l14 = [], e10 = await this.spotifyTrackPlaylistService.fetchPlaylistWithAllTracks(i18, true), c21 = e10[0]?.playlistName;
    for (let n11 of e10) {
      let r9 = a22.find((t11) => this.spotifyTrackPlaylistService.filterCondition(t11, n11));
      if (r9) {
        let t11 = r9.playlistName, o21 = s18.get(t11);
        s18.set(t11, { playlistName: t11, trackIds: [r9.uri, ...o21?.trackIds || []] });
      } else l14.push(n11.uri);
    }
    let p15 = { playlistName: c21, playlistId: e10[0]?.playlistId, trackIds: l14, checked: true }, y12 = this.generateNewPlaylistNameForDuplicate(a22, c21);
    return { newTracks: p15, existingTracks: s18, newPlaylistName: y12 };
  }
  generateNewPlaylistNameForDuplicate(a22, i18) {
    let l14 = [...new Set(a22.map((e10) => e10.playlistName))].sort().reverse().find((e10) => e10.toLowerCase().includes(i18.toLowerCase()));
    if (l14) {
      let e10 = l14.split("#");
      return `${e10[0]}#${Number(e10[1] || 1) + 1}`;
    }
    return `${i18}#2`;
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-A3I3UDU6.js
var v7 = class {
  static {
    __name(this, "v");
  }
  static {
    j(this, "SpotifyOperationsService");
  }
  spotifyTrackPlaylistService = c2(u16);
  spotifyDataService = c2(d10);
  spotifyUIService = c2(k3);
  async executeTrackOperation(e10, r9) {
    if (!e10?.length) return { success: false, message: "No tracks selected." };
    switch (r9) {
      case "Promote (Direct)":
      case "Demote (Direct)":
        return this.changeTrackPlaylistRank(e10, r9);
      case "Move to Top":
      case "Move to Bottom":
        return this.moveTrackToExtremity(e10[0], e10.length, r9);
      case "Delete Selected":
        return this.spotifyTrackPlaylistService.batchDeletePlaylistTracks(e10);
      case "Like":
        return this.spotifyTrackPlaylistService.saveUserTracks(e10.map((t11) => t11.trackId).filter((t11) => !!t11));
      case "Save":
        return this.spotifyTrackPlaylistService.addTracksToPlaylist(e10.map((t11) => t11.uri).filter((t11) => !!t11), e10[0].playlistId);
      default:
        throw new Error(`Operation ${r9} not implemented in service.`);
    }
  }
  async moveTrackToExtremity(e10, r9, t11) {
    let o21 = t11 === "Move to Top" ? 1 : e10.playlistLength || 1, c21 = await this.spotifyTrackPlaylistService.reorderPlaylistTracks(e10, o21, r9);
    return { playlistId: e10.playlistId, snapshot_id: c21.snapshot_id };
  }
  async changeTrackPlaylistRank(e10, r9) {
    let t11 = [], o21 = this.spotifyTrackPlaylistService.groupTracksBy(e10, (i18) => i18.playlistName), c21 = (await this.spotifyTrackPlaylistService.fetchUserPlaylists(true)).map((i18) => this.spotifyTrackPlaylistService.mapRawPlaylistResponse(i18)).filter((i18) => i18.owner);
    for (let [i18, k5] of o21.entries()) {
      let { currentRank: y12, baseName: n11 } = this.spotifyTrackPlaylistService.parsePlaylistName(i18);
      if (r9 === "Promote (Direct)" && y12 === 1) throw new Error(`Cannot promote from "${i18}": Already at the highest rank (1).`);
      let m18 = c21.filter((a22) => a22.playlistName.startsWith(n11)).map((a22) => {
        let l14 = a22.playlistName.match(/^(.*?)(?:#(\d+))?$/);
        return { ...a22, rank: Number(l14?.[2] || 1) };
      }).sort((a22, l14) => a22.rank - l14.rank), p15 = r9 === "Promote (Direct)" ? [...m18].reverse().find((a22) => a22.rank < y12) : m18.find((a22) => a22.rank > y12);
      if (!p15) {
        let a22 = y12 + (r9 === "Promote (Direct)" ? -1 : 1), l14 = `${n11} #${a22}`, d15 = await this.spotifyTrackPlaylistService.createUserPlaylist(l14);
        p15 = this.spotifyTrackPlaylistService.mapRawPlaylistResponse(d15), c21.push(p15);
      }
      let f13 = r9 === "Demote (Direct)" ? 0 : p15.playlistLength || 0, s18 = await this.spotifyTrackPlaylistService.moveTracks(k5, p15.playlistId, f13);
      t11 = [...t11, ...s18];
    }
    return Array.from(new Map(t11.map((i18) => [i18.playlistId + i18.snapshot_id, i18])).values());
  }
  async createDuplicatePlaylist(e10) {
    let r9 = e10.newTracks?.trackIds || [];
    if (e10.existingTracks.forEach((o21) => {
      o21.checked && (r9 = [...r9, ...o21.trackIds]);
    }), !r9.length) throw new Error("No Track IDs to add");
    let t11 = e10.newPlaylist ? (await this.spotifyTrackPlaylistService.createUserPlaylist(e10.newPlaylistName)).id : e10.selectedPlaylistId;
    for (let o21 of a11(r9, 100)) await this.spotifyTrackPlaylistService.addTracksToPlaylist(o21, t11);
    return t11;
  }
  async getSortedPlaylistData(e10, r9, t11, o21, c21, i18) {
    let k5 = r9.map((s18) => s18.playlistId), y12 = e10.filter((s18) => k5.includes(s18.playlistId)), n11 = Array.from(new Set(y12.map((s18) => t11 === "Album" ? s18.albumId : t11 === "Artist" ? s18.artistId : s18.playlistId)));
    n11 = Array.from(new Set(n11.flatMap((s18) => s18?.toString().split(",") || [])));
    let m18 = [];
    if (t11 === "PlayList") {
      let s18 = /* @__PURE__ */ new Map();
      y12.forEach((a22) => {
        s18.has(a22.playlistId) || s18.set(a22.playlistId, []), s18.get(a22.playlistId).push({ ...a22, owner: true });
      });
      for (let [a22, l14] of s18.entries()) {
        let d15 = r9.find((u20) => u20.playlistId === a22);
        m18.push({ name: d15?.playlistName || a22, tracks: l14 });
      }
    } else if (t11 === "Album") for (let s18 of n11) {
      let a22 = await this.spotifyDataService.getPlayCountByAlbum(s18, false);
      m18.push({ name: a22.data.name, tracks: a22.data.discs.flatMap((l14) => l14.tracks.map((d15) => ({ playCount: d15.playcount, trackId: d15.uri.replace("spotify:track:", ""), trackName: d15.name, albumId: a22.data.uri.replace("spotify:album:", ""), albumName: a22.data.name, artistId: d15.artists.map((u20) => u20.uri.replace("spotify:artist:", "")).join(","), artistName: d15.artists.map((u20) => u20.name).join(","), owner: true, albumImage: a22.data.cover.uri }))) });
    }
    else if (t11 === "Artist") for (let s18 of n11) {
      let a22 = await this.spotifyDataService.getPlayCountByArtist(s18, false);
      m18.push({ name: a22.data.info.name, tracks: a22.data.top_tracks.tracks.map((l14) => ({ playCount: l14.playcount, trackId: l14.uri.replace("spotify:track:", ""), trackName: l14.name, albumId: l14.release.uri.replace("spotify:album:", ""), albumName: l14.release.name, artistId: a22.data.info.uri.replace("spotify:artist:", ""), artistName: a22.data.info.name, owner: true, albumImage: l14.release.cover.uri })) });
    }
    let p15 = m18.reduce((s18, a22) => s18 + a22.tracks.length, 0), f13 = this.generatePlaylistNameForSort(t11, o21, c21, i18, r9);
    return { newTracks: m18, newTracksLength: p15, newPlaylistName: f13 };
  }
  generatePlaylistNameForSort(e10, r9, t11, o21, c21) {
    return ["Sorted", "On", (/* @__PURE__ */ new Date()).toISOString().replace(new RegExp("-", "g"), "").replace("T", "").slice(0, 8), "By", e10, r9 ? "T" + o21 : "", r9 ? "" : "S" + t11, c21.length === 1 ? c21[0].playlistName.replace(/#/g, "") : "", "#2"].filter(Boolean).join("_");
  }
  async createSortedPlaylist(e10, r9, t11, o21) {
    let i18 = e10.flatMap((n11) => n11.tracks).filter((n11, m18, p15) => m18 === p15.findIndex((f13) => this.spotifyTrackPlaylistService.filterCondition(n11, f13))), k5 = Array.from(new Set(i18.map((n11) => n11.trackId)));
    if (!k5.length) throw new Error("No track ids to add");
    let y12 = r9 ? (await this.spotifyTrackPlaylistService.createUserPlaylist(t11)).id : o21;
    for (let n11 of a11(k5, 100)) await this.spotifyTrackPlaylistService.addTracksToPlaylist(n11, y12);
    return y12;
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-BA2T4EEM.js
var D5 = ((v8) => (v8.Promote = "Promoted", v8.Demote = "Demoted", v8.MoveToTop = "Moved to top", v8.MoveToBottom = "Moved to bottom", v8.Reorder = "Reordered", v8.MoveBetweenPlaylists = "Moved between playlists", v8.DeleteSelected = "Deleted", v8.SwapSongs = "Swapped", v8.Like = "Liked", v8.Add = "Saved", v8))(D5 || {}), S3 = ((M) => (M.Promote = "promote", M.Demote = "demote", M.MoveToTop = "top", M.MoveToBottom = "bottom", M.DeleteSelected = "delete", M.Like = "like", M.Add = "add", M))(S3 || {}), o17 = ((e10) => (e10.Promote = "Promote (Direct)", e10.Demote = "Demote (Direct)", e10.MoveToTopQuick = "Move to Top (Direct)", e10.MoveToBottomQuick = "Move to Bottom (Direct)", e10.MoveToTop = "Move to Top", e10.Reorder = "Reorder", e10.MoveToBottom = "Move to Bottom", e10.MoveBetweenPlaylists = "Add/Move Songs", e10.DeleteSelected = "Delete Selected", e10.SwapSongs = "Swap", e10.Like = "Like", e10.Add = "Save", e10))(o17 || {});

// node_modules/@mahindar5/common-lib/dist/chunk-RGB6VMDK.js
var import_meta2 = {};

// node_modules/pdfjs-dist/build/pdf.mjs
var import_meta = {};
var __webpack_require__ = {};
(() => {
  __webpack_require__.d = (exports2, definition) => {
    for (var key in definition) {
      if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
        Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
      }
    }
  };
})();
(() => {
  __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
})();
var __webpack_exports__ = {};
;
var isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
var FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
var LINE_FACTOR = 1.35;
var LINE_DESCENT_FACTOR = 0.35;
var BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
var RenderingIntentFlag = {
  ANY: 1,
  DISPLAY: 2,
  PRINT: 4,
  SAVE: 8,
  ANNOTATIONS_FORMS: 16,
  ANNOTATIONS_STORAGE: 32,
  ANNOTATIONS_DISABLE: 64,
  IS_EDITING: 128,
  OPLIST: 256
};
var AnnotationMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
};
var AnnotationEditorPrefix = "pdfjs_internal_editor_";
var AnnotationEditorType = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15,
  POPUP: 16,
  SIGNATURE: 101,
  COMMENT: 102
};
var AnnotationEditorParamsType = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23,
  HIGHLIGHT_COLOR: 31,
  HIGHLIGHT_THICKNESS: 32,
  HIGHLIGHT_FREE: 33,
  HIGHLIGHT_SHOW_ALL: 34,
  DRAW_STEP: 41
};
var PermissionFlag = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE: 1024,
  PRINT_HIGH_QUALITY: 2048
};
var TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
var util_ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
var AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
var AnnotationReplyType = {
  GROUP: "Group",
  REPLY: "R"
};
var AnnotationFlag = {
  INVISIBLE: 1,
  HIDDEN: 2,
  PRINT: 4,
  NOZOOM: 8,
  NOROTATE: 16,
  NOVIEW: 32,
  READONLY: 64,
  LOCKED: 128,
  TOGGLENOVIEW: 256,
  LOCKEDCONTENTS: 512
};
var AnnotationFieldFlag = {
  READONLY: 1,
  REQUIRED: 2,
  NOEXPORT: 4,
  MULTILINE: 4096,
  PASSWORD: 8192,
  NOTOGGLETOOFF: 16384,
  RADIO: 32768,
  PUSHBUTTON: 65536,
  COMBO: 131072,
  EDIT: 262144,
  SORT: 524288,
  FILESELECT: 1048576,
  MULTISELECT: 2097152,
  DONOTSPELLCHECK: 4194304,
  DONOTSCROLL: 8388608,
  COMB: 16777216,
  RICHTEXT: 33554432,
  RADIOSINUNISON: 33554432,
  COMMITONSELCHANGE: 67108864
};
var AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
var AnnotationActionEventType = {
  E: "Mouse Enter",
  X: "Mouse Exit",
  D: "Mouse Down",
  U: "Mouse Up",
  Fo: "Focus",
  Bl: "Blur",
  PO: "PageOpen",
  PC: "PageClose",
  PV: "PageVisible",
  PI: "PageInvisible",
  K: "Keystroke",
  F: "Format",
  V: "Validate",
  C: "Calculate"
};
var DocumentActionEventType = {
  WC: "WillClose",
  WS: "WillSave",
  DS: "DidSave",
  WP: "WillPrint",
  DP: "DidPrint"
};
var PageActionEventType = {
  O: "PageOpen",
  C: "PageClose"
};
var VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
var OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91,
  setStrokeTransparent: 92,
  setFillTransparent: 93,
  rawFillPath: 94
};
var DrawOPS = {
  moveTo: 0,
  lineTo: 1,
  curveTo: 2,
  closePath: 3
};
var PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
var verbosity = VerbosityLevel.WARNINGS;
function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}
__name(setVerbosityLevel, "setVerbosityLevel");
function getVerbosityLevel() {
  return verbosity;
}
__name(getVerbosityLevel, "getVerbosityLevel");
function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.info(`Info: ${msg}`);
  }
}
__name(info, "info");
function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.warn(`Warning: ${msg}`);
  }
}
__name(warn, "warn");
function unreachable(msg) {
  throw new Error(msg);
}
__name(unreachable, "unreachable");
function assert2(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}
__name(assert2, "assert");
function _isValidProtocol(url) {
  switch (url?.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;
    default:
      return false;
  }
}
__name(_isValidProtocol, "_isValidProtocol");
function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
  if (!url) {
    return null;
  }
  if (options && typeof url === "string") {
    if (options.addDefaultProtocol && url.startsWith("www.")) {
      const dots = url.match(/\./g);
      if (dots?.length >= 2) {
        url = `http://${url}`;
      }
    }
    if (options.tryConvertEncoding) {
      try {
        url = stringToUTF8String(url);
      } catch {
      }
    }
  }
  const absoluteUrl = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);
  return _isValidProtocol(absoluteUrl) ? absoluteUrl : null;
}
__name(createValidAbsoluteUrl, "createValidAbsoluteUrl");
function updateUrlHash(url, hash, allowRel = false) {
  const res = URL.parse(url);
  if (res) {
    res.hash = hash;
    return res.href;
  }
  if (allowRel && createValidAbsoluteUrl(url, "http://example.com")) {
    return url.split("#", 1)[0] + `${hash ? `#${hash}` : ""}`;
  }
  return "";
}
__name(updateUrlHash, "updateUrlHash");
function shadow(obj, prop, value, nonSerializable = false) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: !nonSerializable,
    configurable: true,
    writable: false
  });
  return value;
}
__name(shadow, "shadow");
var BaseException = (/* @__PURE__ */ __name(function BaseExceptionClosure() {
  function BaseException2(message, name4) {
    this.message = message;
    this.name = name4;
  }
  __name(BaseException2, "BaseException");
  BaseException2.prototype = new Error();
  BaseException2.constructor = BaseException2;
  return BaseException2;
}, "BaseExceptionClosure"))();
var PasswordException = class extends BaseException {
  static {
    __name(this, "PasswordException");
  }
  constructor(msg, code) {
    super(msg, "PasswordException");
    this.code = code;
  }
};
var UnknownErrorException = class extends BaseException {
  static {
    __name(this, "UnknownErrorException");
  }
  constructor(msg, details) {
    super(msg, "UnknownErrorException");
    this.details = details;
  }
};
var InvalidPDFException = class extends BaseException {
  static {
    __name(this, "InvalidPDFException");
  }
  constructor(msg) {
    super(msg, "InvalidPDFException");
  }
};
var ResponseException = class extends BaseException {
  static {
    __name(this, "ResponseException");
  }
  constructor(msg, status, missing) {
    super(msg, "ResponseException");
    this.status = status;
    this.missing = missing;
  }
};
var FormatError = class extends BaseException {
  static {
    __name(this, "FormatError");
  }
  constructor(msg) {
    super(msg, "FormatError");
  }
};
var AbortException = class extends BaseException {
  static {
    __name(this, "AbortException");
  }
  constructor(msg) {
    super(msg, "AbortException");
  }
};
function bytesToString(bytes) {
  if (typeof bytes !== "object" || bytes?.length === void 0) {
    unreachable("Invalid argument for bytesToString");
  }
  const length = bytes.length;
  const MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  const strBuf = [];
  for (let i18 = 0; i18 < length; i18 += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i18 + MAX_ARGUMENT_COUNT, length);
    const chunk = bytes.subarray(i18, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join("");
}
__name(bytesToString, "bytesToString");
function stringToBytes(str) {
  if (typeof str !== "string") {
    unreachable("Invalid argument for stringToBytes");
  }
  const length = str.length;
  const bytes = new Uint8Array(length);
  for (let i18 = 0; i18 < length; ++i18) {
    bytes[i18] = str.charCodeAt(i18) & 255;
  }
  return bytes;
}
__name(stringToBytes, "stringToBytes");
function string32(value) {
  return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
}
__name(string32, "string32");
function objectSize2(obj) {
  return Object.keys(obj).length;
}
__name(objectSize2, "objectSize");
function isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}
__name(isLittleEndian, "isLittleEndian");
function isEvalSupported() {
  try {
    new Function("");
    return true;
  } catch {
    return false;
  }
}
__name(isEvalSupported, "isEvalSupported");
var util_FeatureTest = class {
  static {
    __name(this, "util_FeatureTest");
  }
  static get isLittleEndian() {
    return shadow(this, "isLittleEndian", isLittleEndian());
  }
  static get isEvalSupported() {
    return shadow(this, "isEvalSupported", isEvalSupported());
  }
  static get isOffscreenCanvasSupported() {
    return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
  }
  static get isImageDecoderSupported() {
    return shadow(this, "isImageDecoderSupported", typeof ImageDecoder !== "undefined");
  }
  static get platform() {
    const {
      platform: platform2,
      userAgent
    } = navigator;
    return shadow(this, "platform", {
      isAndroid: userAgent.includes("Android"),
      isLinux: platform2.includes("Linux"),
      isMac: platform2.includes("Mac"),
      isWindows: platform2.includes("Win"),
      isFirefox: userAgent.includes("Firefox")
    });
  }
  static get isCSSRoundSupported() {
    return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
  }
};
var hexNumbers = Array.from(Array(256).keys(), (n11) => n11.toString(16).padStart(2, "0"));
var Util = class {
  static {
    __name(this, "Util");
  }
  static makeHexColor(r9, g10, b7) {
    return `#${hexNumbers[r9]}${hexNumbers[g10]}${hexNumbers[b7]}`;
  }
  static domMatrixToTransform(dm) {
    return [dm.a, dm.b, dm.c, dm.d, dm.e, dm.f];
  }
  static scaleMinMax(transform, minMax) {
    let temp;
    if (transform[0]) {
      if (transform[0] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[2];
        minMax[2] = temp;
      }
      minMax[0] *= transform[0];
      minMax[2] *= transform[0];
      if (transform[3] < 0) {
        temp = minMax[1];
        minMax[1] = minMax[3];
        minMax[3] = temp;
      }
      minMax[1] *= transform[3];
      minMax[3] *= transform[3];
    } else {
      temp = minMax[0];
      minMax[0] = minMax[1];
      minMax[1] = temp;
      temp = minMax[2];
      minMax[2] = minMax[3];
      minMax[3] = temp;
      if (transform[1] < 0) {
        temp = minMax[1];
        minMax[1] = minMax[3];
        minMax[3] = temp;
      }
      minMax[1] *= transform[1];
      minMax[3] *= transform[1];
      if (transform[2] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[2];
        minMax[2] = temp;
      }
      minMax[0] *= transform[2];
      minMax[2] *= transform[2];
    }
    minMax[0] += transform[4];
    minMax[1] += transform[5];
    minMax[2] += transform[4];
    minMax[3] += transform[5];
  }
  static transform(m1, m22) {
    return [m1[0] * m22[0] + m1[2] * m22[1], m1[1] * m22[0] + m1[3] * m22[1], m1[0] * m22[2] + m1[2] * m22[3], m1[1] * m22[2] + m1[3] * m22[3], m1[0] * m22[4] + m1[2] * m22[5] + m1[4], m1[1] * m22[4] + m1[3] * m22[5] + m1[5]];
  }
  static multiplyByDOMMatrix(m18, md) {
    return [m18[0] * md.a + m18[2] * md.b, m18[1] * md.a + m18[3] * md.b, m18[0] * md.c + m18[2] * md.d, m18[1] * md.c + m18[3] * md.d, m18[0] * md.e + m18[2] * md.f + m18[4], m18[1] * md.e + m18[3] * md.f + m18[5]];
  }
  static applyTransform(p15, m18, pos = 0) {
    const p0 = p15[pos];
    const p1 = p15[pos + 1];
    p15[pos] = p0 * m18[0] + p1 * m18[2] + m18[4];
    p15[pos + 1] = p0 * m18[1] + p1 * m18[3] + m18[5];
  }
  static applyTransformToBezier(p15, transform, pos = 0) {
    const m0 = transform[0];
    const m1 = transform[1];
    const m22 = transform[2];
    const m32 = transform[3];
    const m42 = transform[4];
    const m52 = transform[5];
    for (let i18 = 0; i18 < 6; i18 += 2) {
      const pI = p15[pos + i18];
      const pI1 = p15[pos + i18 + 1];
      p15[pos + i18] = pI * m0 + pI1 * m22 + m42;
      p15[pos + i18 + 1] = pI * m1 + pI1 * m32 + m52;
    }
  }
  static applyInverseTransform(p15, m18) {
    const p0 = p15[0];
    const p1 = p15[1];
    const d15 = m18[0] * m18[3] - m18[1] * m18[2];
    p15[0] = (p0 * m18[3] - p1 * m18[2] + m18[2] * m18[5] - m18[4] * m18[3]) / d15;
    p15[1] = (-p0 * m18[1] + p1 * m18[0] + m18[4] * m18[1] - m18[5] * m18[0]) / d15;
  }
  static axialAlignedBoundingBox(rect, transform, output) {
    const m0 = transform[0];
    const m1 = transform[1];
    const m22 = transform[2];
    const m32 = transform[3];
    const m42 = transform[4];
    const m52 = transform[5];
    const r0 = rect[0];
    const r1 = rect[1];
    const r22 = rect[2];
    const r32 = rect[3];
    let a0 = m0 * r0 + m42;
    let a22 = a0;
    let a1 = m0 * r22 + m42;
    let a32 = a1;
    let b0 = m32 * r1 + m52;
    let b22 = b0;
    let b1 = m32 * r32 + m52;
    let b32 = b1;
    if (m1 !== 0 || m22 !== 0) {
      const m1r0 = m1 * r0;
      const m1r2 = m1 * r22;
      const m2r1 = m22 * r1;
      const m2r3 = m22 * r32;
      a0 += m2r1;
      a32 += m2r1;
      a1 += m2r3;
      a22 += m2r3;
      b0 += m1r0;
      b32 += m1r0;
      b1 += m1r2;
      b22 += m1r2;
    }
    output[0] = Math.min(output[0], a0, a1, a22, a32);
    output[1] = Math.min(output[1], b0, b1, b22, b32);
    output[2] = Math.max(output[2], a0, a1, a22, a32);
    output[3] = Math.max(output[3], b0, b1, b22, b32);
  }
  static inverseTransform(m18) {
    const d15 = m18[0] * m18[3] - m18[1] * m18[2];
    return [m18[3] / d15, -m18[1] / d15, -m18[2] / d15, m18[0] / d15, (m18[2] * m18[5] - m18[4] * m18[3]) / d15, (m18[4] * m18[1] - m18[5] * m18[0]) / d15];
  }
  static singularValueDecompose2dScale(matrix, output) {
    const m0 = matrix[0];
    const m1 = matrix[1];
    const m22 = matrix[2];
    const m32 = matrix[3];
    const a22 = m0 ** 2 + m1 ** 2;
    const b7 = m0 * m22 + m1 * m32;
    const c21 = m22 ** 2 + m32 ** 2;
    const first = (a22 + c21) / 2;
    const second = Math.sqrt(first ** 2 - (a22 * c21 - b7 ** 2));
    output[0] = Math.sqrt(first + second || 1);
    output[1] = Math.sqrt(first - second || 1);
  }
  static normalizeRect(rect) {
    const r9 = rect.slice(0);
    if (rect[0] > rect[2]) {
      r9[0] = rect[2];
      r9[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r9[1] = rect[3];
      r9[3] = rect[1];
    }
    return r9;
  }
  static intersect(rect1, rect2) {
    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
    if (xLow > xHigh) {
      return null;
    }
    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
    if (yLow > yHigh) {
      return null;
    }
    return [xLow, yLow, xHigh, yHigh];
  }
  static pointBoundingBox(x3, y12, minMax) {
    minMax[0] = Math.min(minMax[0], x3);
    minMax[1] = Math.min(minMax[1], y12);
    minMax[2] = Math.max(minMax[2], x3);
    minMax[3] = Math.max(minMax[3], y12);
  }
  static rectBoundingBox(x0, y0, x1, y1, minMax) {
    minMax[0] = Math.min(minMax[0], x0, x1);
    minMax[1] = Math.min(minMax[1], y0, y1);
    minMax[2] = Math.max(minMax[2], x0, x1);
    minMax[3] = Math.max(minMax[3], y0, y1);
  }
  static #getExtremumOnCurve(x0, x1, x22, x3, y0, y1, y22, y32, t11, minMax) {
    if (t11 <= 0 || t11 >= 1) {
      return;
    }
    const mt = 1 - t11;
    const tt = t11 * t11;
    const ttt = tt * t11;
    const x4 = mt * (mt * (mt * x0 + 3 * t11 * x1) + 3 * tt * x22) + ttt * x3;
    const y12 = mt * (mt * (mt * y0 + 3 * t11 * y1) + 3 * tt * y22) + ttt * y32;
    minMax[0] = Math.min(minMax[0], x4);
    minMax[1] = Math.min(minMax[1], y12);
    minMax[2] = Math.max(minMax[2], x4);
    minMax[3] = Math.max(minMax[3], y12);
  }
  static #getExtremum(x0, x1, x22, x3, y0, y1, y22, y32, a22, b7, c21, minMax) {
    if (Math.abs(a22) < 1e-12) {
      if (Math.abs(b7) >= 1e-12) {
        this.#getExtremumOnCurve(x0, x1, x22, x3, y0, y1, y22, y32, -c21 / b7, minMax);
      }
      return;
    }
    const delta = b7 ** 2 - 4 * c21 * a22;
    if (delta < 0) {
      return;
    }
    const sqrtDelta = Math.sqrt(delta);
    const a23 = 2 * a22;
    this.#getExtremumOnCurve(x0, x1, x22, x3, y0, y1, y22, y32, (-b7 + sqrtDelta) / a23, minMax);
    this.#getExtremumOnCurve(x0, x1, x22, x3, y0, y1, y22, y32, (-b7 - sqrtDelta) / a23, minMax);
  }
  static bezierBoundingBox(x0, y0, x1, y1, x22, y22, x3, y32, minMax) {
    minMax[0] = Math.min(minMax[0], x0, x3);
    minMax[1] = Math.min(minMax[1], y0, y32);
    minMax[2] = Math.max(minMax[2], x0, x3);
    minMax[3] = Math.max(minMax[3], y0, y32);
    this.#getExtremum(x0, x1, x22, x3, y0, y1, y22, y32, 3 * (-x0 + 3 * (x1 - x22) + x3), 6 * (x0 - 2 * x1 + x22), 3 * (x1 - x0), minMax);
    this.#getExtremum(x0, x1, x22, x3, y0, y1, y22, y32, 3 * (-y0 + 3 * (y1 - y22) + y32), 6 * (y0 - 2 * y1 + y22), 3 * (y1 - y0), minMax);
  }
};
var PDFStringTranslateTable = (
  /* unused pure expression or super */
  null
);
function stringToPDFString(str, keepEscapeSequence = false) {
  if (str[0] >= "\xEF") {
    let encoding;
    if (str[0] === "\xFE" && str[1] === "\xFF") {
      encoding = "utf-16be";
      if (str.length % 2 === 1) {
        str = str.slice(0, -1);
      }
    } else if (str[0] === "\xFF" && str[1] === "\xFE") {
      encoding = "utf-16le";
      if (str.length % 2 === 1) {
        str = str.slice(0, -1);
      }
    } else if (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") {
      encoding = "utf-8";
    }
    if (encoding) {
      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = stringToBytes(str);
        const decoded = decoder.decode(buffer);
        if (keepEscapeSequence || !decoded.includes("\x1B")) {
          return decoded;
        }
        return decoded.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "");
      } catch (ex) {
        warn(`stringToPDFString: "${ex}".`);
      }
    }
  }
  const strBuf = [];
  for (let i18 = 0, ii = str.length; i18 < ii; i18++) {
    const charCode = str.charCodeAt(i18);
    if (!keepEscapeSequence && charCode === 27) {
      while (++i18 < ii && str.charCodeAt(i18) !== 27) {
      }
      continue;
    }
    const code = PDFStringTranslateTable[charCode];
    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i18));
  }
  return strBuf.join("");
}
__name(stringToPDFString, "stringToPDFString");
function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}
__name(stringToUTF8String, "stringToUTF8String");
function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}
__name(utf8StringToString, "utf8StringToString");
function isArrayEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i18 = 0, ii = arr1.length; i18 < ii; i18++) {
    if (arr1[i18] !== arr2[i18]) {
      return false;
    }
  }
  return true;
}
__name(isArrayEqual, "isArrayEqual");
function getModificationDate(date = /* @__PURE__ */ new Date()) {
  if (!(date instanceof Date)) {
    date = new Date(date);
  }
  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
  return buffer.join("");
}
__name(getModificationDate, "getModificationDate");
var NormalizeRegex = null;
var NormalizationMap = null;
function normalizeUnicode(str) {
  if (!NormalizeRegex) {
    NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
    NormalizationMap = /* @__PURE__ */ new Map([["\uFB05", "\u017Ft"]]);
  }
  return str.replaceAll(NormalizeRegex, (_, p1, p22) => p1 ? p1.normalize("NFKC") : NormalizationMap.get(p22));
}
__name(normalizeUnicode, "normalizeUnicode");
function getUuid() {
  if (typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  const buf = new Uint8Array(32);
  crypto.getRandomValues(buf);
  return bytesToString(buf);
}
__name(getUuid, "getUuid");
var AnnotationPrefix = "pdfjs_internal_id_";
function _isValidExplicitDest(validRef, validName, dest) {
  if (!Array.isArray(dest) || dest.length < 2) {
    return false;
  }
  const [page, zoom, ...args] = dest;
  if (!validRef(page) && !Number.isInteger(page)) {
    return false;
  }
  if (!validName(zoom)) {
    return false;
  }
  const argsLen = args.length;
  let allowNull = true;
  switch (zoom.name) {
    case "XYZ":
      if (argsLen < 2 || argsLen > 3) {
        return false;
      }
      break;
    case "Fit":
    case "FitB":
      return argsLen === 0;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (argsLen > 1) {
        return false;
      }
      break;
    case "FitR":
      if (argsLen !== 4) {
        return false;
      }
      allowNull = false;
      break;
    default:
      return false;
  }
  for (const arg of args) {
    if (typeof arg === "number" || allowNull && arg === null) {
      continue;
    }
    return false;
  }
  return true;
}
__name(_isValidExplicitDest, "_isValidExplicitDest");
function MathClamp(v8, min, max) {
  return Math.min(Math.max(v8, min), max);
}
__name(MathClamp, "MathClamp");
function toHexUtil(arr) {
  if (Uint8Array.prototype.toHex) {
    return arr.toHex();
  }
  return Array.from(arr, (num) => hexNumbers[num]).join("");
}
__name(toHexUtil, "toHexUtil");
function toBase64Util(arr) {
  if (Uint8Array.prototype.toBase64) {
    return arr.toBase64();
  }
  return btoa(bytesToString(arr));
}
__name(toBase64Util, "toBase64Util");
function fromBase64Util(str) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(str);
  }
  return stringToBytes(atob(str));
}
__name(fromBase64Util, "fromBase64Util");
if (typeof Promise.try !== "function") {
  Promise.try = function(fn, ...args) {
    return new Promise((resolve) => {
      resolve(fn(...args));
    });
  };
}
if (typeof Math.sumPrecise !== "function") {
  Math.sumPrecise = function(numbers) {
    return numbers.reduce((a22, b7) => a22 + b7, 0);
  };
}
;
var XfaText = class _XfaText {
  static {
    __name(this, "XfaText");
  }
  static textContent(xfa) {
    const items = [];
    const output = {
      items,
      styles: /* @__PURE__ */ Object.create(null)
    };
    function walk(node) {
      if (!node) {
        return;
      }
      let str = null;
      const name4 = node.name;
      if (name4 === "#text") {
        str = node.value;
      } else if (!_XfaText.shouldBuildText(name4)) {
        return;
      } else if (node?.attributes?.textContent) {
        str = node.attributes.textContent;
      } else if (node.value) {
        str = node.value;
      }
      if (str !== null) {
        items.push({
          str
        });
      }
      if (!node.children) {
        return;
      }
      for (const child of node.children) {
        walk(child);
      }
    }
    __name(walk, "walk");
    walk(xfa);
    return output;
  }
  static shouldBuildText(name4) {
    return !(name4 === "textarea" || name4 === "input" || name4 === "option" || name4 === "select");
  }
};
;
var XfaLayer = class {
  static {
    __name(this, "XfaLayer");
  }
  static setupStorage(html, id, element, storage, intent) {
    const storedData = storage.getValue(id, {
      value: null
    });
    switch (element.name) {
      case "textarea":
        if (storedData.value !== null) {
          html.textContent = storedData.value;
        }
        if (intent === "print") {
          break;
        }
        html.addEventListener("input", (event) => {
          storage.setValue(id, {
            value: event.target.value
          });
        });
        break;
      case "input":
        if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
          if (storedData.value === element.attributes.xfaOn) {
            html.setAttribute("checked", true);
          } else if (storedData.value === element.attributes.xfaOff) {
            html.removeAttribute("checked");
          }
          if (intent === "print") {
            break;
          }
          html.addEventListener("change", (event) => {
            storage.setValue(id, {
              value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (storedData.value !== null) {
            html.setAttribute("value", storedData.value);
          }
          if (intent === "print") {
            break;
          }
          html.addEventListener("input", (event) => {
            storage.setValue(id, {
              value: event.target.value
            });
          });
        }
        break;
      case "select":
        if (storedData.value !== null) {
          html.setAttribute("value", storedData.value);
          for (const option of element.children) {
            if (option.attributes.value === storedData.value) {
              option.attributes.selected = true;
            } else if (option.attributes.hasOwnProperty("selected")) {
              delete option.attributes.selected;
            }
          }
        }
        html.addEventListener("input", (event) => {
          const options = event.target.options;
          const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
          storage.setValue(id, {
            value
          });
        });
        break;
    }
  }
  static setAttributes({
    html,
    element,
    storage = null,
    intent,
    linkService
  }) {
    const {
      attributes
    } = element;
    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
    if (attributes.type === "radio") {
      attributes.name = `${attributes.name}-${intent}`;
    }
    for (const [key, value] of Object.entries(attributes)) {
      if (value === null || value === void 0) {
        continue;
      }
      switch (key) {
        case "class":
          if (value.length) {
            html.setAttribute(key, value.join(" "));
          }
          break;
        case "dataId":
          break;
        case "id":
          html.setAttribute("data-element-id", value);
          break;
        case "style":
          Object.assign(html.style, value);
          break;
        case "textContent":
          html.textContent = value;
          break;
        default:
          if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
            html.setAttribute(key, value);
          }
      }
    }
    if (isHTMLAnchorElement) {
      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
    }
    if (storage && attributes.dataId) {
      this.setupStorage(html, attributes.dataId, element, storage);
    }
  }
  static render(parameters) {
    const storage = parameters.annotationStorage;
    const linkService = parameters.linkService;
    const root = parameters.xfaHtml;
    const intent = parameters.intent || "display";
    const rootHtml = document.createElement(root.name);
    if (root.attributes) {
      this.setAttributes({
        html: rootHtml,
        element: root,
        intent,
        linkService
      });
    }
    const isNotForRichText = intent !== "richText";
    const rootDiv = parameters.div;
    rootDiv.append(rootHtml);
    if (parameters.viewport) {
      const transform = `matrix(${parameters.viewport.transform.join(",")})`;
      rootDiv.style.transform = transform;
    }
    if (isNotForRichText) {
      rootDiv.setAttribute("class", "xfaLayer xfaFont");
    }
    const textDivs = [];
    if (root.children.length === 0) {
      if (root.value) {
        const node = document.createTextNode(root.value);
        rootHtml.append(node);
        if (isNotForRichText && XfaText.shouldBuildText(root.name)) {
          textDivs.push(node);
        }
      }
      return {
        textDivs
      };
    }
    const stack = [[root, -1, rootHtml]];
    while (stack.length > 0) {
      const [parent, i18, html] = stack.at(-1);
      if (i18 + 1 === parent.children.length) {
        stack.pop();
        continue;
      }
      const child = parent.children[++stack.at(-1)[1]];
      if (child === null) {
        continue;
      }
      const {
        name: name4
      } = child;
      if (name4 === "#text") {
        const node = document.createTextNode(child.value);
        textDivs.push(node);
        html.append(node);
        continue;
      }
      const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name4) : document.createElement(name4);
      html.append(childHtml);
      if (child.attributes) {
        this.setAttributes({
          html: childHtml,
          element: child,
          storage,
          intent,
          linkService
        });
      }
      if (child.children?.length > 0) {
        stack.push([child, -1, childHtml]);
      } else if (child.value) {
        const node = document.createTextNode(child.value);
        if (isNotForRichText && XfaText.shouldBuildText(name4)) {
          textDivs.push(node);
        }
        childHtml.append(node);
      }
    }
    for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
      el.setAttribute("readOnly", true);
    }
    return {
      textDivs
    };
  }
  static update(parameters) {
    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
    parameters.div.style.transform = transform;
    parameters.div.hidden = false;
  }
};
;
var SVG_NS = "http://www.w3.org/2000/svg";
var PixelsPerInch = class {
  static {
    __name(this, "PixelsPerInch");
  }
  static CSS = 96;
  static PDF = 72;
  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
};
async function fetchData(url, type = "text") {
  if (isValidFetchUrl(url, document.baseURI)) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(response.statusText);
    }
    switch (type) {
      case "arraybuffer":
        return response.arrayBuffer();
      case "blob":
        return response.blob();
      case "json":
        return response.json();
    }
    return response.text();
  }
  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.open("GET", url, true);
    request.responseType = type;
    request.onreadystatechange = () => {
      if (request.readyState !== XMLHttpRequest.DONE) {
        return;
      }
      if (request.status === 200 || request.status === 0) {
        switch (type) {
          case "arraybuffer":
          case "blob":
          case "json":
            resolve(request.response);
            return;
        }
        resolve(request.responseText);
        return;
      }
      reject(new Error(request.statusText));
    };
    request.send(null);
  });
}
__name(fetchData, "fetchData");
var PageViewport = class _PageViewport {
  static {
    __name(this, "PageViewport");
  }
  constructor({
    viewBox,
    userUnit,
    scale,
    rotation,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  }) {
    this.viewBox = viewBox;
    this.userUnit = userUnit;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    scale *= userUnit;
    const centerX = (viewBox[2] + viewBox[0]) / 2;
    const centerY = (viewBox[3] + viewBox[1]) / 2;
    let rotateA, rotateB, rotateC, rotateD;
    rotation %= 360;
    if (rotation < 0) {
      rotation += 360;
    }
    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;
      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;
      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;
      case 0:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }
    let offsetCanvasX, offsetCanvasY;
    let width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = (viewBox[3] - viewBox[1]) * scale;
      height = (viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = (viewBox[2] - viewBox[0]) * scale;
      height = (viewBox[3] - viewBox[1]) * scale;
    }
    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
  }
  get rawDims() {
    const dims = this.viewBox;
    return shadow(this, "rawDims", {
      pageWidth: dims[2] - dims[0],
      pageHeight: dims[3] - dims[1],
      pageX: dims[0],
      pageY: dims[1]
    });
  }
  clone({
    scale = this.scale,
    rotation = this.rotation,
    offsetX = this.offsetX,
    offsetY = this.offsetY,
    dontFlip = false
  } = {}) {
    return new _PageViewport({
      viewBox: this.viewBox.slice(),
      userUnit: this.userUnit,
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }
  convertToViewportPoint(x3, y12) {
    const p15 = [x3, y12];
    Util.applyTransform(p15, this.transform);
    return p15;
  }
  convertToViewportRectangle(rect) {
    const topLeft = [rect[0], rect[1]];
    Util.applyTransform(topLeft, this.transform);
    const bottomRight = [rect[2], rect[3]];
    Util.applyTransform(bottomRight, this.transform);
    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
  }
  convertToPdfPoint(x3, y12) {
    const p15 = [x3, y12];
    Util.applyInverseTransform(p15, this.transform);
    return p15;
  }
};
var RenderingCancelledException = class extends BaseException {
  static {
    __name(this, "RenderingCancelledException");
  }
  constructor(msg, extraDelay = 0) {
    super(msg, "RenderingCancelledException");
    this.extraDelay = extraDelay;
  }
};
function isDataScheme(url) {
  const ii = url.length;
  let i18 = 0;
  while (i18 < ii && url[i18].trim() === "") {
    i18++;
  }
  return url.substring(i18, i18 + 5).toLowerCase() === "data:";
}
__name(isDataScheme, "isDataScheme");
function isPdfFile(filename) {
  return typeof filename === "string" && /\.pdf$/i.test(filename);
}
__name(isPdfFile, "isPdfFile");
function getFilenameFromUrl(url) {
  [url] = url.split(/[#?]/, 1);
  return url.substring(url.lastIndexOf("/") + 1);
}
__name(getFilenameFromUrl, "getFilenameFromUrl");
function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
  if (typeof url !== "string") {
    return defaultFilename;
  }
  if (isDataScheme(url)) {
    warn('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
    return defaultFilename;
  }
  const getURL = /* @__PURE__ */ __name((urlString) => {
    try {
      return new URL(urlString);
    } catch {
      try {
        return new URL(decodeURIComponent(urlString));
      } catch {
        try {
          return new URL(urlString, "https://foo.bar");
        } catch {
          try {
            return new URL(decodeURIComponent(urlString), "https://foo.bar");
          } catch {
            return null;
          }
        }
      }
    }
  }, "getURL");
  const newURL = getURL(url);
  if (!newURL) {
    return defaultFilename;
  }
  const decode2 = /* @__PURE__ */ __name((name4) => {
    try {
      let decoded = decodeURIComponent(name4);
      if (decoded.includes("/")) {
        decoded = decoded.split("/").at(-1);
        if (decoded.test(/^\.pdf$/i)) {
          return decoded;
        }
        return name4;
      }
      return decoded;
    } catch {
      return name4;
    }
  }, "decode");
  const pdfRegex = /\.pdf$/i;
  const filename = newURL.pathname.split("/").at(-1);
  if (pdfRegex.test(filename)) {
    return decode2(filename);
  }
  if (newURL.searchParams.size > 0) {
    const values = Array.from(newURL.searchParams.values()).reverse();
    for (const value of values) {
      if (pdfRegex.test(value)) {
        return decode2(value);
      }
    }
    const keys = Array.from(newURL.searchParams.keys()).reverse();
    for (const key of keys) {
      if (pdfRegex.test(key)) {
        return decode2(key);
      }
    }
  }
  if (newURL.hash) {
    const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
    const hashFilename = reFilename.exec(newURL.hash);
    if (hashFilename) {
      return decode2(hashFilename[0]);
    }
  }
  return defaultFilename;
}
__name(getPdfFilenameFromUrl, "getPdfFilenameFromUrl");
var StatTimer = class {
  static {
    __name(this, "StatTimer");
  }
  started = /* @__PURE__ */ Object.create(null);
  times = [];
  time(name4) {
    if (name4 in this.started) {
      warn(`Timer is already running for ${name4}`);
    }
    this.started[name4] = Date.now();
  }
  timeEnd(name4) {
    if (!(name4 in this.started)) {
      warn(`Timer has not been started for ${name4}`);
    }
    this.times.push({
      name: name4,
      start: this.started[name4],
      end: Date.now()
    });
    delete this.started[name4];
  }
  toString() {
    const outBuf = [];
    let longest = 0;
    for (const {
      name: name4
    } of this.times) {
      longest = Math.max(name4.length, longest);
    }
    for (const {
      name: name4,
      start,
      end
    } of this.times) {
      outBuf.push(`${name4.padEnd(longest)} ${end - start}ms
`);
    }
    return outBuf.join("");
  }
};
function isValidFetchUrl(url, baseUrl) {
  const res = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);
  return res?.protocol === "http:" || res?.protocol === "https:";
}
__name(isValidFetchUrl, "isValidFetchUrl");
function noContextMenu(e10) {
  e10.preventDefault();
}
__name(noContextMenu, "noContextMenu");
function stopEvent(e10) {
  e10.preventDefault();
  e10.stopPropagation();
}
__name(stopEvent, "stopEvent");
function deprecated(details) {
  console.log("Deprecated API usage: " + details);
}
__name(deprecated, "deprecated");
var PDFDateString = class {
  static {
    __name(this, "PDFDateString");
  }
  static #regex;
  static toDateObject(input) {
    if (input instanceof Date) {
      return input;
    }
    if (!input || typeof input !== "string") {
      return null;
    }
    this.#regex ||= new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
    const matches = this.#regex.exec(input);
    if (!matches) {
      return null;
    }
    const year = parseInt(matches[1], 10);
    let month = parseInt(matches[2], 10);
    month = month >= 1 && month <= 12 ? month - 1 : 0;
    let day = parseInt(matches[3], 10);
    day = day >= 1 && day <= 31 ? day : 1;
    let hour = parseInt(matches[4], 10);
    hour = hour >= 0 && hour <= 23 ? hour : 0;
    let minute = parseInt(matches[5], 10);
    minute = minute >= 0 && minute <= 59 ? minute : 0;
    let second = parseInt(matches[6], 10);
    second = second >= 0 && second <= 59 ? second : 0;
    const universalTimeRelation = matches[7] || "Z";
    let offsetHour = parseInt(matches[8], 10);
    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
    let offsetMinute = parseInt(matches[9], 10) || 0;
    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
    if (universalTimeRelation === "-") {
      hour += offsetHour;
      minute += offsetMinute;
    } else if (universalTimeRelation === "+") {
      hour -= offsetHour;
      minute -= offsetMinute;
    }
    return new Date(Date.UTC(year, month, day, hour, minute, second));
  }
};
function getXfaPageViewport(xfaPage, {
  scale = 1,
  rotation = 0
}) {
  const {
    width,
    height
  } = xfaPage.attributes.style;
  const viewBox = [0, 0, parseInt(width), parseInt(height)];
  return new PageViewport({
    viewBox,
    userUnit: 1,
    scale,
    rotation
  });
}
__name(getXfaPageViewport, "getXfaPageViewport");
function getRGB(color) {
  if (color.startsWith("#")) {
    const colorRGB = parseInt(color.slice(1), 16);
    return [(colorRGB & 16711680) >> 16, (colorRGB & 65280) >> 8, colorRGB & 255];
  }
  if (color.startsWith("rgb(")) {
    return color.slice(4, -1).split(",").map((x3) => parseInt(x3));
  }
  if (color.startsWith("rgba(")) {
    return color.slice(5, -1).split(",").map((x3) => parseInt(x3)).slice(0, 3);
  }
  warn(`Not a valid color format: "${color}"`);
  return [0, 0, 0];
}
__name(getRGB, "getRGB");
function getColorValues(colors) {
  const span = document.createElement("span");
  span.style.visibility = "hidden";
  span.style.colorScheme = "only light";
  document.body.append(span);
  for (const name4 of colors.keys()) {
    span.style.color = name4;
    const computedColor = window.getComputedStyle(span).color;
    colors.set(name4, getRGB(computedColor));
  }
  span.remove();
}
__name(getColorValues, "getColorValues");
function getCurrentTransform(ctx) {
  const {
    a: a22,
    b: b7,
    c: c21,
    d: d15,
    e: e10,
    f: f13
  } = ctx.getTransform();
  return [a22, b7, c21, d15, e10, f13];
}
__name(getCurrentTransform, "getCurrentTransform");
function getCurrentTransformInverse(ctx) {
  const {
    a: a22,
    b: b7,
    c: c21,
    d: d15,
    e: e10,
    f: f13
  } = ctx.getTransform().invertSelf();
  return [a22, b7, c21, d15, e10, f13];
}
__name(getCurrentTransformInverse, "getCurrentTransformInverse");
function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {
  if (viewport instanceof PageViewport) {
    const {
      pageWidth,
      pageHeight
    } = viewport.rawDims;
    const {
      style
    } = div;
    const useRound = util_FeatureTest.isCSSRoundSupported;
    const w4 = `var(--total-scale-factor) * ${pageWidth}px`, h12 = `var(--total-scale-factor) * ${pageHeight}px`;
    const widthStr = useRound ? `round(down, ${w4}, var(--scale-round-x))` : `calc(${w4})`, heightStr = useRound ? `round(down, ${h12}, var(--scale-round-y))` : `calc(${h12})`;
    if (!mustFlip || viewport.rotation % 180 === 0) {
      style.width = widthStr;
      style.height = heightStr;
    } else {
      style.width = heightStr;
      style.height = widthStr;
    }
  }
  if (mustRotate) {
    div.setAttribute("data-main-rotation", viewport.rotation);
  }
}
__name(setLayerDimensions, "setLayerDimensions");
var OutputScale = class _OutputScale {
  static {
    __name(this, "OutputScale");
  }
  constructor() {
    const {
      pixelRatio
    } = _OutputScale;
    this.sx = pixelRatio;
    this.sy = pixelRatio;
  }
  get scaled() {
    return this.sx !== 1 || this.sy !== 1;
  }
  get symmetric() {
    return this.sx === this.sy;
  }
  limitCanvas(width, height, maxPixels, maxDim, capAreaFactor = -1) {
    let maxAreaScale = Infinity, maxWidthScale = Infinity, maxHeightScale = Infinity;
    maxPixels = _OutputScale.capPixels(maxPixels, capAreaFactor);
    if (maxPixels > 0) {
      maxAreaScale = Math.sqrt(maxPixels / (width * height));
    }
    if (maxDim !== -1) {
      maxWidthScale = maxDim / width;
      maxHeightScale = maxDim / height;
    }
    const maxScale = Math.min(maxAreaScale, maxWidthScale, maxHeightScale);
    if (this.sx > maxScale || this.sy > maxScale) {
      this.sx = maxScale;
      this.sy = maxScale;
      return true;
    }
    return false;
  }
  static get pixelRatio() {
    return globalThis.devicePixelRatio || 1;
  }
  static capPixels(maxPixels, capAreaFactor) {
    if (capAreaFactor >= 0) {
      const winPixels = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + capAreaFactor / 100));
      return maxPixels > 0 ? Math.min(maxPixels, winPixels) : winPixels;
    }
    return maxPixels;
  }
};
var SupportedImageMimeTypes = ["image/apng", "image/avif", "image/bmp", "image/gif", "image/jpeg", "image/png", "image/svg+xml", "image/webp", "image/x-icon"];
var ColorScheme = class {
  static {
    __name(this, "ColorScheme");
  }
  static get isDarkMode() {
    return shadow(this, "isDarkMode", !!window?.matchMedia?.("(prefers-color-scheme: dark)").matches);
  }
};
var CSSConstants = class {
  static {
    __name(this, "CSSConstants");
  }
  static get commentForegroundColor() {
    const element = document.createElement("span");
    element.classList.add("comment", "sidebar");
    const {
      style
    } = element;
    style.width = style.height = "0";
    style.display = "none";
    style.color = "var(--comment-fg-color)";
    document.body.append(element);
    const {
      color
    } = window.getComputedStyle(element);
    element.remove();
    return shadow(this, "commentForegroundColor", getRGB(color));
  }
};
function applyOpacity(r9, g10, b7, opacity) {
  opacity = Math.min(Math.max(opacity ?? 1, 0), 1);
  const white = 255 * (1 - opacity);
  r9 = Math.round(r9 * opacity + white);
  g10 = Math.round(g10 * opacity + white);
  b7 = Math.round(b7 * opacity + white);
  return [r9, g10, b7];
}
__name(applyOpacity, "applyOpacity");
function RGBToHSL(rgb, output) {
  const r9 = rgb[0] / 255;
  const g10 = rgb[1] / 255;
  const b7 = rgb[2] / 255;
  const max = Math.max(r9, g10, b7);
  const min = Math.min(r9, g10, b7);
  const l14 = (max + min) / 2;
  if (max === min) {
    output[0] = output[1] = 0;
  } else {
    const d15 = max - min;
    output[1] = l14 < 0.5 ? d15 / (max + min) : d15 / (2 - max - min);
    switch (max) {
      case r9:
        output[0] = ((g10 - b7) / d15 + (g10 < b7 ? 6 : 0)) * 60;
        break;
      case g10:
        output[0] = ((b7 - r9) / d15 + 2) * 60;
        break;
      case b7:
        output[0] = ((r9 - g10) / d15 + 4) * 60;
        break;
    }
  }
  output[2] = l14;
}
__name(RGBToHSL, "RGBToHSL");
function HSLToRGB(hsl, output) {
  const h12 = hsl[0];
  const s18 = hsl[1];
  const l14 = hsl[2];
  const c21 = (1 - Math.abs(2 * l14 - 1)) * s18;
  const x3 = c21 * (1 - Math.abs(h12 / 60 % 2 - 1));
  const m18 = l14 - c21 / 2;
  switch (Math.floor(h12 / 60)) {
    case 0:
      output[0] = c21 + m18;
      output[1] = x3 + m18;
      output[2] = m18;
      break;
    case 1:
      output[0] = x3 + m18;
      output[1] = c21 + m18;
      output[2] = m18;
      break;
    case 2:
      output[0] = m18;
      output[1] = c21 + m18;
      output[2] = x3 + m18;
      break;
    case 3:
      output[0] = m18;
      output[1] = x3 + m18;
      output[2] = c21 + m18;
      break;
    case 4:
      output[0] = x3 + m18;
      output[1] = m18;
      output[2] = c21 + m18;
      break;
    case 5:
    case 6:
      output[0] = c21 + m18;
      output[1] = m18;
      output[2] = x3 + m18;
      break;
  }
}
__name(HSLToRGB, "HSLToRGB");
function computeLuminance(x3) {
  return x3 <= 0.03928 ? x3 / 12.92 : ((x3 + 0.055) / 1.055) ** 2.4;
}
__name(computeLuminance, "computeLuminance");
function contrastRatio(hsl1, hsl2, output) {
  HSLToRGB(hsl1, output);
  output.map(computeLuminance);
  const lum1 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];
  HSLToRGB(hsl2, output);
  output.map(computeLuminance);
  const lum2 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];
  return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);
}
__name(contrastRatio, "contrastRatio");
var contrastCache = /* @__PURE__ */ new Map();
function findContrastColor(baseColor, fixedColor) {
  const key = baseColor[0] + baseColor[1] * 256 + baseColor[2] * 65536 + fixedColor[0] * 16777216 + fixedColor[1] * 4294967296 + fixedColor[2] * 1099511627776;
  let cachedValue = contrastCache.get(key);
  if (cachedValue) {
    return cachedValue;
  }
  const array = new Float32Array(9);
  const output = array.subarray(0, 3);
  const baseHSL = array.subarray(3, 6);
  RGBToHSL(baseColor, baseHSL);
  const fixedHSL = array.subarray(6, 9);
  RGBToHSL(fixedColor, fixedHSL);
  const isFixedColorDark = fixedHSL[2] < 0.5;
  const minContrast = isFixedColorDark ? 12 : 4.5;
  baseHSL[2] = isFixedColorDark ? Math.sqrt(baseHSL[2]) : 1 - Math.sqrt(1 - baseHSL[2]);
  if (contrastRatio(baseHSL, fixedHSL, output) < minContrast) {
    let start, end;
    if (isFixedColorDark) {
      start = baseHSL[2];
      end = 1;
    } else {
      start = 0;
      end = baseHSL[2];
    }
    const PRECISION = 5e-3;
    while (end - start > PRECISION) {
      const mid = baseHSL[2] = (start + end) / 2;
      if (isFixedColorDark === contrastRatio(baseHSL, fixedHSL, output) < minContrast) {
        start = mid;
      } else {
        end = mid;
      }
    }
    baseHSL[2] = isFixedColorDark ? end : start;
  }
  HSLToRGB(baseHSL, output);
  cachedValue = Util.makeHexColor(Math.round(output[0] * 255), Math.round(output[1] * 255), Math.round(output[2] * 255));
  contrastCache.set(key, cachedValue);
  return cachedValue;
}
__name(findContrastColor, "findContrastColor");
function renderRichText({
  html,
  dir,
  className
}, container) {
  const fragment = document.createDocumentFragment();
  if (typeof html === "string") {
    const p15 = document.createElement("p");
    p15.dir = dir || "auto";
    const lines = html.split(/(?:\r\n?|\n)/);
    for (let i18 = 0, ii = lines.length; i18 < ii; ++i18) {
      const line = lines[i18];
      p15.append(document.createTextNode(line));
      if (i18 < ii - 1) {
        p15.append(document.createElement("br"));
      }
    }
    fragment.append(p15);
  } else {
    XfaLayer.render({
      xfaHtml: html,
      div: fragment,
      intent: "richText"
    });
  }
  fragment.firstChild.classList.add("richText", className);
  container.append(fragment);
}
__name(renderRichText, "renderRichText");
;
var EditorToolbar = class _EditorToolbar {
  static {
    __name(this, "EditorToolbar");
  }
  #toolbar = null;
  #colorPicker = null;
  #editor;
  #buttons = null;
  #altText = null;
  #comment = null;
  #commentButtonDivider = null;
  #signatureDescriptionButton = null;
  static #l10nRemove = null;
  constructor(editor) {
    this.#editor = editor;
    _EditorToolbar.#l10nRemove ||= Object.freeze({
      freetext: "pdfjs-editor-remove-freetext-button",
      highlight: "pdfjs-editor-remove-highlight-button",
      ink: "pdfjs-editor-remove-ink-button",
      stamp: "pdfjs-editor-remove-stamp-button",
      signature: "pdfjs-editor-remove-signature-button"
    });
  }
  render() {
    const editToolbar = this.#toolbar = document.createElement("div");
    editToolbar.classList.add("editToolbar", "hidden");
    editToolbar.setAttribute("role", "toolbar");
    const signal = this.#editor._uiManager._signal;
    if (signal instanceof AbortSignal && !signal.aborted) {
      editToolbar.addEventListener("contextmenu", noContextMenu, {
        signal
      });
      editToolbar.addEventListener("pointerdown", _EditorToolbar.#pointerDown, {
        signal
      });
    }
    const buttons = this.#buttons = document.createElement("div");
    buttons.className = "buttons";
    editToolbar.append(buttons);
    const position = this.#editor.toolbarPosition;
    if (position) {
      const {
        style
      } = editToolbar;
      const x3 = this.#editor._uiManager.direction === "ltr" ? 1 - position[0] : position[0];
      style.insetInlineEnd = `${100 * x3}%`;
      style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    return editToolbar;
  }
  get div() {
    return this.#toolbar;
  }
  static #pointerDown(e10) {
    e10.stopPropagation();
  }
  #focusIn(e10) {
    this.#editor._focusEventsAllowed = false;
    stopEvent(e10);
  }
  #focusOut(e10) {
    this.#editor._focusEventsAllowed = true;
    stopEvent(e10);
  }
  #addListenersToElement(element) {
    const signal = this.#editor._uiManager._signal;
    if (!(signal instanceof AbortSignal) || signal.aborted) {
      return false;
    }
    element.addEventListener("focusin", this.#focusIn.bind(this), {
      capture: true,
      signal
    });
    element.addEventListener("focusout", this.#focusOut.bind(this), {
      capture: true,
      signal
    });
    element.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    return true;
  }
  hide() {
    this.#toolbar.classList.add("hidden");
    this.#colorPicker?.hideDropdown();
  }
  show() {
    this.#toolbar.classList.remove("hidden");
    this.#altText?.shown();
    this.#comment?.shown();
  }
  addDeleteButton() {
    const {
      editorType,
      _uiManager
    } = this.#editor;
    const button = document.createElement("button");
    button.classList.add("basic", "deleteButton");
    button.tabIndex = 0;
    button.setAttribute("data-l10n-id", _EditorToolbar.#l10nRemove[editorType]);
    if (this.#addListenersToElement(button)) {
      button.addEventListener("click", (e10) => {
        _uiManager.delete();
      }, {
        signal: _uiManager._signal
      });
    }
    this.#buttons.append(button);
  }
  get #divider() {
    const divider = document.createElement("div");
    divider.className = "divider";
    return divider;
  }
  async addAltText(altText) {
    const button = await altText.render();
    this.#addListenersToElement(button);
    this.#buttons.append(button, this.#divider);
    this.#altText = altText;
  }
  addComment(comment, beforeElement = null) {
    if (this.#comment) {
      return;
    }
    const button = comment.renderForToolbar();
    if (!button) {
      return;
    }
    this.#addListenersToElement(button);
    const divider = this.#commentButtonDivider = this.#divider;
    if (!beforeElement) {
      this.#buttons.append(button, divider);
    } else {
      this.#buttons.insertBefore(button, beforeElement);
      this.#buttons.insertBefore(divider, beforeElement);
    }
    this.#comment = comment;
    comment.toolbar = this;
  }
  addColorPicker(colorPicker) {
    if (this.#colorPicker) {
      return;
    }
    this.#colorPicker = colorPicker;
    const button = colorPicker.renderButton();
    this.#addListenersToElement(button);
    this.#buttons.append(button, this.#divider);
  }
  async addEditSignatureButton(signatureManager) {
    const button = this.#signatureDescriptionButton = await signatureManager.renderEditButton(this.#editor);
    this.#addListenersToElement(button);
    this.#buttons.append(button, this.#divider);
  }
  removeButton(name4) {
    switch (name4) {
      case "comment":
        this.#comment?.removeToolbarCommentButton();
        this.#comment = null;
        this.#commentButtonDivider?.remove();
        this.#commentButtonDivider = null;
        break;
    }
  }
  async addButton(name4, tool) {
    switch (name4) {
      case "colorPicker":
        this.addColorPicker(tool);
        break;
      case "altText":
        await this.addAltText(tool);
        break;
      case "editSignature":
        await this.addEditSignatureButton(tool);
        break;
      case "delete":
        this.addDeleteButton();
        break;
      case "comment":
        this.addComment(tool);
        break;
    }
  }
  async addButtonBefore(name4, tool, beforeSelector) {
    const beforeElement = this.#buttons.querySelector(beforeSelector);
    if (!beforeElement) {
      return;
    }
    if (name4 === "comment") {
      this.addComment(tool, beforeElement);
    }
  }
  updateEditSignatureButton(description) {
    if (this.#signatureDescriptionButton) {
      this.#signatureDescriptionButton.title = description;
    }
  }
  remove() {
    this.#toolbar.remove();
    this.#colorPicker?.destroy();
    this.#colorPicker = null;
  }
};
var FloatingToolbar = class {
  static {
    __name(this, "FloatingToolbar");
  }
  #buttons = null;
  #toolbar = null;
  #uiManager;
  constructor(uiManager) {
    this.#uiManager = uiManager;
  }
  #render() {
    const editToolbar = this.#toolbar = document.createElement("div");
    editToolbar.className = "editToolbar";
    editToolbar.setAttribute("role", "toolbar");
    const signal = this.#uiManager._signal;
    if (signal instanceof AbortSignal && !signal.aborted) {
      editToolbar.addEventListener("contextmenu", noContextMenu, {
        signal
      });
    }
    const buttons = this.#buttons = document.createElement("div");
    buttons.className = "buttons";
    editToolbar.append(buttons);
    if (this.#uiManager.hasCommentManager()) {
      this.#makeButton("commentButton", `pdfjs-comment-floating-button`, "pdfjs-comment-floating-button-label", () => {
        this.#uiManager.commentSelection("floating_button");
      });
    }
    this.#makeButton("highlightButton", `pdfjs-highlight-floating-button1`, "pdfjs-highlight-floating-button-label", () => {
      this.#uiManager.highlightSelection("floating_button");
    });
    return editToolbar;
  }
  #getLastPoint(boxes, isLTR) {
    let lastY = 0;
    let lastX = 0;
    for (const box of boxes) {
      const y12 = box.y + box.height;
      if (y12 < lastY) {
        continue;
      }
      const x3 = box.x + (isLTR ? box.width : 0);
      if (y12 > lastY) {
        lastX = x3;
        lastY = y12;
        continue;
      }
      if (isLTR) {
        if (x3 > lastX) {
          lastX = x3;
        }
      } else if (x3 < lastX) {
        lastX = x3;
      }
    }
    return [isLTR ? 1 - lastX : lastX, lastY];
  }
  show(parent, boxes, isLTR) {
    const [x3, y12] = this.#getLastPoint(boxes, isLTR);
    const {
      style
    } = this.#toolbar ||= this.#render();
    parent.append(this.#toolbar);
    style.insetInlineEnd = `${100 * x3}%`;
    style.top = `calc(${100 * y12}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    this.#toolbar.remove();
  }
  #makeButton(buttonClass, l10nId, labelL10nId, clickHandler) {
    const button = document.createElement("button");
    button.classList.add("basic", buttonClass);
    button.tabIndex = 0;
    button.setAttribute("data-l10n-id", l10nId);
    const span = document.createElement("span");
    button.append(span);
    span.className = "visuallyHidden";
    span.setAttribute("data-l10n-id", labelL10nId);
    const signal = this.#uiManager._signal;
    if (signal instanceof AbortSignal && !signal.aborted) {
      button.addEventListener("contextmenu", noContextMenu, {
        signal
      });
      button.addEventListener("click", clickHandler, {
        signal
      });
    }
    this.#buttons.append(button);
  }
};
;
function bindEvents(obj, element, names) {
  for (const name4 of names) {
    element.addEventListener(name4, obj[name4].bind(obj));
  }
}
__name(bindEvents, "bindEvents");
var IdManager = class {
  static {
    __name(this, "IdManager");
  }
  #id = 0;
  get id() {
    return `${AnnotationEditorPrefix}${this.#id++}`;
  }
};
var ImageManager = class _ImageManager {
  static {
    __name(this, "ImageManager");
  }
  #baseId = getUuid();
  #id = 0;
  #cache = null;
  static get _isSVGFittingCanvas() {
    const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
    const canvas = new OffscreenCanvas(1, 3);
    const ctx = canvas.getContext("2d", {
      willReadFrequently: true
    });
    const image = new Image();
    image.src = svg;
    const promise = image.decode().then(() => {
      ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
      return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
    });
    return shadow(this, "_isSVGFittingCanvas", promise);
  }
  async #get(key, rawData) {
    this.#cache ||= /* @__PURE__ */ new Map();
    let data = this.#cache.get(key);
    if (data === null) {
      return null;
    }
    if (data?.bitmap) {
      data.refCounter += 1;
      return data;
    }
    try {
      data ||= {
        bitmap: null,
        id: `image_${this.#baseId}_${this.#id++}`,
        refCounter: 0,
        isSvg: false
      };
      let image;
      if (typeof rawData === "string") {
        data.url = rawData;
        image = await fetchData(rawData, "blob");
      } else if (rawData instanceof File) {
        image = data.file = rawData;
      } else if (rawData instanceof Blob) {
        image = rawData;
      }
      if (image.type === "image/svg+xml") {
        const mustRemoveAspectRatioPromise = _ImageManager._isSVGFittingCanvas;
        const fileReader = new FileReader();
        const imageElement = new Image();
        const imagePromise = new Promise((resolve, reject) => {
          imageElement.onload = () => {
            data.bitmap = imageElement;
            data.isSvg = true;
            resolve();
          };
          fileReader.onload = async () => {
            const url = data.svgUrl = fileReader.result;
            imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;
          };
          imageElement.onerror = fileReader.onerror = reject;
        });
        fileReader.readAsDataURL(image);
        await imagePromise;
      } else {
        data.bitmap = await createImageBitmap(image);
      }
      data.refCounter = 1;
    } catch (e10) {
      warn(e10);
      data = null;
    }
    this.#cache.set(key, data);
    if (data) {
      this.#cache.set(data.id, data);
    }
    return data;
  }
  async getFromFile(file) {
    const {
      lastModified,
      name: name4,
      size,
      type
    } = file;
    return this.#get(`${lastModified}_${name4}_${size}_${type}`, file);
  }
  async getFromUrl(url) {
    return this.#get(url, url);
  }
  async getFromBlob(id, blobPromise) {
    const blob = await blobPromise;
    return this.#get(id, blob);
  }
  async getFromId(id) {
    this.#cache ||= /* @__PURE__ */ new Map();
    const data = this.#cache.get(id);
    if (!data) {
      return null;
    }
    if (data.bitmap) {
      data.refCounter += 1;
      return data;
    }
    if (data.file) {
      return this.getFromFile(data.file);
    }
    if (data.blobPromise) {
      const {
        blobPromise
      } = data;
      delete data.blobPromise;
      return this.getFromBlob(data.id, blobPromise);
    }
    return this.getFromUrl(data.url);
  }
  getFromCanvas(id, canvas) {
    this.#cache ||= /* @__PURE__ */ new Map();
    let data = this.#cache.get(id);
    if (data?.bitmap) {
      data.refCounter += 1;
      return data;
    }
    const offscreen = new OffscreenCanvas(canvas.width, canvas.height);
    const ctx = offscreen.getContext("2d");
    ctx.drawImage(canvas, 0, 0);
    data = {
      bitmap: offscreen.transferToImageBitmap(),
      id: `image_${this.#baseId}_${this.#id++}`,
      refCounter: 1,
      isSvg: false
    };
    this.#cache.set(id, data);
    this.#cache.set(data.id, data);
    return data;
  }
  getSvgUrl(id) {
    const data = this.#cache.get(id);
    if (!data?.isSvg) {
      return null;
    }
    return data.svgUrl;
  }
  deleteId(id) {
    this.#cache ||= /* @__PURE__ */ new Map();
    const data = this.#cache.get(id);
    if (!data) {
      return;
    }
    data.refCounter -= 1;
    if (data.refCounter !== 0) {
      return;
    }
    const {
      bitmap
    } = data;
    if (!data.url && !data.file) {
      const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
      const ctx = canvas.getContext("bitmaprenderer");
      ctx.transferFromImageBitmap(bitmap);
      data.blobPromise = canvas.convertToBlob();
    }
    bitmap.close?.();
    data.bitmap = null;
  }
  isValidId(id) {
    return id.startsWith(`image_${this.#baseId}_`);
  }
};
var CommandManager = class {
  static {
    __name(this, "CommandManager");
  }
  #commands = [];
  #locked = false;
  #maxSize;
  #position = -1;
  constructor(maxSize = 128) {
    this.#maxSize = maxSize;
  }
  add({
    cmd,
    undo,
    post,
    mustExec,
    type = NaN,
    overwriteIfSameType = false,
    keepUndo = false
  }) {
    if (mustExec) {
      cmd();
    }
    if (this.#locked) {
      return;
    }
    const save = {
      cmd,
      undo,
      post,
      type
    };
    if (this.#position === -1) {
      if (this.#commands.length > 0) {
        this.#commands.length = 0;
      }
      this.#position = 0;
      this.#commands.push(save);
      return;
    }
    if (overwriteIfSameType && this.#commands[this.#position].type === type) {
      if (keepUndo) {
        save.undo = this.#commands[this.#position].undo;
      }
      this.#commands[this.#position] = save;
      return;
    }
    const next = this.#position + 1;
    if (next === this.#maxSize) {
      this.#commands.splice(0, 1);
    } else {
      this.#position = next;
      if (next < this.#commands.length) {
        this.#commands.splice(next);
      }
    }
    this.#commands.push(save);
  }
  undo() {
    if (this.#position === -1) {
      return;
    }
    this.#locked = true;
    const {
      undo,
      post
    } = this.#commands[this.#position];
    undo();
    post?.();
    this.#locked = false;
    this.#position -= 1;
  }
  redo() {
    if (this.#position < this.#commands.length - 1) {
      this.#position += 1;
      this.#locked = true;
      const {
        cmd,
        post
      } = this.#commands[this.#position];
      cmd();
      post?.();
      this.#locked = false;
    }
  }
  hasSomethingToUndo() {
    return this.#position !== -1;
  }
  hasSomethingToRedo() {
    return this.#position < this.#commands.length - 1;
  }
  cleanType(type) {
    if (this.#position === -1) {
      return;
    }
    for (let i18 = this.#position; i18 >= 0; i18--) {
      if (this.#commands[i18].type !== type) {
        this.#commands.splice(i18 + 1, this.#position - i18);
        this.#position = i18;
        return;
      }
    }
    this.#commands.length = 0;
    this.#position = -1;
  }
  destroy() {
    this.#commands = null;
  }
};
var KeyboardManager = class {
  static {
    __name(this, "KeyboardManager");
  }
  constructor(callbacks) {
    this.buffer = [];
    this.callbacks = /* @__PURE__ */ new Map();
    this.allKeys = /* @__PURE__ */ new Set();
    const {
      isMac
    } = util_FeatureTest.platform;
    for (const [keys, callback, options = {}] of callbacks) {
      for (const key of keys) {
        const isMacKey = key.startsWith("mac+");
        if (isMac && isMacKey) {
          this.callbacks.set(key.slice(4), {
            callback,
            options
          });
          this.allKeys.add(key.split("+").at(-1));
        } else if (!isMac && !isMacKey) {
          this.callbacks.set(key, {
            callback,
            options
          });
          this.allKeys.add(key.split("+").at(-1));
        }
      }
    }
  }
  #serialize(event) {
    if (event.altKey) {
      this.buffer.push("alt");
    }
    if (event.ctrlKey) {
      this.buffer.push("ctrl");
    }
    if (event.metaKey) {
      this.buffer.push("meta");
    }
    if (event.shiftKey) {
      this.buffer.push("shift");
    }
    this.buffer.push(event.key);
    const str = this.buffer.join("+");
    this.buffer.length = 0;
    return str;
  }
  exec(self2, event) {
    if (!this.allKeys.has(event.key)) {
      return;
    }
    const info2 = this.callbacks.get(this.#serialize(event));
    if (!info2) {
      return;
    }
    const {
      callback,
      options: {
        bubbles = false,
        args = [],
        checker = null
      }
    } = info2;
    if (checker && !checker(self2, event)) {
      return;
    }
    callback.bind(self2, ...args, event)();
    if (!bubbles) {
      stopEvent(event);
    }
  }
};
var ColorManager = class _ColorManager {
  static {
    __name(this, "ColorManager");
  }
  static _colorsMapping = /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]);
  get _colors() {
    const colors = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
    getColorValues(colors);
    return shadow(this, "_colors", colors);
  }
  convert(color) {
    const rgb = getRGB(color);
    if (!window.matchMedia("(forced-colors: active)").matches) {
      return rgb;
    }
    for (const [name4, RGB] of this._colors) {
      if (RGB.every((x3, i18) => x3 === rgb[i18])) {
        return _ColorManager._colorsMapping.get(name4);
      }
    }
    return rgb;
  }
  getHexCode(name4) {
    const rgb = this._colors.get(name4);
    if (!rgb) {
      return name4;
    }
    return Util.makeHexColor(...rgb);
  }
};
var AnnotationEditorUIManager = class _AnnotationEditorUIManager {
  static {
    __name(this, "AnnotationEditorUIManager");
  }
  #abortController = new AbortController();
  #activeEditor = null;
  #allEditableAnnotations = null;
  #allEditors = /* @__PURE__ */ new Map();
  #allLayers = /* @__PURE__ */ new Map();
  #altTextManager = null;
  #annotationStorage = null;
  #changedExistingAnnotations = null;
  #commandManager = new CommandManager();
  #commentManager = null;
  #copyPasteAC = null;
  #currentDrawingSession = null;
  #currentPageIndex = 0;
  #deletedAnnotationsElementIds = /* @__PURE__ */ new Set();
  #draggingEditors = null;
  #editorTypes = null;
  #editorsToRescale = /* @__PURE__ */ new Set();
  _editorUndoBar = null;
  #enableHighlightFloatingButton = false;
  #enableUpdatedAddImage = false;
  #enableNewAltTextWhenAddingImage = false;
  #filterFactory = null;
  #focusMainContainerTimeoutId = null;
  #focusManagerAC = null;
  #highlightColors = null;
  #highlightWhenShiftUp = false;
  #floatingToolbar = null;
  #idManager = new IdManager();
  #isEnabled = false;
  #isPointerDown = false;
  #isWaiting = false;
  #keyboardManagerAC = null;
  #lastActiveElement = null;
  #mainHighlightColorPicker = null;
  #missingCanvases = null;
  #mlManager = null;
  #mode = AnnotationEditorType.NONE;
  #selectedEditors = /* @__PURE__ */ new Set();
  #selectedTextNode = null;
  #signatureManager = null;
  #pageColors = null;
  #showAllStates = null;
  #pdfDocument = null;
  #previousStates = {
    isEditing: false,
    isEmpty: true,
    hasSomethingToUndo: false,
    hasSomethingToRedo: false,
    hasSelectedEditor: false,
    hasSelectedText: false
  };
  #translation = [0, 0];
  #translationTimeoutId = null;
  #container = null;
  #viewer = null;
  #viewerAlert = null;
  #updateModeCapability = null;
  static TRANSLATE_SMALL = 1;
  static TRANSLATE_BIG = 10;
  static get _keyboardManager() {
    const proto = _AnnotationEditorUIManager.prototype;
    const arrowChecker = /* @__PURE__ */ __name((self2) => self2.#container.contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && self2.hasSomethingToControl(), "arrowChecker");
    const textInputChecker = /* @__PURE__ */ __name((_self, {
      target: el
    }) => {
      if (el instanceof HTMLInputElement) {
        const {
          type
        } = el;
        return type !== "text" && type !== "number";
      }
      return true;
    }, "textInputChecker");
    const small = this.TRANSLATE_SMALL;
    const big = this.TRANSLATE_BIG;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], proto.selectAll, {
      checker: textInputChecker
    }], [["ctrl+z", "mac+meta+z"], proto.undo, {
      checker: textInputChecker
    }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], proto.redo, {
      checker: textInputChecker
    }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], proto.delete, {
      checker: textInputChecker
    }], [["Enter", "mac+Enter"], proto.addNewEditorFromKeyboard, {
      checker: /* @__PURE__ */ __name((self2, {
        target: el
      }) => !(el instanceof HTMLButtonElement) && self2.#container.contains(el) && !self2.isEnterHandled, "checker")
    }], [[" ", "mac+ "], proto.addNewEditorFromKeyboard, {
      checker: /* @__PURE__ */ __name((self2, {
        target: el
      }) => !(el instanceof HTMLButtonElement) && self2.#container.contains(document.activeElement), "checker")
    }], [["Escape", "mac+Escape"], proto.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], proto.translateSelectedEditors, {
      args: [-small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto.translateSelectedEditors, {
      args: [-big, 0],
      checker: arrowChecker
    }], [["ArrowRight", "mac+ArrowRight"], proto.translateSelectedEditors, {
      args: [small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto.translateSelectedEditors, {
      args: [big, 0],
      checker: arrowChecker
    }], [["ArrowUp", "mac+ArrowUp"], proto.translateSelectedEditors, {
      args: [0, -small],
      checker: arrowChecker
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto.translateSelectedEditors, {
      args: [0, -big],
      checker: arrowChecker
    }], [["ArrowDown", "mac+ArrowDown"], proto.translateSelectedEditors, {
      args: [0, small],
      checker: arrowChecker
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto.translateSelectedEditors, {
      args: [0, big],
      checker: arrowChecker
    }]]));
  }
  constructor(container, viewer, viewerAlert, altTextManager, commentManager, signatureManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom) {
    const signal = this._signal = this.#abortController.signal;
    this.#container = container;
    this.#viewer = viewer;
    this.#viewerAlert = viewerAlert;
    this.#altTextManager = altTextManager;
    this.#commentManager = commentManager;
    this.#signatureManager = signatureManager;
    this.#pdfDocument = pdfDocument;
    this._eventBus = eventBus;
    eventBus._on("editingaction", this.onEditingAction.bind(this), {
      signal
    });
    eventBus._on("pagechanging", this.onPageChanging.bind(this), {
      signal
    });
    eventBus._on("scalechanging", this.onScaleChanging.bind(this), {
      signal
    });
    eventBus._on("rotationchanging", this.onRotationChanging.bind(this), {
      signal
    });
    eventBus._on("setpreference", this.onSetPreference.bind(this), {
      signal
    });
    eventBus._on("switchannotationeditorparams", (evt) => this.updateParams(evt.type, evt.value), {
      signal
    });
    window.addEventListener("pointerdown", () => {
      this.#isPointerDown = true;
    }, {
      capture: true,
      signal
    });
    window.addEventListener("pointerup", () => {
      this.#isPointerDown = false;
    }, {
      capture: true,
      signal
    });
    this.#addSelectionListener();
    this.#addDragAndDropListeners();
    this.#addKeyboardManager();
    this.#annotationStorage = pdfDocument.annotationStorage;
    this.#filterFactory = pdfDocument.filterFactory;
    this.#pageColors = pageColors;
    this.#highlightColors = highlightColors || null;
    this.#enableHighlightFloatingButton = enableHighlightFloatingButton;
    this.#enableUpdatedAddImage = enableUpdatedAddImage;
    this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;
    this.#mlManager = mlManager || null;
    this.viewParameters = {
      realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
      rotation: 0
    };
    this.isShiftKeyDown = false;
    this._editorUndoBar = editorUndoBar || null;
    this._supportsPinchToZoom = supportsPinchToZoom !== false;
    commentManager?.setSidebarUiManager(this);
  }
  destroy() {
    this.#updateModeCapability?.resolve();
    this.#updateModeCapability = null;
    this.#abortController?.abort();
    this.#abortController = null;
    this._signal = null;
    for (const layer of this.#allLayers.values()) {
      layer.destroy();
    }
    this.#allLayers.clear();
    this.#allEditors.clear();
    this.#editorsToRescale.clear();
    this.#missingCanvases?.clear();
    this.#activeEditor = null;
    this.#selectedEditors.clear();
    this.#commandManager.destroy();
    this.#altTextManager?.destroy();
    this.#commentManager?.destroy();
    this.#signatureManager?.destroy();
    this.#floatingToolbar?.hide();
    this.#floatingToolbar = null;
    this.#mainHighlightColorPicker?.destroy();
    this.#mainHighlightColorPicker = null;
    this.#allEditableAnnotations = null;
    if (this.#focusMainContainerTimeoutId) {
      clearTimeout(this.#focusMainContainerTimeoutId);
      this.#focusMainContainerTimeoutId = null;
    }
    if (this.#translationTimeoutId) {
      clearTimeout(this.#translationTimeoutId);
      this.#translationTimeoutId = null;
    }
    this._editorUndoBar?.destroy();
    this.#pdfDocument = null;
  }
  combinedSignal(ac) {
    return AbortSignal.any([this._signal, ac.signal]);
  }
  get mlManager() {
    return this.#mlManager;
  }
  get useNewAltTextFlow() {
    return this.#enableUpdatedAddImage;
  }
  get useNewAltTextWhenAddingImage() {
    return this.#enableNewAltTextWhenAddingImage;
  }
  get hcmFilter() {
    return shadow(this, "hcmFilter", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : "none");
  }
  get direction() {
    return shadow(this, "direction", getComputedStyle(this.#container).direction);
  }
  get _highlightColors() {
    return shadow(this, "_highlightColors", this.#highlightColors ? new Map(this.#highlightColors.split(",").map((pair) => {
      pair = pair.split("=").map((x3) => x3.trim());
      pair[1] = pair[1].toUpperCase();
      return pair;
    })) : null);
  }
  get highlightColors() {
    const {
      _highlightColors
    } = this;
    if (!_highlightColors) {
      return shadow(this, "highlightColors", null);
    }
    const map2 = /* @__PURE__ */ new Map();
    const hasHCM = !!this.#pageColors;
    for (const [name4, color] of _highlightColors) {
      const isNameForHCM = name4.endsWith("_HCM");
      if (hasHCM && isNameForHCM) {
        map2.set(name4.replace("_HCM", ""), color);
        continue;
      }
      if (!hasHCM && !isNameForHCM) {
        map2.set(name4, color);
      }
    }
    return shadow(this, "highlightColors", map2);
  }
  get highlightColorNames() {
    return shadow(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e10) => e10.reverse())) : null);
  }
  getNonHCMColor(color) {
    if (!this._highlightColors) {
      return color;
    }
    const colorName = this.highlightColorNames.get(color);
    return this._highlightColors.get(colorName) || color;
  }
  getNonHCMColorName(color) {
    return this.highlightColorNames.get(color) || color;
  }
  setCurrentDrawingSession(layer) {
    if (layer) {
      this.unselectAll();
      this.disableUserSelect(true);
    } else {
      this.disableUserSelect(false);
    }
    this.#currentDrawingSession = layer;
  }
  setMainHighlightColorPicker(colorPicker) {
    this.#mainHighlightColorPicker = colorPicker;
  }
  editAltText(editor, firstTime = false) {
    this.#altTextManager?.editAltText(this, editor, firstTime);
  }
  hasCommentManager() {
    return !!this.#commentManager;
  }
  editComment(editor, posX, posY, options) {
    this.#commentManager?.showDialog(this, editor, posX, posY, options);
  }
  selectComment(pageIndex, uid) {
    const layer = this.#allLayers.get(pageIndex);
    const editor = layer?.getEditorByUID(uid);
    editor?.toggleComment(true, true);
  }
  updateComment(editor) {
    this.#commentManager?.updateComment(editor.getData());
  }
  updatePopupColor(editor) {
    this.#commentManager?.updatePopupColor(editor);
  }
  removeComment(editor) {
    this.#commentManager?.removeComments([editor.uid]);
  }
  toggleComment(editor, isSelected, visibility = void 0) {
    this.#commentManager?.toggleCommentPopup(editor, isSelected, visibility);
  }
  makeCommentColor(color, opacity) {
    return color && this.#commentManager?.makeCommentColor(color, opacity) || null;
  }
  getCommentDialogElement() {
    return this.#commentManager?.dialogElement || null;
  }
  async waitForEditorsRendered(pageNumber) {
    if (this.#allLayers.has(pageNumber - 1)) {
      return;
    }
    const {
      resolve,
      promise
    } = Promise.withResolvers();
    const onEditorsRendered = /* @__PURE__ */ __name((evt) => {
      if (evt.pageNumber === pageNumber) {
        this._eventBus._off("editorsrendered", onEditorsRendered);
        resolve();
      }
    }, "onEditorsRendered");
    this._eventBus.on("editorsrendered", onEditorsRendered);
    await promise;
  }
  getSignature(editor) {
    this.#signatureManager?.getSignature({
      uiManager: this,
      editor
    });
  }
  get signatureManager() {
    return this.#signatureManager;
  }
  switchToMode(mode, callback) {
    this._eventBus.on("annotationeditormodechanged", callback, {
      once: true,
      signal: this._signal
    });
    this._eventBus.dispatch("showannotationeditorui", {
      source: this,
      mode
    });
  }
  setPreference(name4, value) {
    this._eventBus.dispatch("setpreference", {
      source: this,
      name: name4,
      value
    });
  }
  onSetPreference({
    name: name4,
    value
  }) {
    switch (name4) {
      case "enableNewAltTextWhenAddingImage":
        this.#enableNewAltTextWhenAddingImage = value;
        break;
    }
  }
  onPageChanging({
    pageNumber
  }) {
    this.#currentPageIndex = pageNumber - 1;
  }
  focusMainContainer() {
    this.#container.focus();
  }
  findParent(x3, y12) {
    for (const layer of this.#allLayers.values()) {
      const {
        x: layerX,
        y: layerY,
        width,
        height
      } = layer.div.getBoundingClientRect();
      if (x3 >= layerX && x3 <= layerX + width && y12 >= layerY && y12 <= layerY + height) {
        return layer;
      }
    }
    return null;
  }
  disableUserSelect(value = false) {
    this.#viewer.classList.toggle("noUserSelect", value);
  }
  addShouldRescale(editor) {
    this.#editorsToRescale.add(editor);
  }
  removeShouldRescale(editor) {
    this.#editorsToRescale.delete(editor);
  }
  onScaleChanging({
    scale
  }) {
    this.commitOrRemove();
    this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
    for (const editor of this.#editorsToRescale) {
      editor.onScaleChanging();
    }
    this.#currentDrawingSession?.onScaleChanging();
  }
  onRotationChanging({
    pagesRotation
  }) {
    this.commitOrRemove();
    this.viewParameters.rotation = pagesRotation;
  }
  #getAnchorElementForSelection({
    anchorNode
  }) {
    return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;
  }
  #getLayerForTextLayer(textLayer) {
    const {
      currentLayer
    } = this;
    if (currentLayer.hasTextLayer(textLayer)) {
      return currentLayer;
    }
    for (const layer of this.#allLayers.values()) {
      if (layer.hasTextLayer(textLayer)) {
        return layer;
      }
    }
    return null;
  }
  highlightSelection(methodOfCreation = "", comment = false) {
    const selection = document.getSelection();
    if (!selection || selection.isCollapsed) {
      return;
    }
    const {
      anchorNode,
      anchorOffset,
      focusNode,
      focusOffset
    } = selection;
    const text = selection.toString();
    const anchorElement = this.#getAnchorElementForSelection(selection);
    const textLayer = anchorElement.closest(".textLayer");
    const boxes = this.getSelectionBoxes(textLayer);
    if (!boxes) {
      return;
    }
    selection.empty();
    const layer = this.#getLayerForTextLayer(textLayer);
    const isNoneMode = this.#mode === AnnotationEditorType.NONE;
    const callback = /* @__PURE__ */ __name(() => {
      const editor = layer?.createAndAddNewEditor({
        x: 0,
        y: 0
      }, false, {
        methodOfCreation,
        boxes,
        anchorNode,
        anchorOffset,
        focusNode,
        focusOffset,
        text
      });
      if (isNoneMode) {
        this.showAllEditors("highlight", true, true);
      }
      if (comment) {
        editor?.editComment();
      }
    }, "callback");
    if (isNoneMode) {
      this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);
      return;
    }
    callback();
  }
  commentSelection(methodOfCreation = "") {
    this.highlightSelection(methodOfCreation, true);
  }
  #displayFloatingToolbar() {
    const selection = document.getSelection();
    if (!selection || selection.isCollapsed) {
      return;
    }
    const anchorElement = this.#getAnchorElementForSelection(selection);
    const textLayer = anchorElement.closest(".textLayer");
    const boxes = this.getSelectionBoxes(textLayer);
    if (!boxes) {
      return;
    }
    this.#floatingToolbar ||= new FloatingToolbar(this);
    this.#floatingToolbar.show(textLayer, boxes, this.direction === "ltr");
  }
  getAndRemoveDataFromAnnotationStorage(annotationId) {
    if (!this.#annotationStorage) {
      return null;
    }
    const key = `${AnnotationEditorPrefix}${annotationId}`;
    const storedValue = this.#annotationStorage.getRawValue(key);
    if (storedValue) {
      this.#annotationStorage.remove(key);
    }
    return storedValue;
  }
  addToAnnotationStorage(editor) {
    if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {
      this.#annotationStorage.setValue(editor.id, editor);
    }
  }
  a11yAlert(messageId, args = null) {
    const viewerAlert = this.#viewerAlert;
    if (!viewerAlert) {
      return;
    }
    viewerAlert.setAttribute("data-l10n-id", messageId);
    if (args) {
      viewerAlert.setAttribute("data-l10n-args", JSON.stringify(args));
    } else {
      viewerAlert.removeAttribute("data-l10n-args");
    }
  }
  #selectionChange() {
    const selection = document.getSelection();
    if (!selection || selection.isCollapsed) {
      if (this.#selectedTextNode) {
        this.#floatingToolbar?.hide();
        this.#selectedTextNode = null;
        this.#dispatchUpdateStates({
          hasSelectedText: false
        });
      }
      return;
    }
    const {
      anchorNode
    } = selection;
    if (anchorNode === this.#selectedTextNode) {
      return;
    }
    const anchorElement = this.#getAnchorElementForSelection(selection);
    const textLayer = anchorElement.closest(".textLayer");
    if (!textLayer) {
      if (this.#selectedTextNode) {
        this.#floatingToolbar?.hide();
        this.#selectedTextNode = null;
        this.#dispatchUpdateStates({
          hasSelectedText: false
        });
      }
      return;
    }
    this.#floatingToolbar?.hide();
    this.#selectedTextNode = anchorNode;
    this.#dispatchUpdateStates({
      hasSelectedText: true
    });
    if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {
      return;
    }
    if (this.#mode === AnnotationEditorType.HIGHLIGHT) {
      this.showAllEditors("highlight", true, true);
    }
    this.#highlightWhenShiftUp = this.isShiftKeyDown;
    if (!this.isShiftKeyDown) {
      const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;
      activeLayer?.toggleDrawing();
      if (this.#isPointerDown) {
        const ac = new AbortController();
        const signal = this.combinedSignal(ac);
        const pointerup = /* @__PURE__ */ __name((e10) => {
          if (e10.type === "pointerup" && e10.button !== 0) {
            return;
          }
          ac.abort();
          activeLayer?.toggleDrawing(true);
          if (e10.type === "pointerup") {
            this.#onSelectEnd("main_toolbar");
          }
        }, "pointerup");
        window.addEventListener("pointerup", pointerup, {
          signal
        });
        window.addEventListener("blur", pointerup, {
          signal
        });
      } else {
        activeLayer?.toggleDrawing(true);
        this.#onSelectEnd("main_toolbar");
      }
    }
  }
  #onSelectEnd(methodOfCreation = "") {
    if (this.#mode === AnnotationEditorType.HIGHLIGHT) {
      this.highlightSelection(methodOfCreation);
    } else if (this.#enableHighlightFloatingButton) {
      this.#displayFloatingToolbar();
    }
  }
  #addSelectionListener() {
    document.addEventListener("selectionchange", this.#selectionChange.bind(this), {
      signal: this._signal
    });
  }
  #addFocusManager() {
    if (this.#focusManagerAC) {
      return;
    }
    this.#focusManagerAC = new AbortController();
    const signal = this.combinedSignal(this.#focusManagerAC);
    window.addEventListener("focus", this.focus.bind(this), {
      signal
    });
    window.addEventListener("blur", this.blur.bind(this), {
      signal
    });
  }
  #removeFocusManager() {
    this.#focusManagerAC?.abort();
    this.#focusManagerAC = null;
  }
  blur() {
    this.isShiftKeyDown = false;
    if (this.#highlightWhenShiftUp) {
      this.#highlightWhenShiftUp = false;
      this.#onSelectEnd("main_toolbar");
    }
    if (!this.hasSelection) {
      return;
    }
    const {
      activeElement
    } = document;
    for (const editor of this.#selectedEditors) {
      if (editor.div.contains(activeElement)) {
        this.#lastActiveElement = [editor, activeElement];
        editor._focusEventsAllowed = false;
        break;
      }
    }
  }
  focus() {
    if (!this.#lastActiveElement) {
      return;
    }
    const [lastEditor, lastActiveElement] = this.#lastActiveElement;
    this.#lastActiveElement = null;
    lastActiveElement.addEventListener("focusin", () => {
      lastEditor._focusEventsAllowed = true;
    }, {
      once: true,
      signal: this._signal
    });
    lastActiveElement.focus();
  }
  #addKeyboardManager() {
    if (this.#keyboardManagerAC) {
      return;
    }
    this.#keyboardManagerAC = new AbortController();
    const signal = this.combinedSignal(this.#keyboardManagerAC);
    window.addEventListener("keydown", this.keydown.bind(this), {
      signal
    });
    window.addEventListener("keyup", this.keyup.bind(this), {
      signal
    });
  }
  #removeKeyboardManager() {
    this.#keyboardManagerAC?.abort();
    this.#keyboardManagerAC = null;
  }
  #addCopyPasteListeners() {
    if (this.#copyPasteAC) {
      return;
    }
    this.#copyPasteAC = new AbortController();
    const signal = this.combinedSignal(this.#copyPasteAC);
    document.addEventListener("copy", this.copy.bind(this), {
      signal
    });
    document.addEventListener("cut", this.cut.bind(this), {
      signal
    });
    document.addEventListener("paste", this.paste.bind(this), {
      signal
    });
  }
  #removeCopyPasteListeners() {
    this.#copyPasteAC?.abort();
    this.#copyPasteAC = null;
  }
  #addDragAndDropListeners() {
    const signal = this._signal;
    document.addEventListener("dragover", this.dragOver.bind(this), {
      signal
    });
    document.addEventListener("drop", this.drop.bind(this), {
      signal
    });
  }
  addEditListeners() {
    this.#addKeyboardManager();
    this.#addCopyPasteListeners();
  }
  removeEditListeners() {
    this.#removeKeyboardManager();
    this.#removeCopyPasteListeners();
  }
  dragOver(event) {
    for (const {
      type
    } of event.dataTransfer.items) {
      for (const editorType of this.#editorTypes) {
        if (editorType.isHandlingMimeForPasting(type)) {
          event.dataTransfer.dropEffect = "copy";
          event.preventDefault();
          return;
        }
      }
    }
  }
  drop(event) {
    for (const item of event.dataTransfer.items) {
      for (const editorType of this.#editorTypes) {
        if (editorType.isHandlingMimeForPasting(item.type)) {
          editorType.paste(item, this.currentLayer);
          event.preventDefault();
          return;
        }
      }
    }
  }
  copy(event) {
    event.preventDefault();
    this.#activeEditor?.commitOrRemove();
    if (!this.hasSelection) {
      return;
    }
    const editors = [];
    for (const editor of this.#selectedEditors) {
      const serialized = editor.serialize(true);
      if (serialized) {
        editors.push(serialized);
      }
    }
    if (editors.length === 0) {
      return;
    }
    event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
  }
  cut(event) {
    this.copy(event);
    this.delete();
  }
  async paste(event) {
    event.preventDefault();
    const {
      clipboardData
    } = event;
    for (const item of clipboardData.items) {
      for (const editorType of this.#editorTypes) {
        if (editorType.isHandlingMimeForPasting(item.type)) {
          editorType.paste(item, this.currentLayer);
          return;
        }
      }
    }
    let data = clipboardData.getData("application/pdfjs");
    if (!data) {
      return;
    }
    try {
      data = JSON.parse(data);
    } catch (ex) {
      warn(`paste: "${ex.message}".`);
      return;
    }
    if (!Array.isArray(data)) {
      return;
    }
    this.unselectAll();
    const layer = this.currentLayer;
    try {
      const newEditors = [];
      for (const editor of data) {
        const deserializedEditor = await layer.deserialize(editor);
        if (!deserializedEditor) {
          return;
        }
        newEditors.push(deserializedEditor);
      }
      const cmd = /* @__PURE__ */ __name(() => {
        for (const editor of newEditors) {
          this.#addEditorToLayer(editor);
        }
        this.#selectEditors(newEditors);
      }, "cmd");
      const undo = /* @__PURE__ */ __name(() => {
        for (const editor of newEditors) {
          editor.remove();
        }
      }, "undo");
      this.addCommands({
        cmd,
        undo,
        mustExec: true
      });
    } catch (ex) {
      warn(`paste: "${ex.message}".`);
    }
  }
  keydown(event) {
    if (!this.isShiftKeyDown && event.key === "Shift") {
      this.isShiftKeyDown = true;
    }
    if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {
      _AnnotationEditorUIManager._keyboardManager.exec(this, event);
    }
  }
  keyup(event) {
    if (this.isShiftKeyDown && event.key === "Shift") {
      this.isShiftKeyDown = false;
      if (this.#highlightWhenShiftUp) {
        this.#highlightWhenShiftUp = false;
        this.#onSelectEnd("main_toolbar");
      }
    }
  }
  onEditingAction({
    name: name4
  }) {
    switch (name4) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[name4]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
        break;
      case "commentSelection":
        this.commentSelection("context_menu");
        break;
    }
  }
  #dispatchUpdateStates(details) {
    const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);
    if (hasChanged) {
      this._eventBus.dispatch("annotationeditorstateschanged", {
        source: this,
        details: Object.assign(this.#previousStates, details)
      });
      if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {
        this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_FREE, true]]);
      }
    }
  }
  #dispatchUpdateUI(details) {
    this._eventBus.dispatch("annotationeditorparamschanged", {
      source: this,
      details
    });
  }
  setEditingState(isEditing) {
    if (isEditing) {
      this.#addFocusManager();
      this.#addCopyPasteListeners();
      this.#dispatchUpdateStates({
        isEditing: this.#mode !== AnnotationEditorType.NONE,
        isEmpty: this.#isEmpty(),
        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
        hasSelectedEditor: false
      });
    } else {
      this.#removeFocusManager();
      this.#removeCopyPasteListeners();
      this.#dispatchUpdateStates({
        isEditing: false
      });
      this.disableUserSelect(false);
    }
  }
  registerEditorTypes(types) {
    if (this.#editorTypes) {
      return;
    }
    this.#editorTypes = types;
    for (const editorType of this.#editorTypes) {
      this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return this.#idManager.id;
  }
  get currentLayer() {
    return this.#allLayers.get(this.#currentPageIndex);
  }
  getLayer(pageIndex) {
    return this.#allLayers.get(pageIndex);
  }
  get currentPageIndex() {
    return this.#currentPageIndex;
  }
  addLayer(layer) {
    this.#allLayers.set(layer.pageIndex, layer);
    if (this.#isEnabled) {
      layer.enable();
    } else {
      layer.disable();
    }
  }
  removeLayer(layer) {
    this.#allLayers.delete(layer.pageIndex);
  }
  async updateMode(mode, editId = null, isFromKeyboard = false, mustEnterInEditMode = false, editComment = false) {
    if (this.#mode === mode) {
      return;
    }
    if (this.#updateModeCapability) {
      await this.#updateModeCapability.promise;
      if (!this.#updateModeCapability) {
        return;
      }
    }
    this.#updateModeCapability = Promise.withResolvers();
    this.#currentDrawingSession?.commitOrRemove();
    if (this.#mode === AnnotationEditorType.POPUP) {
      this.#commentManager?.hideSidebar();
    }
    this.#commentManager?.destroyPopup();
    this.#mode = mode;
    if (mode === AnnotationEditorType.NONE) {
      this.setEditingState(false);
      this.#disableAll();
      for (const editor of this.#allEditors.values()) {
        editor.hideStandaloneCommentButton();
      }
      this._editorUndoBar?.hide();
      this.toggleComment(null);
      this.#updateModeCapability.resolve();
      return;
    }
    for (const editor of this.#allEditors.values()) {
      editor.addStandaloneCommentButton();
    }
    if (mode === AnnotationEditorType.SIGNATURE) {
      await this.#signatureManager?.loadSignatures();
    }
    this.setEditingState(true);
    await this.#enableAll();
    this.unselectAll();
    for (const layer of this.#allLayers.values()) {
      layer.updateMode(mode);
    }
    if (mode === AnnotationEditorType.POPUP) {
      this.#allEditableAnnotations ||= await this.#pdfDocument.getAnnotationsByType(new Set(this.#editorTypes.map((editorClass) => editorClass._editorType)));
      const elementIds = /* @__PURE__ */ new Set();
      const allComments = [];
      for (const editor of this.#allEditors.values()) {
        const {
          annotationElementId,
          hasComment,
          deleted
        } = editor;
        if (annotationElementId) {
          elementIds.add(annotationElementId);
        }
        if (hasComment && !deleted) {
          allComments.push(editor.getData());
        }
      }
      for (const annotation of this.#allEditableAnnotations) {
        const {
          id,
          popupRef,
          contentsObj
        } = annotation;
        if (popupRef && contentsObj?.str && !elementIds.has(id) && !this.#deletedAnnotationsElementIds.has(id)) {
          allComments.push(annotation);
        }
      }
      this.#commentManager?.showSidebar(allComments);
    }
    if (!editId) {
      if (isFromKeyboard) {
        this.addNewEditorFromKeyboard();
      }
      this.#updateModeCapability.resolve();
      return;
    }
    for (const editor of this.#allEditors.values()) {
      if (editor.uid === editId) {
        this.setSelected(editor);
        if (editComment) {
          editor.editComment();
        } else if (mustEnterInEditMode) {
          editor.enterInEditMode();
        } else {
          editor.focus();
        }
      } else {
        editor.unselect();
      }
    }
    this.#updateModeCapability.resolve();
  }
  addNewEditorFromKeyboard() {
    if (this.currentLayer.canCreateNewEmptyEditor()) {
      this.currentLayer.addNewEditor();
    }
  }
  updateToolbar(options) {
    if (options.mode === this.#mode) {
      return;
    }
    this._eventBus.dispatch("switchannotationeditormode", {
      source: this,
      ...options
    });
  }
  updateParams(type, value) {
    if (!this.#editorTypes) {
      return;
    }
    switch (type) {
      case AnnotationEditorParamsType.CREATE:
        this.currentLayer.addNewEditor(value);
        return;
      case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:
        this._eventBus.dispatch("reporttelemetry", {
          source: this,
          details: {
            type: "editing",
            data: {
              type: "highlight",
              action: "toggle_visibility"
            }
          }
        });
        (this.#showAllStates ||= /* @__PURE__ */ new Map()).set(type, value);
        this.showAllEditors("highlight", value);
        break;
    }
    if (this.hasSelection) {
      for (const editor of this.#selectedEditors) {
        editor.updateParams(type, value);
      }
    } else {
      for (const editorType of this.#editorTypes) {
        editorType.updateDefaultParams(type, value);
      }
    }
  }
  showAllEditors(type, visible, updateButton = false) {
    for (const editor of this.#allEditors.values()) {
      if (editor.editorType === type) {
        editor.show(visible);
      }
    }
    const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;
    if (state !== visible) {
      this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, visible]]);
    }
  }
  enableWaiting(mustWait = false) {
    if (this.#isWaiting === mustWait) {
      return;
    }
    this.#isWaiting = mustWait;
    for (const layer of this.#allLayers.values()) {
      if (mustWait) {
        layer.disableClick();
      } else {
        layer.enableClick();
      }
      layer.div.classList.toggle("waiting", mustWait);
    }
  }
  async #enableAll() {
    if (!this.#isEnabled) {
      this.#isEnabled = true;
      const promises = [];
      for (const layer of this.#allLayers.values()) {
        promises.push(layer.enable());
      }
      await Promise.all(promises);
      for (const editor of this.#allEditors.values()) {
        editor.enable();
      }
    }
  }
  #disableAll() {
    this.unselectAll();
    if (this.#isEnabled) {
      this.#isEnabled = false;
      for (const layer of this.#allLayers.values()) {
        layer.disable();
      }
      for (const editor of this.#allEditors.values()) {
        editor.disable();
      }
    }
  }
  *getEditors(pageIndex) {
    for (const editor of this.#allEditors.values()) {
      if (editor.pageIndex === pageIndex) {
        yield editor;
      }
    }
  }
  getEditor(id) {
    return this.#allEditors.get(id);
  }
  addEditor(editor) {
    this.#allEditors.set(editor.id, editor);
  }
  removeEditor(editor) {
    if (editor.div.contains(document.activeElement)) {
      if (this.#focusMainContainerTimeoutId) {
        clearTimeout(this.#focusMainContainerTimeoutId);
      }
      this.#focusMainContainerTimeoutId = setTimeout(() => {
        this.focusMainContainer();
        this.#focusMainContainerTimeoutId = null;
      }, 0);
    }
    this.#allEditors.delete(editor.id);
    if (editor.annotationElementId) {
      this.#missingCanvases?.delete(editor.annotationElementId);
    }
    this.unselect(editor);
    if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {
      this.#annotationStorage?.remove(editor.id);
    }
  }
  addDeletedAnnotationElement(editor) {
    this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
    this.addChangedExistingAnnotation(editor);
    editor.deleted = true;
  }
  isDeletedAnnotationElement(annotationElementId) {
    return this.#deletedAnnotationsElementIds.has(annotationElementId);
  }
  removeDeletedAnnotationElement(editor) {
    this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
    this.removeChangedExistingAnnotation(editor);
    editor.deleted = false;
  }
  #addEditorToLayer(editor) {
    const layer = this.#allLayers.get(editor.pageIndex);
    if (layer) {
      layer.addOrRebuild(editor);
    } else {
      this.addEditor(editor);
      this.addToAnnotationStorage(editor);
    }
  }
  setActiveEditor(editor) {
    if (this.#activeEditor === editor) {
      return;
    }
    this.#activeEditor = editor;
    if (editor) {
      this.#dispatchUpdateUI(editor.propertiesToUpdate);
    }
  }
  get #lastSelectedEditor() {
    let ed = null;
    for (ed of this.#selectedEditors) {
    }
    return ed;
  }
  updateUI(editor) {
    if (this.#lastSelectedEditor === editor) {
      this.#dispatchUpdateUI(editor.propertiesToUpdate);
    }
  }
  updateUIForDefaultProperties(editorType) {
    this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
  }
  toggleSelected(editor) {
    if (this.#selectedEditors.has(editor)) {
      this.#selectedEditors.delete(editor);
      editor.unselect();
      this.#dispatchUpdateStates({
        hasSelectedEditor: this.hasSelection
      });
      return;
    }
    this.#selectedEditors.add(editor);
    editor.select();
    this.#dispatchUpdateUI(editor.propertiesToUpdate);
    this.#dispatchUpdateStates({
      hasSelectedEditor: true
    });
  }
  setSelected(editor) {
    this.updateToolbar({
      mode: editor.mode,
      editId: editor.id
    });
    this.#currentDrawingSession?.commitOrRemove();
    for (const ed of this.#selectedEditors) {
      if (ed !== editor) {
        ed.unselect();
      }
    }
    this.#selectedEditors.clear();
    this.#selectedEditors.add(editor);
    editor.select();
    this.#dispatchUpdateUI(editor.propertiesToUpdate);
    this.#dispatchUpdateStates({
      hasSelectedEditor: true
    });
  }
  isSelected(editor) {
    return this.#selectedEditors.has(editor);
  }
  get firstSelectedEditor() {
    return this.#selectedEditors.values().next().value;
  }
  unselect(editor) {
    editor.unselect();
    this.#selectedEditors.delete(editor);
    this.#dispatchUpdateStates({
      hasSelectedEditor: this.hasSelection
    });
  }
  get hasSelection() {
    return this.#selectedEditors.size !== 0;
  }
  get isEnterHandled() {
    return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    this.#commandManager.undo();
    this.#dispatchUpdateStates({
      hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
      hasSomethingToRedo: true,
      isEmpty: this.#isEmpty()
    });
    this._editorUndoBar?.hide();
  }
  redo() {
    this.#commandManager.redo();
    this.#dispatchUpdateStates({
      hasSomethingToUndo: true,
      hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
      isEmpty: this.#isEmpty()
    });
  }
  addCommands(params) {
    this.#commandManager.add(params);
    this.#dispatchUpdateStates({
      hasSomethingToUndo: true,
      hasSomethingToRedo: false,
      isEmpty: this.#isEmpty()
    });
  }
  cleanUndoStack(type) {
    this.#commandManager.cleanType(type);
  }
  #isEmpty() {
    if (this.#allEditors.size === 0) {
      return true;
    }
    if (this.#allEditors.size === 1) {
      for (const editor of this.#allEditors.values()) {
        return editor.isEmpty();
      }
    }
    return false;
  }
  delete() {
    this.commitOrRemove();
    const drawingEditor = this.currentLayer?.endDrawingSession(true);
    if (!this.hasSelection && !drawingEditor) {
      return;
    }
    const editors = drawingEditor ? [drawingEditor] : [...this.#selectedEditors];
    const cmd = /* @__PURE__ */ __name(() => {
      this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);
      for (const editor of editors) {
        editor.remove();
      }
    }, "cmd");
    const undo = /* @__PURE__ */ __name(() => {
      for (const editor of editors) {
        this.#addEditorToLayer(editor);
      }
    }, "undo");
    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }
  commitOrRemove() {
    this.#activeEditor?.commitOrRemove();
  }
  hasSomethingToControl() {
    return this.#activeEditor || this.hasSelection;
  }
  #selectEditors(editors) {
    for (const editor of this.#selectedEditors) {
      editor.unselect();
    }
    this.#selectedEditors.clear();
    for (const editor of editors) {
      if (editor.isEmpty()) {
        continue;
      }
      this.#selectedEditors.add(editor);
      editor.select();
    }
    this.#dispatchUpdateStates({
      hasSelectedEditor: this.hasSelection
    });
  }
  selectAll() {
    for (const editor of this.#selectedEditors) {
      editor.commit();
    }
    this.#selectEditors(this.#allEditors.values());
  }
  unselectAll() {
    if (this.#activeEditor) {
      this.#activeEditor.commitOrRemove();
      if (this.#mode !== AnnotationEditorType.NONE) {
        return;
      }
    }
    if (this.#currentDrawingSession?.commitOrRemove()) {
      return;
    }
    if (!this.hasSelection) {
      return;
    }
    for (const editor of this.#selectedEditors) {
      editor.unselect();
    }
    this.#selectedEditors.clear();
    this.#dispatchUpdateStates({
      hasSelectedEditor: false
    });
  }
  translateSelectedEditors(x3, y12, noCommit = false) {
    if (!noCommit) {
      this.commitOrRemove();
    }
    if (!this.hasSelection) {
      return;
    }
    this.#translation[0] += x3;
    this.#translation[1] += y12;
    const [totalX, totalY] = this.#translation;
    const editors = [...this.#selectedEditors];
    const TIME_TO_WAIT = 1e3;
    if (this.#translationTimeoutId) {
      clearTimeout(this.#translationTimeoutId);
    }
    this.#translationTimeoutId = setTimeout(() => {
      this.#translationTimeoutId = null;
      this.#translation[0] = this.#translation[1] = 0;
      this.addCommands({
        cmd: /* @__PURE__ */ __name(() => {
          for (const editor of editors) {
            if (this.#allEditors.has(editor.id)) {
              editor.translateInPage(totalX, totalY);
              editor.translationDone();
            }
          }
        }, "cmd"),
        undo: /* @__PURE__ */ __name(() => {
          for (const editor of editors) {
            if (this.#allEditors.has(editor.id)) {
              editor.translateInPage(-totalX, -totalY);
              editor.translationDone();
            }
          }
        }, "undo"),
        mustExec: false
      });
    }, TIME_TO_WAIT);
    for (const editor of editors) {
      editor.translateInPage(x3, y12);
      editor.translationDone();
    }
  }
  setUpDragSession() {
    if (!this.hasSelection) {
      return;
    }
    this.disableUserSelect(true);
    this.#draggingEditors = /* @__PURE__ */ new Map();
    for (const editor of this.#selectedEditors) {
      this.#draggingEditors.set(editor, {
        savedX: editor.x,
        savedY: editor.y,
        savedPageIndex: editor.pageIndex,
        newX: 0,
        newY: 0,
        newPageIndex: -1
      });
    }
  }
  endDragSession() {
    if (!this.#draggingEditors) {
      return false;
    }
    this.disableUserSelect(false);
    const map2 = this.#draggingEditors;
    this.#draggingEditors = null;
    let mustBeAddedInUndoStack = false;
    for (const [{
      x: x3,
      y: y12,
      pageIndex
    }, value] of map2) {
      value.newX = x3;
      value.newY = y12;
      value.newPageIndex = pageIndex;
      mustBeAddedInUndoStack ||= x3 !== value.savedX || y12 !== value.savedY || pageIndex !== value.savedPageIndex;
    }
    if (!mustBeAddedInUndoStack) {
      return false;
    }
    const move = /* @__PURE__ */ __name((editor, x3, y12, pageIndex) => {
      if (this.#allEditors.has(editor.id)) {
        const parent = this.#allLayers.get(pageIndex);
        if (parent) {
          editor._setParentAndPosition(parent, x3, y12);
        } else {
          editor.pageIndex = pageIndex;
          editor.x = x3;
          editor.y = y12;
        }
      }
    }, "move");
    this.addCommands({
      cmd: /* @__PURE__ */ __name(() => {
        for (const [editor, {
          newX,
          newY,
          newPageIndex
        }] of map2) {
          move(editor, newX, newY, newPageIndex);
        }
      }, "cmd"),
      undo: /* @__PURE__ */ __name(() => {
        for (const [editor, {
          savedX,
          savedY,
          savedPageIndex
        }] of map2) {
          move(editor, savedX, savedY, savedPageIndex);
        }
      }, "undo"),
      mustExec: true
    });
    return true;
  }
  dragSelectedEditors(tx, ty) {
    if (!this.#draggingEditors) {
      return;
    }
    for (const editor of this.#draggingEditors.keys()) {
      editor.drag(tx, ty);
    }
  }
  rebuild(editor) {
    if (editor.parent === null) {
      const parent = this.getLayer(editor.pageIndex);
      if (parent) {
        parent.changeParent(editor);
        parent.addOrRebuild(editor);
      } else {
        this.addEditor(editor);
        this.addToAnnotationStorage(editor);
        editor.rebuild();
      }
    } else {
      editor.parent.addOrRebuild(editor);
    }
  }
  get isEditorHandlingKeyboard() {
    return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(editor) {
    return this.#activeEditor === editor;
  }
  getActive() {
    return this.#activeEditor;
  }
  getMode() {
    return this.#mode;
  }
  isEditingMode() {
    return this.#mode !== AnnotationEditorType.NONE;
  }
  get imageManager() {
    return shadow(this, "imageManager", new ImageManager());
  }
  getSelectionBoxes(textLayer) {
    if (!textLayer) {
      return null;
    }
    const selection = document.getSelection();
    for (let i18 = 0, ii = selection.rangeCount; i18 < ii; i18++) {
      if (!textLayer.contains(selection.getRangeAt(i18).commonAncestorContainer)) {
        return null;
      }
    }
    const {
      x: layerX,
      y: layerY,
      width: parentWidth,
      height: parentHeight
    } = textLayer.getBoundingClientRect();
    let rotator;
    switch (textLayer.getAttribute("data-main-rotation")) {
      case "90":
        rotator = /* @__PURE__ */ __name((x3, y12, w4, h12) => ({
          x: (y12 - layerY) / parentHeight,
          y: 1 - (x3 + w4 - layerX) / parentWidth,
          width: h12 / parentHeight,
          height: w4 / parentWidth
        }), "rotator");
        break;
      case "180":
        rotator = /* @__PURE__ */ __name((x3, y12, w4, h12) => ({
          x: 1 - (x3 + w4 - layerX) / parentWidth,
          y: 1 - (y12 + h12 - layerY) / parentHeight,
          width: w4 / parentWidth,
          height: h12 / parentHeight
        }), "rotator");
        break;
      case "270":
        rotator = /* @__PURE__ */ __name((x3, y12, w4, h12) => ({
          x: 1 - (y12 + h12 - layerY) / parentHeight,
          y: (x3 - layerX) / parentWidth,
          width: h12 / parentHeight,
          height: w4 / parentWidth
        }), "rotator");
        break;
      default:
        rotator = /* @__PURE__ */ __name((x3, y12, w4, h12) => ({
          x: (x3 - layerX) / parentWidth,
          y: (y12 - layerY) / parentHeight,
          width: w4 / parentWidth,
          height: h12 / parentHeight
        }), "rotator");
        break;
    }
    const boxes = [];
    for (let i18 = 0, ii = selection.rangeCount; i18 < ii; i18++) {
      const range = selection.getRangeAt(i18);
      if (range.collapsed) {
        continue;
      }
      for (const {
        x: x3,
        y: y12,
        width,
        height
      } of range.getClientRects()) {
        if (width === 0 || height === 0) {
          continue;
        }
        boxes.push(rotator(x3, y12, width, height));
      }
    }
    return boxes.length === 0 ? null : boxes;
  }
  addChangedExistingAnnotation({
    annotationElementId,
    id
  }) {
    (this.#changedExistingAnnotations ||= /* @__PURE__ */ new Map()).set(annotationElementId, id);
  }
  removeChangedExistingAnnotation({
    annotationElementId
  }) {
    this.#changedExistingAnnotations?.delete(annotationElementId);
  }
  renderAnnotationElement(annotation) {
    const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);
    if (!editorId) {
      return;
    }
    const editor = this.#annotationStorage.getRawValue(editorId);
    if (!editor) {
      return;
    }
    if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {
      return;
    }
    editor.renderAnnotationElement(annotation);
  }
  setMissingCanvas(annotationId, annotationElementId, canvas) {
    const editor = this.#missingCanvases?.get(annotationId);
    if (!editor) {
      return;
    }
    editor.setCanvas(annotationElementId, canvas);
    this.#missingCanvases.delete(annotationId);
  }
  addMissingCanvas(annotationId, editor) {
    (this.#missingCanvases ||= /* @__PURE__ */ new Map()).set(annotationId, editor);
  }
};
;
var AltText = class _AltText {
  static {
    __name(this, "AltText");
  }
  #altText = null;
  #altTextDecorative = false;
  #altTextButton = null;
  #altTextButtonLabel = null;
  #altTextTooltip = null;
  #altTextTooltipTimeout = null;
  #altTextWasFromKeyBoard = false;
  #badge = null;
  #editor = null;
  #guessedText = null;
  #textWithDisclaimer = null;
  #useNewAltTextFlow = false;
  static #l10nNewButton = null;
  static _l10n = null;
  constructor(editor) {
    this.#editor = editor;
    this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;
    _AltText.#l10nNewButton ||= Object.freeze({
      added: "pdfjs-editor-new-alt-text-added-button",
      "added-label": "pdfjs-editor-new-alt-text-added-button-label",
      missing: "pdfjs-editor-new-alt-text-missing-button",
      "missing-label": "pdfjs-editor-new-alt-text-missing-button-label",
      review: "pdfjs-editor-new-alt-text-to-review-button",
      "review-label": "pdfjs-editor-new-alt-text-to-review-button-label"
    });
  }
  static initialize(l10n) {
    _AltText._l10n ??= l10n;
  }
  async render() {
    const altText = this.#altTextButton = document.createElement("button");
    altText.className = "altText";
    altText.tabIndex = "0";
    const label = this.#altTextButtonLabel = document.createElement("span");
    altText.append(label);
    if (this.#useNewAltTextFlow) {
      altText.classList.add("new");
      altText.setAttribute("data-l10n-id", _AltText.#l10nNewButton.missing);
      label.setAttribute("data-l10n-id", _AltText.#l10nNewButton["missing-label"]);
    } else {
      altText.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button");
      label.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label");
    }
    const signal = this.#editor._uiManager._signal;
    altText.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    altText.addEventListener("pointerdown", (event) => event.stopPropagation(), {
      signal
    });
    const onClick = /* @__PURE__ */ __name((event) => {
      event.preventDefault();
      this.#editor._uiManager.editAltText(this.#editor);
      if (this.#useNewAltTextFlow) {
        this.#editor._reportTelemetry({
          action: "pdfjs.image.alt_text.image_status_label_clicked",
          data: {
            label: this.#label
          }
        });
      }
    }, "onClick");
    altText.addEventListener("click", onClick, {
      capture: true,
      signal
    });
    altText.addEventListener("keydown", (event) => {
      if (event.target === altText && event.key === "Enter") {
        this.#altTextWasFromKeyBoard = true;
        onClick(event);
      }
    }, {
      signal
    });
    await this.#setState();
    return altText;
  }
  get #label() {
    return this.#altText && "added" || this.#altText === null && this.guessedText && "review" || "missing";
  }
  finish() {
    if (!this.#altTextButton) {
      return;
    }
    this.#altTextButton.focus({
      focusVisible: this.#altTextWasFromKeyBoard
    });
    this.#altTextWasFromKeyBoard = false;
  }
  isEmpty() {
    if (this.#useNewAltTextFlow) {
      return this.#altText === null;
    }
    return !this.#altText && !this.#altTextDecorative;
  }
  hasData() {
    if (this.#useNewAltTextFlow) {
      return this.#altText !== null || !!this.#guessedText;
    }
    return this.isEmpty();
  }
  get guessedText() {
    return this.#guessedText;
  }
  async setGuessedText(guessedText) {
    if (this.#altText !== null) {
      return;
    }
    this.#guessedText = guessedText;
    this.#textWithDisclaimer = await _AltText._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", {
      generatedAltText: guessedText
    });
    this.#setState();
  }
  toggleAltTextBadge(visibility = false) {
    if (!this.#useNewAltTextFlow || this.#altText) {
      this.#badge?.remove();
      this.#badge = null;
      return;
    }
    if (!this.#badge) {
      const badge = this.#badge = document.createElement("div");
      badge.className = "noAltTextBadge";
      this.#editor.div.append(badge);
    }
    this.#badge.classList.toggle("hidden", !visibility);
  }
  serialize(isForCopying) {
    let altText = this.#altText;
    if (!isForCopying && this.#guessedText === altText) {
      altText = this.#textWithDisclaimer;
    }
    return {
      altText,
      decorative: this.#altTextDecorative,
      guessedText: this.#guessedText,
      textWithDisclaimer: this.#textWithDisclaimer
    };
  }
  get data() {
    return {
      altText: this.#altText,
      decorative: this.#altTextDecorative
    };
  }
  set data({
    altText,
    decorative,
    guessedText,
    textWithDisclaimer,
    cancel = false
  }) {
    if (guessedText) {
      this.#guessedText = guessedText;
      this.#textWithDisclaimer = textWithDisclaimer;
    }
    if (this.#altText === altText && this.#altTextDecorative === decorative) {
      return;
    }
    if (!cancel) {
      this.#altText = altText;
      this.#altTextDecorative = decorative;
    }
    this.#setState();
  }
  toggle(enabled = false) {
    if (!this.#altTextButton) {
      return;
    }
    if (!enabled && this.#altTextTooltipTimeout) {
      clearTimeout(this.#altTextTooltipTimeout);
      this.#altTextTooltipTimeout = null;
    }
    this.#altTextButton.disabled = !enabled;
  }
  shown() {
    this.#editor._reportTelemetry({
      action: "pdfjs.image.alt_text.image_status_label_displayed",
      data: {
        label: this.#label
      }
    });
  }
  destroy() {
    this.#altTextButton?.remove();
    this.#altTextButton = null;
    this.#altTextButtonLabel = null;
    this.#altTextTooltip = null;
    this.#badge?.remove();
    this.#badge = null;
  }
  async #setState() {
    const button = this.#altTextButton;
    if (!button) {
      return;
    }
    if (this.#useNewAltTextFlow) {
      button.classList.toggle("done", !!this.#altText);
      button.setAttribute("data-l10n-id", _AltText.#l10nNewButton[this.#label]);
      this.#altTextButtonLabel?.setAttribute("data-l10n-id", _AltText.#l10nNewButton[`${this.#label}-label`]);
      if (!this.#altText) {
        this.#altTextTooltip?.remove();
        return;
      }
    } else {
      if (!this.#altText && !this.#altTextDecorative) {
        button.classList.remove("done");
        this.#altTextTooltip?.remove();
        return;
      }
      button.classList.add("done");
      button.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
    }
    let tooltip = this.#altTextTooltip;
    if (!tooltip) {
      this.#altTextTooltip = tooltip = document.createElement("span");
      tooltip.className = "tooltip";
      tooltip.setAttribute("role", "tooltip");
      tooltip.id = `alt-text-tooltip-${this.#editor.id}`;
      const DELAY_TO_SHOW_TOOLTIP = 100;
      const signal = this.#editor._uiManager._signal;
      signal.addEventListener("abort", () => {
        clearTimeout(this.#altTextTooltipTimeout);
        this.#altTextTooltipTimeout = null;
      }, {
        once: true
      });
      button.addEventListener("mouseenter", () => {
        this.#altTextTooltipTimeout = setTimeout(() => {
          this.#altTextTooltipTimeout = null;
          this.#altTextTooltip.classList.add("show");
          this.#editor._reportTelemetry({
            action: "alt_text_tooltip"
          });
        }, DELAY_TO_SHOW_TOOLTIP);
      }, {
        signal
      });
      button.addEventListener("mouseleave", () => {
        if (this.#altTextTooltipTimeout) {
          clearTimeout(this.#altTextTooltipTimeout);
          this.#altTextTooltipTimeout = null;
        }
        this.#altTextTooltip?.classList.remove("show");
      }, {
        signal
      });
    }
    if (this.#altTextDecorative) {
      tooltip.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip");
    } else {
      tooltip.removeAttribute("data-l10n-id");
      tooltip.textContent = this.#altText;
    }
    if (!tooltip.parentNode) {
      button.append(tooltip);
    }
    const element = this.#editor.getElementForAltText();
    element?.setAttribute("aria-describedby", tooltip.id);
  }
};
;
var Comment = class {
  static {
    __name(this, "Comment");
  }
  #commentStandaloneButton = null;
  #commentToolbarButton = null;
  #commentWasFromKeyBoard = false;
  #editor = null;
  #initialText = null;
  #richText = null;
  #text = null;
  #date = null;
  #deleted = false;
  #popupPosition = null;
  constructor(editor) {
    this.#editor = editor;
  }
  renderForToolbar() {
    const button = this.#commentToolbarButton = document.createElement("button");
    button.className = "comment";
    return this.#render(button, false);
  }
  renderForStandalone() {
    const button = this.#commentStandaloneButton = document.createElement("button");
    button.className = "annotationCommentButton";
    const position = this.#editor.commentButtonPosition;
    if (position) {
      const {
        style
      } = button;
      style.insetInlineEnd = `calc(${100 * (this.#editor._uiManager.direction === "ltr" ? 1 - position[0] : position[0])}% - var(--comment-button-dim))`;
      style.top = `calc(${100 * position[1]}% - var(--comment-button-dim))`;
      const color = this.#editor.commentButtonColor;
      if (color) {
        style.backgroundColor = color;
      }
    }
    return this.#render(button, true);
  }
  focusButton() {
    setTimeout(() => {
      (this.#commentStandaloneButton ?? this.#commentToolbarButton)?.focus();
    }, 0);
  }
  onUpdatedColor() {
    if (!this.#commentStandaloneButton) {
      return;
    }
    const color = this.#editor.commentButtonColor;
    if (color) {
      this.#commentStandaloneButton.style.backgroundColor = color;
    }
    this.#editor._uiManager.updatePopupColor(this.#editor);
  }
  get commentButtonWidth() {
    return (this.#commentStandaloneButton?.getBoundingClientRect().width ?? 0) / this.#editor.parent.boundingClientRect.width;
  }
  get commentPopupPositionInLayer() {
    if (this.#popupPosition) {
      return this.#popupPosition;
    }
    if (!this.#commentStandaloneButton) {
      return null;
    }
    const {
      x: x3,
      y: y12,
      height
    } = this.#commentStandaloneButton.getBoundingClientRect();
    const {
      x: parentX,
      y: parentY,
      width: parentWidth,
      height: parentHeight
    } = this.#editor.parent.boundingClientRect;
    return [(x3 - parentX) / parentWidth, (y12 + height - parentY) / parentHeight];
  }
  set commentPopupPositionInLayer(pos) {
    this.#popupPosition = pos;
  }
  hasDefaultPopupPosition() {
    return this.#popupPosition === null;
  }
  removeStandaloneCommentButton() {
    this.#commentStandaloneButton?.remove();
    this.#commentStandaloneButton = null;
  }
  removeToolbarCommentButton() {
    this.#commentToolbarButton?.remove();
    this.#commentToolbarButton = null;
  }
  setCommentButtonStates({
    selected,
    hasPopup
  }) {
    if (!this.#commentStandaloneButton) {
      return;
    }
    this.#commentStandaloneButton.classList.toggle("selected", selected);
    this.#commentStandaloneButton.ariaExpanded = hasPopup;
  }
  #render(comment, isStandalone) {
    if (!this.#editor._uiManager.hasCommentManager()) {
      return null;
    }
    comment.tabIndex = "0";
    comment.ariaHasPopup = "dialog";
    if (isStandalone) {
      comment.ariaControls = "commentPopup";
      comment.setAttribute("data-l10n-id", "pdfjs-show-comment-button");
    } else {
      comment.ariaControlsElements = [this.#editor._uiManager.getCommentDialogElement()];
      comment.setAttribute("data-l10n-id", "pdfjs-editor-edit-comment-button");
    }
    const signal = this.#editor._uiManager._signal;
    if (!(signal instanceof AbortSignal) || signal.aborted) {
      return comment;
    }
    comment.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    if (isStandalone) {
      comment.addEventListener("focusin", (e10) => {
        this.#editor._focusEventsAllowed = false;
        stopEvent(e10);
      }, {
        capture: true,
        signal
      });
      comment.addEventListener("focusout", (e10) => {
        this.#editor._focusEventsAllowed = true;
        stopEvent(e10);
      }, {
        capture: true,
        signal
      });
    }
    comment.addEventListener("pointerdown", (event) => event.stopPropagation(), {
      signal
    });
    const onClick = /* @__PURE__ */ __name((event) => {
      event.preventDefault();
      if (comment === this.#commentToolbarButton) {
        this.edit();
      } else {
        this.#editor.toggleComment(true);
      }
    }, "onClick");
    comment.addEventListener("click", onClick, {
      capture: true,
      signal
    });
    comment.addEventListener("keydown", (event) => {
      if (event.target === comment && event.key === "Enter") {
        this.#commentWasFromKeyBoard = true;
        onClick(event);
      }
    }, {
      signal
    });
    comment.addEventListener("pointerenter", () => {
      this.#editor.toggleComment(false, true);
    }, {
      signal
    });
    comment.addEventListener("pointerleave", () => {
      this.#editor.toggleComment(false, false);
    }, {
      signal
    });
    return comment;
  }
  edit(options) {
    const position = this.commentPopupPositionInLayer;
    let posX, posY;
    if (position) {
      [posX, posY] = position;
    } else {
      [posX, posY] = this.#editor.commentButtonPosition;
      const {
        width,
        height,
        x: x3,
        y: y12
      } = this.#editor;
      posX = x3 + posX * width;
      posY = y12 + posY * height;
    }
    const parentDimensions = this.#editor.parent.boundingClientRect;
    const {
      x: parentX,
      y: parentY,
      width: parentWidth,
      height: parentHeight
    } = parentDimensions;
    this.#editor._uiManager.editComment(this.#editor, parentX + posX * parentWidth, parentY + posY * parentHeight, {
      ...options,
      parentDimensions
    });
  }
  finish() {
    if (!this.#commentToolbarButton) {
      return;
    }
    this.#commentToolbarButton.focus({
      focusVisible: this.#commentWasFromKeyBoard
    });
    this.#commentWasFromKeyBoard = false;
  }
  isDeleted() {
    return this.#deleted || this.#text === "";
  }
  isEmpty() {
    return this.#text === null;
  }
  hasBeenEdited() {
    return this.isDeleted() || this.#text !== this.#initialText;
  }
  serialize() {
    return this.data;
  }
  get data() {
    return {
      text: this.#text,
      richText: this.#richText,
      date: this.#date,
      deleted: this.isDeleted()
    };
  }
  set data(text) {
    if (text !== this.#text) {
      this.#richText = null;
    }
    if (text === null) {
      this.#text = "";
      this.#deleted = true;
      return;
    }
    this.#text = text;
    this.#date = /* @__PURE__ */ new Date();
    this.#deleted = false;
  }
  setInitialText(text, richText = null) {
    this.#initialText = text;
    this.data = text;
    this.#date = null;
    this.#richText = richText;
  }
  shown() {
  }
  destroy() {
    this.#commentToolbarButton?.remove();
    this.#commentToolbarButton = null;
    this.#commentStandaloneButton?.remove();
    this.#commentStandaloneButton = null;
    this.#text = "";
    this.#richText = null;
    this.#date = null;
    this.#editor = null;
    this.#commentWasFromKeyBoard = false;
    this.#deleted = false;
  }
};
;
var TouchManager = class _TouchManager {
  static {
    __name(this, "TouchManager");
  }
  #container;
  #isPinching = false;
  #isPinchingStopped = null;
  #isPinchingDisabled;
  #onPinchStart;
  #onPinching;
  #onPinchEnd;
  #pointerDownAC = null;
  #signal;
  #touchInfo = null;
  #touchManagerAC;
  #touchMoveAC = null;
  constructor({
    container,
    isPinchingDisabled = null,
    isPinchingStopped = null,
    onPinchStart = null,
    onPinching = null,
    onPinchEnd = null,
    signal
  }) {
    this.#container = container;
    this.#isPinchingStopped = isPinchingStopped;
    this.#isPinchingDisabled = isPinchingDisabled;
    this.#onPinchStart = onPinchStart;
    this.#onPinching = onPinching;
    this.#onPinchEnd = onPinchEnd;
    this.#touchManagerAC = new AbortController();
    this.#signal = AbortSignal.any([signal, this.#touchManagerAC.signal]);
    container.addEventListener("touchstart", this.#onTouchStart.bind(this), {
      passive: false,
      signal: this.#signal
    });
  }
  get MIN_TOUCH_DISTANCE_TO_PINCH() {
    return 35 / OutputScale.pixelRatio;
  }
  #onTouchStart(evt) {
    if (this.#isPinchingDisabled?.()) {
      return;
    }
    if (evt.touches.length === 1) {
      if (this.#pointerDownAC) {
        return;
      }
      const pointerDownAC = this.#pointerDownAC = new AbortController();
      const signal = AbortSignal.any([this.#signal, pointerDownAC.signal]);
      const container = this.#container;
      const opts = {
        capture: true,
        signal,
        passive: false
      };
      const cancelPointerDown = /* @__PURE__ */ __name((e10) => {
        if (e10.pointerType === "touch") {
          this.#pointerDownAC?.abort();
          this.#pointerDownAC = null;
        }
      }, "cancelPointerDown");
      container.addEventListener("pointerdown", (e10) => {
        if (e10.pointerType === "touch") {
          stopEvent(e10);
          cancelPointerDown(e10);
        }
      }, opts);
      container.addEventListener("pointerup", cancelPointerDown, opts);
      container.addEventListener("pointercancel", cancelPointerDown, opts);
      return;
    }
    if (!this.#touchMoveAC) {
      this.#touchMoveAC = new AbortController();
      const signal = AbortSignal.any([this.#signal, this.#touchMoveAC.signal]);
      const container = this.#container;
      const opt = {
        signal,
        capture: false,
        passive: false
      };
      container.addEventListener("touchmove", this.#onTouchMove.bind(this), opt);
      const onTouchEnd = this.#onTouchEnd.bind(this);
      container.addEventListener("touchend", onTouchEnd, opt);
      container.addEventListener("touchcancel", onTouchEnd, opt);
      opt.capture = true;
      container.addEventListener("pointerdown", stopEvent, opt);
      container.addEventListener("pointermove", stopEvent, opt);
      container.addEventListener("pointercancel", stopEvent, opt);
      container.addEventListener("pointerup", stopEvent, opt);
      this.#onPinchStart?.();
    }
    stopEvent(evt);
    if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {
      this.#touchInfo = null;
      return;
    }
    let [touch0, touch1] = evt.touches;
    if (touch0.identifier > touch1.identifier) {
      [touch0, touch1] = [touch1, touch0];
    }
    this.#touchInfo = {
      touch0X: touch0.screenX,
      touch0Y: touch0.screenY,
      touch1X: touch1.screenX,
      touch1Y: touch1.screenY
    };
  }
  #onTouchMove(evt) {
    if (!this.#touchInfo || evt.touches.length !== 2) {
      return;
    }
    stopEvent(evt);
    let [touch0, touch1] = evt.touches;
    if (touch0.identifier > touch1.identifier) {
      [touch0, touch1] = [touch1, touch0];
    }
    const {
      screenX: screen0X,
      screenY: screen0Y
    } = touch0;
    const {
      screenX: screen1X,
      screenY: screen1Y
    } = touch1;
    const touchInfo = this.#touchInfo;
    const {
      touch0X: pTouch0X,
      touch0Y: pTouch0Y,
      touch1X: pTouch1X,
      touch1Y: pTouch1Y
    } = touchInfo;
    const prevGapX = pTouch1X - pTouch0X;
    const prevGapY = pTouch1Y - pTouch0Y;
    const currGapX = screen1X - screen0X;
    const currGapY = screen1Y - screen0Y;
    const distance = Math.hypot(currGapX, currGapY) || 1;
    const pDistance = Math.hypot(prevGapX, prevGapY) || 1;
    if (!this.#isPinching && Math.abs(pDistance - distance) <= _TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {
      return;
    }
    touchInfo.touch0X = screen0X;
    touchInfo.touch0Y = screen0Y;
    touchInfo.touch1X = screen1X;
    touchInfo.touch1Y = screen1Y;
    if (!this.#isPinching) {
      this.#isPinching = true;
      return;
    }
    const origin = [(screen0X + screen1X) / 2, (screen0Y + screen1Y) / 2];
    this.#onPinching?.(origin, pDistance, distance);
  }
  #onTouchEnd(evt) {
    if (evt.touches.length >= 2) {
      return;
    }
    if (this.#touchMoveAC) {
      this.#touchMoveAC.abort();
      this.#touchMoveAC = null;
      this.#onPinchEnd?.();
    }
    if (!this.#touchInfo) {
      return;
    }
    stopEvent(evt);
    this.#touchInfo = null;
    this.#isPinching = false;
  }
  destroy() {
    this.#touchManagerAC?.abort();
    this.#touchManagerAC = null;
    this.#pointerDownAC?.abort();
    this.#pointerDownAC = null;
  }
};
;
var AnnotationEditor = class _AnnotationEditor {
  static {
    __name(this, "AnnotationEditor");
  }
  #accessibilityData = null;
  #allResizerDivs = null;
  #altText = null;
  #comment = null;
  #commentStandaloneButton = null;
  #disabled = false;
  #dragPointerId = null;
  #dragPointerType = "";
  #resizersDiv = null;
  #lastPointerCoords = null;
  #savedDimensions = null;
  #fakeAnnotation = null;
  #focusAC = null;
  #focusedResizerName = "";
  #hasBeenClicked = false;
  #initialRect = null;
  #isEditing = false;
  #isInEditMode = false;
  #isResizerEnabledForKeyboard = false;
  #moveInDOMTimeout = null;
  #prevDragX = 0;
  #prevDragY = 0;
  #telemetryTimeouts = null;
  #touchManager = null;
  isSelected = false;
  _isCopy = false;
  _editToolbar = null;
  _initialOptions = /* @__PURE__ */ Object.create(null);
  _initialData = null;
  _isVisible = true;
  _uiManager = null;
  _focusEventsAllowed = true;
  static _l10n = null;
  static _l10nResizer = null;
  #isDraggable = false;
  #zIndex = _AnnotationEditor._zIndex++;
  static _borderLineWidth = -1;
  static _colorManager = new ColorManager();
  static _zIndex = 1;
  static _telemetryTimeout = 1e3;
  static get _resizerKeyboardManager() {
    const resize = _AnnotationEditor.prototype._resizeWithKeyboard;
    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
    const big = AnnotationEditorUIManager.TRANSLATE_BIG;
    return shadow(this, "_resizerKeyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], resize, {
      args: [-small, 0]
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], resize, {
      args: [-big, 0]
    }], [["ArrowRight", "mac+ArrowRight"], resize, {
      args: [small, 0]
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], resize, {
      args: [big, 0]
    }], [["ArrowUp", "mac+ArrowUp"], resize, {
      args: [0, -small]
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], resize, {
      args: [0, -big]
    }], [["ArrowDown", "mac+ArrowDown"], resize, {
      args: [0, small]
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], resize, {
      args: [0, big]
    }], [["Escape", "mac+Escape"], _AnnotationEditor.prototype._stopResizingWithKeyboard]]));
  }
  constructor(parameters) {
    this.parent = parameters.parent;
    this.id = parameters.id;
    this.width = this.height = null;
    this.pageIndex = parameters.parent.pageIndex;
    this.name = parameters.name;
    this.div = null;
    this._uiManager = parameters.uiManager;
    this.annotationElementId = null;
    this._willKeepAspectRatio = false;
    this._initialOptions.isCentered = parameters.isCentered;
    this._structTreeParentId = null;
    this.annotationElementId = parameters.annotationElementId || null;
    this.creationDate = parameters.creationDate || /* @__PURE__ */ new Date();
    this.modificationDate = parameters.modificationDate || null;
    const {
      rotation,
      rawDims: {
        pageWidth,
        pageHeight,
        pageX,
        pageY
      }
    } = this.parent.viewport;
    this.rotation = rotation;
    this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
    this.pageDimensions = [pageWidth, pageHeight];
    this.pageTranslation = [pageX, pageY];
    const [width, height] = this.parentDimensions;
    this.x = parameters.x / width;
    this.y = parameters.y / height;
    this.isAttachedToDOM = false;
    this.deleted = false;
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  get mode() {
    return Object.getPrototypeOf(this).constructor._editorType;
  }
  static get isDrawer() {
    return false;
  }
  static get _defaultLineColor() {
    return shadow(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(editor) {
    const fakeEditor = new FakeEditor({
      id: editor.parent.getNextId(),
      parent: editor.parent,
      uiManager: editor._uiManager
    });
    fakeEditor.annotationElementId = editor.annotationElementId;
    fakeEditor.deleted = true;
    fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
  }
  static initialize(l10n, _uiManager) {
    _AnnotationEditor._l10n ??= l10n;
    _AnnotationEditor._l10nResizer ||= Object.freeze({
      topLeft: "pdfjs-editor-resizer-top-left",
      topMiddle: "pdfjs-editor-resizer-top-middle",
      topRight: "pdfjs-editor-resizer-top-right",
      middleRight: "pdfjs-editor-resizer-middle-right",
      bottomRight: "pdfjs-editor-resizer-bottom-right",
      bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
      bottomLeft: "pdfjs-editor-resizer-bottom-left",
      middleLeft: "pdfjs-editor-resizer-middle-left"
    });
    if (_AnnotationEditor._borderLineWidth !== -1) {
      return;
    }
    const style = getComputedStyle(document.documentElement);
    _AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(_type, _value) {
  }
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(mime) {
    return false;
  }
  static paste(item, parent) {
    unreachable("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return this.#isDraggable;
  }
  set _isDraggable(value) {
    this.#isDraggable = value;
    this.div?.classList.toggle("draggable", value);
  }
  get uid() {
    return this.annotationElementId || this.id;
  }
  get isEnterHandled() {
    return true;
  }
  center() {
    const [pageWidth, pageHeight] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * pageHeight / (pageWidth * 2);
        this.y += this.width * pageWidth / (pageHeight * 2);
        break;
      case 180:
        this.x += this.width / 2;
        this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * pageHeight / (pageWidth * 2);
        this.y -= this.width * pageWidth / (pageHeight * 2);
        break;
      default:
        this.x -= this.width / 2;
        this.y -= this.height / 2;
        break;
    }
    this.fixAndSetPosition();
  }
  addCommands(params) {
    this._uiManager.addCommands(params);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = this.#zIndex;
  }
  setParent(parent) {
    if (parent !== null) {
      this.pageIndex = parent.pageIndex;
      this.pageDimensions = parent.pageDimensions;
    } else {
      this.#stopResizing();
      this.#fakeAnnotation?.remove();
      this.#fakeAnnotation = null;
    }
    this.parent = parent;
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    if (!this.#hasBeenClicked) {
      this.parent.setSelected(this);
    } else {
      this.#hasBeenClicked = false;
    }
  }
  focusout(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    if (!this.isAttachedToDOM) {
      return;
    }
    const target = event.relatedTarget;
    if (target?.closest(`#${this.id}`)) {
      return;
    }
    event.preventDefault();
    if (!this.parent?.isMultipleSelection) {
      this.commitOrRemove();
    }
  }
  commitOrRemove() {
    if (this.isEmpty()) {
      this.remove();
    } else {
      this.commit();
    }
  }
  commit() {
    if (!this.isInEditMode()) {
      return;
    }
    this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(x3, y12, tx, ty) {
    const [width, height] = this.parentDimensions;
    [tx, ty] = this.screenToPageTranslation(tx, ty);
    this.x = (x3 + tx) / width;
    this.y = (y12 + ty) / height;
    this.fixAndSetPosition();
  }
  _moveAfterPaste(baseX, baseY) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
    this._onTranslated();
  }
  #translate([width, height], x3, y12) {
    [x3, y12] = this.screenToPageTranslation(x3, y12);
    this.x += x3 / width;
    this.y += y12 / height;
    this._onTranslating(this.x, this.y);
    this.fixAndSetPosition();
  }
  translate(x3, y12) {
    this.#translate(this.parentDimensions, x3, y12);
  }
  translateInPage(x3, y12) {
    this.#initialRect ||= [this.x, this.y, this.width, this.height];
    this.#translate(this.pageDimensions, x3, y12);
    this.div.scrollIntoView({
      block: "nearest"
    });
  }
  translationDone() {
    this._onTranslated(this.x, this.y);
  }
  drag(tx, ty) {
    this.#initialRect ||= [this.x, this.y, this.width, this.height];
    const {
      div,
      parentDimensions: [parentWidth, parentHeight]
    } = this;
    this.x += tx / parentWidth;
    this.y += ty / parentHeight;
    if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const {
        x: x4,
        y: y13
      } = this.div.getBoundingClientRect();
      if (this.parent.findNewParent(this, x4, y13)) {
        this.x -= Math.floor(this.x);
        this.y -= Math.floor(this.y);
      }
    }
    let {
      x: x3,
      y: y12
    } = this;
    const [bx, by] = this.getBaseTranslation();
    x3 += bx;
    y12 += by;
    const {
      style
    } = div;
    style.left = `${(100 * x3).toFixed(2)}%`;
    style.top = `${(100 * y12).toFixed(2)}%`;
    this._onTranslating(x3, y12);
    div.scrollIntoView({
      block: "nearest"
    });
  }
  _onTranslating(x3, y12) {
  }
  _onTranslated(x3, y12) {
  }
  get _hasBeenMoved() {
    return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);
  }
  get _hasBeenResized() {
    return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);
  }
  getBaseTranslation() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const {
      _borderLineWidth
    } = _AnnotationEditor;
    const x3 = _borderLineWidth / parentWidth;
    const y12 = _borderLineWidth / parentHeight;
    switch (this.rotation) {
      case 90:
        return [-x3, y12];
      case 180:
        return [x3, y12];
      case 270:
        return [x3, -y12];
      default:
        return [-x3, -y12];
    }
  }
  get _mustFixPosition() {
    return true;
  }
  fixAndSetPosition(rotation = this.rotation) {
    const {
      div: {
        style
      },
      pageDimensions: [pageWidth, pageHeight]
    } = this;
    let {
      x: x3,
      y: y12,
      width,
      height
    } = this;
    width *= pageWidth;
    height *= pageHeight;
    x3 *= pageWidth;
    y12 *= pageHeight;
    if (this._mustFixPosition) {
      switch (rotation) {
        case 0:
          x3 = MathClamp(x3, 0, pageWidth - width);
          y12 = MathClamp(y12, 0, pageHeight - height);
          break;
        case 90:
          x3 = MathClamp(x3, 0, pageWidth - height);
          y12 = MathClamp(y12, width, pageHeight);
          break;
        case 180:
          x3 = MathClamp(x3, width, pageWidth);
          y12 = MathClamp(y12, height, pageHeight);
          break;
        case 270:
          x3 = MathClamp(x3, height, pageWidth);
          y12 = MathClamp(y12, 0, pageHeight - width);
          break;
      }
    }
    this.x = x3 /= pageWidth;
    this.y = y12 /= pageHeight;
    const [bx, by] = this.getBaseTranslation();
    x3 += bx;
    y12 += by;
    style.left = `${(100 * x3).toFixed(2)}%`;
    style.top = `${(100 * y12).toFixed(2)}%`;
    this.moveInDOM();
  }
  static #rotatePoint(x3, y12, angle) {
    switch (angle) {
      case 90:
        return [y12, -x3];
      case 180:
        return [-x3, -y12];
      case 270:
        return [-y12, x3];
      default:
        return [x3, y12];
    }
  }
  screenToPageTranslation(x3, y12) {
    return _AnnotationEditor.#rotatePoint(x3, y12, this.parentRotation);
  }
  pageTranslationToScreen(x3, y12) {
    return _AnnotationEditor.#rotatePoint(x3, y12, 360 - this.parentRotation);
  }
  #getRotationMatrix(rotation) {
    switch (rotation) {
      case 90: {
        const [pageWidth, pageHeight] = this.pageDimensions;
        return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
      }
      case 180:
        return [-1, 0, 0, -1];
      case 270: {
        const [pageWidth, pageHeight] = this.pageDimensions;
        return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];
      }
      default:
        return [1, 0, 0, 1];
    }
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const {
      parentScale,
      pageDimensions: [pageWidth, pageHeight]
    } = this;
    return [pageWidth * parentScale, pageHeight * parentScale];
  }
  setDims() {
    const {
      div: {
        style
      },
      width,
      height
    } = this;
    style.width = `${(100 * width).toFixed(2)}%`;
    style.height = `${(100 * height).toFixed(2)}%`;
  }
  getInitialTranslation() {
    return [0, 0];
  }
  #createResizers() {
    if (this.#resizersDiv) {
      return;
    }
    this.#resizersDiv = document.createElement("div");
    this.#resizersDiv.classList.add("resizers");
    const classes = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"];
    const signal = this._uiManager._signal;
    for (const name4 of classes) {
      const div = document.createElement("div");
      this.#resizersDiv.append(div);
      div.classList.add("resizer", name4);
      div.setAttribute("data-resizer-name", name4);
      div.addEventListener("pointerdown", this.#resizerPointerdown.bind(this, name4), {
        signal
      });
      div.addEventListener("contextmenu", noContextMenu, {
        signal
      });
      div.tabIndex = -1;
    }
    this.div.prepend(this.#resizersDiv);
  }
  #resizerPointerdown(name4, event) {
    event.preventDefault();
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    this.#altText?.toggle(false);
    const savedDraggable = this._isDraggable;
    this._isDraggable = false;
    this.#lastPointerCoords = [event.screenX, event.screenY];
    const ac = new AbortController();
    const signal = this._uiManager.combinedSignal(ac);
    this.parent.togglePointerEvents(false);
    window.addEventListener("pointermove", this.#resizerPointermove.bind(this, name4), {
      passive: true,
      capture: true,
      signal
    });
    window.addEventListener("touchmove", stopEvent, {
      passive: false,
      signal
    });
    window.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    this.#savedDimensions = {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    };
    const savedParentCursor = this.parent.div.style.cursor;
    const savedCursor = this.div.style.cursor;
    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;
    const pointerUpCallback = /* @__PURE__ */ __name(() => {
      ac.abort();
      this.parent.togglePointerEvents(true);
      this.#altText?.toggle(true);
      this._isDraggable = savedDraggable;
      this.parent.div.style.cursor = savedParentCursor;
      this.div.style.cursor = savedCursor;
      this.#addResizeToUndoStack();
    }, "pointerUpCallback");
    window.addEventListener("pointerup", pointerUpCallback, {
      signal
    });
    window.addEventListener("blur", pointerUpCallback, {
      signal
    });
  }
  #resize(x3, y12, width, height) {
    this.width = width;
    this.height = height;
    this.x = x3;
    this.y = y12;
    this.setDims();
    this.fixAndSetPosition();
    this._onResized();
  }
  _onResized() {
  }
  #addResizeToUndoStack() {
    if (!this.#savedDimensions) {
      return;
    }
    const {
      savedX,
      savedY,
      savedWidth,
      savedHeight
    } = this.#savedDimensions;
    this.#savedDimensions = null;
    const newX = this.x;
    const newY = this.y;
    const newWidth = this.width;
    const newHeight = this.height;
    if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {
      return;
    }
    this.addCommands({
      cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),
      undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),
      mustExec: true
    });
  }
  static _round(x3) {
    return Math.round(x3 * 1e4) / 1e4;
  }
  #resizerPointermove(name4, event) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const savedX = this.x;
    const savedY = this.y;
    const savedWidth = this.width;
    const savedHeight = this.height;
    const minWidth = _AnnotationEditor.MIN_SIZE / parentWidth;
    const minHeight = _AnnotationEditor.MIN_SIZE / parentHeight;
    const rotationMatrix = this.#getRotationMatrix(this.rotation);
    const transf = /* @__PURE__ */ __name((x3, y12) => [rotationMatrix[0] * x3 + rotationMatrix[2] * y12, rotationMatrix[1] * x3 + rotationMatrix[3] * y12], "transf");
    const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);
    const invTransf = /* @__PURE__ */ __name((x3, y12) => [invRotationMatrix[0] * x3 + invRotationMatrix[2] * y12, invRotationMatrix[1] * x3 + invRotationMatrix[3] * y12], "invTransf");
    let getPoint;
    let getOpposite;
    let isDiagonal = false;
    let isHorizontal = false;
    switch (name4) {
      case "topLeft":
        isDiagonal = true;
        getPoint = /* @__PURE__ */ __name((w4, h12) => [0, 0], "getPoint");
        getOpposite = /* @__PURE__ */ __name((w4, h12) => [w4, h12], "getOpposite");
        break;
      case "topMiddle":
        getPoint = /* @__PURE__ */ __name((w4, h12) => [w4 / 2, 0], "getPoint");
        getOpposite = /* @__PURE__ */ __name((w4, h12) => [w4 / 2, h12], "getOpposite");
        break;
      case "topRight":
        isDiagonal = true;
        getPoint = /* @__PURE__ */ __name((w4, h12) => [w4, 0], "getPoint");
        getOpposite = /* @__PURE__ */ __name((w4, h12) => [0, h12], "getOpposite");
        break;
      case "middleRight":
        isHorizontal = true;
        getPoint = /* @__PURE__ */ __name((w4, h12) => [w4, h12 / 2], "getPoint");
        getOpposite = /* @__PURE__ */ __name((w4, h12) => [0, h12 / 2], "getOpposite");
        break;
      case "bottomRight":
        isDiagonal = true;
        getPoint = /* @__PURE__ */ __name((w4, h12) => [w4, h12], "getPoint");
        getOpposite = /* @__PURE__ */ __name((w4, h12) => [0, 0], "getOpposite");
        break;
      case "bottomMiddle":
        getPoint = /* @__PURE__ */ __name((w4, h12) => [w4 / 2, h12], "getPoint");
        getOpposite = /* @__PURE__ */ __name((w4, h12) => [w4 / 2, 0], "getOpposite");
        break;
      case "bottomLeft":
        isDiagonal = true;
        getPoint = /* @__PURE__ */ __name((w4, h12) => [0, h12], "getPoint");
        getOpposite = /* @__PURE__ */ __name((w4, h12) => [w4, 0], "getOpposite");
        break;
      case "middleLeft":
        isHorizontal = true;
        getPoint = /* @__PURE__ */ __name((w4, h12) => [0, h12 / 2], "getPoint");
        getOpposite = /* @__PURE__ */ __name((w4, h12) => [w4, h12 / 2], "getOpposite");
        break;
    }
    const point = getPoint(savedWidth, savedHeight);
    const oppositePoint = getOpposite(savedWidth, savedHeight);
    let transfOppositePoint = transf(...oppositePoint);
    const oppositeX = _AnnotationEditor._round(savedX + transfOppositePoint[0]);
    const oppositeY = _AnnotationEditor._round(savedY + transfOppositePoint[1]);
    let ratioX = 1;
    let ratioY = 1;
    let deltaX, deltaY;
    if (!event.fromKeyboard) {
      const {
        screenX,
        screenY
      } = event;
      const [lastScreenX, lastScreenY] = this.#lastPointerCoords;
      [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);
      this.#lastPointerCoords[0] = screenX;
      this.#lastPointerCoords[1] = screenY;
    } else {
      ({
        deltaX,
        deltaY
      } = event);
    }
    [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
    if (isDiagonal) {
      const oldDiag = Math.hypot(savedWidth, savedHeight);
      ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
    } else if (isHorizontal) {
      ratioX = MathClamp(Math.abs(oppositePoint[0] - point[0] - deltaX), minWidth, 1) / savedWidth;
    } else {
      ratioY = MathClamp(Math.abs(oppositePoint[1] - point[1] - deltaY), minHeight, 1) / savedHeight;
    }
    const newWidth = _AnnotationEditor._round(savedWidth * ratioX);
    const newHeight = _AnnotationEditor._round(savedHeight * ratioY);
    transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
    const newX = oppositeX - transfOppositePoint[0];
    const newY = oppositeY - transfOppositePoint[1];
    this.#initialRect ||= [this.x, this.y, this.width, this.height];
    this.width = newWidth;
    this.height = newHeight;
    this.x = newX;
    this.y = newY;
    this.setDims();
    this.fixAndSetPosition();
    this._onResizing();
  }
  _onResizing() {
  }
  altTextFinish() {
    this.#altText?.finish();
  }
  get toolbarButtons() {
    return null;
  }
  async addEditToolbar() {
    if (this._editToolbar || this.#isInEditMode) {
      return this._editToolbar;
    }
    this._editToolbar = new EditorToolbar(this);
    this.div.append(this._editToolbar.render());
    const {
      toolbarButtons
    } = this;
    if (toolbarButtons) {
      for (const [name4, tool] of toolbarButtons) {
        await this._editToolbar.addButton(name4, tool);
      }
    }
    if (!this.hasComment) {
      this._editToolbar.addButton("comment", this.addCommentButton());
    }
    this._editToolbar.addButton("delete");
    return this._editToolbar;
  }
  addCommentButtonInToolbar() {
    this._editToolbar?.addButtonBefore("comment", this.addCommentButton(), ".deleteButton");
  }
  removeCommentButtonFromToolbar() {
    this._editToolbar?.removeButton("comment");
  }
  removeEditToolbar() {
    this._editToolbar?.remove();
    this._editToolbar = null;
    this.#altText?.destroy();
  }
  addContainer(container) {
    const editToolbarDiv = this._editToolbar?.div;
    if (editToolbarDiv) {
      editToolbarDiv.before(container);
    } else {
      this.div.append(container);
    }
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  createAltText() {
    if (!this.#altText) {
      AltText.initialize(_AnnotationEditor._l10n);
      this.#altText = new AltText(this);
      if (this.#accessibilityData) {
        this.#altText.data = this.#accessibilityData;
        this.#accessibilityData = null;
      }
    }
    return this.#altText;
  }
  get altTextData() {
    return this.#altText?.data;
  }
  set altTextData(data) {
    if (!this.#altText) {
      return;
    }
    this.#altText.data = data;
  }
  get guessedAltText() {
    return this.#altText?.guessedText;
  }
  async setGuessedAltText(text) {
    await this.#altText?.setGuessedText(text);
  }
  serializeAltText(isForCopying) {
    return this.#altText?.serialize(isForCopying);
  }
  hasAltText() {
    return !!this.#altText && !this.#altText.isEmpty();
  }
  hasAltTextData() {
    return this.#altText?.hasData() ?? false;
  }
  focusCommentButton() {
    this.#comment?.focusButton();
  }
  addCommentButton() {
    return this.#comment ||= new Comment(this);
  }
  addStandaloneCommentButton() {
    if (this.#commentStandaloneButton) {
      if (this._uiManager.isEditingMode()) {
        this.#commentStandaloneButton.classList.remove("hidden");
      }
      return;
    }
    if (!this.hasComment) {
      return;
    }
    this.#commentStandaloneButton = this.#comment.renderForStandalone();
    this.div.append(this.#commentStandaloneButton);
  }
  removeStandaloneCommentButton() {
    this.#comment.removeStandaloneCommentButton();
    this.#commentStandaloneButton = null;
  }
  hideStandaloneCommentButton() {
    this.#commentStandaloneButton?.classList.add("hidden");
  }
  get comment() {
    const {
      data: {
        richText,
        text,
        date,
        deleted
      }
    } = this.#comment;
    return {
      text,
      richText,
      date,
      deleted,
      color: this.getNonHCMColor(),
      opacity: this.opacity ?? 1
    };
  }
  set comment(text) {
    this.#comment ||= new Comment(this);
    this.#comment.data = text;
    if (this.hasComment) {
      this.removeCommentButtonFromToolbar();
      this.addStandaloneCommentButton();
      this._uiManager.updateComment(this);
    } else {
      this.addCommentButtonInToolbar();
      this.removeStandaloneCommentButton();
      this._uiManager.removeComment(this);
    }
  }
  setCommentData({
    comment,
    popupRef,
    richText
  }) {
    if (!popupRef) {
      return;
    }
    this.#comment ||= new Comment(this);
    this.#comment.setInitialText(comment, richText);
    if (!this.annotationElementId) {
      return;
    }
    const storedData = this._uiManager.getAndRemoveDataFromAnnotationStorage(this.annotationElementId);
    if (storedData) {
      this.updateFromAnnotationLayer(storedData);
    }
  }
  get hasEditedComment() {
    return this.#comment?.hasBeenEdited();
  }
  get hasDeletedComment() {
    return this.#comment?.isDeleted();
  }
  get hasComment() {
    return !!this.#comment && !this.#comment.isEmpty() && !this.#comment.isDeleted();
  }
  async editComment(options) {
    this.#comment ||= new Comment(this);
    this.#comment.edit(options);
  }
  toggleComment(isSelected, visibility = void 0) {
    if (this.hasComment) {
      this._uiManager.toggleComment(this, isSelected, visibility);
    }
  }
  setSelectedCommentButton(selected) {
    this.#comment.setSelectedButton(selected);
  }
  addComment(serialized) {
    if (this.hasEditedComment) {
      const DEFAULT_POPUP_WIDTH = 180;
      const DEFAULT_POPUP_HEIGHT = 100;
      const [, , , trY] = serialized.rect;
      const [pageWidth] = this.pageDimensions;
      const [pageX] = this.pageTranslation;
      const blX = pageX + pageWidth + 1;
      const blY = trY - DEFAULT_POPUP_HEIGHT;
      const trX = blX + DEFAULT_POPUP_WIDTH;
      serialized.popup = {
        contents: this.comment.text,
        deleted: this.comment.deleted,
        rect: [blX, blY, trX, trY]
      };
    }
  }
  updateFromAnnotationLayer({
    popup: {
      contents,
      deleted
    }
  }) {
    this.#comment.data = deleted ? null : contents;
  }
  get parentBoundingClientRect() {
    return this.parent.boundingClientRect;
  }
  render() {
    const div = this.div = document.createElement("div");
    div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
    div.className = this.name;
    div.setAttribute("id", this.id);
    div.tabIndex = this.#disabled ? -1 : 0;
    div.setAttribute("role", "application");
    if (this.defaultL10nId) {
      div.setAttribute("data-l10n-id", this.defaultL10nId);
    }
    if (!this._isVisible) {
      div.classList.add("hidden");
    }
    this.setInForeground();
    this.#addFocusListeners();
    const [parentWidth, parentHeight] = this.parentDimensions;
    if (this.parentRotation % 180 !== 0) {
      div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;
      div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;
    }
    const [tx, ty] = this.getInitialTranslation();
    this.translate(tx, ty);
    bindEvents(this, div, ["keydown", "pointerdown", "dblclick"]);
    if (this.isResizable && this._uiManager._supportsPinchToZoom) {
      this.#touchManager ||= new TouchManager({
        container: div,
        isPinchingDisabled: /* @__PURE__ */ __name(() => !this.isSelected, "isPinchingDisabled"),
        onPinchStart: this.#touchPinchStartCallback.bind(this),
        onPinching: this.#touchPinchCallback.bind(this),
        onPinchEnd: this.#touchPinchEndCallback.bind(this),
        signal: this._uiManager._signal
      });
    }
    this.addStandaloneCommentButton();
    this._uiManager._editorUndoBar?.hide();
    return div;
  }
  #touchPinchStartCallback() {
    this.#savedDimensions = {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    };
    this.#altText?.toggle(false);
    this.parent.togglePointerEvents(false);
  }
  #touchPinchCallback(_origin, prevDistance, distance) {
    const slowDownFactor = 0.7;
    let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;
    if (factor === 1) {
      return;
    }
    const rotationMatrix = this.#getRotationMatrix(this.rotation);
    const transf = /* @__PURE__ */ __name((x3, y12) => [rotationMatrix[0] * x3 + rotationMatrix[2] * y12, rotationMatrix[1] * x3 + rotationMatrix[3] * y12], "transf");
    const [parentWidth, parentHeight] = this.parentDimensions;
    const savedX = this.x;
    const savedY = this.y;
    const savedWidth = this.width;
    const savedHeight = this.height;
    const minWidth = _AnnotationEditor.MIN_SIZE / parentWidth;
    const minHeight = _AnnotationEditor.MIN_SIZE / parentHeight;
    factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
    const newWidth = _AnnotationEditor._round(savedWidth * factor);
    const newHeight = _AnnotationEditor._round(savedHeight * factor);
    if (newWidth === savedWidth && newHeight === savedHeight) {
      return;
    }
    this.#initialRect ||= [savedX, savedY, savedWidth, savedHeight];
    const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);
    const centerX = _AnnotationEditor._round(savedX + transfCenterPoint[0]);
    const centerY = _AnnotationEditor._round(savedY + transfCenterPoint[1]);
    const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);
    this.x = centerX - newTransfCenterPoint[0];
    this.y = centerY - newTransfCenterPoint[1];
    this.width = newWidth;
    this.height = newHeight;
    this.setDims();
    this.fixAndSetPosition();
    this._onResizing();
  }
  #touchPinchEndCallback() {
    this.#altText?.toggle(true);
    this.parent.togglePointerEvents(true);
    this.#addResizeToUndoStack();
  }
  pointerdown(event) {
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      event.preventDefault();
      return;
    }
    this.#hasBeenClicked = true;
    if (this._isDraggable) {
      this.#setUpDragSession(event);
      return;
    }
    this.#selectOnPointerEvent(event);
  }
  #selectOnPointerEvent(event) {
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
      this.parent.toggleSelected(this);
    } else {
      this.parent.setSelected(this);
    }
  }
  #setUpDragSession(event) {
    const {
      isSelected
    } = this;
    this._uiManager.setUpDragSession();
    let hasDraggingStarted = false;
    const ac = new AbortController();
    const signal = this._uiManager.combinedSignal(ac);
    const opts = {
      capture: true,
      passive: false,
      signal
    };
    const cancelDrag = /* @__PURE__ */ __name((e10) => {
      ac.abort();
      this.#dragPointerId = null;
      this.#hasBeenClicked = false;
      if (!this._uiManager.endDragSession()) {
        this.#selectOnPointerEvent(e10);
      }
      if (hasDraggingStarted) {
        this._onStopDragging();
      }
    }, "cancelDrag");
    if (isSelected) {
      this.#prevDragX = event.clientX;
      this.#prevDragY = event.clientY;
      this.#dragPointerId = event.pointerId;
      this.#dragPointerType = event.pointerType;
      window.addEventListener("pointermove", (e10) => {
        if (!hasDraggingStarted) {
          hasDraggingStarted = true;
          this._uiManager.toggleComment(this, true, false);
          this._onStartDragging();
        }
        const {
          clientX: x3,
          clientY: y12,
          pointerId
        } = e10;
        if (pointerId !== this.#dragPointerId) {
          stopEvent(e10);
          return;
        }
        const [tx, ty] = this.screenToPageTranslation(x3 - this.#prevDragX, y12 - this.#prevDragY);
        this.#prevDragX = x3;
        this.#prevDragY = y12;
        this._uiManager.dragSelectedEditors(tx, ty);
      }, opts);
      window.addEventListener("touchmove", stopEvent, opts);
      window.addEventListener("pointerdown", (e10) => {
        if (e10.pointerType === this.#dragPointerType) {
          if (this.#touchManager || e10.isPrimary) {
            cancelDrag(e10);
          }
        }
        stopEvent(e10);
      }, opts);
    }
    const pointerUpCallback = /* @__PURE__ */ __name((e10) => {
      if (!this.#dragPointerId || this.#dragPointerId === e10.pointerId) {
        cancelDrag(e10);
        return;
      }
      stopEvent(e10);
    }, "pointerUpCallback");
    window.addEventListener("pointerup", pointerUpCallback, {
      signal
    });
    window.addEventListener("blur", pointerUpCallback, {
      signal
    });
  }
  _onStartDragging() {
  }
  _onStopDragging() {
  }
  moveInDOM() {
    if (this.#moveInDOMTimeout) {
      clearTimeout(this.#moveInDOMTimeout);
    }
    this.#moveInDOMTimeout = setTimeout(() => {
      this.#moveInDOMTimeout = null;
      this.parent?.moveEditorInDOM(this);
    }, 0);
  }
  _setParentAndPosition(parent, x3, y12) {
    parent.changeParent(this);
    this.x = x3;
    this.y = y12;
    this.fixAndSetPosition();
    this._onTranslated();
  }
  getRect(tx, ty, rotation = this.rotation) {
    const scale = this.parentScale;
    const [pageWidth, pageHeight] = this.pageDimensions;
    const [pageX, pageY] = this.pageTranslation;
    const shiftX = tx / scale;
    const shiftY = ty / scale;
    const x3 = this.x * pageWidth;
    const y12 = this.y * pageHeight;
    const width = this.width * pageWidth;
    const height = this.height * pageHeight;
    switch (rotation) {
      case 0:
        return [x3 + shiftX + pageX, pageHeight - y12 - shiftY - height + pageY, x3 + shiftX + width + pageX, pageHeight - y12 - shiftY + pageY];
      case 90:
        return [x3 + shiftY + pageX, pageHeight - y12 + shiftX + pageY, x3 + shiftY + height + pageX, pageHeight - y12 + shiftX + width + pageY];
      case 180:
        return [x3 - shiftX - width + pageX, pageHeight - y12 + shiftY + pageY, x3 - shiftX + pageX, pageHeight - y12 + shiftY + height + pageY];
      case 270:
        return [x3 - shiftY - height + pageX, pageHeight - y12 - shiftX - width + pageY, x3 - shiftY + pageX, pageHeight - y12 - shiftX + pageY];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(rect, pageHeight) {
    const [x1, y1, x22, y22] = rect;
    const width = x22 - x1;
    const height = y22 - y1;
    switch (this.rotation) {
      case 0:
        return [x1, pageHeight - y22, width, height];
      case 90:
        return [x1, pageHeight - y1, height, width];
      case 180:
        return [x22, pageHeight - y1, width, height];
      case 270:
        return [x22, pageHeight - y22, height, width];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getPDFRect() {
    return this.getRect(0, 0);
  }
  getNonHCMColor() {
    return this.color && _AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));
  }
  onUpdatedColor() {
    this.#comment?.onUpdatedColor();
  }
  getData() {
    const {
      comment: {
        text: str,
        color,
        date,
        opacity,
        deleted,
        richText
      },
      uid: id,
      pageIndex,
      creationDate,
      modificationDate
    } = this;
    return {
      id,
      pageIndex,
      rect: this.getPDFRect(),
      richText,
      contentsObj: {
        str
      },
      creationDate,
      modificationDate: date || modificationDate,
      popupRef: !deleted,
      color,
      opacity
    };
  }
  onceAdded(focus) {
  }
  isEmpty() {
    return false;
  }
  enableEditMode() {
    if (this.isInEditMode()) {
      return false;
    }
    this.parent.setEditingState(false);
    this.#isInEditMode = true;
    return true;
  }
  disableEditMode() {
    if (!this.isInEditMode()) {
      return false;
    }
    this.parent.setEditingState(true);
    this.#isInEditMode = false;
    return true;
  }
  isInEditMode() {
    return this.#isInEditMode;
  }
  shouldGetKeyboardEvents() {
    return this.#isResizerEnabledForKeyboard;
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  get isOnScreen() {
    const {
      top,
      left,
      bottom,
      right
    } = this.getClientDimensions();
    const {
      innerHeight,
      innerWidth
    } = window;
    return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;
  }
  #addFocusListeners() {
    if (this.#focusAC || !this.div) {
      return;
    }
    this.#focusAC = new AbortController();
    const signal = this._uiManager.combinedSignal(this.#focusAC);
    this.div.addEventListener("focusin", this.focusin.bind(this), {
      signal
    });
    this.div.addEventListener("focusout", this.focusout.bind(this), {
      signal
    });
  }
  rebuild() {
    this.#addFocusListeners();
  }
  rotate(_angle) {
  }
  resize() {
  }
  serializeDeleted() {
    return {
      id: this.annotationElementId,
      deleted: true,
      pageIndex: this.pageIndex,
      popupRef: this._initialData?.popupRef || ""
    };
  }
  serialize(isForCopying = false, context2 = null) {
    return {
      annotationType: this.mode,
      pageIndex: this.pageIndex,
      rect: this.getPDFRect(),
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId,
      popupRef: this._initialData?.popupRef || ""
    };
  }
  static async deserialize(data, parent, uiManager) {
    const editor = new this.prototype.constructor({
      parent,
      id: parent.getNextId(),
      uiManager,
      annotationElementId: data.annotationElementId,
      creationDate: data.creationDate,
      modificationDate: data.modificationDate
    });
    editor.rotation = data.rotation;
    editor.#accessibilityData = data.accessibilityData;
    editor._isCopy = data.isCopy || false;
    const [pageWidth, pageHeight] = editor.pageDimensions;
    const [x3, y12, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
    editor.x = x3 / pageWidth;
    editor.y = y12 / pageHeight;
    editor.width = width / pageWidth;
    editor.height = height / pageHeight;
    return editor;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
  }
  remove() {
    this.#focusAC?.abort();
    this.#focusAC = null;
    if (!this.isEmpty()) {
      this.commit();
    }
    if (this.parent) {
      this.parent.remove(this);
    } else {
      this._uiManager.removeEditor(this);
    }
    if (this.#moveInDOMTimeout) {
      clearTimeout(this.#moveInDOMTimeout);
      this.#moveInDOMTimeout = null;
    }
    this.#stopResizing();
    this.removeEditToolbar();
    if (this.#telemetryTimeouts) {
      for (const timeout of this.#telemetryTimeouts.values()) {
        clearTimeout(timeout);
      }
      this.#telemetryTimeouts = null;
    }
    this.parent = null;
    this.#touchManager?.destroy();
    this.#touchManager = null;
  }
  get isResizable() {
    return false;
  }
  makeResizable() {
    if (this.isResizable) {
      this.#createResizers();
      this.#resizersDiv.classList.remove("hidden");
    }
  }
  get toolbarPosition() {
    return null;
  }
  get commentButtonPosition() {
    return this._uiManager.direction === "ltr" ? [1, 0] : [0, 0];
  }
  get commentButtonPositionInPage() {
    const {
      commentButtonPosition: [posX, posY]
    } = this;
    const [blX, blY, trX, trY] = this.getPDFRect();
    return [_AnnotationEditor._round(blX + (trX - blX) * posX), _AnnotationEditor._round(blY + (trY - blY) * (1 - posY))];
  }
  get commentButtonColor() {
    return this._uiManager.makeCommentColor(this.getNonHCMColor(), this.opacity);
  }
  get commentPopupPosition() {
    return this.#comment.commentPopupPositionInLayer;
  }
  set commentPopupPosition(pos) {
    this.#comment.commentPopupPositionInLayer = pos;
  }
  hasDefaultPopupPosition() {
    return this.#comment.hasDefaultPopupPosition();
  }
  get commentButtonWidth() {
    return this.#comment.commentButtonWidth;
  }
  get elementBeforePopup() {
    return this.div;
  }
  setCommentButtonStates(options) {
    this.#comment.setCommentButtonStates(options);
  }
  keydown(event) {
    if (!this.isResizable || event.target !== this.div || event.key !== "Enter") {
      return;
    }
    this._uiManager.setSelected(this);
    this.#savedDimensions = {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    };
    const children = this.#resizersDiv.children;
    if (!this.#allResizerDivs) {
      this.#allResizerDivs = Array.from(children);
      const boundResizerKeydown = this.#resizerKeydown.bind(this);
      const boundResizerBlur = this.#resizerBlur.bind(this);
      const signal = this._uiManager._signal;
      for (const div of this.#allResizerDivs) {
        const name4 = div.getAttribute("data-resizer-name");
        div.setAttribute("role", "spinbutton");
        div.addEventListener("keydown", boundResizerKeydown, {
          signal
        });
        div.addEventListener("blur", boundResizerBlur, {
          signal
        });
        div.addEventListener("focus", this.#resizerFocus.bind(this, name4), {
          signal
        });
        div.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[name4]);
      }
    }
    const first = this.#allResizerDivs[0];
    let firstPosition = 0;
    for (const div of children) {
      if (div === first) {
        break;
      }
      firstPosition++;
    }
    const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);
    if (nextFirstPosition !== firstPosition) {
      if (nextFirstPosition < firstPosition) {
        for (let i19 = 0; i19 < firstPosition - nextFirstPosition; i19++) {
          this.#resizersDiv.append(this.#resizersDiv.firstChild);
        }
      } else if (nextFirstPosition > firstPosition) {
        for (let i19 = 0; i19 < nextFirstPosition - firstPosition; i19++) {
          this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);
        }
      }
      let i18 = 0;
      for (const child of children) {
        const div = this.#allResizerDivs[i18++];
        const name4 = div.getAttribute("data-resizer-name");
        child.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[name4]);
      }
    }
    this.#setResizerTabIndex(0);
    this.#isResizerEnabledForKeyboard = true;
    this.#resizersDiv.firstChild.focus({
      focusVisible: true
    });
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  #resizerKeydown(event) {
    _AnnotationEditor._resizerKeyboardManager.exec(this, event);
  }
  #resizerBlur(event) {
    if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {
      this.#stopResizing();
    }
  }
  #resizerFocus(name4) {
    this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name4 : "";
  }
  #setResizerTabIndex(value) {
    if (!this.#allResizerDivs) {
      return;
    }
    for (const div of this.#allResizerDivs) {
      div.tabIndex = value;
    }
  }
  _resizeWithKeyboard(x3, y12) {
    if (!this.#isResizerEnabledForKeyboard) {
      return;
    }
    this.#resizerPointermove(this.#focusedResizerName, {
      deltaX: x3,
      deltaY: y12,
      fromKeyboard: true
    });
  }
  #stopResizing() {
    this.#isResizerEnabledForKeyboard = false;
    this.#setResizerTabIndex(-1);
    this.#addResizeToUndoStack();
  }
  _stopResizingWithKeyboard() {
    this.#stopResizing();
    this.div.focus();
  }
  select() {
    if (this.isSelected && this._editToolbar) {
      this._editToolbar.show();
      return;
    }
    this.isSelected = true;
    this.makeResizable();
    this.div?.classList.add("selectedEditor");
    if (!this._editToolbar) {
      this.addEditToolbar().then(() => {
        if (this.div?.classList.contains("selectedEditor")) {
          this._editToolbar?.show();
        }
      });
      return;
    }
    this._editToolbar?.show();
    this.#altText?.toggleAltTextBadge(false);
  }
  focus() {
    if (this.div && !this.div.contains(document.activeElement)) {
      setTimeout(() => this.div?.focus({
        preventScroll: true
      }), 0);
    }
  }
  unselect() {
    if (!this.isSelected) {
      return;
    }
    this.isSelected = false;
    this.#resizersDiv?.classList.add("hidden");
    this.div?.classList.remove("selectedEditor");
    if (this.div?.contains(document.activeElement)) {
      this._uiManager.currentLayer.div.focus({
        preventScroll: true
      });
    }
    this._editToolbar?.hide();
    this.#altText?.toggleAltTextBadge(true);
    if (this.hasComment) {
      this._uiManager.toggleComment(this, false, false);
    }
  }
  updateParams(type, value) {
  }
  disableEditing() {
  }
  enableEditing() {
  }
  get canChangeContent() {
    return false;
  }
  enterInEditMode() {
    if (!this.canChangeContent) {
      return;
    }
    this.enableEditMode();
    this.div.focus();
  }
  dblclick(event) {
    if (event.target.nodeName === "BUTTON") {
      return;
    }
    this.enterInEditMode();
    this.parent.updateToolbar({
      mode: this.constructor._editorType,
      editId: this.id
    });
  }
  getElementForAltText() {
    return this.div;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return this.#isEditing;
  }
  set isEditing(value) {
    this.#isEditing = value;
    if (!this.parent) {
      return;
    }
    if (value) {
      this.parent.setSelected(this);
      this.parent.setActiveEditor(this);
    } else {
      this.parent.setActiveEditor(null);
    }
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return true;
  }
  get telemetryInitialData() {
    return {
      action: "added"
    };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(data, mustWait = false) {
    if (mustWait) {
      this.#telemetryTimeouts ||= /* @__PURE__ */ new Map();
      const {
        action
      } = data;
      let timeout = this.#telemetryTimeouts.get(action);
      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        this._reportTelemetry(data);
        this.#telemetryTimeouts.delete(action);
        if (this.#telemetryTimeouts.size === 0) {
          this.#telemetryTimeouts = null;
        }
      }, _AnnotationEditor._telemetryTimeout);
      this.#telemetryTimeouts.set(action, timeout);
      return;
    }
    data.type ||= this.editorType;
    this._uiManager._eventBus.dispatch("reporttelemetry", {
      source: this,
      details: {
        type: "editing",
        data
      }
    });
  }
  show(visible = this._isVisible) {
    this.div.classList.toggle("hidden", !visible);
    this._isVisible = visible;
  }
  enable() {
    if (this.div) {
      this.div.tabIndex = 0;
    }
    this.#disabled = false;
  }
  disable() {
    if (this.div) {
      this.div.tabIndex = -1;
    }
    this.#disabled = true;
  }
  updateFakeAnnotationElement(annotationLayer) {
    if (!this.#fakeAnnotation && !this.deleted) {
      this.#fakeAnnotation = annotationLayer.addFakeAnnotation(this);
      return;
    }
    if (this.deleted) {
      this.#fakeAnnotation.remove();
      this.#fakeAnnotation = null;
      return;
    }
    if (this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized) {
      this.#fakeAnnotation.updateEdited({
        rect: this.getPDFRect(),
        popup: this.comment
      });
    }
  }
  renderAnnotationElement(annotation) {
    if (this.deleted) {
      annotation.hide();
      return null;
    }
    let content = annotation.container.querySelector(".annotationContent");
    if (!content) {
      content = document.createElement("div");
      content.classList.add("annotationContent", this.editorType);
      annotation.container.prepend(content);
    } else if (content.nodeName === "CANVAS") {
      const canvas = content;
      content = document.createElement("div");
      content.classList.add("annotationContent", this.editorType);
      canvas.before(content);
    }
    return content;
  }
  resetAnnotationElement(annotation) {
    const {
      firstChild
    } = annotation.container;
    if (firstChild?.nodeName === "DIV" && firstChild.classList.contains("annotationContent")) {
      firstChild.remove();
    }
  }
};
var FakeEditor = class extends AnnotationEditor {
  static {
    __name(this, "FakeEditor");
  }
  constructor(params) {
    super(params);
    this.annotationElementId = params.annotationElementId;
    this.deleted = true;
  }
  serialize() {
    return this.serializeDeleted();
  }
};
;
var SEED = 3285377520;
var MASK_HIGH = 4294901760;
var MASK_LOW = 65535;
var MurmurHash3_64 = class {
  static {
    __name(this, "MurmurHash3_64");
  }
  constructor(seed) {
    this.h1 = seed ? seed & 4294967295 : SEED;
    this.h2 = seed ? seed & 4294967295 : SEED;
  }
  update(input) {
    let data, length;
    if (typeof input === "string") {
      data = new Uint8Array(input.length * 2);
      length = 0;
      for (let i18 = 0, ii = input.length; i18 < ii; i18++) {
        const code = input.charCodeAt(i18);
        if (code <= 255) {
          data[length++] = code;
        } else {
          data[length++] = code >>> 8;
          data[length++] = code & 255;
        }
      }
    } else if (ArrayBuffer.isView(input)) {
      data = input.slice();
      length = data.byteLength;
    } else {
      throw new Error("Invalid data format, must be a string or TypedArray.");
    }
    const blockCounts = length >> 2;
    const tailLength = length - blockCounts * 4;
    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
    let k1 = 0, k22 = 0;
    let h1 = this.h1, h22 = this.h2;
    const C1 = 3432918353, C22 = 461845907;
    const C1_LOW = C1 & MASK_LOW, C2_LOW = C22 & MASK_LOW;
    for (let i18 = 0; i18 < blockCounts; i18++) {
      if (i18 & 1) {
        k1 = dataUint32[i18];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C22 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = h1 * 5 + 3864292196;
      } else {
        k22 = dataUint32[i18];
        k22 = k22 * C1 & MASK_HIGH | k22 * C1_LOW & MASK_LOW;
        k22 = k22 << 15 | k22 >>> 17;
        k22 = k22 * C22 & MASK_HIGH | k22 * C2_LOW & MASK_LOW;
        h22 ^= k22;
        h22 = h22 << 13 | h22 >>> 19;
        h22 = h22 * 5 + 3864292196;
      }
    }
    k1 = 0;
    switch (tailLength) {
      case 3:
        k1 ^= data[blockCounts * 4 + 2] << 16;
      case 2:
        k1 ^= data[blockCounts * 4 + 1] << 8;
      case 1:
        k1 ^= data[blockCounts * 4];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C22 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        if (blockCounts & 1) {
          h1 ^= k1;
        } else {
          h22 ^= k1;
        }
    }
    this.h1 = h1;
    this.h2 = h22;
  }
  hexdigest() {
    let h1 = this.h1, h22 = this.h2;
    h1 ^= h22 >>> 1;
    h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
    h22 = h22 * 4283543511 & MASK_HIGH | ((h22 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
    h1 ^= h22 >>> 1;
    h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
    h22 = h22 * 3301882366 & MASK_HIGH | ((h22 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
    h1 ^= h22 >>> 1;
    return (h1 >>> 0).toString(16).padStart(8, "0") + (h22 >>> 0).toString(16).padStart(8, "0");
  }
};
;
var SerializableEmpty = Object.freeze({
  map: null,
  hash: "",
  transfer: void 0
});
var AnnotationStorage = class {
  static {
    __name(this, "AnnotationStorage");
  }
  #modified = false;
  #modifiedIds = null;
  #editorsMap = null;
  #storage = /* @__PURE__ */ new Map();
  constructor() {
    this.onSetModified = null;
    this.onResetModified = null;
    this.onAnnotationEditor = null;
  }
  getValue(key, defaultValue) {
    const value = this.#storage.get(key);
    if (value === void 0) {
      return defaultValue;
    }
    return Object.assign(defaultValue, value);
  }
  getRawValue(key) {
    return this.#storage.get(key);
  }
  remove(key) {
    const storedValue = this.#storage.get(key);
    if (storedValue === void 0) {
      return;
    }
    if (storedValue instanceof AnnotationEditor) {
      this.#editorsMap.delete(storedValue.annotationElementId);
    }
    this.#storage.delete(key);
    if (this.#storage.size === 0) {
      this.resetModified();
    }
    if (typeof this.onAnnotationEditor === "function") {
      for (const value of this.#storage.values()) {
        if (value instanceof AnnotationEditor) {
          return;
        }
      }
      this.onAnnotationEditor(null);
    }
  }
  setValue(key, value) {
    const obj = this.#storage.get(key);
    let modified = false;
    if (obj !== void 0) {
      for (const [entry, val] of Object.entries(value)) {
        if (obj[entry] !== val) {
          modified = true;
          obj[entry] = val;
        }
      }
    } else {
      modified = true;
      this.#storage.set(key, value);
    }
    if (modified) {
      this.#setModified();
    }
    if (value instanceof AnnotationEditor) {
      (this.#editorsMap ||= /* @__PURE__ */ new Map()).set(value.annotationElementId, value);
      if (typeof this.onAnnotationEditor === "function") {
        this.onAnnotationEditor(value.constructor._type);
      }
    }
  }
  has(key) {
    return this.#storage.has(key);
  }
  get size() {
    return this.#storage.size;
  }
  #setModified() {
    if (!this.#modified) {
      this.#modified = true;
      if (typeof this.onSetModified === "function") {
        this.onSetModified();
      }
    }
  }
  resetModified() {
    if (this.#modified) {
      this.#modified = false;
      if (typeof this.onResetModified === "function") {
        this.onResetModified();
      }
    }
  }
  get print() {
    return new PrintAnnotationStorage(this);
  }
  get serializable() {
    if (this.#storage.size === 0) {
      return SerializableEmpty;
    }
    const map2 = /* @__PURE__ */ new Map(), hash = new MurmurHash3_64(), transfer = [];
    const context2 = /* @__PURE__ */ Object.create(null);
    let hasBitmap = false;
    for (const [key, val] of this.#storage) {
      const serialized = val instanceof AnnotationEditor ? val.serialize(false, context2) : val;
      if (serialized) {
        map2.set(key, serialized);
        hash.update(`${key}:${JSON.stringify(serialized)}`);
        hasBitmap ||= !!serialized.bitmap;
      }
    }
    if (hasBitmap) {
      for (const value of map2.values()) {
        if (value.bitmap) {
          transfer.push(value.bitmap);
        }
      }
    }
    return map2.size > 0 ? {
      map: map2,
      hash: hash.hexdigest(),
      transfer
    } : SerializableEmpty;
  }
  get editorStats() {
    let stats = null;
    const typeToEditor = /* @__PURE__ */ new Map();
    let numberOfEditedComments = 0;
    let numberOfDeletedComments = 0;
    for (const value of this.#storage.values()) {
      if (!(value instanceof AnnotationEditor)) {
        if (value.popup) {
          if (value.popup.deleted) {
            numberOfDeletedComments += 1;
          } else {
            numberOfEditedComments += 1;
          }
        }
        continue;
      }
      if (value.isCommentDeleted) {
        numberOfDeletedComments += 1;
      } else if (value.hasEditedComment) {
        numberOfEditedComments += 1;
      }
      const editorStats = value.telemetryFinalData;
      if (!editorStats) {
        continue;
      }
      const {
        type
      } = editorStats;
      if (!typeToEditor.has(type)) {
        typeToEditor.set(type, Object.getPrototypeOf(value).constructor);
      }
      stats ||= /* @__PURE__ */ Object.create(null);
      const map2 = stats[type] ||= /* @__PURE__ */ new Map();
      for (const [key, val] of Object.entries(editorStats)) {
        if (key === "type") {
          continue;
        }
        let counters = map2.get(key);
        if (!counters) {
          counters = /* @__PURE__ */ new Map();
          map2.set(key, counters);
        }
        const count2 = counters.get(val) ?? 0;
        counters.set(val, count2 + 1);
      }
    }
    if (numberOfDeletedComments > 0 || numberOfEditedComments > 0) {
      stats ||= /* @__PURE__ */ Object.create(null);
      stats.comments = {
        deleted: numberOfDeletedComments,
        edited: numberOfEditedComments
      };
    }
    if (!stats) {
      return null;
    }
    for (const [type, editor] of typeToEditor) {
      stats[type] = editor.computeTelemetryFinalData(stats[type]);
    }
    return stats;
  }
  resetModifiedIds() {
    this.#modifiedIds = null;
  }
  updateEditor(annotationId, data) {
    const value = this.#editorsMap?.get(annotationId);
    if (value) {
      value.updateFromAnnotationLayer(data);
      return true;
    }
    return false;
  }
  getEditor(annotationId) {
    return this.#editorsMap?.get(annotationId) || null;
  }
  get modifiedIds() {
    if (this.#modifiedIds) {
      return this.#modifiedIds;
    }
    const ids = [];
    if (this.#editorsMap) {
      for (const value of this.#editorsMap.values()) {
        if (!value.serialize()) {
          continue;
        }
        ids.push(value.annotationElementId);
      }
    }
    return this.#modifiedIds = {
      ids: new Set(ids),
      hash: ids.join(",")
    };
  }
  [Symbol.iterator]() {
    return this.#storage.entries();
  }
};
var PrintAnnotationStorage = class extends AnnotationStorage {
  static {
    __name(this, "PrintAnnotationStorage");
  }
  #serializable;
  constructor(parent) {
    super();
    const {
      map: map2,
      hash,
      transfer
    } = parent.serializable;
    const clone = structuredClone(map2, transfer ? {
      transfer
    } : null);
    this.#serializable = {
      map: clone,
      hash,
      transfer
    };
  }
  get print() {
    unreachable("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return this.#serializable;
  }
  get modifiedIds() {
    return shadow(this, "modifiedIds", {
      ids: /* @__PURE__ */ new Set(),
      hash: ""
    });
  }
};
;
var FontLoader = class {
  static {
    __name(this, "FontLoader");
  }
  #systemFonts = /* @__PURE__ */ new Set();
  constructor({
    ownerDocument = globalThis.document,
    styleElement = null
  }) {
    this._document = ownerDocument;
    this.nativeFontFaces = /* @__PURE__ */ new Set();
    this.styleElement = null;
    this.loadingRequests = [];
    this.loadTestFontId = 0;
  }
  addNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.add(nativeFontFace);
    this._document.fonts.add(nativeFontFace);
  }
  removeNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.delete(nativeFontFace);
    this._document.fonts.delete(nativeFontFace);
  }
  insertRule(rule) {
    if (!this.styleElement) {
      this.styleElement = this._document.createElement("style");
      this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
    }
    const styleSheet = this.styleElement.sheet;
    styleSheet.insertRule(rule, styleSheet.cssRules.length);
  }
  clear() {
    for (const nativeFontFace of this.nativeFontFaces) {
      this._document.fonts.delete(nativeFontFace);
    }
    this.nativeFontFaces.clear();
    this.#systemFonts.clear();
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }
  async loadSystemFont({
    systemFontInfo: info2,
    disableFontFace,
    _inspectFont
  }) {
    if (!info2 || this.#systemFonts.has(info2.loadedName)) {
      return;
    }
    assert2(!disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
    if (this.isFontLoadingAPISupported) {
      const {
        loadedName,
        src,
        style
      } = info2;
      const fontFace = new FontFace(loadedName, src, style);
      this.addNativeFontFace(fontFace);
      try {
        await fontFace.load();
        this.#systemFonts.add(loadedName);
        _inspectFont?.(info2);
      } catch {
        warn(`Cannot load system font: ${info2.baseFontName}, installing it could help to improve PDF rendering.`);
        this.removeNativeFontFace(fontFace);
      }
      return;
    }
    unreachable("Not implemented: loadSystemFont without the Font Loading API.");
  }
  async bind(font) {
    if (font.attached || font.missingFile && !font.systemFontInfo) {
      return;
    }
    font.attached = true;
    if (font.systemFontInfo) {
      await this.loadSystemFont(font);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const nativeFontFace = font.createNativeFontFace();
      if (nativeFontFace) {
        this.addNativeFontFace(nativeFontFace);
        try {
          await nativeFontFace.loaded;
        } catch (ex) {
          warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
          font.disableFontFace = true;
          throw ex;
        }
      }
      return;
    }
    const rule = font.createFontFaceRule();
    if (rule) {
      this.insertRule(rule);
      if (this.isSyncFontLoadingSupported) {
        return;
      }
      await new Promise((resolve) => {
        const request = this._queueLoadingCallback(resolve);
        this._prepareFontLoadEvent(font, request);
      });
    }
  }
  get isFontLoadingAPISupported() {
    const hasFonts = !!this._document?.fonts;
    return shadow(this, "isFontLoadingAPISupported", hasFonts);
  }
  get isSyncFontLoadingSupported() {
    return shadow(this, "isSyncFontLoadingSupported", isNodeJS || util_FeatureTest.platform.isFirefox);
  }
  _queueLoadingCallback(callback) {
    function completeRequest() {
      assert2(!request.done, "completeRequest() cannot be called twice.");
      request.done = true;
      while (loadingRequests.length > 0 && loadingRequests[0].done) {
        const otherRequest = loadingRequests.shift();
        setTimeout(otherRequest.callback, 0);
      }
    }
    __name(completeRequest, "completeRequest");
    const {
      loadingRequests
    } = this;
    const request = {
      done: false,
      complete: completeRequest,
      callback
    };
    loadingRequests.push(request);
    return request;
  }
  get _loadTestFont() {
    const testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
    return shadow(this, "_loadTestFont", testFont);
  }
  _prepareFontLoadEvent(font, request) {
    function int32(data2, offset) {
      return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
    }
    __name(int32, "int32");
    function spliceString(s18, offset, remove, insert) {
      const chunk1 = s18.substring(0, offset);
      const chunk2 = s18.substring(offset + remove);
      return chunk1 + insert + chunk2;
    }
    __name(spliceString, "spliceString");
    let i18, ii;
    const canvas = this._document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext("2d");
    let called = 0;
    function isFontReady(name4, callback) {
      if (++called > 30) {
        warn("Load test font never loaded.");
        callback();
        return;
      }
      ctx.font = "30px " + name4;
      ctx.fillText(".", 0, 20);
      const imageData = ctx.getImageData(0, 0, 1, 1);
      if (imageData.data[3] > 0) {
        callback();
        return;
      }
      setTimeout(isFontReady.bind(null, name4, callback));
    }
    __name(isFontReady, "isFontReady");
    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
    let data = this._loadTestFont;
    const COMMENT_OFFSET = 976;
    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
    const CFF_CHECKSUM_OFFSET = 16;
    const XXXX_VALUE = 1482184792;
    let checksum = int32(data, CFF_CHECKSUM_OFFSET);
    for (i18 = 0, ii = loadTestFontId.length - 3; i18 < ii; i18 += 4) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i18) | 0;
    }
    if (i18 < loadTestFontId.length) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i18) | 0;
    }
    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));
    const url = `url(data:font/opentype;base64,${btoa(data)});`;
    const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
    this.insertRule(rule);
    const div = this._document.createElement("div");
    div.style.visibility = "hidden";
    div.style.width = div.style.height = "10px";
    div.style.position = "absolute";
    div.style.top = div.style.left = "0px";
    for (const name4 of [font.loadedName, loadTestFontId]) {
      const span = this._document.createElement("span");
      span.textContent = "Hi";
      span.style.fontFamily = name4;
      div.append(span);
    }
    this._document.body.append(div);
    isFontReady(loadTestFontId, () => {
      div.remove();
      request.complete();
    });
  }
};
var FontFaceObject = class {
  static {
    __name(this, "FontFaceObject");
  }
  #fontData;
  constructor(translatedData, inspectFont = null, extra, charProcOperatorList) {
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    this.#fontData = translatedData;
    this._inspectFont = inspectFont;
    if (extra) {
      Object.assign(this, extra);
    }
    if (charProcOperatorList) {
      this.charProcOperatorList = charProcOperatorList;
    }
  }
  createNativeFontFace() {
    if (!this.data || this.disableFontFace) {
      return null;
    }
    let nativeFontFace;
    if (!this.cssFontInfo) {
      nativeFontFace = new FontFace(this.loadedName, this.data, {});
    } else {
      const css = {
        weight: this.cssFontInfo.fontWeight
      };
      if (this.cssFontInfo.italicAngle) {
        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
      }
      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
    }
    this._inspectFont?.(this);
    return nativeFontFace;
  }
  createFontFaceRule() {
    if (!this.data || this.disableFontFace) {
      return null;
    }
    const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;
    let rule;
    if (!this.cssFontInfo) {
      rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
    } else {
      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
      if (this.cssFontInfo.italicAngle) {
        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
      }
      rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
    }
    this._inspectFont?.(this, url);
    return rule;
  }
  getPathGenerator(objs, character) {
    if (this.compiledGlyphs[character] !== void 0) {
      return this.compiledGlyphs[character];
    }
    const objId = this.loadedName + "_path_" + character;
    let cmds;
    try {
      cmds = objs.get(objId);
    } catch (ex) {
      warn(`getPathGenerator - ignoring character: "${ex}".`);
    }
    const path = new Path2D(cmds || "");
    if (!this.fontExtraProperties) {
      objs.delete(objId);
    }
    return this.compiledGlyphs[character] = path;
  }
  get black() {
    return this.#fontData.black;
  }
  get bold() {
    return this.#fontData.bold;
  }
  get disableFontFace() {
    return this.#fontData.disableFontFace ?? false;
  }
  get fontExtraProperties() {
    return this.#fontData.fontExtraProperties ?? false;
  }
  get isInvalidPDFjsFont() {
    return this.#fontData.isInvalidPDFjsFont;
  }
  get isType3Font() {
    return this.#fontData.isType3Font;
  }
  get italic() {
    return this.#fontData.italic;
  }
  get missingFile() {
    return this.#fontData.missingFile;
  }
  get remeasure() {
    return this.#fontData.remeasure;
  }
  get vertical() {
    return this.#fontData.vertical;
  }
  get ascent() {
    return this.#fontData.ascent;
  }
  get defaultWidth() {
    return this.#fontData.defaultWidth;
  }
  get descent() {
    return this.#fontData.descent;
  }
  get bbox() {
    return this.#fontData.bbox;
  }
  get fontMatrix() {
    return this.#fontData.fontMatrix;
  }
  get fallbackName() {
    return this.#fontData.fallbackName;
  }
  get loadedName() {
    return this.#fontData.loadedName;
  }
  get mimetype() {
    return this.#fontData.mimetype;
  }
  get name() {
    return this.#fontData.name;
  }
  get data() {
    return this.#fontData.data;
  }
  clearData() {
    this.#fontData.clearData();
  }
  get cssFontInfo() {
    return this.#fontData.cssFontInfo;
  }
  get systemFontInfo() {
    return this.#fontData.systemFontInfo;
  }
  get defaultVMetrics() {
    return this.#fontData.defaultVMetrics;
  }
};
;
function getUrlProp(val) {
  if (val instanceof URL) {
    return val.href;
  }
  if (typeof val === "string") {
    if (isNodeJS) {
      return val;
    }
    const url = URL.parse(val, window.location);
    if (url) {
      return url.href;
    }
  }
  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
}
__name(getUrlProp, "getUrlProp");
function getDataProp(val) {
  if (isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) {
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  }
  if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
    return val;
  }
  if (typeof val === "string") {
    return stringToBytes(val);
  }
  if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === "object" && !isNaN(val?.length)) {
    return new Uint8Array(val);
  }
  throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
}
__name(getDataProp, "getDataProp");
function getFactoryUrlProp(val) {
  if (typeof val !== "string") {
    return null;
  }
  if (val.endsWith("/")) {
    return val;
  }
  throw new Error(`Invalid factory url: "${val}" must include trailing slash.`);
}
__name(getFactoryUrlProp, "getFactoryUrlProp");
var isRefProxy = /* @__PURE__ */ __name((v8) => typeof v8 === "object" && Number.isInteger(v8?.num) && v8.num >= 0 && Number.isInteger(v8?.gen) && v8.gen >= 0, "isRefProxy");
var isNameProxy = /* @__PURE__ */ __name((v8) => typeof v8 === "object" && typeof v8?.name === "string", "isNameProxy");
var isValidExplicitDest = _isValidExplicitDest.bind(null, isRefProxy, isNameProxy);
var LoopbackPort = class {
  static {
    __name(this, "LoopbackPort");
  }
  #listeners = /* @__PURE__ */ new Map();
  #deferred = Promise.resolve();
  postMessage(obj, transfer) {
    const event = {
      data: structuredClone(obj, transfer ? {
        transfer
      } : null)
    };
    this.#deferred.then(() => {
      for (const [listener] of this.#listeners) {
        listener.call(this, event);
      }
    });
  }
  addEventListener(name4, listener, options = null) {
    let rmAbort = null;
    if (options?.signal instanceof AbortSignal) {
      const {
        signal
      } = options;
      if (signal.aborted) {
        warn("LoopbackPort - cannot use an `aborted` signal.");
        return;
      }
      const onAbort = /* @__PURE__ */ __name(() => this.removeEventListener(name4, listener), "onAbort");
      rmAbort = /* @__PURE__ */ __name(() => signal.removeEventListener("abort", onAbort), "rmAbort");
      signal.addEventListener("abort", onAbort);
    }
    this.#listeners.set(listener, rmAbort);
  }
  removeEventListener(name4, listener) {
    const rmAbort = this.#listeners.get(listener);
    rmAbort?.();
    this.#listeners.delete(listener);
  }
  terminate() {
    for (const [, rmAbort] of this.#listeners) {
      rmAbort?.();
    }
    this.#listeners.clear();
  }
};
;
var CallbackKind = {
  DATA: 1,
  ERROR: 2
};
var StreamKind = {
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function onFn() {
}
__name(onFn, "onFn");
function wrapReason(ex) {
  if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof PasswordException || ex instanceof ResponseException || ex instanceof UnknownErrorException) {
    return ex;
  }
  if (!(ex instanceof Error || typeof ex === "object" && ex !== null)) {
    unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  }
  switch (ex.name) {
    case "AbortException":
      return new AbortException(ex.message);
    case "InvalidPDFException":
      return new InvalidPDFException(ex.message);
    case "PasswordException":
      return new PasswordException(ex.message, ex.code);
    case "ResponseException":
      return new ResponseException(ex.message, ex.status, ex.missing);
    case "UnknownErrorException":
      return new UnknownErrorException(ex.message, ex.details);
  }
  return new UnknownErrorException(ex.message, ex.toString());
}
__name(wrapReason, "wrapReason");
var MessageHandler = class {
  static {
    __name(this, "MessageHandler");
  }
  #messageAC = new AbortController();
  constructor(sourceName, targetName, comObj) {
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = /* @__PURE__ */ Object.create(null);
    this.streamControllers = /* @__PURE__ */ Object.create(null);
    this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
    this.actionHandler = /* @__PURE__ */ Object.create(null);
    comObj.addEventListener("message", this.#onMessage.bind(this), {
      signal: this.#messageAC.signal
    });
  }
  #onMessage({
    data
  }) {
    if (data.targetName !== this.sourceName) {
      return;
    }
    if (data.stream) {
      this.#processStreamMessage(data);
      return;
    }
    if (data.callback) {
      const callbackId = data.callbackId;
      const capability = this.callbackCapabilities[callbackId];
      if (!capability) {
        throw new Error(`Cannot resolve callback ${callbackId}`);
      }
      delete this.callbackCapabilities[callbackId];
      if (data.callback === CallbackKind.DATA) {
        capability.resolve(data.data);
      } else if (data.callback === CallbackKind.ERROR) {
        capability.reject(wrapReason(data.reason));
      } else {
        throw new Error("Unexpected callback case");
      }
      return;
    }
    const action = this.actionHandler[data.action];
    if (!action) {
      throw new Error(`Unknown action from worker: ${data.action}`);
    }
    if (data.callbackId) {
      const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
      Promise.try(action, data.data).then(function(result) {
        comObj.postMessage({
          sourceName,
          targetName,
          callback: CallbackKind.DATA,
          callbackId: data.callbackId,
          data: result
        });
      }, function(reason) {
        comObj.postMessage({
          sourceName,
          targetName,
          callback: CallbackKind.ERROR,
          callbackId: data.callbackId,
          reason: wrapReason(reason)
        });
      });
      return;
    }
    if (data.streamId) {
      this.#createStreamSink(data);
      return;
    }
    action(data.data);
  }
  on(actionName, handler) {
    const ah = this.actionHandler;
    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }
    ah[actionName] = handler;
  }
  send(actionName, data, transfers) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data
    }, transfers);
  }
  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = Promise.withResolvers();
    this.callbackCapabilities[callbackId] = capability;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }
    return capability.promise;
  }
  sendWithStream(actionName, data, queueingStrategy, transfers) {
    const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
    return new ReadableStream({
      start: /* @__PURE__ */ __name((controller) => {
        const startCapability = Promise.withResolvers();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };
        comObj.postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data,
          desiredSize: controller.desiredSize
        }, transfers);
        return startCapability.promise;
      }, "start"),
      pull: /* @__PURE__ */ __name((controller) => {
        const pullCapability = Promise.withResolvers();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      }, "pull"),
      cancel: /* @__PURE__ */ __name((reason) => {
        assert2(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = Promise.withResolvers();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }, "cancel")
    }, queueingStrategy);
  }
  #createStreamSink(data) {
    const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
    const self2 = this, action = this.actionHandler[data.action];
    const streamSink = {
      enqueue(chunk, size = 1, transfers) {
        if (this.isCancelled) {
          return;
        }
        const lastDesiredSize = this.desiredSize;
        this.desiredSize -= size;
        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = Promise.withResolvers();
          this.ready = this.sinkCapability.promise;
        }
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ENQUEUE,
          streamId,
          chunk
        }, transfers);
      },
      close() {
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CLOSE,
          streamId
        });
        delete self2.streamSinks[streamId];
      },
      error(reason) {
        assert2(reason instanceof Error, "error must have a valid reason");
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ERROR,
          streamId,
          reason: wrapReason(reason)
        });
      },
      sinkCapability: Promise.withResolvers(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: data.desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    Promise.try(action, data.data, streamSink).then(function() {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        success: true
      });
    }, function(reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        reason: wrapReason(reason)
      });
    });
  }
  #processStreamMessage(data) {
    const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
    const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
    switch (data.stream) {
      case StreamKind.START_COMPLETE:
        if (data.success) {
          streamController.startCall.resolve();
        } else {
          streamController.startCall.reject(wrapReason(data.reason));
        }
        break;
      case StreamKind.PULL_COMPLETE:
        if (data.success) {
          streamController.pullCall.resolve();
        } else {
          streamController.pullCall.reject(wrapReason(data.reason));
        }
        break;
      case StreamKind.PULL:
        if (!streamSink) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
          break;
        }
        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
          streamSink.sinkCapability.resolve();
        }
        streamSink.desiredSize = data.desiredSize;
        Promise.try(streamSink.onPull || onFn).then(function() {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
        }, function(reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        break;
      case StreamKind.ENQUEUE:
        assert2(streamController, "enqueue should have stream controller");
        if (streamController.isClosed) {
          break;
        }
        streamController.controller.enqueue(data.chunk);
        break;
      case StreamKind.CLOSE:
        assert2(streamController, "close should have stream controller");
        if (streamController.isClosed) {
          break;
        }
        streamController.isClosed = true;
        streamController.controller.close();
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.ERROR:
        assert2(streamController, "error should have stream controller");
        streamController.controller.error(wrapReason(data.reason));
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.CANCEL_COMPLETE:
        if (data.success) {
          streamController.cancelCall.resolve();
        } else {
          streamController.cancelCall.reject(wrapReason(data.reason));
        }
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.CANCEL:
        if (!streamSink) {
          break;
        }
        const dataReason = wrapReason(data.reason);
        Promise.try(streamSink.onCancel || onFn, dataReason).then(function() {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            success: true
          });
        }, function(reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        streamSink.sinkCapability.reject(dataReason);
        streamSink.isCancelled = true;
        delete this.streamSinks[streamId];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }
  async #deleteStreamController(streamController, streamId) {
    await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);
    delete this.streamControllers[streamId];
  }
  destroy() {
    this.#messageAC?.abort();
    this.#messageAC = null;
  }
};
;
var BaseCanvasFactory = class {
  static {
    __name(this, "BaseCanvasFactory");
  }
  #enableHWA = false;
  constructor({
    enableHWA = false
  }) {
    this.#enableHWA = enableHWA;
  }
  create(width, height) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }
    const canvas = this._createCanvas(width, height);
    return {
      canvas,
      context: canvas.getContext("2d", {
        willReadFrequently: !this.#enableHWA
      })
    };
  }
  reset(canvasAndContext, width, height) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }
    canvasAndContext.canvas.width = width;
    canvasAndContext.canvas.height = height;
  }
  destroy(canvasAndContext) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }
    canvasAndContext.canvas.width = 0;
    canvasAndContext.canvas.height = 0;
    canvasAndContext.canvas = null;
    canvasAndContext.context = null;
  }
  _createCanvas(width, height) {
    unreachable("Abstract method `_createCanvas` called.");
  }
};
var DOMCanvasFactory = class extends BaseCanvasFactory {
  static {
    __name(this, "DOMCanvasFactory");
  }
  constructor({
    ownerDocument = globalThis.document,
    enableHWA = false
  }) {
    super({
      enableHWA
    });
    this._document = ownerDocument;
  }
  _createCanvas(width, height) {
    const canvas = this._document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }
};
;
var BaseCMapReaderFactory = class {
  static {
    __name(this, "BaseCMapReaderFactory");
  }
  constructor({
    baseUrl = null,
    isCompressed = true
  }) {
    this.baseUrl = baseUrl;
    this.isCompressed = isCompressed;
  }
  async fetch({
    name: name4
  }) {
    if (!this.baseUrl) {
      throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
    }
    if (!name4) {
      throw new Error("CMap name must be specified.");
    }
    const url = this.baseUrl + name4 + (this.isCompressed ? ".bcmap" : "");
    return this._fetch(url).then((cMapData) => ({
      cMapData,
      isCompressed: this.isCompressed
    })).catch((reason) => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
    });
  }
  async _fetch(url) {
    unreachable("Abstract method `_fetch` called.");
  }
};
var DOMCMapReaderFactory = class extends BaseCMapReaderFactory {
  static {
    __name(this, "DOMCMapReaderFactory");
  }
  async _fetch(url) {
    const data = await fetchData(url, this.isCompressed ? "arraybuffer" : "text");
    return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);
  }
};
;
var BaseFilterFactory = class {
  static {
    __name(this, "BaseFilterFactory");
  }
  addFilter(maps) {
    return "none";
  }
  addHCMFilter(fgColor, bgColor) {
    return "none";
  }
  addAlphaFilter(map2) {
    return "none";
  }
  addLuminosityFilter(map2) {
    return "none";
  }
  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
    return "none";
  }
  destroy(keepHCM = false) {
  }
};
var DOMFilterFactory = class extends BaseFilterFactory {
  static {
    __name(this, "DOMFilterFactory");
  }
  #baseUrl;
  #_cache;
  #_defs;
  #docId;
  #document;
  #_hcmCache;
  #id = 0;
  constructor({
    docId,
    ownerDocument = globalThis.document
  }) {
    super();
    this.#docId = docId;
    this.#document = ownerDocument;
  }
  get #cache() {
    return this.#_cache ||= /* @__PURE__ */ new Map();
  }
  get #hcmCache() {
    return this.#_hcmCache ||= /* @__PURE__ */ new Map();
  }
  get #defs() {
    if (!this.#_defs) {
      const div = this.#document.createElement("div");
      const {
        style
      } = div;
      style.visibility = "hidden";
      style.contain = "strict";
      style.width = style.height = 0;
      style.position = "absolute";
      style.top = style.left = 0;
      style.zIndex = -1;
      const svg = this.#document.createElementNS(SVG_NS, "svg");
      svg.setAttribute("width", 0);
      svg.setAttribute("height", 0);
      this.#_defs = this.#document.createElementNS(SVG_NS, "defs");
      div.append(svg);
      svg.append(this.#_defs);
      this.#document.body.append(div);
    }
    return this.#_defs;
  }
  #createTables(maps) {
    if (maps.length === 1) {
      const mapR2 = maps[0];
      const buffer = new Array(256);
      for (let i18 = 0; i18 < 256; i18++) {
        buffer[i18] = mapR2[i18] / 255;
      }
      const table = buffer.join(",");
      return [table, table, table];
    }
    const [mapR, mapG, mapB] = maps;
    const bufferR = new Array(256);
    const bufferG = new Array(256);
    const bufferB = new Array(256);
    for (let i18 = 0; i18 < 256; i18++) {
      bufferR[i18] = mapR[i18] / 255;
      bufferG[i18] = mapG[i18] / 255;
      bufferB[i18] = mapB[i18] / 255;
    }
    return [bufferR.join(","), bufferG.join(","), bufferB.join(",")];
  }
  #createUrl(id) {
    if (this.#baseUrl === void 0) {
      this.#baseUrl = "";
      const url = this.#document.URL;
      if (url !== this.#document.baseURI) {
        if (isDataScheme(url)) {
          warn('#createUrl: ignore "data:"-URL for performance reasons.');
        } else {
          this.#baseUrl = updateUrlHash(url, "");
        }
      }
    }
    return `url(${this.#baseUrl}#${id})`;
  }
  addFilter(maps) {
    if (!maps) {
      return "none";
    }
    let value = this.#cache.get(maps);
    if (value) {
      return value;
    }
    const [tableR, tableG, tableB] = this.#createTables(maps);
    const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;
    value = this.#cache.get(key);
    if (value) {
      this.#cache.set(maps, value);
      return value;
    }
    const id = `g_${this.#docId}_transfer_map_${this.#id++}`;
    const url = this.#createUrl(id);
    this.#cache.set(maps, url);
    this.#cache.set(key, url);
    const filter = this.#createFilter(id);
    this.#addTransferMapConversion(tableR, tableG, tableB, filter);
    return url;
  }
  addHCMFilter(fgColor, bgColor) {
    const key = `${fgColor}-${bgColor}`;
    const filterName = "base";
    let info2 = this.#hcmCache.get(filterName);
    if (info2?.key === key) {
      return info2.url;
    }
    if (info2) {
      info2.filter?.remove();
      info2.key = key;
      info2.url = "none";
      info2.filter = null;
    } else {
      info2 = {
        key,
        url: "none",
        filter: null
      };
      this.#hcmCache.set(filterName, info2);
    }
    if (!fgColor || !bgColor) {
      return info2.url;
    }
    const fgRGB = this.#getRGB(fgColor);
    fgColor = Util.makeHexColor(...fgRGB);
    const bgRGB = this.#getRGB(bgColor);
    bgColor = Util.makeHexColor(...bgRGB);
    this.#defs.style.color = "";
    if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) {
      return info2.url;
    }
    const map2 = new Array(256);
    for (let i18 = 0; i18 <= 255; i18++) {
      const x3 = i18 / 255;
      map2[i18] = x3 <= 0.03928 ? x3 / 12.92 : ((x3 + 0.055) / 1.055) ** 2.4;
    }
    const table = map2.join(",");
    const id = `g_${this.#docId}_hcm_filter`;
    const filter = info2.filter = this.#createFilter(id);
    this.#addTransferMapConversion(table, table, table, filter);
    this.#addGrayConversion(filter);
    const getSteps = /* @__PURE__ */ __name((c21, n11) => {
      const start = fgRGB[c21] / 255;
      const end = bgRGB[c21] / 255;
      const arr = new Array(n11 + 1);
      for (let i18 = 0; i18 <= n11; i18++) {
        arr[i18] = start + i18 / n11 * (end - start);
      }
      return arr.join(",");
    }, "getSteps");
    this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);
    info2.url = this.#createUrl(id);
    return info2.url;
  }
  addAlphaFilter(map2) {
    let value = this.#cache.get(map2);
    if (value) {
      return value;
    }
    const [tableA] = this.#createTables([map2]);
    const key = `alpha_${tableA}`;
    value = this.#cache.get(key);
    if (value) {
      this.#cache.set(map2, value);
      return value;
    }
    const id = `g_${this.#docId}_alpha_map_${this.#id++}`;
    const url = this.#createUrl(id);
    this.#cache.set(map2, url);
    this.#cache.set(key, url);
    const filter = this.#createFilter(id);
    this.#addTransferMapAlphaConversion(tableA, filter);
    return url;
  }
  addLuminosityFilter(map2) {
    let value = this.#cache.get(map2 || "luminosity");
    if (value) {
      return value;
    }
    let tableA, key;
    if (map2) {
      [tableA] = this.#createTables([map2]);
      key = `luminosity_${tableA}`;
    } else {
      key = "luminosity";
    }
    value = this.#cache.get(key);
    if (value) {
      this.#cache.set(map2, value);
      return value;
    }
    const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;
    const url = this.#createUrl(id);
    this.#cache.set(map2, url);
    this.#cache.set(key, url);
    const filter = this.#createFilter(id);
    this.#addLuminosityConversion(filter);
    if (map2) {
      this.#addTransferMapAlphaConversion(tableA, filter);
    }
    return url;
  }
  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
    const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;
    let info2 = this.#hcmCache.get(filterName);
    if (info2?.key === key) {
      return info2.url;
    }
    if (info2) {
      info2.filter?.remove();
      info2.key = key;
      info2.url = "none";
      info2.filter = null;
    } else {
      info2 = {
        key,
        url: "none",
        filter: null
      };
      this.#hcmCache.set(filterName, info2);
    }
    if (!fgColor || !bgColor) {
      return info2.url;
    }
    const [fgRGB, bgRGB] = [fgColor, bgColor].map(this.#getRGB.bind(this));
    let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
    let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
    let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(this.#getRGB.bind(this));
    if (bgGray < fgGray) {
      [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];
    }
    this.#defs.style.color = "";
    const getSteps = /* @__PURE__ */ __name((fg, bg, n11) => {
      const arr = new Array(256);
      const step = (bgGray - fgGray) / n11;
      const newStart = fg / 255;
      const newStep = (bg - fg) / (255 * n11);
      let prev = 0;
      for (let i18 = 0; i18 <= n11; i18++) {
        const k5 = Math.round(fgGray + i18 * step);
        const value = newStart + i18 * newStep;
        for (let j2 = prev; j2 <= k5; j2++) {
          arr[j2] = value;
        }
        prev = k5 + 1;
      }
      for (let i18 = prev; i18 < 256; i18++) {
        arr[i18] = arr[prev - 1];
      }
      return arr.join(",");
    }, "getSteps");
    const id = `g_${this.#docId}_hcm_${filterName}_filter`;
    const filter = info2.filter = this.#createFilter(id);
    this.#addGrayConversion(filter);
    this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);
    info2.url = this.#createUrl(id);
    return info2.url;
  }
  destroy(keepHCM = false) {
    if (keepHCM && this.#_hcmCache?.size) {
      return;
    }
    this.#_defs?.parentNode.parentNode.remove();
    this.#_defs = null;
    this.#_cache?.clear();
    this.#_cache = null;
    this.#_hcmCache?.clear();
    this.#_hcmCache = null;
    this.#id = 0;
  }
  #addLuminosityConversion(filter) {
    const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
    feColorMatrix.setAttribute("type", "matrix");
    feColorMatrix.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0");
    filter.append(feColorMatrix);
  }
  #addGrayConversion(filter) {
    const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
    feColorMatrix.setAttribute("type", "matrix");
    feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
    filter.append(feColorMatrix);
  }
  #createFilter(id) {
    const filter = this.#document.createElementNS(SVG_NS, "filter");
    filter.setAttribute("color-interpolation-filters", "sRGB");
    filter.setAttribute("id", id);
    this.#defs.append(filter);
    return filter;
  }
  #appendFeFunc(feComponentTransfer, func, table) {
    const feFunc = this.#document.createElementNS(SVG_NS, func);
    feFunc.setAttribute("type", "discrete");
    feFunc.setAttribute("tableValues", table);
    feComponentTransfer.append(feFunc);
  }
  #addTransferMapConversion(rTable, gTable, bTable, filter) {
    const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
    filter.append(feComponentTransfer);
    this.#appendFeFunc(feComponentTransfer, "feFuncR", rTable);
    this.#appendFeFunc(feComponentTransfer, "feFuncG", gTable);
    this.#appendFeFunc(feComponentTransfer, "feFuncB", bTable);
  }
  #addTransferMapAlphaConversion(aTable, filter) {
    const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
    filter.append(feComponentTransfer);
    this.#appendFeFunc(feComponentTransfer, "feFuncA", aTable);
  }
  #getRGB(color) {
    this.#defs.style.color = color;
    return getRGB(getComputedStyle(this.#defs).getPropertyValue("color"));
  }
};
;
var BaseStandardFontDataFactory = class {
  static {
    __name(this, "BaseStandardFontDataFactory");
  }
  constructor({
    baseUrl = null
  }) {
    this.baseUrl = baseUrl;
  }
  async fetch({
    filename
  }) {
    if (!this.baseUrl) {
      throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
    }
    if (!filename) {
      throw new Error("Font filename must be specified.");
    }
    const url = `${this.baseUrl}${filename}`;
    return this._fetch(url).catch((reason) => {
      throw new Error(`Unable to load font data at: ${url}`);
    });
  }
  async _fetch(url) {
    unreachable("Abstract method `_fetch` called.");
  }
};
var DOMStandardFontDataFactory = class extends BaseStandardFontDataFactory {
  static {
    __name(this, "DOMStandardFontDataFactory");
  }
  async _fetch(url) {
    const data = await fetchData(url, "arraybuffer");
    return new Uint8Array(data);
  }
};
;
var BaseWasmFactory = class {
  static {
    __name(this, "BaseWasmFactory");
  }
  constructor({
    baseUrl = null
  }) {
    this.baseUrl = baseUrl;
  }
  async fetch({
    filename
  }) {
    if (!this.baseUrl) {
      throw new Error("Ensure that the `wasmUrl` API parameter is provided.");
    }
    if (!filename) {
      throw new Error("Wasm filename must be specified.");
    }
    const url = `${this.baseUrl}${filename}`;
    return this._fetch(url).catch((reason) => {
      throw new Error(`Unable to load wasm data at: ${url}`);
    });
  }
  async _fetch(url) {
    unreachable("Abstract method `_fetch` called.");
  }
};
var DOMWasmFactory = class extends BaseWasmFactory {
  static {
    __name(this, "DOMWasmFactory");
  }
  async _fetch(url) {
    const data = await fetchData(url, "arraybuffer");
    return new Uint8Array(data);
  }
};
;
if (isNodeJS) {
  warn("Please use the `legacy` build in Node.js environments.");
}
async function node_utils_fetchData(url) {
  const fs = process.getBuiltinModule("fs");
  const data = await fs.promises.readFile(url);
  return new Uint8Array(data);
}
__name(node_utils_fetchData, "node_utils_fetchData");
var NodeFilterFactory = class extends BaseFilterFactory {
  static {
    __name(this, "NodeFilterFactory");
  }
};
var NodeCanvasFactory = class extends BaseCanvasFactory {
  static {
    __name(this, "NodeCanvasFactory");
  }
  _createCanvas(width, height) {
    const require2 = process.getBuiltinModule("module").createRequire(import_meta.url);
    const canvas = require2("@napi-rs/canvas");
    return canvas.createCanvas(width, height);
  }
};
var NodeCMapReaderFactory = class extends BaseCMapReaderFactory {
  static {
    __name(this, "NodeCMapReaderFactory");
  }
  async _fetch(url) {
    return node_utils_fetchData(url);
  }
};
var NodeStandardFontDataFactory = class extends BaseStandardFontDataFactory {
  static {
    __name(this, "NodeStandardFontDataFactory");
  }
  async _fetch(url) {
    return node_utils_fetchData(url);
  }
};
var NodeWasmFactory = class extends BaseWasmFactory {
  static {
    __name(this, "NodeWasmFactory");
  }
  async _fetch(url) {
    return node_utils_fetchData(url);
  }
};
;
var FORCED_DEPENDENCY_LABEL = "__forcedDependency";
var {
  floor,
  ceil
} = Math;
function expandBBox(array, index, minX, minY, maxX, maxY) {
  array[index * 4 + 0] = Math.min(array[index * 4 + 0], minX);
  array[index * 4 + 1] = Math.min(array[index * 4 + 1], minY);
  array[index * 4 + 2] = Math.max(array[index * 4 + 2], maxX);
  array[index * 4 + 3] = Math.max(array[index * 4 + 3], maxY);
}
__name(expandBBox, "expandBBox");
var EMPTY_BBOX = new Uint32Array(new Uint8Array([255, 255, 0, 0]).buffer)[0];
var BBoxReader = class {
  static {
    __name(this, "BBoxReader");
  }
  #bboxes;
  #coords;
  constructor(bboxes, coords) {
    this.#bboxes = bboxes;
    this.#coords = coords;
  }
  get length() {
    return this.#bboxes.length;
  }
  isEmpty(i18) {
    return this.#bboxes[i18] === EMPTY_BBOX;
  }
  minX(i18) {
    return this.#coords[i18 * 4 + 0] / 256;
  }
  minY(i18) {
    return this.#coords[i18 * 4 + 1] / 256;
  }
  maxX(i18) {
    return (this.#coords[i18 * 4 + 2] + 1) / 256;
  }
  maxY(i18) {
    return (this.#coords[i18 * 4 + 3] + 1) / 256;
  }
};
var ensureDebugMetadata = /* @__PURE__ */ __name((map2, key) => {
  if (!map2) {
    return void 0;
  }
  let value = map2.get(key);
  if (!value) {
    value = {
      dependencies: /* @__PURE__ */ new Set(),
      isRenderingOperation: false
    };
    map2.set(key, value);
  }
  return value;
}, "ensureDebugMetadata");
var CanvasDependencyTracker = class {
  static {
    __name(this, "CanvasDependencyTracker");
  }
  #simple = {
    __proto__: null
  };
  #incremental = {
    __proto__: null,
    transform: [],
    moveText: [],
    sameLineText: [],
    [FORCED_DEPENDENCY_LABEL]: []
  };
  #namedDependencies = /* @__PURE__ */ new Map();
  #savesStack = [];
  #markedContentStack = [];
  #baseTransformStack = [[1, 0, 0, 1, 0, 0]];
  #clipBox = [-Infinity, -Infinity, Infinity, Infinity];
  #pendingBBox = new Float64Array([Infinity, Infinity, -Infinity, -Infinity]);
  #pendingBBoxIdx = -1;
  #pendingDependencies = /* @__PURE__ */ new Set();
  #operations = /* @__PURE__ */ new Map();
  #fontBBoxTrustworthy = /* @__PURE__ */ new Map();
  #canvasWidth;
  #canvasHeight;
  #bboxesCoords;
  #bboxes;
  #debugMetadata;
  constructor(canvas, operationsCount, recordDebugMetadata = false) {
    this.#canvasWidth = canvas.width;
    this.#canvasHeight = canvas.height;
    this.#initializeBBoxes(operationsCount);
    if (recordDebugMetadata) {
      this.#debugMetadata = /* @__PURE__ */ new Map();
    }
  }
  growOperationsCount(operationsCount) {
    if (operationsCount >= this.#bboxes.length) {
      this.#initializeBBoxes(operationsCount, this.#bboxes);
    }
  }
  #initializeBBoxes(operationsCount, oldBBoxes) {
    const buffer = new ArrayBuffer(operationsCount * 4);
    this.#bboxesCoords = new Uint8ClampedArray(buffer);
    this.#bboxes = new Uint32Array(buffer);
    if (oldBBoxes && oldBBoxes.length > 0) {
      this.#bboxes.set(oldBBoxes);
      this.#bboxes.fill(EMPTY_BBOX, oldBBoxes.length);
    } else {
      this.#bboxes.fill(EMPTY_BBOX);
    }
  }
  save(opIdx) {
    this.#simple = {
      __proto__: this.#simple
    };
    this.#incremental = {
      __proto__: this.#incremental,
      transform: {
        __proto__: this.#incremental.transform
      },
      moveText: {
        __proto__: this.#incremental.moveText
      },
      sameLineText: {
        __proto__: this.#incremental.sameLineText
      },
      [FORCED_DEPENDENCY_LABEL]: {
        __proto__: this.#incremental[FORCED_DEPENDENCY_LABEL]
      }
    };
    this.#clipBox = {
      __proto__: this.#clipBox
    };
    this.#savesStack.push(opIdx);
    return this;
  }
  restore(opIdx) {
    const previous = Object.getPrototypeOf(this.#simple);
    if (previous === null) {
      return this;
    }
    this.#simple = previous;
    this.#incremental = Object.getPrototypeOf(this.#incremental);
    this.#clipBox = Object.getPrototypeOf(this.#clipBox);
    const lastSave = this.#savesStack.pop();
    if (lastSave !== void 0) {
      ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);
      this.#bboxes[opIdx] = this.#bboxes[lastSave];
    }
    return this;
  }
  recordOpenMarker(idx) {
    this.#savesStack.push(idx);
    return this;
  }
  getOpenMarker() {
    if (this.#savesStack.length === 0) {
      return null;
    }
    return this.#savesStack.at(-1);
  }
  recordCloseMarker(opIdx) {
    const lastSave = this.#savesStack.pop();
    if (lastSave !== void 0) {
      ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);
      this.#bboxes[opIdx] = this.#bboxes[lastSave];
    }
    return this;
  }
  beginMarkedContent(opIdx) {
    this.#markedContentStack.push(opIdx);
    return this;
  }
  endMarkedContent(opIdx) {
    const lastSave = this.#markedContentStack.pop();
    if (lastSave !== void 0) {
      ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);
      this.#bboxes[opIdx] = this.#bboxes[lastSave];
    }
    return this;
  }
  pushBaseTransform(ctx) {
    this.#baseTransformStack.push(Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform()));
    return this;
  }
  popBaseTransform() {
    if (this.#baseTransformStack.length > 1) {
      this.#baseTransformStack.pop();
    }
    return this;
  }
  recordSimpleData(name4, idx) {
    this.#simple[name4] = idx;
    return this;
  }
  recordIncrementalData(name4, idx) {
    this.#incremental[name4].push(idx);
    return this;
  }
  resetIncrementalData(name4, idx) {
    this.#incremental[name4].length = 0;
    return this;
  }
  recordNamedData(name4, idx) {
    this.#namedDependencies.set(name4, idx);
    return this;
  }
  recordSimpleDataFromNamed(name4, depName, fallbackIdx) {
    this.#simple[name4] = this.#namedDependencies.get(depName) ?? fallbackIdx;
  }
  recordFutureForcedDependency(name4, idx) {
    this.recordIncrementalData(FORCED_DEPENDENCY_LABEL, idx);
    return this;
  }
  inheritSimpleDataAsFutureForcedDependencies(names) {
    for (const name4 of names) {
      if (name4 in this.#simple) {
        this.recordFutureForcedDependency(name4, this.#simple[name4]);
      }
    }
    return this;
  }
  inheritPendingDependenciesAsFutureForcedDependencies() {
    for (const dep of this.#pendingDependencies) {
      this.recordFutureForcedDependency(FORCED_DEPENDENCY_LABEL, dep);
    }
    return this;
  }
  resetBBox(idx) {
    if (this.#pendingBBoxIdx !== idx) {
      this.#pendingBBoxIdx = idx;
      this.#pendingBBox[0] = Infinity;
      this.#pendingBBox[1] = Infinity;
      this.#pendingBBox[2] = -Infinity;
      this.#pendingBBox[3] = -Infinity;
    }
    return this;
  }
  recordClipBox(idx, ctx, minX, maxX, minY, maxY) {
    const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());
    const clipBox = [Infinity, Infinity, -Infinity, -Infinity];
    Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, clipBox);
    const intersection = Util.intersect(this.#clipBox, clipBox);
    if (intersection) {
      this.#clipBox[0] = intersection[0];
      this.#clipBox[1] = intersection[1];
      this.#clipBox[2] = intersection[2];
      this.#clipBox[3] = intersection[3];
    } else {
      this.#clipBox[0] = this.#clipBox[1] = Infinity;
      this.#clipBox[2] = this.#clipBox[3] = -Infinity;
    }
    return this;
  }
  recordBBox(idx, ctx, minX, maxX, minY, maxY) {
    const clipBox = this.#clipBox;
    if (clipBox[0] === Infinity) {
      return this;
    }
    const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());
    if (clipBox[0] === -Infinity) {
      Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, this.#pendingBBox);
      return this;
    }
    const bbox = [Infinity, Infinity, -Infinity, -Infinity];
    Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, bbox);
    this.#pendingBBox[0] = Math.min(this.#pendingBBox[0], Math.max(bbox[0], clipBox[0]));
    this.#pendingBBox[1] = Math.min(this.#pendingBBox[1], Math.max(bbox[1], clipBox[1]));
    this.#pendingBBox[2] = Math.max(this.#pendingBBox[2], Math.min(bbox[2], clipBox[2]));
    this.#pendingBBox[3] = Math.max(this.#pendingBBox[3], Math.min(bbox[3], clipBox[3]));
    return this;
  }
  recordCharacterBBox(idx, ctx, font, scale = 1, x3 = 0, y12 = 0, getMeasure) {
    const fontBBox = font.bbox;
    let isBBoxTrustworthy;
    let computedBBox;
    if (fontBBox) {
      isBBoxTrustworthy = fontBBox[2] !== fontBBox[0] && fontBBox[3] !== fontBBox[1] && this.#fontBBoxTrustworthy.get(font);
      if (isBBoxTrustworthy !== false) {
        computedBBox = [0, 0, 0, 0];
        Util.axialAlignedBoundingBox(fontBBox, font.fontMatrix, computedBBox);
        if (scale !== 1 || x3 !== 0 || y12 !== 0) {
          Util.scaleMinMax([scale, 0, 0, -scale, x3, y12], computedBBox);
        }
        if (isBBoxTrustworthy) {
          return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);
        }
      }
    }
    if (!getMeasure) {
      return this.recordFullPageBBox(idx);
    }
    const measure = getMeasure();
    if (fontBBox && computedBBox && isBBoxTrustworthy === void 0) {
      isBBoxTrustworthy = computedBBox[0] <= x3 - measure.actualBoundingBoxLeft && computedBBox[2] >= x3 + measure.actualBoundingBoxRight && computedBBox[1] <= y12 - measure.actualBoundingBoxAscent && computedBBox[3] >= y12 + measure.actualBoundingBoxDescent;
      this.#fontBBoxTrustworthy.set(font, isBBoxTrustworthy);
      if (isBBoxTrustworthy) {
        return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);
      }
    }
    return this.recordBBox(idx, ctx, x3 - measure.actualBoundingBoxLeft, x3 + measure.actualBoundingBoxRight, y12 - measure.actualBoundingBoxAscent, y12 + measure.actualBoundingBoxDescent);
  }
  recordFullPageBBox(idx) {
    this.#pendingBBox[0] = Math.max(0, this.#clipBox[0]);
    this.#pendingBBox[1] = Math.max(0, this.#clipBox[1]);
    this.#pendingBBox[2] = Math.min(this.#canvasWidth, this.#clipBox[2]);
    this.#pendingBBox[3] = Math.min(this.#canvasHeight, this.#clipBox[3]);
    return this;
  }
  getSimpleIndex(dependencyName) {
    return this.#simple[dependencyName];
  }
  recordDependencies(idx, dependencyNames) {
    const pendingDependencies = this.#pendingDependencies;
    const simple = this.#simple;
    const incremental = this.#incremental;
    for (const name4 of dependencyNames) {
      if (name4 in this.#simple) {
        pendingDependencies.add(simple[name4]);
      } else if (name4 in incremental) {
        incremental[name4].forEach(pendingDependencies.add, pendingDependencies);
      }
    }
    return this;
  }
  recordNamedDependency(idx, name4) {
    if (this.#namedDependencies.has(name4)) {
      this.#pendingDependencies.add(this.#namedDependencies.get(name4));
    }
    return this;
  }
  recordOperation(idx, preserve = false) {
    this.recordDependencies(idx, [FORCED_DEPENDENCY_LABEL]);
    if (this.#debugMetadata) {
      const metadata = ensureDebugMetadata(this.#debugMetadata, idx);
      const {
        dependencies
      } = metadata;
      this.#pendingDependencies.forEach(dependencies.add, dependencies);
      this.#savesStack.forEach(dependencies.add, dependencies);
      this.#markedContentStack.forEach(dependencies.add, dependencies);
      dependencies.delete(idx);
      metadata.isRenderingOperation = true;
    }
    if (this.#pendingBBoxIdx === idx) {
      const minX = floor(this.#pendingBBox[0] * 256 / this.#canvasWidth);
      const minY = floor(this.#pendingBBox[1] * 256 / this.#canvasHeight);
      const maxX = ceil(this.#pendingBBox[2] * 256 / this.#canvasWidth);
      const maxY = ceil(this.#pendingBBox[3] * 256 / this.#canvasHeight);
      expandBBox(this.#bboxesCoords, idx, minX, minY, maxX, maxY);
      for (const depIdx of this.#pendingDependencies) {
        if (depIdx !== idx) {
          expandBBox(this.#bboxesCoords, depIdx, minX, minY, maxX, maxY);
        }
      }
      for (const saveIdx of this.#savesStack) {
        if (saveIdx !== idx) {
          expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);
        }
      }
      for (const saveIdx of this.#markedContentStack) {
        if (saveIdx !== idx) {
          expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);
        }
      }
      if (!preserve) {
        this.#pendingDependencies.clear();
        this.#pendingBBoxIdx = -1;
      }
    }
    return this;
  }
  recordShowTextOperation(idx, preserve = false) {
    const deps = Array.from(this.#pendingDependencies);
    this.recordOperation(idx, preserve);
    this.recordIncrementalData("sameLineText", idx);
    for (const dep of deps) {
      this.recordIncrementalData("sameLineText", dep);
    }
    return this;
  }
  bboxToClipBoxDropOperation(idx, preserve = false) {
    if (this.#pendingBBoxIdx === idx) {
      this.#pendingBBoxIdx = -1;
      this.#clipBox[0] = Math.max(this.#clipBox[0], this.#pendingBBox[0]);
      this.#clipBox[1] = Math.max(this.#clipBox[1], this.#pendingBBox[1]);
      this.#clipBox[2] = Math.min(this.#clipBox[2], this.#pendingBBox[2]);
      this.#clipBox[3] = Math.min(this.#clipBox[3], this.#pendingBBox[3]);
      if (!preserve) {
        this.#pendingDependencies.clear();
      }
    }
    return this;
  }
  _takePendingDependencies() {
    const pendingDependencies = this.#pendingDependencies;
    this.#pendingDependencies = /* @__PURE__ */ new Set();
    return pendingDependencies;
  }
  _extractOperation(idx) {
    const operation = this.#operations.get(idx);
    this.#operations.delete(idx);
    return operation;
  }
  _pushPendingDependencies(dependencies) {
    for (const dep of dependencies) {
      this.#pendingDependencies.add(dep);
    }
  }
  take() {
    this.#fontBBoxTrustworthy.clear();
    return new BBoxReader(this.#bboxes, this.#bboxesCoords);
  }
  takeDebugMetadata() {
    return this.#debugMetadata;
  }
};
var CanvasNestedDependencyTracker = class _CanvasNestedDependencyTracker {
  static {
    __name(this, "CanvasNestedDependencyTracker");
  }
  #dependencyTracker;
  #opIdx;
  #ignoreBBoxes;
  #nestingLevel = 0;
  #savesLevel = 0;
  constructor(dependencyTracker, opIdx, ignoreBBoxes) {
    if (dependencyTracker instanceof _CanvasNestedDependencyTracker && dependencyTracker.#ignoreBBoxes === !!ignoreBBoxes) {
      return dependencyTracker;
    }
    this.#dependencyTracker = dependencyTracker;
    this.#opIdx = opIdx;
    this.#ignoreBBoxes = !!ignoreBBoxes;
  }
  growOperationsCount() {
    throw new Error("Unreachable");
  }
  save(opIdx) {
    this.#savesLevel++;
    this.#dependencyTracker.save(this.#opIdx);
    return this;
  }
  restore(opIdx) {
    if (this.#savesLevel > 0) {
      this.#dependencyTracker.restore(this.#opIdx);
      this.#savesLevel--;
    }
    return this;
  }
  recordOpenMarker(idx) {
    this.#nestingLevel++;
    return this;
  }
  getOpenMarker() {
    return this.#nestingLevel > 0 ? this.#opIdx : this.#dependencyTracker.getOpenMarker();
  }
  recordCloseMarker(idx) {
    this.#nestingLevel--;
    return this;
  }
  beginMarkedContent(opIdx) {
    return this;
  }
  endMarkedContent(opIdx) {
    return this;
  }
  pushBaseTransform(ctx) {
    this.#dependencyTracker.pushBaseTransform(ctx);
    return this;
  }
  popBaseTransform() {
    this.#dependencyTracker.popBaseTransform();
    return this;
  }
  recordSimpleData(name4, idx) {
    this.#dependencyTracker.recordSimpleData(name4, this.#opIdx);
    return this;
  }
  recordIncrementalData(name4, idx) {
    this.#dependencyTracker.recordIncrementalData(name4, this.#opIdx);
    return this;
  }
  resetIncrementalData(name4, idx) {
    this.#dependencyTracker.resetIncrementalData(name4, this.#opIdx);
    return this;
  }
  recordNamedData(name4, idx) {
    return this;
  }
  recordSimpleDataFromNamed(name4, depName, fallbackIdx) {
    this.#dependencyTracker.recordSimpleDataFromNamed(name4, depName, this.#opIdx);
    return this;
  }
  recordFutureForcedDependency(name4, idx) {
    this.#dependencyTracker.recordFutureForcedDependency(name4, this.#opIdx);
    return this;
  }
  inheritSimpleDataAsFutureForcedDependencies(names) {
    this.#dependencyTracker.inheritSimpleDataAsFutureForcedDependencies(names);
    return this;
  }
  inheritPendingDependenciesAsFutureForcedDependencies() {
    this.#dependencyTracker.inheritPendingDependenciesAsFutureForcedDependencies();
    return this;
  }
  resetBBox(idx) {
    if (!this.#ignoreBBoxes) {
      this.#dependencyTracker.resetBBox(this.#opIdx);
    }
    return this;
  }
  recordClipBox(idx, ctx, minX, maxX, minY, maxY) {
    if (!this.#ignoreBBoxes) {
      this.#dependencyTracker.recordClipBox(this.#opIdx, ctx, minX, maxX, minY, maxY);
    }
    return this;
  }
  recordBBox(idx, ctx, minX, maxX, minY, maxY) {
    if (!this.#ignoreBBoxes) {
      this.#dependencyTracker.recordBBox(this.#opIdx, ctx, minX, maxX, minY, maxY);
    }
    return this;
  }
  recordCharacterBBox(idx, ctx, font, scale, x3, y12, getMeasure) {
    if (!this.#ignoreBBoxes) {
      this.#dependencyTracker.recordCharacterBBox(this.#opIdx, ctx, font, scale, x3, y12, getMeasure);
    }
    return this;
  }
  recordFullPageBBox(idx) {
    if (!this.#ignoreBBoxes) {
      this.#dependencyTracker.recordFullPageBBox(this.#opIdx);
    }
    return this;
  }
  getSimpleIndex(dependencyName) {
    return this.#dependencyTracker.getSimpleIndex(dependencyName);
  }
  recordDependencies(idx, dependencyNames) {
    this.#dependencyTracker.recordDependencies(this.#opIdx, dependencyNames);
    return this;
  }
  recordNamedDependency(idx, name4) {
    this.#dependencyTracker.recordNamedDependency(this.#opIdx, name4);
    return this;
  }
  recordOperation(idx) {
    this.#dependencyTracker.recordOperation(this.#opIdx, true);
    return this;
  }
  recordShowTextOperation(idx) {
    this.#dependencyTracker.recordShowTextOperation(this.#opIdx, true);
    return this;
  }
  bboxToClipBoxDropOperation(idx) {
    if (!this.#ignoreBBoxes) {
      this.#dependencyTracker.bboxToClipBoxDropOperation(this.#opIdx, true);
    }
    return this;
  }
  take() {
    throw new Error("Unreachable");
  }
  takeDebugMetadata() {
    throw new Error("Unreachable");
  }
};
var Dependencies = {
  stroke: ["path", "transform", "filter", "strokeColor", "strokeAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "dash"],
  fill: ["path", "transform", "filter", "fillColor", "fillAlpha", "globalCompositeOperation", "SMask"],
  imageXObject: ["transform", "SMask", "filter", "fillAlpha", "strokeAlpha", "globalCompositeOperation"],
  rawFillPath: ["filter", "fillColor", "fillAlpha"],
  showText: ["transform", "leading", "charSpacing", "wordSpacing", "hScale", "textRise", "moveText", "textMatrix", "font", "fontObj", "filter", "fillColor", "textRenderingMode", "SMask", "fillAlpha", "strokeAlpha", "globalCompositeOperation", "sameLineText"],
  transform: ["transform"],
  transformAndFill: ["transform", "fillColor"]
};
;
var PathType = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
function applyBoundingBox(ctx, bbox) {
  if (!bbox) {
    return;
  }
  const width = bbox[2] - bbox[0];
  const height = bbox[3] - bbox[1];
  const region = new Path2D();
  region.rect(bbox[0], bbox[1], width, height);
  ctx.clip(region);
}
__name(applyBoundingBox, "applyBoundingBox");
var BaseShadingPattern = class {
  static {
    __name(this, "BaseShadingPattern");
  }
  isModifyingCurrentTransform() {
    return false;
  }
  getPattern() {
    unreachable("Abstract method `getPattern` called.");
  }
};
var RadialAxialShadingPattern = class extends BaseShadingPattern {
  static {
    __name(this, "RadialAxialShadingPattern");
  }
  constructor(IR) {
    super();
    this._type = IR[1];
    this._bbox = IR[2];
    this._colorStops = IR[3];
    this._p0 = IR[4];
    this._p1 = IR[5];
    this._r0 = IR[6];
    this._r1 = IR[7];
    this.matrix = null;
  }
  _createGradient(ctx) {
    let grad;
    if (this._type === "axial") {
      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
    } else if (this._type === "radial") {
      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
    }
    for (const colorStop of this._colorStops) {
      grad.addColorStop(colorStop[0], colorStop[1]);
    }
    return grad;
  }
  getPattern(ctx, owner, inverse, pathType) {
    let pattern;
    if (pathType === PathType.STROKE || pathType === PathType.FILL) {
      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [0, 0, 0, 0];
      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
      const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height);
      const tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.beginPath();
      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
      inverse = Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
      tmpCtx.transform(...owner.baseTransform);
      if (this.matrix) {
        tmpCtx.transform(...this.matrix);
      }
      applyBoundingBox(tmpCtx, this._bbox);
      tmpCtx.fillStyle = this._createGradient(tmpCtx);
      tmpCtx.fill();
      pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
      const domMatrix = new DOMMatrix(inverse);
      pattern.setTransform(domMatrix);
    } else {
      applyBoundingBox(ctx, this._bbox);
      pattern = this._createGradient(ctx);
    }
    return pattern;
  }
};
function drawTriangle(data, context2, p1, p22, p32, c1, c22, c32) {
  const coords = context2.coords, colors = context2.colors;
  const bytes = data.data, rowSize = data.width * 4;
  let tmp;
  if (coords[p1 + 1] > coords[p22 + 1]) {
    tmp = p1;
    p1 = p22;
    p22 = tmp;
    tmp = c1;
    c1 = c22;
    c22 = tmp;
  }
  if (coords[p22 + 1] > coords[p32 + 1]) {
    tmp = p22;
    p22 = p32;
    p32 = tmp;
    tmp = c22;
    c22 = c32;
    c32 = tmp;
  }
  if (coords[p1 + 1] > coords[p22 + 1]) {
    tmp = p1;
    p1 = p22;
    p22 = tmp;
    tmp = c1;
    c1 = c22;
    c22 = tmp;
  }
  const x1 = (coords[p1] + context2.offsetX) * context2.scaleX;
  const y1 = (coords[p1 + 1] + context2.offsetY) * context2.scaleY;
  const x22 = (coords[p22] + context2.offsetX) * context2.scaleX;
  const y22 = (coords[p22 + 1] + context2.offsetY) * context2.scaleY;
  const x3 = (coords[p32] + context2.offsetX) * context2.scaleX;
  const y32 = (coords[p32 + 1] + context2.offsetY) * context2.scaleY;
  if (y1 >= y32) {
    return;
  }
  const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
  const c2r = colors[c22], c2g = colors[c22 + 1], c2b = colors[c22 + 2];
  const c3r = colors[c32], c3g = colors[c32 + 1], c3b = colors[c32 + 2];
  const minY = Math.round(y1), maxY = Math.round(y32);
  let xa, car, cag, cab;
  let xb, cbr, cbg, cbb;
  for (let y12 = minY; y12 <= maxY; y12++) {
    if (y12 < y22) {
      const k6 = y12 < y1 ? 0 : (y1 - y12) / (y1 - y22);
      xa = x1 - (x1 - x22) * k6;
      car = c1r - (c1r - c2r) * k6;
      cag = c1g - (c1g - c2g) * k6;
      cab = c1b - (c1b - c2b) * k6;
    } else {
      let k6;
      if (y12 > y32) {
        k6 = 1;
      } else if (y22 === y32) {
        k6 = 0;
      } else {
        k6 = (y22 - y12) / (y22 - y32);
      }
      xa = x22 - (x22 - x3) * k6;
      car = c2r - (c2r - c3r) * k6;
      cag = c2g - (c2g - c3g) * k6;
      cab = c2b - (c2b - c3b) * k6;
    }
    let k5;
    if (y12 < y1) {
      k5 = 0;
    } else if (y12 > y32) {
      k5 = 1;
    } else {
      k5 = (y1 - y12) / (y1 - y32);
    }
    xb = x1 - (x1 - x3) * k5;
    cbr = c1r - (c1r - c3r) * k5;
    cbg = c1g - (c1g - c3g) * k5;
    cbb = c1b - (c1b - c3b) * k5;
    const x1_ = Math.round(Math.min(xa, xb));
    const x2_ = Math.round(Math.max(xa, xb));
    let j2 = rowSize * y12 + x1_ * 4;
    for (let x4 = x1_; x4 <= x2_; x4++) {
      k5 = (xa - x4) / (xa - xb);
      if (k5 < 0) {
        k5 = 0;
      } else if (k5 > 1) {
        k5 = 1;
      }
      bytes[j2++] = car - (car - cbr) * k5 | 0;
      bytes[j2++] = cag - (cag - cbg) * k5 | 0;
      bytes[j2++] = cab - (cab - cbb) * k5 | 0;
      bytes[j2++] = 255;
    }
  }
}
__name(drawTriangle, "drawTriangle");
function drawFigure(data, figure, context2) {
  const ps = figure.coords;
  const cs = figure.colors;
  let i18, ii;
  switch (figure.type) {
    case "lattice":
      const verticesPerRow = figure.verticesPerRow;
      const rows = Math.floor(ps.length / verticesPerRow) - 1;
      const cols = verticesPerRow - 1;
      for (i18 = 0; i18 < rows; i18++) {
        let q = i18 * verticesPerRow;
        for (let j2 = 0; j2 < cols; j2++, q++) {
          drawTriangle(data, context2, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
          drawTriangle(data, context2, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
        }
      }
      break;
    case "triangles":
      for (i18 = 0, ii = ps.length; i18 < ii; i18 += 3) {
        drawTriangle(data, context2, ps[i18], ps[i18 + 1], ps[i18 + 2], cs[i18], cs[i18 + 1], cs[i18 + 2]);
      }
      break;
    default:
      throw new Error("illegal figure");
  }
}
__name(drawFigure, "drawFigure");
var MeshShadingPattern = class extends BaseShadingPattern {
  static {
    __name(this, "MeshShadingPattern");
  }
  constructor(IR) {
    super();
    this._coords = IR[2];
    this._colors = IR[3];
    this._figures = IR[4];
    this._bounds = IR[5];
    this._bbox = IR[6];
    this._background = IR[7];
    this.matrix = null;
  }
  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
    const EXPECTED_SCALE = 1.1;
    const MAX_PATTERN_SIZE = 3e3;
    const BORDER_SIZE = 2;
    const offsetX = Math.floor(this._bounds[0]);
    const offsetY = Math.floor(this._bounds[1]);
    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const scaleX = boundsWidth / width;
    const scaleY = boundsHeight / height;
    const context2 = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -offsetX,
      offsetY: -offsetY,
      scaleX: 1 / scaleX,
      scaleY: 1 / scaleY
    };
    const paddedWidth = width + BORDER_SIZE * 2;
    const paddedHeight = height + BORDER_SIZE * 2;
    const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight);
    const tmpCtx = tmpCanvas.context;
    const data = tmpCtx.createImageData(width, height);
    if (backgroundColor) {
      const bytes = data.data;
      for (let i18 = 0, ii = bytes.length; i18 < ii; i18 += 4) {
        bytes[i18] = backgroundColor[0];
        bytes[i18 + 1] = backgroundColor[1];
        bytes[i18 + 2] = backgroundColor[2];
        bytes[i18 + 3] = 255;
      }
    }
    for (const figure of this._figures) {
      drawFigure(data, figure, context2);
    }
    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
    const canvas = tmpCanvas.canvas;
    return {
      canvas,
      offsetX: offsetX - BORDER_SIZE * scaleX,
      offsetY: offsetY - BORDER_SIZE * scaleY,
      scaleX,
      scaleY
    };
  }
  isModifyingCurrentTransform() {
    return true;
  }
  getPattern(ctx, owner, inverse, pathType) {
    applyBoundingBox(ctx, this._bbox);
    const scale = new Float32Array(2);
    if (pathType === PathType.SHADING) {
      Util.singularValueDecompose2dScale(getCurrentTransform(ctx), scale);
    } else if (this.matrix) {
      Util.singularValueDecompose2dScale(this.matrix, scale);
      const [matrixScaleX, matrixScaleY] = scale;
      Util.singularValueDecompose2dScale(owner.baseTransform, scale);
      scale[0] *= matrixScaleX;
      scale[1] *= matrixScaleY;
    } else {
      Util.singularValueDecompose2dScale(owner.baseTransform, scale);
    }
    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
    if (pathType !== PathType.SHADING) {
      ctx.setTransform(...owner.baseTransform);
      if (this.matrix) {
        ctx.transform(...this.matrix);
      }
    }
    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
  }
};
var DummyShadingPattern = class extends BaseShadingPattern {
  static {
    __name(this, "DummyShadingPattern");
  }
  getPattern() {
    return "hotpink";
  }
};
function getShadingPattern(IR) {
  switch (IR[0]) {
    case "RadialAxial":
      return new RadialAxialShadingPattern(IR);
    case "Mesh":
      return new MeshShadingPattern(IR);
    case "Dummy":
      return new DummyShadingPattern();
  }
  throw new Error(`Unknown IR type: ${IR[0]}`);
}
__name(getShadingPattern, "getShadingPattern");
var PaintType = {
  COLORED: 1,
  UNCOLORED: 2
};
var TilingPattern = class _TilingPattern {
  static {
    __name(this, "TilingPattern");
  }
  static MAX_PATTERN_SIZE = 3e3;
  constructor(IR, ctx, canvasGraphicsFactory, baseTransform) {
    this.color = IR[1];
    this.operatorList = IR[2];
    this.matrix = IR[3];
    this.bbox = IR[4];
    this.xstep = IR[5];
    this.ystep = IR[6];
    this.paintType = IR[7];
    this.tilingType = IR[8];
    this.ctx = ctx;
    this.canvasGraphicsFactory = canvasGraphicsFactory;
    this.baseTransform = baseTransform;
  }
  createPatternCanvas(owner, opIdx) {
    const {
      bbox,
      operatorList,
      paintType,
      tilingType,
      color,
      canvasGraphicsFactory
    } = this;
    let {
      xstep,
      ystep
    } = this;
    xstep = Math.abs(xstep);
    ystep = Math.abs(ystep);
    info("TilingType: " + tilingType);
    const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
    const width = x1 - x0;
    const height = y1 - y0;
    const scale = new Float32Array(2);
    Util.singularValueDecompose2dScale(this.matrix, scale);
    const [matrixScaleX, matrixScaleY] = scale;
    Util.singularValueDecompose2dScale(this.baseTransform, scale);
    const combinedScaleX = matrixScaleX * scale[0];
    const combinedScaleY = matrixScaleY * scale[1];
    let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;
    const xScaledStep = Math.ceil(xstep * combinedScaleX);
    const yScaledStep = Math.ceil(ystep * combinedScaleY);
    const xScaledWidth = Math.ceil(width * combinedScaleX);
    const yScaledHeight = Math.ceil(height * combinedScaleY);
    if (xScaledStep >= xScaledWidth) {
      canvasWidth = xstep;
    } else {
      redrawHorizontally = true;
    }
    if (yScaledStep >= yScaledHeight) {
      canvasHeight = ystep;
    } else {
      redrawVertically = true;
    }
    const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
    const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size);
    const tmpCtx = tmpCanvas.context;
    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx, opIdx);
    graphics.groupLevel = owner.groupLevel;
    this.setFillAndStrokeStyleToContext(graphics, paintType, color);
    tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);
    graphics.transform(0, dimx.scale, 0, 0, dimy.scale, 0, 0);
    tmpCtx.save();
    graphics.dependencyTracker?.save();
    this.clipBbox(graphics, x0, y0, x1, y1);
    graphics.baseTransform = getCurrentTransform(graphics.ctx);
    graphics.executeOperatorList(operatorList);
    graphics.endDrawing();
    graphics.dependencyTracker?.restore();
    tmpCtx.restore();
    if (redrawHorizontally || redrawVertically) {
      const image = tmpCanvas.canvas;
      if (redrawHorizontally) {
        canvasWidth = xstep;
      }
      if (redrawVertically) {
        canvasHeight = ystep;
      }
      const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
      const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
      const xSize = dimx2.size;
      const ySize = dimy2.size;
      const tmpCanvas2 = owner.cachedCanvases.getCanvas("pattern-workaround", xSize, ySize);
      const tmpCtx2 = tmpCanvas2.context;
      const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;
      const jj = redrawVertically ? Math.floor(height / ystep) : 0;
      for (let i18 = 0; i18 <= ii; i18++) {
        for (let j2 = 0; j2 <= jj; j2++) {
          tmpCtx2.drawImage(image, xSize * i18, ySize * j2, xSize, ySize, 0, 0, xSize, ySize);
        }
      }
      return {
        canvas: tmpCanvas2.canvas,
        scaleX: dimx2.scale,
        scaleY: dimy2.scale,
        offsetX: x0,
        offsetY: y0
      };
    }
    return {
      canvas: tmpCanvas.canvas,
      scaleX: dimx.scale,
      scaleY: dimy.scale,
      offsetX: x0,
      offsetY: y0
    };
  }
  getSizeAndScale(step, realOutputSize, scale) {
    const maxSize = Math.max(_TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
    let size = Math.ceil(step * scale);
    if (size >= maxSize) {
      size = maxSize;
    } else {
      scale = size / step;
    }
    return {
      scale,
      size
    };
  }
  clipBbox(graphics, x0, y0, x1, y1) {
    const bboxWidth = x1 - x0;
    const bboxHeight = y1 - y0;
    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
    Util.axialAlignedBoundingBox([x0, y0, x1, y1], getCurrentTransform(graphics.ctx), graphics.current.minMax);
    graphics.clip();
    graphics.endPath();
  }
  setFillAndStrokeStyleToContext(graphics, paintType, color) {
    const context2 = graphics.ctx, current = graphics.current;
    switch (paintType) {
      case PaintType.COLORED:
        const {
          fillStyle,
          strokeStyle
        } = this.ctx;
        context2.fillStyle = current.fillColor = fillStyle;
        context2.strokeStyle = current.strokeColor = strokeStyle;
        break;
      case PaintType.UNCOLORED:
        context2.fillStyle = context2.strokeStyle = color;
        current.fillColor = current.strokeColor = color;
        break;
      default:
        throw new FormatError(`Unsupported paint type: ${paintType}`);
    }
  }
  isModifyingCurrentTransform() {
    return false;
  }
  getPattern(ctx, owner, inverse, pathType, opIdx) {
    let matrix = inverse;
    if (pathType !== PathType.SHADING) {
      matrix = Util.transform(matrix, owner.baseTransform);
      if (this.matrix) {
        matrix = Util.transform(matrix, this.matrix);
      }
    }
    const temporaryPatternCanvas = this.createPatternCanvas(owner, opIdx);
    let domMatrix = new DOMMatrix(matrix);
    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
    pattern.setTransform(domMatrix);
    return pattern;
  }
};
;
function convertToRGBA(params) {
  switch (params.kind) {
    case ImageKind.GRAYSCALE_1BPP:
      return convertBlackAndWhiteToRGBA(params);
    case ImageKind.RGB_24BPP:
      return convertRGBToRGBA(params);
  }
  return null;
}
__name(convertToRGBA, "convertToRGBA");
function convertBlackAndWhiteToRGBA({
  src,
  srcPos = 0,
  dest,
  width,
  height,
  nonBlackColor = 4294967295,
  inverseDecode = false
}) {
  const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
  const widthInSource = width >> 3;
  const widthRemainder = width & 7;
  const srcLength = src.length;
  dest = new Uint32Array(dest.buffer);
  let destPos = 0;
  for (let i18 = 0; i18 < height; i18++) {
    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
      const elem2 = srcPos < srcLength ? src[srcPos] : 255;
      dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
    }
    if (widthRemainder === 0) {
      continue;
    }
    const elem = srcPos < srcLength ? src[srcPos++] : 255;
    for (let j2 = 0; j2 < widthRemainder; j2++) {
      dest[destPos++] = elem & 1 << 7 - j2 ? oneMapping : zeroMapping;
    }
  }
  return {
    srcPos,
    destPos
  };
}
__name(convertBlackAndWhiteToRGBA, "convertBlackAndWhiteToRGBA");
function convertRGBToRGBA({
  src,
  srcPos = 0,
  dest,
  destPos = 0,
  width,
  height
}) {
  let i18 = 0;
  const len = width * height * 3;
  const len32 = len >> 2;
  const src32 = new Uint32Array(src.buffer, srcPos, len32);
  if (FeatureTest.isLittleEndian) {
    for (; i18 < len32 - 2; i18 += 3, destPos += 4) {
      const s1 = src32[i18];
      const s22 = src32[i18 + 1];
      const s32 = src32[i18 + 2];
      dest[destPos] = s1 | 4278190080;
      dest[destPos + 1] = s1 >>> 24 | s22 << 8 | 4278190080;
      dest[destPos + 2] = s22 >>> 16 | s32 << 16 | 4278190080;
      dest[destPos + 3] = s32 >>> 8 | 4278190080;
    }
    for (let j2 = i18 * 4, jj = srcPos + len; j2 < jj; j2 += 3) {
      dest[destPos++] = src[j2] | src[j2 + 1] << 8 | src[j2 + 2] << 16 | 4278190080;
    }
  } else {
    for (; i18 < len32 - 2; i18 += 3, destPos += 4) {
      const s1 = src32[i18];
      const s22 = src32[i18 + 1];
      const s32 = src32[i18 + 2];
      dest[destPos] = s1 | 255;
      dest[destPos + 1] = s1 << 24 | s22 >>> 8 | 255;
      dest[destPos + 2] = s22 << 16 | s32 >>> 16 | 255;
      dest[destPos + 3] = s32 << 8 | 255;
    }
    for (let j2 = i18 * 4, jj = srcPos + len; j2 < jj; j2 += 3) {
      dest[destPos++] = src[j2] << 24 | src[j2 + 1] << 16 | src[j2 + 2] << 8 | 255;
    }
  }
  return {
    srcPos: srcPos + len,
    destPos
  };
}
__name(convertRGBToRGBA, "convertRGBToRGBA");
function grayToRGBA(src, dest) {
  if (FeatureTest.isLittleEndian) {
    for (let i18 = 0, ii = src.length; i18 < ii; i18++) {
      dest[i18] = src[i18] * 65793 | 4278190080;
    }
  } else {
    for (let i18 = 0, ii = src.length; i18 < ii; i18++) {
      dest[i18] = src[i18] * 16843008 | 255;
    }
  }
}
__name(grayToRGBA, "grayToRGBA");
;
var MIN_FONT_SIZE = 16;
var MAX_FONT_SIZE = 100;
var EXECUTION_TIME = 15;
var EXECUTION_STEPS = 10;
var FULL_CHUNK_HEIGHT = 16;
var SCALE_MATRIX = new DOMMatrix();
var XY = new Float32Array(2);
var MIN_MAX_INIT = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);
function mirrorContextOperations(ctx, destCtx) {
  if (ctx._removeMirroring) {
    throw new Error("Context is already forwarding operations.");
  }
  ctx.__originalSave = ctx.save;
  ctx.__originalRestore = ctx.restore;
  ctx.__originalRotate = ctx.rotate;
  ctx.__originalScale = ctx.scale;
  ctx.__originalTranslate = ctx.translate;
  ctx.__originalTransform = ctx.transform;
  ctx.__originalSetTransform = ctx.setTransform;
  ctx.__originalResetTransform = ctx.resetTransform;
  ctx.__originalClip = ctx.clip;
  ctx.__originalMoveTo = ctx.moveTo;
  ctx.__originalLineTo = ctx.lineTo;
  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
  ctx.__originalRect = ctx.rect;
  ctx.__originalClosePath = ctx.closePath;
  ctx.__originalBeginPath = ctx.beginPath;
  ctx._removeMirroring = () => {
    ctx.save = ctx.__originalSave;
    ctx.restore = ctx.__originalRestore;
    ctx.rotate = ctx.__originalRotate;
    ctx.scale = ctx.__originalScale;
    ctx.translate = ctx.__originalTranslate;
    ctx.transform = ctx.__originalTransform;
    ctx.setTransform = ctx.__originalSetTransform;
    ctx.resetTransform = ctx.__originalResetTransform;
    ctx.clip = ctx.__originalClip;
    ctx.moveTo = ctx.__originalMoveTo;
    ctx.lineTo = ctx.__originalLineTo;
    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
    ctx.rect = ctx.__originalRect;
    ctx.closePath = ctx.__originalClosePath;
    ctx.beginPath = ctx.__originalBeginPath;
    delete ctx._removeMirroring;
  };
  ctx.save = function() {
    destCtx.save();
    this.__originalSave();
  };
  ctx.restore = function() {
    destCtx.restore();
    this.__originalRestore();
  };
  ctx.translate = function(x3, y12) {
    destCtx.translate(x3, y12);
    this.__originalTranslate(x3, y12);
  };
  ctx.scale = function(x3, y12) {
    destCtx.scale(x3, y12);
    this.__originalScale(x3, y12);
  };
  ctx.transform = function(a22, b7, c21, d15, e10, f13) {
    destCtx.transform(a22, b7, c21, d15, e10, f13);
    this.__originalTransform(a22, b7, c21, d15, e10, f13);
  };
  ctx.setTransform = function(a22, b7, c21, d15, e10, f13) {
    destCtx.setTransform(a22, b7, c21, d15, e10, f13);
    this.__originalSetTransform(a22, b7, c21, d15, e10, f13);
  };
  ctx.resetTransform = function() {
    destCtx.resetTransform();
    this.__originalResetTransform();
  };
  ctx.rotate = function(angle) {
    destCtx.rotate(angle);
    this.__originalRotate(angle);
  };
  ctx.clip = function(rule) {
    destCtx.clip(rule);
    this.__originalClip(rule);
  };
  ctx.moveTo = function(x3, y12) {
    destCtx.moveTo(x3, y12);
    this.__originalMoveTo(x3, y12);
  };
  ctx.lineTo = function(x3, y12) {
    destCtx.lineTo(x3, y12);
    this.__originalLineTo(x3, y12);
  };
  ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x3, y12) {
    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y12);
    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y12);
  };
  ctx.rect = function(x3, y12, width, height) {
    destCtx.rect(x3, y12, width, height);
    this.__originalRect(x3, y12, width, height);
  };
  ctx.closePath = function() {
    destCtx.closePath();
    this.__originalClosePath();
  };
  ctx.beginPath = function() {
    destCtx.beginPath();
    this.__originalBeginPath();
  };
}
__name(mirrorContextOperations, "mirrorContextOperations");
var CachedCanvases = class {
  static {
    __name(this, "CachedCanvases");
  }
  constructor(canvasFactory) {
    this.canvasFactory = canvasFactory;
    this.cache = /* @__PURE__ */ Object.create(null);
  }
  getCanvas(id, width, height) {
    let canvasEntry;
    if (this.cache[id] !== void 0) {
      canvasEntry = this.cache[id];
      this.canvasFactory.reset(canvasEntry, width, height);
    } else {
      canvasEntry = this.canvasFactory.create(width, height);
      this.cache[id] = canvasEntry;
    }
    return canvasEntry;
  }
  delete(id) {
    delete this.cache[id];
  }
  clear() {
    for (const id in this.cache) {
      const canvasEntry = this.cache[id];
      this.canvasFactory.destroy(canvasEntry);
      delete this.cache[id];
    }
  }
};
function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
  const [a22, b7, c21, d15, tx, ty] = getCurrentTransform(ctx);
  if (b7 === 0 && c21 === 0) {
    const tlX = destX * a22 + tx;
    const rTlX = Math.round(tlX);
    const tlY = destY * d15 + ty;
    const rTlY = Math.round(tlY);
    const brX = (destX + destW) * a22 + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destY + destH) * d15 + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(Math.sign(a22), 0, 0, Math.sign(d15), rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
    ctx.setTransform(a22, b7, c21, d15, tx, ty);
    return [rWidth, rHeight];
  }
  if (a22 === 0 && d15 === 0) {
    const tlX = destY * c21 + tx;
    const rTlX = Math.round(tlX);
    const tlY = destX * b7 + ty;
    const rTlY = Math.round(tlY);
    const brX = (destY + destH) * c21 + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destX + destW) * b7 + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(0, Math.sign(b7), Math.sign(c21), 0, rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
    ctx.setTransform(a22, b7, c21, d15, tx, ty);
    return [rHeight, rWidth];
  }
  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
  const scaleX = Math.hypot(a22, b7);
  const scaleY = Math.hypot(c21, d15);
  return [scaleX * destW, scaleY * destH];
}
__name(drawImageAtIntegerCoords, "drawImageAtIntegerCoords");
var CanvasExtraState = class {
  static {
    __name(this, "CanvasExtraState");
  }
  alphaIsShape = false;
  fontSize = 0;
  fontSizeScale = 1;
  textMatrix = null;
  textMatrixScale = 1;
  fontMatrix = FONT_IDENTITY_MATRIX;
  leading = 0;
  x = 0;
  y = 0;
  lineX = 0;
  lineY = 0;
  charSpacing = 0;
  wordSpacing = 0;
  textHScale = 1;
  textRenderingMode = TextRenderingMode.FILL;
  textRise = 0;
  fillColor = "#000000";
  strokeColor = "#000000";
  patternFill = false;
  patternStroke = false;
  fillAlpha = 1;
  strokeAlpha = 1;
  lineWidth = 1;
  activeSMask = null;
  transferMaps = "none";
  constructor(width, height, preInit) {
    preInit?.(this);
    this.clipBox = new Float32Array([0, 0, width, height]);
    this.minMax = MIN_MAX_INIT.slice();
  }
  clone() {
    const clone = Object.create(this);
    clone.clipBox = this.clipBox.slice();
    clone.minMax = this.minMax.slice();
    return clone;
  }
  getPathBoundingBox(pathType = PathType.FILL, transform = null) {
    const box = this.minMax.slice();
    if (pathType === PathType.STROKE) {
      if (!transform) {
        unreachable("Stroke bounding box must include transform.");
      }
      Util.singularValueDecompose2dScale(transform, XY);
      const xStrokePad = XY[0] * this.lineWidth / 2;
      const yStrokePad = XY[1] * this.lineWidth / 2;
      box[0] -= xStrokePad;
      box[1] -= yStrokePad;
      box[2] += xStrokePad;
      box[3] += yStrokePad;
    }
    return box;
  }
  updateClipFromPath() {
    const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minMax[0] === Infinity;
  }
  startNewPathAndClipBox(box) {
    this.clipBox.set(box, 0);
    this.minMax.set(MIN_MAX_INIT, 0);
  }
  getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
    return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
  }
};
function putBinaryImageData(ctx, imgData) {
  if (imgData instanceof ImageData) {
    ctx.putImageData(imgData, 0, 0);
    return;
  }
  const height = imgData.height, width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0, destPos;
  const src = imgData.data;
  const dest = chunkImgData.data;
  let i18, j2, thisChunkHeight, elemsInThisChunk;
  if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {
    const srcLength = src.byteLength;
    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
    const dest32DataLength = dest32.length;
    const fullSrcDiff = width + 7 >> 3;
    const white = 4294967295;
    const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
    for (i18 = 0; i18 < totalChunks; i18++) {
      thisChunkHeight = i18 < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      destPos = 0;
      for (j2 = 0; j2 < thisChunkHeight; j2++) {
        const srcDiff = srcLength - srcPos;
        let k5 = 0;
        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
        const kEndUnrolled = kEnd & ~7;
        let mask = 0;
        let srcByte = 0;
        for (; k5 < kEndUnrolled; k5 += 8) {
          srcByte = src[srcPos++];
          dest32[destPos++] = srcByte & 128 ? white : black;
          dest32[destPos++] = srcByte & 64 ? white : black;
          dest32[destPos++] = srcByte & 32 ? white : black;
          dest32[destPos++] = srcByte & 16 ? white : black;
          dest32[destPos++] = srcByte & 8 ? white : black;
          dest32[destPos++] = srcByte & 4 ? white : black;
          dest32[destPos++] = srcByte & 2 ? white : black;
          dest32[destPos++] = srcByte & 1 ? white : black;
        }
        for (; k5 < kEnd; k5++) {
          if (mask === 0) {
            srcByte = src[srcPos++];
            mask = 128;
          }
          dest32[destPos++] = srcByte & mask ? white : black;
          mask >>= 1;
        }
      }
      while (destPos < dest32DataLength) {
        dest32[destPos++] = 0;
      }
      ctx.putImageData(chunkImgData, 0, i18 * FULL_CHUNK_HEIGHT);
    }
  } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {
    j2 = 0;
    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
    for (i18 = 0; i18 < fullChunks; i18++) {
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      srcPos += elemsInThisChunk;
      ctx.putImageData(chunkImgData, 0, j2);
      j2 += FULL_CHUNK_HEIGHT;
    }
    if (i18 < totalChunks) {
      elemsInThisChunk = width * partialChunkHeight * 4;
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      ctx.putImageData(chunkImgData, 0, j2);
    }
  } else if (imgData.kind === util_ImageKind.RGB_24BPP) {
    thisChunkHeight = FULL_CHUNK_HEIGHT;
    elemsInThisChunk = width * thisChunkHeight;
    for (i18 = 0; i18 < totalChunks; i18++) {
      if (i18 >= fullChunks) {
        thisChunkHeight = partialChunkHeight;
        elemsInThisChunk = width * thisChunkHeight;
      }
      destPos = 0;
      for (j2 = elemsInThisChunk; j2--; ) {
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = 255;
      }
      ctx.putImageData(chunkImgData, 0, i18 * FULL_CHUNK_HEIGHT);
    }
  } else {
    throw new Error(`bad image kind: ${imgData.kind}`);
  }
}
__name(putBinaryImageData, "putBinaryImageData");
function putBinaryImageMask(ctx, imgData) {
  if (imgData.bitmap) {
    ctx.drawImage(imgData.bitmap, 0, 0);
    return;
  }
  const height = imgData.height, width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0;
  const src = imgData.data;
  const dest = chunkImgData.data;
  for (let i18 = 0; i18 < totalChunks; i18++) {
    const thisChunkHeight = i18 < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
    ({
      srcPos
    } = convertBlackAndWhiteToRGBA({
      src,
      srcPos,
      dest,
      width,
      height: thisChunkHeight,
      nonBlackColor: 0
    }));
    ctx.putImageData(chunkImgData, 0, i18 * FULL_CHUNK_HEIGHT);
  }
}
__name(putBinaryImageMask, "putBinaryImageMask");
function copyCtxState(sourceCtx, destCtx) {
  const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const property of properties) {
    if (sourceCtx[property] !== void 0) {
      destCtx[property] = sourceCtx[property];
    }
  }
  if (sourceCtx.setLineDash !== void 0) {
    destCtx.setLineDash(sourceCtx.getLineDash());
    destCtx.lineDashOffset = sourceCtx.lineDashOffset;
  }
}
__name(copyCtxState, "copyCtxState");
function resetCtxToDefault(ctx) {
  ctx.strokeStyle = ctx.fillStyle = "#000000";
  ctx.fillRule = "nonzero";
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.lineCap = "butt";
  ctx.lineJoin = "miter";
  ctx.miterLimit = 10;
  ctx.globalCompositeOperation = "source-over";
  ctx.font = "10px sans-serif";
  if (ctx.setLineDash !== void 0) {
    ctx.setLineDash([]);
    ctx.lineDashOffset = 0;
  }
  const {
    filter
  } = ctx;
  if (filter !== "none" && filter !== "") {
    ctx.filter = "none";
  }
}
__name(resetCtxToDefault, "resetCtxToDefault");
function getImageSmoothingEnabled(transform, interpolate) {
  if (interpolate) {
    return true;
  }
  Util.singularValueDecompose2dScale(transform, XY);
  const actualScale = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);
  return XY[0] <= actualScale && XY[1] <= actualScale;
}
__name(getImageSmoothingEnabled, "getImageSmoothingEnabled");
var LINE_CAP_STYLES = ["butt", "round", "square"];
var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
var NORMAL_CLIP = {};
var EO_CLIP = {};
var CanvasGraphics = class _CanvasGraphics {
  static {
    __name(this, "CanvasGraphics");
  }
  constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {
    optionalContentConfig,
    markedContentStack = null
  }, annotationCanvasMap, pageColors, dependencyTracker) {
    this.ctx = canvasCtx;
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.stateStack = [];
    this.pendingClip = null;
    this.pendingEOFill = false;
    this.res = null;
    this.xobjs = null;
    this.commonObjs = commonObjs;
    this.objs = objs;
    this.canvasFactory = canvasFactory;
    this.filterFactory = filterFactory;
    this.groupStack = [];
    this.baseTransform = null;
    this.baseTransformStack = [];
    this.groupLevel = 0;
    this.smaskStack = [];
    this.smaskCounter = 0;
    this.tempSMask = null;
    this.suspendedCtx = null;
    this.contentVisible = true;
    this.markedContentStack = markedContentStack || [];
    this.optionalContentConfig = optionalContentConfig;
    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
    this.cachedPatterns = /* @__PURE__ */ new Map();
    this.annotationCanvasMap = annotationCanvasMap;
    this.viewportScale = 1;
    this.outputScaleX = 1;
    this.outputScaleY = 1;
    this.pageColors = pageColors;
    this._cachedScaleForStroking = [-1, 0];
    this._cachedGetSinglePixelWidth = null;
    this._cachedBitmapsMap = /* @__PURE__ */ new Map();
    this.dependencyTracker = dependencyTracker ?? null;
  }
  getObject(opIdx, data, fallback = null) {
    if (typeof data === "string") {
      this.dependencyTracker?.recordNamedDependency(opIdx, data);
      return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
    }
    return fallback;
  }
  beginDrawing({
    transform,
    viewport,
    transparency = false,
    background = null
  }) {
    const width = this.ctx.canvas.width;
    const height = this.ctx.canvas.height;
    const savedFillStyle = this.ctx.fillStyle;
    this.ctx.fillStyle = background || "#ffffff";
    this.ctx.fillRect(0, 0, width, height);
    this.ctx.fillStyle = savedFillStyle;
    if (transparency) {
      const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
      this.compositeCtx = this.ctx;
      this.transparentCanvas = transparentCanvas.canvas;
      this.ctx = transparentCanvas.context;
      this.ctx.save();
      this.ctx.transform(...getCurrentTransform(this.compositeCtx));
    }
    this.ctx.save();
    resetCtxToDefault(this.ctx);
    if (transform) {
      this.ctx.transform(...transform);
      this.outputScaleX = transform[0];
      this.outputScaleY = transform[0];
    }
    this.ctx.transform(...viewport.transform);
    this.viewportScale = viewport.scale;
    this.baseTransform = getCurrentTransform(this.ctx);
  }
  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper, operationsFilter) {
    const argsArray = operatorList.argsArray;
    const fnArray = operatorList.fnArray;
    let i18 = executionStartIdx || 0;
    const argsArrayLen = argsArray.length;
    if (argsArrayLen === i18) {
      return i18;
    }
    const chunkOperations = argsArrayLen - i18 > EXECUTION_STEPS && typeof continueCallback === "function";
    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
    let steps = 0;
    const commonObjs = this.commonObjs;
    const objs = this.objs;
    let fnId, fnArgs;
    while (true) {
      if (stepper !== void 0 && i18 === stepper.nextBreakPoint) {
        stepper.breakIt(i18, continueCallback);
        return i18;
      }
      if (!operationsFilter || operationsFilter(i18)) {
        fnId = fnArray[i18];
        fnArgs = argsArray[i18] ?? null;
        if (fnId !== OPS.dependency) {
          if (fnArgs === null) {
            this[fnId](i18);
          } else {
            this[fnId](i18, ...fnArgs);
          }
        } else {
          for (const depObjId of fnArgs) {
            this.dependencyTracker?.recordNamedData(depObjId, i18);
            const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
            if (!objsPool.has(depObjId)) {
              objsPool.get(depObjId, continueCallback);
              return i18;
            }
          }
        }
      }
      i18++;
      if (i18 === argsArrayLen) {
        return i18;
      }
      if (chunkOperations && ++steps > EXECUTION_STEPS) {
        if (Date.now() > endTime) {
          continueCallback();
          return i18;
        }
        steps = 0;
      }
    }
  }
  #restoreInitialState() {
    while (this.stateStack.length || this.inSMaskMode) {
      this.restore();
    }
    this.current.activeSMask = null;
    this.ctx.restore();
    if (this.transparentCanvas) {
      this.ctx = this.compositeCtx;
      this.ctx.save();
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.drawImage(this.transparentCanvas, 0, 0);
      this.ctx.restore();
      this.transparentCanvas = null;
    }
  }
  endDrawing() {
    this.#restoreInitialState();
    this.cachedCanvases.clear();
    this.cachedPatterns.clear();
    for (const cache of this._cachedBitmapsMap.values()) {
      for (const canvas of cache.values()) {
        if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
          canvas.width = canvas.height = 0;
        }
      }
      cache.clear();
    }
    this._cachedBitmapsMap.clear();
    this.#drawFilter();
  }
  #drawFilter() {
    if (this.pageColors) {
      const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
      if (hcmFilterId !== "none") {
        const savedFilter = this.ctx.filter;
        this.ctx.filter = hcmFilterId;
        this.ctx.drawImage(this.ctx.canvas, 0, 0);
        this.ctx.filter = savedFilter;
      }
    }
  }
  _scaleImage(img, inverseTransform) {
    const width = img.width ?? img.displayWidth;
    const height = img.height ?? img.displayHeight;
    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
    let paintWidth = width, paintHeight = height;
    let tmpCanvasId = "prescale1";
    let tmpCanvas, tmpCtx;
    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
      let newWidth = paintWidth, newHeight = paintHeight;
      if (widthScale > 2 && paintWidth > 1) {
        newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
        widthScale /= paintWidth / newWidth;
      }
      if (heightScale > 2 && paintHeight > 1) {
        newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
        heightScale /= paintHeight / newHeight;
      }
      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
      tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, newWidth, newHeight);
      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
      img = tmpCanvas.canvas;
      paintWidth = newWidth;
      paintHeight = newHeight;
      tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
    }
    return {
      img,
      paintWidth,
      paintHeight
    };
  }
  _createMaskCanvas(opIdx, img) {
    const ctx = this.ctx;
    const {
      width,
      height
    } = img;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    const currentTransform = getCurrentTransform(ctx);
    let cache, cacheKey, scaled, maskCanvas;
    if ((img.bitmap || img.data) && img.count > 1) {
      const mainKey = img.bitmap || img.data.buffer;
      cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);
      cache = this._cachedBitmapsMap.get(mainKey);
      if (!cache) {
        cache = /* @__PURE__ */ new Map();
        this._cachedBitmapsMap.set(mainKey, cache);
      }
      const cachedImage = cache.get(cacheKey);
      if (cachedImage && !isPatternFill) {
        const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
        const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);
        return {
          canvas: cachedImage,
          offsetX: offsetX2,
          offsetY: offsetY2
        };
      }
      scaled = cachedImage;
    }
    if (!scaled) {
      maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      putBinaryImageMask(maskCanvas.context, img);
    }
    let maskToCanvas = Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
    maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
    const minMax = MIN_MAX_INIT.slice();
    Util.axialAlignedBoundingBox([0, 0, width, height], maskToCanvas, minMax);
    const [minX, minY, maxX, maxY] = minMax;
    const drawnWidth = Math.round(maxX - minX) || 1;
    const drawnHeight = Math.round(maxY - minY) || 1;
    const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
    const fillCtx = fillCanvas.context;
    const offsetX = minX;
    const offsetY = minY;
    fillCtx.translate(-offsetX, -offsetY);
    fillCtx.transform(...maskToCanvas);
    if (!scaled) {
      scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));
      scaled = scaled.img;
      if (cache && isPatternFill) {
        cache.set(cacheKey, scaled);
      }
    }
    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);
    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
    fillCtx.globalCompositeOperation = "source-in";
    const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL, opIdx) : fillColor;
    fillCtx.fillRect(0, 0, width, height);
    if (cache && !isPatternFill) {
      this.cachedCanvases.delete("fillCanvas");
      cache.set(cacheKey, fillCanvas.canvas);
    }
    this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);
    return {
      canvas: fillCanvas.canvas,
      offsetX: Math.round(offsetX),
      offsetY: Math.round(offsetY)
    };
  }
  setLineWidth(opIdx, width) {
    this.dependencyTracker?.recordSimpleData("lineWidth", opIdx);
    if (width !== this.current.lineWidth) {
      this._cachedScaleForStroking[0] = -1;
    }
    this.current.lineWidth = width;
    this.ctx.lineWidth = width;
  }
  setLineCap(opIdx, style) {
    this.dependencyTracker?.recordSimpleData("lineCap", opIdx);
    this.ctx.lineCap = LINE_CAP_STYLES[style];
  }
  setLineJoin(opIdx, style) {
    this.dependencyTracker?.recordSimpleData("lineJoin", opIdx);
    this.ctx.lineJoin = LINE_JOIN_STYLES[style];
  }
  setMiterLimit(opIdx, limit2) {
    this.dependencyTracker?.recordSimpleData("miterLimit", opIdx);
    this.ctx.miterLimit = limit2;
  }
  setDash(opIdx, dashArray, dashPhase) {
    this.dependencyTracker?.recordSimpleData("dash", opIdx);
    const ctx = this.ctx;
    if (ctx.setLineDash !== void 0) {
      ctx.setLineDash(dashArray);
      ctx.lineDashOffset = dashPhase;
    }
  }
  setRenderingIntent(opIdx, intent) {
  }
  setFlatness(opIdx, flatness) {
  }
  setGState(opIdx, states) {
    for (const [key, value] of states) {
      switch (key) {
        case "LW":
          this.setLineWidth(opIdx, value);
          break;
        case "LC":
          this.setLineCap(opIdx, value);
          break;
        case "LJ":
          this.setLineJoin(opIdx, value);
          break;
        case "ML":
          this.setMiterLimit(opIdx, value);
          break;
        case "D":
          this.setDash(opIdx, value[0], value[1]);
          break;
        case "RI":
          this.setRenderingIntent(opIdx, value);
          break;
        case "FL":
          this.setFlatness(opIdx, value);
          break;
        case "Font":
          this.setFont(opIdx, value[0], value[1]);
          break;
        case "CA":
          this.dependencyTracker?.recordSimpleData("strokeAlpha", opIdx);
          this.current.strokeAlpha = value;
          break;
        case "ca":
          this.dependencyTracker?.recordSimpleData("fillAlpha", opIdx);
          this.ctx.globalAlpha = this.current.fillAlpha = value;
          break;
        case "BM":
          this.dependencyTracker?.recordSimpleData("globalCompositeOperation", opIdx);
          this.ctx.globalCompositeOperation = value;
          break;
        case "SMask":
          this.dependencyTracker?.recordSimpleData("SMask", opIdx);
          this.current.activeSMask = value ? this.tempSMask : null;
          this.tempSMask = null;
          this.checkSMaskState();
          break;
        case "TR":
          this.dependencyTracker?.recordSimpleData("filter", opIdx);
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
          break;
      }
    }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const inSMaskMode = this.inSMaskMode;
    if (this.current.activeSMask && !inSMaskMode) {
      this.beginSMaskMode();
    } else if (!this.current.activeSMask && inSMaskMode) {
      this.endSMaskMode();
    }
  }
  beginSMaskMode(opIdx) {
    if (this.inSMaskMode) {
      throw new Error("beginSMaskMode called while already in smask mode");
    }
    const drawnWidth = this.ctx.canvas.width;
    const drawnHeight = this.ctx.canvas.height;
    const cacheId = "smaskGroupAt" + this.groupLevel;
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    this.suspendedCtx = this.ctx;
    const ctx = this.ctx = scratchCanvas.context;
    ctx.setTransform(this.suspendedCtx.getTransform());
    copyCtxState(this.suspendedCtx, ctx);
    mirrorContextOperations(ctx, this.suspendedCtx);
    this.setGState(opIdx, [["BM", "source-over"]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode) {
      throw new Error("endSMaskMode called while not in smask mode");
    }
    this.ctx._removeMirroring();
    copyCtxState(this.ctx, this.suspendedCtx);
    this.ctx = this.suspendedCtx;
    this.suspendedCtx = null;
  }
  compose(dirtyBox) {
    if (!this.current.activeSMask) {
      return;
    }
    if (!dirtyBox) {
      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    } else {
      dirtyBox[0] = Math.floor(dirtyBox[0]);
      dirtyBox[1] = Math.floor(dirtyBox[1]);
      dirtyBox[2] = Math.ceil(dirtyBox[2]);
      dirtyBox[3] = Math.ceil(dirtyBox[3]);
    }
    const smask = this.current.activeSMask;
    const suspendedCtx = this.suspendedCtx;
    this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.ctx.restore();
  }
  composeSMask(ctx, smask, layerCtx, layerBox) {
    const layerOffsetX = layerBox[0];
    const layerOffsetY = layerBox[1];
    const layerWidth = layerBox[2] - layerOffsetX;
    const layerHeight = layerBox[3] - layerOffsetY;
    if (layerWidth === 0 || layerHeight === 0) {
      return;
    }
    this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(layerCtx.canvas, 0, 0);
    ctx.restore();
  }
  genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
    let maskCanvas = maskCtx.canvas;
    let maskX = layerOffsetX - maskOffsetX;
    let maskY = layerOffsetY - maskOffsetY;
    if (backdrop) {
      if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {
        const canvas = this.cachedCanvases.getCanvas("maskExtension", width, height);
        const ctx = canvas.context;
        ctx.drawImage(maskCanvas, -maskX, -maskY);
        ctx.globalCompositeOperation = "destination-atop";
        ctx.fillStyle = backdrop;
        ctx.fillRect(0, 0, width, height);
        ctx.globalCompositeOperation = "source-over";
        maskCanvas = canvas.canvas;
        maskX = maskY = 0;
      } else {
        maskCtx.save();
        maskCtx.globalAlpha = 1;
        maskCtx.setTransform(1, 0, 0, 1, 0, 0);
        const clip2 = new Path2D();
        clip2.rect(maskX, maskY, width, height);
        maskCtx.clip(clip2);
        maskCtx.globalCompositeOperation = "destination-atop";
        maskCtx.fillStyle = backdrop;
        maskCtx.fillRect(maskX, maskY, width, height);
        maskCtx.restore();
      }
    }
    layerCtx.save();
    layerCtx.globalAlpha = 1;
    layerCtx.setTransform(1, 0, 0, 1, 0, 0);
    if (subtype === "Alpha" && transferMap) {
      layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
    } else if (subtype === "Luminosity") {
      layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
    }
    const clip = new Path2D();
    clip.rect(layerOffsetX, layerOffsetY, width, height);
    layerCtx.clip(clip);
    layerCtx.globalCompositeOperation = "destination-in";
    layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);
    layerCtx.restore();
  }
  save(opIdx) {
    if (this.inSMaskMode) {
      copyCtxState(this.ctx, this.suspendedCtx);
    }
    this.ctx.save();
    const old = this.current;
    this.stateStack.push(old);
    this.current = old.clone();
    this.dependencyTracker?.save(opIdx);
  }
  restore(opIdx) {
    this.dependencyTracker?.restore(opIdx);
    if (this.stateStack.length === 0) {
      if (this.inSMaskMode) {
        this.endSMaskMode();
      }
      return;
    }
    this.current = this.stateStack.pop();
    this.ctx.restore();
    if (this.inSMaskMode) {
      copyCtxState(this.suspendedCtx, this.ctx);
    }
    this.checkSMaskState();
    this.pendingClip = null;
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
  }
  transform(opIdx, a22, b7, c21, d15, e10, f13) {
    this.dependencyTracker?.recordIncrementalData("transform", opIdx);
    this.ctx.transform(a22, b7, c21, d15, e10, f13);
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
  }
  constructPath(opIdx, op, data, minMax) {
    let [path] = data;
    if (!minMax) {
      path ||= data[0] = new Path2D();
      this[op](opIdx, path);
      return;
    }
    if (this.dependencyTracker !== null) {
      const outerExtraSize = op === OPS.stroke ? this.current.lineWidth / 2 : 0;
      this.dependencyTracker.resetBBox(opIdx).recordBBox(opIdx, this.ctx, minMax[0] - outerExtraSize, minMax[2] + outerExtraSize, minMax[1] - outerExtraSize, minMax[3] + outerExtraSize).recordDependencies(opIdx, ["transform"]);
    }
    if (!(path instanceof Path2D)) {
      const path2d = data[0] = new Path2D();
      for (let i18 = 0, ii = path.length; i18 < ii; ) {
        switch (path[i18++]) {
          case DrawOPS.moveTo:
            path2d.moveTo(path[i18++], path[i18++]);
            break;
          case DrawOPS.lineTo:
            path2d.lineTo(path[i18++], path[i18++]);
            break;
          case DrawOPS.curveTo:
            path2d.bezierCurveTo(path[i18++], path[i18++], path[i18++], path[i18++], path[i18++], path[i18++]);
            break;
          case DrawOPS.closePath:
            path2d.closePath();
            break;
          default:
            warn(`Unrecognized drawing path operator: ${path[i18 - 1]}`);
            break;
        }
      }
      path = path2d;
    }
    Util.axialAlignedBoundingBox(minMax, getCurrentTransform(this.ctx), this.current.minMax);
    this[op](opIdx, path);
    this._pathStartIdx = opIdx;
  }
  closePath(opIdx) {
    this.ctx.closePath();
  }
  stroke(opIdx, path, consumePath = true) {
    const ctx = this.ctx;
    const strokeColor = this.current.strokeColor;
    ctx.globalAlpha = this.current.strokeAlpha;
    if (this.contentVisible) {
      if (typeof strokeColor === "object" && strokeColor?.getPattern) {
        const baseTransform = strokeColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;
        ctx.save();
        ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);
        if (baseTransform) {
          const newPath = new Path2D();
          newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));
          path = newPath;
        }
        this.rescaleAndStroke(path, false);
        ctx.restore();
      } else {
        this.rescaleAndStroke(path, true);
      }
    }
    this.dependencyTracker?.recordDependencies(opIdx, Dependencies.stroke);
    if (consumePath) {
      this.consumePath(opIdx, path, this.current.getClippedPathBoundingBox(PathType.STROKE, getCurrentTransform(this.ctx)));
    }
    ctx.globalAlpha = this.current.fillAlpha;
  }
  closeStroke(opIdx, path) {
    this.stroke(opIdx, path);
  }
  fill(opIdx, path, consumePath = true) {
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    let needRestore = false;
    if (isPatternFill) {
      const baseTransform = fillColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;
      this.dependencyTracker?.save(opIdx);
      ctx.save();
      ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);
      if (baseTransform) {
        const newPath = new Path2D();
        newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));
        path = newPath;
      }
      needRestore = true;
    }
    const intersect = this.current.getClippedPathBoundingBox();
    if (this.contentVisible && intersect !== null) {
      if (this.pendingEOFill) {
        ctx.fill(path, "evenodd");
        this.pendingEOFill = false;
      } else {
        ctx.fill(path);
      }
    }
    this.dependencyTracker?.recordDependencies(opIdx, Dependencies.fill);
    if (needRestore) {
      ctx.restore();
      this.dependencyTracker?.restore(opIdx);
    }
    if (consumePath) {
      this.consumePath(opIdx, path, intersect);
    }
  }
  eoFill(opIdx, path) {
    this.pendingEOFill = true;
    this.fill(opIdx, path);
  }
  fillStroke(opIdx, path) {
    this.fill(opIdx, path, false);
    this.stroke(opIdx, path, false);
    this.consumePath(opIdx, path);
  }
  eoFillStroke(opIdx, path) {
    this.pendingEOFill = true;
    this.fillStroke(opIdx, path);
  }
  closeFillStroke(opIdx, path) {
    this.fillStroke(opIdx, path);
  }
  closeEOFillStroke(opIdx, path) {
    this.pendingEOFill = true;
    this.fillStroke(opIdx, path);
  }
  endPath(opIdx, path) {
    this.consumePath(opIdx, path);
  }
  rawFillPath(opIdx, path) {
    this.ctx.fill(path);
    this.dependencyTracker?.recordDependencies(opIdx, Dependencies.rawFillPath).recordOperation(opIdx);
  }
  clip(opIdx) {
    this.dependencyTracker?.recordFutureForcedDependency("clipMode", opIdx);
    this.pendingClip = NORMAL_CLIP;
  }
  eoClip(opIdx) {
    this.dependencyTracker?.recordFutureForcedDependency("clipMode", opIdx);
    this.pendingClip = EO_CLIP;
  }
  beginText(opIdx) {
    this.current.textMatrix = null;
    this.current.textMatrixScale = 1;
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
    this.dependencyTracker?.recordOpenMarker(opIdx).resetIncrementalData("sameLineText").resetIncrementalData("moveText", opIdx);
  }
  endText(opIdx) {
    const paths = this.pendingTextPaths;
    const ctx = this.ctx;
    if (this.dependencyTracker) {
      const {
        dependencyTracker
      } = this;
      if (paths !== void 0) {
        dependencyTracker.recordFutureForcedDependency("textClip", dependencyTracker.getOpenMarker()).recordFutureForcedDependency("textClip", opIdx);
      }
      dependencyTracker.recordCloseMarker(opIdx);
    }
    if (paths !== void 0) {
      const newPath = new Path2D();
      const invTransf = ctx.getTransform().invertSelf();
      for (const {
        transform,
        x: x3,
        y: y12,
        fontSize,
        path
      } of paths) {
        if (!path) {
          continue;
        }
        newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x3, y12).scale(fontSize, -fontSize));
      }
      ctx.clip(newPath);
    }
    delete this.pendingTextPaths;
  }
  setCharSpacing(opIdx, spacing) {
    this.dependencyTracker?.recordSimpleData("charSpacing", opIdx);
    this.current.charSpacing = spacing;
  }
  setWordSpacing(opIdx, spacing) {
    this.dependencyTracker?.recordSimpleData("wordSpacing", opIdx);
    this.current.wordSpacing = spacing;
  }
  setHScale(opIdx, scale) {
    this.dependencyTracker?.recordSimpleData("hScale", opIdx);
    this.current.textHScale = scale / 100;
  }
  setLeading(opIdx, leading) {
    this.dependencyTracker?.recordSimpleData("leading", opIdx);
    this.current.leading = -leading;
  }
  setFont(opIdx, fontRefName, size) {
    this.dependencyTracker?.recordSimpleData("font", opIdx).recordSimpleDataFromNamed("fontObj", fontRefName, opIdx);
    const fontObj = this.commonObjs.get(fontRefName);
    const current = this.current;
    if (!fontObj) {
      throw new Error(`Can't find font for ${fontRefName}`);
    }
    current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
      warn("Invalid font matrix for font " + fontRefName);
    }
    if (size < 0) {
      size = -size;
      current.fontDirection = -1;
    } else {
      current.fontDirection = 1;
    }
    this.current.font = fontObj;
    this.current.fontSize = size;
    if (fontObj.isType3Font) {
      return;
    }
    const name4 = fontObj.loadedName || "sans-serif";
    const typeface = fontObj.systemFontInfo?.css || `"${name4}", ${fontObj.fallbackName}`;
    let bold = "normal";
    if (fontObj.black) {
      bold = "900";
    } else if (fontObj.bold) {
      bold = "bold";
    }
    const italic = fontObj.italic ? "italic" : "normal";
    let browserFontSize = size;
    if (size < MIN_FONT_SIZE) {
      browserFontSize = MIN_FONT_SIZE;
    } else if (size > MAX_FONT_SIZE) {
      browserFontSize = MAX_FONT_SIZE;
    }
    this.current.fontSizeScale = size / browserFontSize;
    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
  }
  setTextRenderingMode(opIdx, mode) {
    this.dependencyTracker?.recordSimpleData("textRenderingMode", opIdx);
    this.current.textRenderingMode = mode;
  }
  setTextRise(opIdx, rise) {
    this.dependencyTracker?.recordSimpleData("textRise", opIdx);
    this.current.textRise = rise;
  }
  moveText(opIdx, x3, y12) {
    this.dependencyTracker?.resetIncrementalData("sameLineText").recordIncrementalData("moveText", opIdx);
    this.current.x = this.current.lineX += x3;
    this.current.y = this.current.lineY += y12;
  }
  setLeadingMoveText(opIdx, x3, y12) {
    this.setLeading(opIdx, -y12);
    this.moveText(opIdx, x3, y12);
  }
  setTextMatrix(opIdx, matrix) {
    this.dependencyTracker?.recordSimpleData("textMatrix", opIdx);
    const {
      current
    } = this;
    current.textMatrix = matrix;
    current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);
    current.x = current.lineX = 0;
    current.y = current.lineY = 0;
  }
  nextLine(opIdx) {
    this.moveText(opIdx, 0, this.current.leading);
    this.dependencyTracker?.recordIncrementalData("moveText", this.dependencyTracker.getSimpleIndex("leading") ?? opIdx);
  }
  #getScaledPath(path, currentTransform, transform) {
    const newPath = new Path2D();
    newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));
    return newPath;
  }
  paintChar(opIdx, character, x3, y12, patternFillTransform, patternStrokeTransform) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const textRenderingMode = current.textRenderingMode;
    const fontSize = current.fontSize / current.fontSizeScale;
    const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
    const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);
    const patternFill = current.patternFill && !font.missingFile;
    const patternStroke = current.patternStroke && !font.missingFile;
    let path;
    if ((font.disableFontFace || isAddToPathSet || patternFill || patternStroke) && !font.missingFile) {
      path = font.getPathGenerator(this.commonObjs, character);
    }
    if (path && (font.disableFontFace || patternFill || patternStroke)) {
      ctx.save();
      ctx.translate(x3, y12);
      ctx.scale(fontSize, -fontSize);
      this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font);
      let currentTransform;
      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        if (patternFillTransform) {
          currentTransform = ctx.getTransform();
          ctx.setTransform(...patternFillTransform);
          const scaledPath = this.#getScaledPath(path, currentTransform, patternFillTransform);
          ctx.fill(scaledPath);
        } else {
          ctx.fill(path);
        }
      }
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        if (patternStrokeTransform) {
          currentTransform ||= ctx.getTransform();
          ctx.setTransform(...patternStrokeTransform);
          const {
            a: a22,
            b: b7,
            c: c21,
            d: d15
          } = currentTransform;
          const invPatternTransform = Util.inverseTransform(patternStrokeTransform);
          const transf = Util.transform([a22, b7, c21, d15, 0, 0], invPatternTransform);
          Util.singularValueDecompose2dScale(transf, XY);
          ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;
          ctx.stroke(this.#getScaledPath(path, currentTransform, patternStrokeTransform));
        } else {
          ctx.lineWidth /= fontSize;
          ctx.stroke(path);
        }
      }
      ctx.restore();
    } else {
      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        ctx.fillText(character, x3, y12);
        this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x3, y12, () => ctx.measureText(character));
      }
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        if (this.dependencyTracker) {
          this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x3, y12, () => ctx.measureText(character)).recordDependencies(opIdx, Dependencies.stroke);
        }
        ctx.strokeText(character, x3, y12);
      }
    }
    if (isAddToPathSet) {
      const paths = this.pendingTextPaths ||= [];
      paths.push({
        transform: getCurrentTransform(ctx),
        x: x3,
        y: y12,
        fontSize,
        path
      });
      this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x3, y12);
    }
  }
  get isFontSubpixelAAEnabled() {
    const {
      context: ctx
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    ctx.scale(1.5, 1);
    ctx.fillText("I", 0, 10);
    const data = ctx.getImageData(0, 0, 10, 10).data;
    let enabled = false;
    for (let i18 = 3; i18 < data.length; i18 += 4) {
      if (data[i18] > 0 && data[i18] < 255) {
        enabled = true;
        break;
      }
    }
    return shadow(this, "isFontSubpixelAAEnabled", enabled);
  }
  showText(opIdx, glyphs) {
    if (this.dependencyTracker) {
      this.dependencyTracker.recordDependencies(opIdx, Dependencies.showText).resetBBox(opIdx);
      if (this.current.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG) {
        this.dependencyTracker.recordFutureForcedDependency("textClip", opIdx).inheritPendingDependenciesAsFutureForcedDependencies();
      }
    }
    const current = this.current;
    const font = current.font;
    if (font.isType3Font) {
      this.showType3Text(opIdx, glyphs);
      this.dependencyTracker?.recordShowTextOperation(opIdx);
      return void 0;
    }
    const fontSize = current.fontSize;
    if (fontSize === 0) {
      this.dependencyTracker?.recordOperation(opIdx);
      return void 0;
    }
    const ctx = this.ctx;
    const fontSizeScale = current.fontSizeScale;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const fontDirection = current.fontDirection;
    const textHScale = current.textHScale * fontDirection;
    const glyphsLength = glyphs.length;
    const vertical = font.vertical;
    const spacingDir = vertical ? 1 : -1;
    const defaultVMetrics = font.defaultVMetrics;
    const widthAdvanceScale = fontSize * current.fontMatrix[0];
    const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
    ctx.save();
    if (current.textMatrix) {
      ctx.transform(...current.textMatrix);
    }
    ctx.translate(current.x, current.y + current.textRise);
    if (fontDirection > 0) {
      ctx.scale(textHScale, -1);
    } else {
      ctx.scale(textHScale, 1);
    }
    let patternFillTransform, patternStrokeTransform;
    if (current.patternFill) {
      ctx.save();
      const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);
      patternFillTransform = getCurrentTransform(ctx);
      ctx.restore();
      ctx.fillStyle = pattern;
    }
    if (current.patternStroke) {
      ctx.save();
      const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);
      patternStrokeTransform = getCurrentTransform(ctx);
      ctx.restore();
      ctx.strokeStyle = pattern;
    }
    let lineWidth = current.lineWidth;
    const scale = current.textMatrixScale;
    if (scale === 0 || lineWidth === 0) {
      const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        lineWidth = this.getSinglePixelWidth();
      }
    } else {
      lineWidth /= scale;
    }
    if (fontSizeScale !== 1) {
      ctx.scale(fontSizeScale, fontSizeScale);
      lineWidth /= fontSizeScale;
    }
    ctx.lineWidth = lineWidth;
    if (font.isInvalidPDFjsFont) {
      const chars = [];
      let width = 0;
      for (const glyph of glyphs) {
        chars.push(glyph.unicode);
        width += glyph.width;
      }
      const joinedChars = chars.join("");
      ctx.fillText(joinedChars, 0, 0);
      if (this.dependencyTracker !== null) {
        const measure = ctx.measureText(joinedChars);
        this.dependencyTracker.recordBBox(opIdx, this.ctx, -measure.actualBoundingBoxLeft, measure.actualBoundingBoxRight, -measure.actualBoundingBoxAscent, measure.actualBoundingBoxDescent).recordShowTextOperation(opIdx);
      }
      current.x += width * widthAdvanceScale * textHScale;
      ctx.restore();
      this.compose();
      return void 0;
    }
    let x3 = 0, i18;
    for (i18 = 0; i18 < glyphsLength; ++i18) {
      const glyph = glyphs[i18];
      if (typeof glyph === "number") {
        x3 += spacingDir * glyph * fontSize / 1e3;
        continue;
      }
      let restoreNeeded = false;
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const character = glyph.fontChar;
      const accent = glyph.accent;
      let scaledX, scaledY;
      let width = glyph.width;
      if (vertical) {
        const vmetric = glyph.vmetric || defaultVMetrics;
        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
        const vy = vmetric[2] * widthAdvanceScale;
        width = vmetric ? -vmetric[0] : width;
        scaledX = vx / fontSizeScale;
        scaledY = (x3 + vy) / fontSizeScale;
      } else {
        scaledX = x3 / fontSizeScale;
        scaledY = 0;
      }
      let measure;
      if (font.remeasure && width > 0) {
        measure = ctx.measureText(character);
        const measuredWidth = measure.width * 1e3 / fontSize * fontSizeScale;
        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
          const characterScaleX = width / measuredWidth;
          restoreNeeded = true;
          ctx.save();
          ctx.scale(characterScaleX, 1);
          scaledX /= characterScaleX;
        } else if (width !== measuredWidth) {
          scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
        }
      }
      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
        if (simpleFillText && !accent) {
          ctx.fillText(character, scaledX, scaledY);
          this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, measure ? {
            bbox: null
          } : font, fontSize / fontSizeScale, scaledX, scaledY, () => measure ?? ctx.measureText(character));
        } else {
          this.paintChar(opIdx, character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);
          if (accent) {
            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
            this.paintChar(opIdx, accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);
          }
        }
      }
      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
      x3 += charWidth;
      if (restoreNeeded) {
        ctx.restore();
      }
    }
    if (vertical) {
      current.y -= x3;
    } else {
      current.x += x3 * textHScale;
    }
    ctx.restore();
    this.compose();
    this.dependencyTracker?.recordShowTextOperation(opIdx);
    return void 0;
  }
  showType3Text(opIdx, glyphs) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const fontSize = current.fontSize;
    const fontDirection = current.fontDirection;
    const spacingDir = font.vertical ? 1 : -1;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const textHScale = current.textHScale * fontDirection;
    const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
    const glyphsLength = glyphs.length;
    const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;
    let i18, glyph, width, spacingLength;
    if (isTextInvisible || fontSize === 0) {
      return;
    }
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
    ctx.save();
    if (current.textMatrix) {
      ctx.transform(...current.textMatrix);
    }
    ctx.translate(current.x, current.y + current.textRise);
    ctx.scale(textHScale, fontDirection);
    const dependencyTracker = this.dependencyTracker;
    this.dependencyTracker = dependencyTracker ? new CanvasNestedDependencyTracker(dependencyTracker, opIdx) : null;
    for (i18 = 0; i18 < glyphsLength; ++i18) {
      glyph = glyphs[i18];
      if (typeof glyph === "number") {
        spacingLength = spacingDir * glyph * fontSize / 1e3;
        this.ctx.translate(spacingLength, 0);
        current.x += spacingLength * textHScale;
        continue;
      }
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const operatorList = font.charProcOperatorList[glyph.operatorListId];
      if (!operatorList) {
        warn(`Type3 character "${glyph.operatorListId}" is not available.`);
      } else if (this.contentVisible) {
        this.save();
        ctx.scale(fontSize, fontSize);
        ctx.transform(...fontMatrix);
        this.executeOperatorList(operatorList);
        this.restore();
      }
      const p15 = [glyph.width, 0];
      Util.applyTransform(p15, fontMatrix);
      width = p15[0] * fontSize + spacing;
      ctx.translate(width, 0);
      current.x += width * textHScale;
    }
    ctx.restore();
    if (dependencyTracker) {
      this.dependencyTracker = dependencyTracker;
    }
  }
  setCharWidth(opIdx, xWidth, yWidth) {
  }
  setCharWidthAndBounds(opIdx, xWidth, yWidth, llx, lly, urx, ury) {
    const clip = new Path2D();
    clip.rect(llx, lly, urx - llx, ury - lly);
    this.ctx.clip(clip);
    this.dependencyTracker?.recordBBox(opIdx, this.ctx, llx, urx, lly, ury).recordClipBox(opIdx, this.ctx, llx, urx, lly, ury);
    this.endPath(opIdx);
  }
  getColorN_Pattern(opIdx, IR) {
    let pattern;
    if (IR[0] === "TilingPattern") {
      const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
      const canvasGraphicsFactory = {
        createCanvasGraphics: /* @__PURE__ */ __name((ctx, renderingOpIdx) => new _CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
          optionalContentConfig: this.optionalContentConfig,
          markedContentStack: this.markedContentStack
        }, void 0, void 0, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, renderingOpIdx, true) : null), "createCanvasGraphics")
      };
      pattern = new TilingPattern(IR, this.ctx, canvasGraphicsFactory, baseTransform);
    } else {
      pattern = this._getPattern(opIdx, IR[1], IR[2]);
    }
    return pattern;
  }
  setStrokeColorN(opIdx, ...args) {
    this.dependencyTracker?.recordSimpleData("strokeColor", opIdx);
    this.current.strokeColor = this.getColorN_Pattern(opIdx, args);
    this.current.patternStroke = true;
  }
  setFillColorN(opIdx, ...args) {
    this.dependencyTracker?.recordSimpleData("fillColor", opIdx);
    this.current.fillColor = this.getColorN_Pattern(opIdx, args);
    this.current.patternFill = true;
  }
  setStrokeRGBColor(opIdx, color) {
    this.dependencyTracker?.recordSimpleData("strokeColor", opIdx);
    this.ctx.strokeStyle = this.current.strokeColor = color;
    this.current.patternStroke = false;
  }
  setStrokeTransparent(opIdx) {
    this.dependencyTracker?.recordSimpleData("strokeColor", opIdx);
    this.ctx.strokeStyle = this.current.strokeColor = "transparent";
    this.current.patternStroke = false;
  }
  setFillRGBColor(opIdx, color) {
    this.dependencyTracker?.recordSimpleData("fillColor", opIdx);
    this.ctx.fillStyle = this.current.fillColor = color;
    this.current.patternFill = false;
  }
  setFillTransparent(opIdx) {
    this.dependencyTracker?.recordSimpleData("fillColor", opIdx);
    this.ctx.fillStyle = this.current.fillColor = "transparent";
    this.current.patternFill = false;
  }
  _getPattern(opIdx, objId, matrix = null) {
    let pattern;
    if (this.cachedPatterns.has(objId)) {
      pattern = this.cachedPatterns.get(objId);
    } else {
      pattern = getShadingPattern(this.getObject(opIdx, objId));
      this.cachedPatterns.set(objId, pattern);
    }
    if (matrix) {
      pattern.matrix = matrix;
    }
    return pattern;
  }
  shadingFill(opIdx, objId) {
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    this.save(opIdx);
    const pattern = this._getPattern(opIdx, objId);
    ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING, opIdx);
    const inv = getCurrentTransformInverse(ctx);
    if (inv) {
      const {
        width,
        height
      } = ctx.canvas;
      const minMax = MIN_MAX_INIT.slice();
      Util.axialAlignedBoundingBox([0, 0, width, height], inv, minMax);
      const [x0, y0, x1, y1] = minMax;
      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
    } else {
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    }
    this.dependencyTracker?.resetBBox(opIdx).recordFullPageBBox(opIdx).recordDependencies(opIdx, Dependencies.transform).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);
    this.compose(this.current.getClippedPathBoundingBox());
    this.restore(opIdx);
  }
  beginInlineImage() {
    unreachable("Should not call beginInlineImage");
  }
  beginImageData() {
    unreachable("Should not call beginImageData");
  }
  paintFormXObjectBegin(opIdx, matrix, bbox) {
    if (!this.contentVisible) {
      return;
    }
    this.save(opIdx);
    this.baseTransformStack.push(this.baseTransform);
    if (matrix) {
      this.transform(opIdx, ...matrix);
    }
    this.baseTransform = getCurrentTransform(this.ctx);
    if (bbox) {
      Util.axialAlignedBoundingBox(bbox, this.baseTransform, this.current.minMax);
      const [x0, y0, x1, y1] = bbox;
      const clip = new Path2D();
      clip.rect(x0, y0, x1 - x0, y1 - y0);
      this.ctx.clip(clip);
      this.dependencyTracker?.recordClipBox(opIdx, this.ctx, x0, x1, y0, y1);
      this.endPath(opIdx);
    }
  }
  paintFormXObjectEnd(opIdx) {
    if (!this.contentVisible) {
      return;
    }
    this.restore(opIdx);
    this.baseTransform = this.baseTransformStack.pop();
  }
  beginGroup(opIdx, group) {
    if (!this.contentVisible) {
      return;
    }
    this.save(opIdx);
    if (this.inSMaskMode) {
      this.endSMaskMode();
      this.current.activeSMask = null;
    }
    const currentCtx = this.ctx;
    if (!group.isolated) {
      info("TODO: Support non-isolated groups.");
    }
    if (group.knockout) {
      warn("Knockout groups not supported.");
    }
    const currentTransform = getCurrentTransform(currentCtx);
    if (group.matrix) {
      currentCtx.transform(...group.matrix);
    }
    if (!group.bbox) {
      throw new Error("Bounding box is required.");
    }
    let bounds = MIN_MAX_INIT.slice();
    Util.axialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx), bounds);
    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
    bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
    const offsetX = Math.floor(bounds[0]);
    const offsetY = Math.floor(bounds[1]);
    const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
    const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
    let cacheId = "groupAt" + this.groupLevel;
    if (group.smask) {
      cacheId += "_smask_" + this.smaskCounter++ % 2;
    }
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    const groupCtx = scratchCanvas.context;
    groupCtx.translate(-offsetX, -offsetY);
    groupCtx.transform(...currentTransform);
    let clip = new Path2D();
    const [x0, y0, x1, y1] = group.bbox;
    clip.rect(x0, y0, x1 - x0, y1 - y0);
    if (group.matrix) {
      const path = new Path2D();
      path.addPath(clip, new DOMMatrix(group.matrix));
      clip = path;
    }
    groupCtx.clip(clip);
    if (group.smask) {
      this.smaskStack.push({
        canvas: scratchCanvas.canvas,
        context: groupCtx,
        offsetX,
        offsetY,
        subtype: group.smask.subtype,
        backdrop: group.smask.backdrop,
        transferMap: group.smask.transferMap || null,
        startTransformInverse: null
      });
    }
    if (!group.smask || this.dependencyTracker) {
      currentCtx.setTransform(1, 0, 0, 1, 0, 0);
      currentCtx.translate(offsetX, offsetY);
      currentCtx.save();
    }
    copyCtxState(currentCtx, groupCtx);
    this.ctx = groupCtx;
    this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies(["fillAlpha", "strokeAlpha", "globalCompositeOperation"]).pushBaseTransform(currentCtx);
    this.setGState(opIdx, [["BM", "source-over"], ["ca", 1], ["CA", 1]]);
    this.groupStack.push(currentCtx);
    this.groupLevel++;
  }
  endGroup(opIdx, group) {
    if (!this.contentVisible) {
      return;
    }
    this.groupLevel--;
    const groupCtx = this.ctx;
    const ctx = this.groupStack.pop();
    this.ctx = ctx;
    this.ctx.imageSmoothingEnabled = false;
    this.dependencyTracker?.popBaseTransform();
    if (group.smask) {
      this.tempSMask = this.smaskStack.pop();
      this.restore(opIdx);
      if (this.dependencyTracker) {
        this.ctx.restore();
      }
    } else {
      this.ctx.restore();
      const currentMtx = getCurrentTransform(this.ctx);
      this.restore(opIdx);
      this.ctx.save();
      this.ctx.setTransform(...currentMtx);
      const dirtyBox = MIN_MAX_INIT.slice();
      Util.axialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx, dirtyBox);
      this.ctx.drawImage(groupCtx.canvas, 0, 0);
      this.ctx.restore();
      this.compose(dirtyBox);
    }
  }
  beginAnnotation(opIdx, id, rect, transform, matrix, hasOwnCanvas) {
    this.#restoreInitialState();
    resetCtxToDefault(this.ctx);
    this.ctx.save();
    this.save(opIdx);
    if (this.baseTransform) {
      this.ctx.setTransform(...this.baseTransform);
    }
    if (rect) {
      const width = rect[2] - rect[0];
      const height = rect[3] - rect[1];
      if (hasOwnCanvas && this.annotationCanvasMap) {
        transform = transform.slice();
        transform[4] -= rect[0];
        transform[5] -= rect[1];
        rect = rect.slice();
        rect[0] = rect[1] = 0;
        rect[2] = width;
        rect[3] = height;
        Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);
        const {
          viewportScale
        } = this;
        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
        const {
          canvas,
          context: context2
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(id, canvas);
        this.annotationCanvas.savedCtx = this.ctx;
        this.ctx = context2;
        this.ctx.save();
        this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);
        resetCtxToDefault(this.ctx);
      } else {
        resetCtxToDefault(this.ctx);
        this.endPath(opIdx);
        const clip = new Path2D();
        clip.rect(rect[0], rect[1], width, height);
        this.ctx.clip(clip);
      }
    }
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.transform(opIdx, ...transform);
    this.transform(opIdx, ...matrix);
  }
  endAnnotation(opIdx) {
    if (this.annotationCanvas) {
      this.ctx.restore();
      this.#drawFilter();
      this.ctx = this.annotationCanvas.savedCtx;
      delete this.annotationCanvas.savedCtx;
      delete this.annotationCanvas;
    }
  }
  paintImageMaskXObject(opIdx, img) {
    if (!this.contentVisible) {
      return;
    }
    const count2 = img.count;
    img = this.getObject(opIdx, img.data, img);
    img.count = count2;
    const ctx = this.ctx;
    const mask = this._createMaskCanvas(opIdx, img);
    const maskCanvas = mask.canvas;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
    this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, mask.offsetX, mask.offsetX + maskCanvas.width, mask.offsetY, mask.offsetY + maskCanvas.height).recordOperation(opIdx);
    ctx.restore();
    this.compose();
  }
  paintImageMaskXObjectRepeat(opIdx, img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }
    img = this.getObject(opIdx, img.data, img);
    const ctx = this.ctx;
    ctx.save();
    const currentTransform = getCurrentTransform(ctx);
    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
    const mask = this._createMaskCanvas(opIdx, img);
    ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
    this.dependencyTracker?.resetBBox(opIdx);
    for (let i18 = 0, ii = positions.length; i18 < ii; i18 += 2) {
      const trans = Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i18], positions[i18 + 1]]);
      ctx.drawImage(mask.canvas, trans[4], trans[5]);
      this.dependencyTracker?.recordBBox(opIdx, this.ctx, trans[4], trans[4] + mask.canvas.width, trans[5], trans[5] + mask.canvas.height);
    }
    ctx.restore();
    this.compose();
    this.dependencyTracker?.recordOperation(opIdx);
  }
  paintImageMaskXObjectGroup(opIdx, images) {
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    this.dependencyTracker?.resetBBox(opIdx).recordDependencies(opIdx, Dependencies.transformAndFill);
    for (const image of images) {
      const {
        data,
        width,
        height,
        transform
      } = image;
      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      const maskCtx = maskCanvas.context;
      maskCtx.save();
      const img = this.getObject(opIdx, data, image);
      putBinaryImageMask(maskCtx, img);
      maskCtx.globalCompositeOperation = "source-in";
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      ctx.save();
      ctx.transform(...transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
      this.dependencyTracker?.recordBBox(opIdx, ctx, 0, width, 0, height);
      ctx.restore();
    }
    this.compose();
    this.dependencyTracker?.recordOperation(opIdx);
  }
  paintImageXObject(opIdx, objId) {
    if (!this.contentVisible) {
      return;
    }
    const imgData = this.getObject(opIdx, objId);
    if (!imgData) {
      warn("Dependent image isn't ready yet");
      return;
    }
    this.paintInlineImageXObject(opIdx, imgData);
  }
  paintImageXObjectRepeat(opIdx, objId, scaleX, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }
    const imgData = this.getObject(opIdx, objId);
    if (!imgData) {
      warn("Dependent image isn't ready yet");
      return;
    }
    const width = imgData.width;
    const height = imgData.height;
    const map2 = [];
    for (let i18 = 0, ii = positions.length; i18 < ii; i18 += 2) {
      map2.push({
        transform: [scaleX, 0, 0, scaleY, positions[i18], positions[i18 + 1]],
        x: 0,
        y: 0,
        w: width,
        h: height
      });
    }
    this.paintInlineImageXObjectGroup(opIdx, imgData, map2);
  }
  applyTransferMapsToCanvas(ctx) {
    if (this.current.transferMaps !== "none") {
      ctx.filter = this.current.transferMaps;
      ctx.drawImage(ctx.canvas, 0, 0);
      ctx.filter = "none";
    }
    return ctx.canvas;
  }
  applyTransferMapsToBitmap(imgData) {
    if (this.current.transferMaps === "none") {
      return imgData.bitmap;
    }
    const {
      bitmap,
      width,
      height
    } = imgData;
    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
    const tmpCtx = tmpCanvas.context;
    tmpCtx.filter = this.current.transferMaps;
    tmpCtx.drawImage(bitmap, 0, 0);
    tmpCtx.filter = "none";
    return tmpCanvas.canvas;
  }
  paintInlineImageXObject(opIdx, imgData) {
    if (!this.contentVisible) {
      return;
    }
    const width = imgData.width;
    const height = imgData.height;
    const ctx = this.ctx;
    this.save(opIdx);
    const {
      filter
    } = ctx;
    if (filter !== "none" && filter !== "") {
      ctx.filter = "none";
    }
    ctx.scale(1 / width, -1 / height);
    let imgToPaint;
    if (imgData.bitmap) {
      imgToPaint = this.applyTransferMapsToBitmap(imgData);
    } else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
      imgToPaint = imgData;
    } else {
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);
      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
    }
    const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));
    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);
    this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, ctx, 0, width, -height, 0).recordDependencies(opIdx, Dependencies.imageXObject).recordOperation(opIdx);
    drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
    this.compose();
    this.restore(opIdx);
  }
  paintInlineImageXObjectGroup(opIdx, imgData, map2) {
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    let imgToPaint;
    if (imgData.bitmap) {
      imgToPaint = imgData.bitmap;
    } else {
      const w4 = imgData.width;
      const h12 = imgData.height;
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w4, h12);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);
      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
    }
    this.dependencyTracker?.resetBBox(opIdx);
    for (const entry of map2) {
      ctx.save();
      ctx.transform(...entry.transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
      this.dependencyTracker?.recordBBox(opIdx, ctx, 0, 1, -1, 0);
      ctx.restore();
    }
    this.dependencyTracker?.recordOperation(opIdx);
    this.compose();
  }
  paintSolidColorImageMask(opIdx) {
    if (!this.contentVisible) {
      return;
    }
    this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, 0, 1, 0, 1).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);
    this.ctx.fillRect(0, 0, 1, 1);
    this.compose();
  }
  markPoint(opIdx, tag) {
  }
  markPointProps(opIdx, tag, properties) {
  }
  beginMarkedContent(opIdx, tag) {
    this.dependencyTracker?.beginMarkedContent(opIdx);
    this.markedContentStack.push({
      visible: true
    });
  }
  beginMarkedContentProps(opIdx, tag, properties) {
    this.dependencyTracker?.beginMarkedContent(opIdx);
    if (tag === "OC") {
      this.markedContentStack.push({
        visible: this.optionalContentConfig.isVisible(properties)
      });
    } else {
      this.markedContentStack.push({
        visible: true
      });
    }
    this.contentVisible = this.isContentVisible();
  }
  endMarkedContent(opIdx) {
    this.dependencyTracker?.endMarkedContent(opIdx);
    this.markedContentStack.pop();
    this.contentVisible = this.isContentVisible();
  }
  beginCompat(opIdx) {
  }
  endCompat(opIdx) {
  }
  consumePath(opIdx, path, clipBox) {
    const isEmpty3 = this.current.isEmptyClip();
    if (this.pendingClip) {
      this.current.updateClipFromPath();
    }
    if (!this.pendingClip) {
      this.compose(clipBox);
    }
    const ctx = this.ctx;
    if (this.pendingClip) {
      if (!isEmpty3) {
        if (this.pendingClip === EO_CLIP) {
          ctx.clip(path, "evenodd");
        } else {
          ctx.clip(path);
        }
      }
      this.pendingClip = null;
      this.dependencyTracker?.bboxToClipBoxDropOperation(opIdx).recordFutureForcedDependency("clipPath", opIdx);
    } else {
      this.dependencyTracker?.recordOperation(opIdx);
    }
    this.current.startNewPathAndClipBox(this.current.clipBox);
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const m18 = getCurrentTransform(this.ctx);
      if (m18[1] === 0 && m18[2] === 0) {
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m18[0]), Math.abs(m18[3]));
      } else {
        const absDet = Math.abs(m18[0] * m18[3] - m18[2] * m18[1]);
        const normX = Math.hypot(m18[0], m18[2]);
        const normY = Math.hypot(m18[1], m18[3]);
        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (this._cachedScaleForStroking[0] === -1) {
      const {
        lineWidth
      } = this.current;
      const {
        a: a22,
        b: b7,
        c: c21,
        d: d15
      } = this.ctx.getTransform();
      let scaleX, scaleY;
      if (b7 === 0 && c21 === 0) {
        const normX = Math.abs(a22);
        const normY = Math.abs(d15);
        if (normX === normY) {
          if (lineWidth === 0) {
            scaleX = scaleY = 1 / normX;
          } else {
            const scaledLineWidth = normX * lineWidth;
            scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
          }
        } else if (lineWidth === 0) {
          scaleX = 1 / normX;
          scaleY = 1 / normY;
        } else {
          const scaledXLineWidth = normX * lineWidth;
          const scaledYLineWidth = normY * lineWidth;
          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
        }
      } else {
        const absDet = Math.abs(a22 * d15 - b7 * c21);
        const normX = Math.hypot(a22, b7);
        const normY = Math.hypot(c21, d15);
        if (lineWidth === 0) {
          scaleX = normY / absDet;
          scaleY = normX / absDet;
        } else {
          const baseArea = lineWidth * absDet;
          scaleX = normY > baseArea ? normY / baseArea : 1;
          scaleY = normX > baseArea ? normX / baseArea : 1;
        }
      }
      this._cachedScaleForStroking[0] = scaleX;
      this._cachedScaleForStroking[1] = scaleY;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(path, saveRestore) {
    const {
      ctx,
      current: {
        lineWidth
      }
    } = this;
    const [scaleX, scaleY] = this.getScaleForStroking();
    if (scaleX === scaleY) {
      ctx.lineWidth = (lineWidth || 1) * scaleX;
      ctx.stroke(path);
      return;
    }
    const dashes = ctx.getLineDash();
    if (saveRestore) {
      ctx.save();
    }
    ctx.scale(scaleX, scaleY);
    SCALE_MATRIX.a = 1 / scaleX;
    SCALE_MATRIX.d = 1 / scaleY;
    const newPath = new Path2D();
    newPath.addPath(path, SCALE_MATRIX);
    if (dashes.length > 0) {
      const scale = Math.max(scaleX, scaleY);
      ctx.setLineDash(dashes.map((x3) => x3 / scale));
      ctx.lineDashOffset /= scale;
    }
    ctx.lineWidth = lineWidth || 1;
    ctx.stroke(newPath);
    if (saveRestore) {
      ctx.restore();
    }
  }
  isContentVisible() {
    for (let i18 = this.markedContentStack.length - 1; i18 >= 0; i18--) {
      if (!this.markedContentStack[i18].visible) {
        return false;
      }
    }
    return true;
  }
};
for (const op in OPS) {
  if (CanvasGraphics.prototype[op] !== void 0) {
    CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
  }
}
;
var CssFontInfo = class _CssFontInfo {
  static {
    __name(this, "CssFontInfo");
  }
  #buffer;
  #view;
  #decoder;
  static strings = ["fontFamily", "fontWeight", "italicAngle"];
  static write(info2) {
    const encoder = new TextEncoder();
    const encodedStrings = {};
    let stringsLength = 0;
    for (const prop of _CssFontInfo.strings) {
      const encoded = encoder.encode(info2[prop]);
      encodedStrings[prop] = encoded;
      stringsLength += 4 + encoded.length;
    }
    const buffer = new ArrayBuffer(stringsLength);
    const data = new Uint8Array(buffer);
    const view = new DataView(buffer);
    let offset = 0;
    for (const prop of _CssFontInfo.strings) {
      const encoded = encodedStrings[prop];
      const length = encoded.length;
      view.setUint32(offset, length);
      data.set(encoded, offset + 4);
      offset += 4 + length;
    }
    assert2(offset === buffer.byteLength, "CssFontInfo.write: Buffer overflow");
    return buffer;
  }
  constructor(buffer) {
    this.#buffer = buffer;
    this.#view = new DataView(this.#buffer);
    this.#decoder = new TextDecoder();
  }
  #readString(index) {
    assert2(index < _CssFontInfo.strings.length, "Invalid string index");
    let offset = 0;
    for (let i18 = 0; i18 < index; i18++) {
      offset += this.#view.getUint32(offset) + 4;
    }
    const length = this.#view.getUint32(offset);
    return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));
  }
  get fontFamily() {
    return this.#readString(0);
  }
  get fontWeight() {
    return this.#readString(1);
  }
  get italicAngle() {
    return this.#readString(2);
  }
};
var SystemFontInfo = class _SystemFontInfo {
  static {
    __name(this, "SystemFontInfo");
  }
  #buffer;
  #view;
  #decoder;
  static strings = ["css", "loadedName", "baseFontName", "src"];
  static write(info2) {
    const encoder = new TextEncoder();
    const encodedStrings = {};
    let stringsLength = 0;
    for (const prop of _SystemFontInfo.strings) {
      const encoded = encoder.encode(info2[prop]);
      encodedStrings[prop] = encoded;
      stringsLength += 4 + encoded.length;
    }
    stringsLength += 4;
    let encodedStyleStyle, encodedStyleWeight, lengthEstimate = 1 + stringsLength;
    if (info2.style) {
      encodedStyleStyle = encoder.encode(info2.style.style);
      encodedStyleWeight = encoder.encode(info2.style.weight);
      lengthEstimate += 4 + encodedStyleStyle.length + 4 + encodedStyleWeight.length;
    }
    const buffer = new ArrayBuffer(lengthEstimate);
    const data = new Uint8Array(buffer);
    const view = new DataView(buffer);
    let offset = 0;
    view.setUint8(offset++, info2.guessFallback ? 1 : 0);
    view.setUint32(offset, 0);
    offset += 4;
    stringsLength = 0;
    for (const prop of _SystemFontInfo.strings) {
      const encoded = encodedStrings[prop];
      const length = encoded.length;
      stringsLength += 4 + length;
      view.setUint32(offset, length);
      data.set(encoded, offset + 4);
      offset += 4 + length;
    }
    view.setUint32(offset - stringsLength - 4, stringsLength);
    if (info2.style) {
      view.setUint32(offset, encodedStyleStyle.length);
      data.set(encodedStyleStyle, offset + 4);
      offset += 4 + encodedStyleStyle.length;
      view.setUint32(offset, encodedStyleWeight.length);
      data.set(encodedStyleWeight, offset + 4);
      offset += 4 + encodedStyleWeight.length;
    }
    assert2(offset <= buffer.byteLength, "SubstitionInfo.write: Buffer overflow");
    return buffer.transferToFixedLength(offset);
  }
  constructor(buffer) {
    this.#buffer = buffer;
    this.#view = new DataView(this.#buffer);
    this.#decoder = new TextDecoder();
  }
  get guessFallback() {
    return this.#view.getUint8(0) !== 0;
  }
  #readString(index) {
    assert2(index < _SystemFontInfo.strings.length, "Invalid string index");
    let offset = 5;
    for (let i18 = 0; i18 < index; i18++) {
      offset += this.#view.getUint32(offset) + 4;
    }
    const length = this.#view.getUint32(offset);
    return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));
  }
  get css() {
    return this.#readString(0);
  }
  get loadedName() {
    return this.#readString(1);
  }
  get baseFontName() {
    return this.#readString(2);
  }
  get src() {
    return this.#readString(3);
  }
  get style() {
    let offset = 1;
    offset += 4 + this.#view.getUint32(offset);
    const styleLength = this.#view.getUint32(offset);
    const style = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, styleLength));
    offset += 4 + styleLength;
    const weightLength = this.#view.getUint32(offset);
    const weight = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, weightLength));
    return {
      style,
      weight
    };
  }
};
var FontInfo = class _FontInfo {
  static {
    __name(this, "FontInfo");
  }
  static bools = ["black", "bold", "disableFontFace", "fontExtraProperties", "isInvalidPDFjsFont", "isType3Font", "italic", "missingFile", "remeasure", "vertical"];
  static numbers = ["ascent", "defaultWidth", "descent"];
  static strings = ["fallbackName", "loadedName", "mimetype", "name"];
  static #OFFSET_NUMBERS = Math.ceil(this.bools.length * 2 / 8);
  static #OFFSET_BBOX = this.#OFFSET_NUMBERS + this.numbers.length * 8;
  static #OFFSET_FONT_MATRIX = this.#OFFSET_BBOX + 1 + 2 * 4;
  static #OFFSET_DEFAULT_VMETRICS = this.#OFFSET_FONT_MATRIX + 1 + 8 * 6;
  static #OFFSET_STRINGS = this.#OFFSET_DEFAULT_VMETRICS + 1 + 2 * 3;
  #buffer;
  #decoder;
  #view;
  constructor({
    data,
    extra
  }) {
    this.#buffer = data;
    this.#decoder = new TextDecoder();
    this.#view = new DataView(this.#buffer);
    if (extra) {
      Object.assign(this, extra);
    }
  }
  #readBoolean(index) {
    assert2(index < _FontInfo.bools.length, "Invalid boolean index");
    const byteOffset = Math.floor(index / 4);
    const bitOffset = index * 2 % 8;
    const value = this.#view.getUint8(byteOffset) >> bitOffset & 3;
    return value === 0 ? void 0 : value === 2;
  }
  get black() {
    return this.#readBoolean(0);
  }
  get bold() {
    return this.#readBoolean(1);
  }
  get disableFontFace() {
    return this.#readBoolean(2);
  }
  get fontExtraProperties() {
    return this.#readBoolean(3);
  }
  get isInvalidPDFjsFont() {
    return this.#readBoolean(4);
  }
  get isType3Font() {
    return this.#readBoolean(5);
  }
  get italic() {
    return this.#readBoolean(6);
  }
  get missingFile() {
    return this.#readBoolean(7);
  }
  get remeasure() {
    return this.#readBoolean(8);
  }
  get vertical() {
    return this.#readBoolean(9);
  }
  #readNumber(index) {
    assert2(index < _FontInfo.numbers.length, "Invalid number index");
    return this.#view.getFloat64(_FontInfo.#OFFSET_NUMBERS + index * 8);
  }
  get ascent() {
    return this.#readNumber(0);
  }
  get defaultWidth() {
    return this.#readNumber(1);
  }
  get descent() {
    return this.#readNumber(2);
  }
  get bbox() {
    let offset = _FontInfo.#OFFSET_BBOX;
    const numCoords = this.#view.getUint8(offset);
    if (numCoords === 0) {
      return void 0;
    }
    offset += 1;
    const bbox = [];
    for (let i18 = 0; i18 < 4; i18++) {
      bbox.push(this.#view.getInt16(offset, true));
      offset += 2;
    }
    return bbox;
  }
  get fontMatrix() {
    let offset = _FontInfo.#OFFSET_FONT_MATRIX;
    const numPoints = this.#view.getUint8(offset);
    if (numPoints === 0) {
      return void 0;
    }
    offset += 1;
    const fontMatrix = [];
    for (let i18 = 0; i18 < 6; i18++) {
      fontMatrix.push(this.#view.getFloat64(offset, true));
      offset += 8;
    }
    return fontMatrix;
  }
  get defaultVMetrics() {
    let offset = _FontInfo.#OFFSET_DEFAULT_VMETRICS;
    const numMetrics = this.#view.getUint8(offset);
    if (numMetrics === 0) {
      return void 0;
    }
    offset += 1;
    const defaultVMetrics = [];
    for (let i18 = 0; i18 < 3; i18++) {
      defaultVMetrics.push(this.#view.getInt16(offset, true));
      offset += 2;
    }
    return defaultVMetrics;
  }
  #readString(index) {
    assert2(index < _FontInfo.strings.length, "Invalid string index");
    let offset = _FontInfo.#OFFSET_STRINGS + 4;
    for (let i18 = 0; i18 < index; i18++) {
      offset += this.#view.getUint32(offset) + 4;
    }
    const length = this.#view.getUint32(offset);
    const stringData = new Uint8Array(length);
    stringData.set(new Uint8Array(this.#buffer, offset + 4, length));
    return this.#decoder.decode(stringData);
  }
  get fallbackName() {
    return this.#readString(0);
  }
  get loadedName() {
    return this.#readString(1);
  }
  get mimetype() {
    return this.#readString(2);
  }
  get name() {
    return this.#readString(3);
  }
  get data() {
    let offset = _FontInfo.#OFFSET_STRINGS;
    const stringsLength = this.#view.getUint32(offset);
    offset += 4 + stringsLength;
    const systemFontInfoLength = this.#view.getUint32(offset);
    offset += 4 + systemFontInfoLength;
    const cssFontInfoLength = this.#view.getUint32(offset);
    offset += 4 + cssFontInfoLength;
    const length = this.#view.getUint32(offset);
    if (length === 0) {
      return void 0;
    }
    return new Uint8Array(this.#buffer, offset + 4, length);
  }
  clearData() {
    let offset = _FontInfo.#OFFSET_STRINGS;
    const stringsLength = this.#view.getUint32(offset);
    offset += 4 + stringsLength;
    const systemFontInfoLength = this.#view.getUint32(offset);
    offset += 4 + systemFontInfoLength;
    const cssFontInfoLength = this.#view.getUint32(offset);
    offset += 4 + cssFontInfoLength;
    const length = this.#view.getUint32(offset);
    const data = new Uint8Array(this.#buffer, offset + 4, length);
    data.fill(0);
    this.#view.setUint32(offset, 0);
  }
  get cssFontInfo() {
    let offset = _FontInfo.#OFFSET_STRINGS;
    const stringsLength = this.#view.getUint32(offset);
    offset += 4 + stringsLength;
    const systemFontInfoLength = this.#view.getUint32(offset);
    offset += 4 + systemFontInfoLength;
    const cssFontInfoLength = this.#view.getUint32(offset);
    if (cssFontInfoLength === 0) {
      return null;
    }
    const cssFontInfoData = new Uint8Array(cssFontInfoLength);
    cssFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, cssFontInfoLength));
    return new CssFontInfo(cssFontInfoData.buffer);
  }
  get systemFontInfo() {
    let offset = _FontInfo.#OFFSET_STRINGS;
    const stringsLength = this.#view.getUint32(offset);
    offset += 4 + stringsLength;
    const systemFontInfoLength = this.#view.getUint32(offset);
    if (systemFontInfoLength === 0) {
      return null;
    }
    const systemFontInfoData = new Uint8Array(systemFontInfoLength);
    systemFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, systemFontInfoLength));
    return new SystemFontInfo(systemFontInfoData.buffer);
  }
  static write(font) {
    const systemFontInfoBuffer = font.systemFontInfo ? SystemFontInfo.write(font.systemFontInfo) : null;
    const cssFontInfoBuffer = font.cssFontInfo ? CssFontInfo.write(font.cssFontInfo) : null;
    const encoder = new TextEncoder();
    const encodedStrings = {};
    let stringsLength = 0;
    for (const prop of _FontInfo.strings) {
      encodedStrings[prop] = encoder.encode(font[prop]);
      stringsLength += 4 + encodedStrings[prop].length;
    }
    const lengthEstimate = _FontInfo.#OFFSET_STRINGS + 4 + stringsLength + 4 + (systemFontInfoBuffer ? systemFontInfoBuffer.byteLength : 0) + 4 + (cssFontInfoBuffer ? cssFontInfoBuffer.byteLength : 0) + 4 + (font.data ? font.data.length : 0);
    const buffer = new ArrayBuffer(lengthEstimate);
    const data = new Uint8Array(buffer);
    const view = new DataView(buffer);
    let offset = 0;
    const numBools = _FontInfo.bools.length;
    let boolByte = 0, boolBit = 0;
    for (let i18 = 0; i18 < numBools; i18++) {
      const value = font[_FontInfo.bools[i18]];
      const bits = value === void 0 ? 0 : value ? 2 : 1;
      boolByte |= bits << boolBit;
      boolBit += 2;
      if (boolBit === 8 || i18 === numBools - 1) {
        view.setUint8(offset++, boolByte);
        boolByte = 0;
        boolBit = 0;
      }
    }
    assert2(offset === _FontInfo.#OFFSET_NUMBERS, "FontInfo.write: Boolean properties offset mismatch");
    for (const prop of _FontInfo.numbers) {
      view.setFloat64(offset, font[prop]);
      offset += 8;
    }
    assert2(offset === _FontInfo.#OFFSET_BBOX, "FontInfo.write: Number properties offset mismatch");
    if (font.bbox) {
      view.setUint8(offset++, 4);
      for (const coord of font.bbox) {
        view.setInt16(offset, coord, true);
        offset += 2;
      }
    } else {
      view.setUint8(offset++, 0);
      offset += 2 * 4;
    }
    assert2(offset === _FontInfo.#OFFSET_FONT_MATRIX, "FontInfo.write: BBox properties offset mismatch");
    if (font.fontMatrix) {
      view.setUint8(offset++, 6);
      for (const point of font.fontMatrix) {
        view.setFloat64(offset, point, true);
        offset += 8;
      }
    } else {
      view.setUint8(offset++, 0);
      offset += 8 * 6;
    }
    assert2(offset === _FontInfo.#OFFSET_DEFAULT_VMETRICS, "FontInfo.write: FontMatrix properties offset mismatch");
    if (font.defaultVMetrics) {
      view.setUint8(offset++, 1);
      for (const metric of font.defaultVMetrics) {
        view.setInt16(offset, metric, true);
        offset += 2;
      }
    } else {
      view.setUint8(offset++, 0);
      offset += 3 * 2;
    }
    assert2(offset === _FontInfo.#OFFSET_STRINGS, "FontInfo.write: DefaultVMetrics properties offset mismatch");
    view.setUint32(_FontInfo.#OFFSET_STRINGS, 0);
    offset += 4;
    for (const prop of _FontInfo.strings) {
      const encoded = encodedStrings[prop];
      const length = encoded.length;
      view.setUint32(offset, length);
      data.set(encoded, offset + 4);
      offset += 4 + length;
    }
    view.setUint32(_FontInfo.#OFFSET_STRINGS, offset - _FontInfo.#OFFSET_STRINGS - 4);
    if (!systemFontInfoBuffer) {
      view.setUint32(offset, 0);
      offset += 4;
    } else {
      const length = systemFontInfoBuffer.byteLength;
      view.setUint32(offset, length);
      assert2(offset + 4 + length <= buffer.byteLength, "FontInfo.write: Buffer overflow at systemFontInfo");
      data.set(new Uint8Array(systemFontInfoBuffer), offset + 4);
      offset += 4 + length;
    }
    if (!cssFontInfoBuffer) {
      view.setUint32(offset, 0);
      offset += 4;
    } else {
      const length = cssFontInfoBuffer.byteLength;
      view.setUint32(offset, length);
      assert2(offset + 4 + length <= buffer.byteLength, "FontInfo.write: Buffer overflow at cssFontInfo");
      data.set(new Uint8Array(cssFontInfoBuffer), offset + 4);
      offset += 4 + length;
    }
    if (font.data === void 0) {
      view.setUint32(offset, 0);
      offset += 4;
    } else {
      view.setUint32(offset, font.data.length);
      data.set(font.data, offset + 4);
      offset += 4 + font.data.length;
    }
    assert2(offset <= buffer.byteLength, "FontInfo.write: Buffer overflow");
    return buffer.transferToFixedLength(offset);
  }
};
;
var GlobalWorkerOptions = class {
  static {
    __name(this, "GlobalWorkerOptions");
  }
  static #port = null;
  static #src = "";
  static get workerPort() {
    return this.#port;
  }
  static set workerPort(val) {
    if (!(typeof Worker !== "undefined" && val instanceof Worker) && val !== null) {
      throw new Error("Invalid `workerPort` type.");
    }
    this.#port = val;
  }
  static get workerSrc() {
    return this.#src;
  }
  static set workerSrc(val) {
    if (typeof val !== "string") {
      throw new Error("Invalid `workerSrc` type.");
    }
    this.#src = val;
  }
};
;
var Metadata = class {
  static {
    __name(this, "Metadata");
  }
  #map;
  #data;
  constructor({
    parsedData,
    rawData
  }) {
    this.#map = parsedData;
    this.#data = rawData;
  }
  getRaw() {
    return this.#data;
  }
  get(name4) {
    return this.#map.get(name4) ?? null;
  }
  [Symbol.iterator]() {
    return this.#map.entries();
  }
};
;
var INTERNAL = Symbol("INTERNAL");
var OptionalContentGroup = class {
  static {
    __name(this, "OptionalContentGroup");
  }
  #isDisplay = false;
  #isPrint = false;
  #userSet = false;
  #visible = true;
  constructor(renderingIntent, {
    name: name4,
    intent,
    usage,
    rbGroups
  }) {
    this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);
    this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
    this.name = name4;
    this.intent = intent;
    this.usage = usage;
    this.rbGroups = rbGroups;
  }
  get visible() {
    if (this.#userSet) {
      return this.#visible;
    }
    if (!this.#visible) {
      return false;
    }
    const {
      print,
      view
    } = this.usage;
    if (this.#isDisplay) {
      return view?.viewState !== "OFF";
    } else if (this.#isPrint) {
      return print?.printState !== "OFF";
    }
    return true;
  }
  _setVisible(internal, visible, userSet = false) {
    if (internal !== INTERNAL) {
      unreachable("Internal method `_setVisible` called.");
    }
    this.#userSet = userSet;
    this.#visible = visible;
  }
};
var OptionalContentConfig = class {
  static {
    __name(this, "OptionalContentConfig");
  }
  #cachedGetHash = null;
  #groups = /* @__PURE__ */ new Map();
  #initialHash = null;
  #order = null;
  constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY) {
    this.renderingIntent = renderingIntent;
    this.name = null;
    this.creator = null;
    if (data === null) {
      return;
    }
    this.name = data.name;
    this.creator = data.creator;
    this.#order = data.order;
    for (const group of data.groups) {
      this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));
    }
    if (data.baseState === "OFF") {
      for (const group of this.#groups.values()) {
        group._setVisible(INTERNAL, false);
      }
    }
    for (const on of data.on) {
      this.#groups.get(on)._setVisible(INTERNAL, true);
    }
    for (const off of data.off) {
      this.#groups.get(off)._setVisible(INTERNAL, false);
    }
    this.#initialHash = this.getHash();
  }
  #evaluateVisibilityExpression(array) {
    const length = array.length;
    if (length < 2) {
      return true;
    }
    const operator = array[0];
    for (let i18 = 1; i18 < length; i18++) {
      const element = array[i18];
      let state;
      if (Array.isArray(element)) {
        state = this.#evaluateVisibilityExpression(element);
      } else if (this.#groups.has(element)) {
        state = this.#groups.get(element).visible;
      } else {
        warn(`Optional content group not found: ${element}`);
        return true;
      }
      switch (operator) {
        case "And":
          if (!state) {
            return false;
          }
          break;
        case "Or":
          if (state) {
            return true;
          }
          break;
        case "Not":
          return !state;
        default:
          return true;
      }
    }
    return operator === "And";
  }
  isVisible(group) {
    if (this.#groups.size === 0) {
      return true;
    }
    if (!group) {
      info("Optional content group not defined.");
      return true;
    }
    if (group.type === "OCG") {
      if (!this.#groups.has(group.id)) {
        warn(`Optional content group not found: ${group.id}`);
        return true;
      }
      return this.#groups.get(group.id).visible;
    } else if (group.type === "OCMD") {
      if (group.expression) {
        return this.#evaluateVisibilityExpression(group.expression);
      }
      if (!group.policy || group.policy === "AnyOn") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (this.#groups.get(id).visible) {
            return true;
          }
        }
        return false;
      } else if (group.policy === "AllOn") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (!this.#groups.get(id).visible) {
            return false;
          }
        }
        return true;
      } else if (group.policy === "AnyOff") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (!this.#groups.get(id).visible) {
            return true;
          }
        }
        return false;
      } else if (group.policy === "AllOff") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            warn(`Optional content group not found: ${id}`);
            return true;
          }
          if (this.#groups.get(id).visible) {
            return false;
          }
        }
        return true;
      }
      warn(`Unknown optional content policy ${group.policy}.`);
      return true;
    }
    warn(`Unknown group type ${group.type}.`);
    return true;
  }
  setVisibility(id, visible = true, preserveRB = true) {
    const group = this.#groups.get(id);
    if (!group) {
      warn(`Optional content group not found: ${id}`);
      return;
    }
    if (preserveRB && visible && group.rbGroups.length) {
      for (const rbGroup of group.rbGroups) {
        for (const otherId of rbGroup) {
          if (otherId !== id) {
            this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);
          }
        }
      }
    }
    group._setVisible(INTERNAL, !!visible, true);
    this.#cachedGetHash = null;
  }
  setOCGState({
    state,
    preserveRB
  }) {
    let operator;
    for (const elem of state) {
      switch (elem) {
        case "ON":
        case "OFF":
        case "Toggle":
          operator = elem;
          continue;
      }
      const group = this.#groups.get(elem);
      if (!group) {
        continue;
      }
      switch (operator) {
        case "ON":
          this.setVisibility(elem, true, preserveRB);
          break;
        case "OFF":
          this.setVisibility(elem, false, preserveRB);
          break;
        case "Toggle":
          this.setVisibility(elem, !group.visible, preserveRB);
          break;
      }
    }
    this.#cachedGetHash = null;
  }
  get hasInitialVisibility() {
    return this.#initialHash === null || this.getHash() === this.#initialHash;
  }
  getOrder() {
    if (!this.#groups.size) {
      return null;
    }
    if (this.#order) {
      return this.#order.slice();
    }
    return [...this.#groups.keys()];
  }
  getGroup(id) {
    return this.#groups.get(id) || null;
  }
  getHash() {
    if (this.#cachedGetHash !== null) {
      return this.#cachedGetHash;
    }
    const hash = new MurmurHash3_64();
    for (const [id, group] of this.#groups) {
      hash.update(`${id}:${group.visible}`);
    }
    return this.#cachedGetHash = hash.hexdigest();
  }
  [Symbol.iterator]() {
    return this.#groups.entries();
  }
};
;
var PDFDataTransportStream = class {
  static {
    __name(this, "PDFDataTransportStream");
  }
  constructor(pdfDataRangeTransport, {
    disableRange = false,
    disableStream = false
  }) {
    assert2(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const {
      length,
      initialData,
      progressiveDone,
      contentDispositionFilename
    } = pdfDataRangeTransport;
    this._queuedChunks = [];
    this._progressiveDone = progressiveDone;
    this._contentDispositionFilename = contentDispositionFilename;
    if (initialData?.length > 0) {
      const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
      this._queuedChunks.push(buffer);
    }
    this._pdfDataRangeTransport = pdfDataRangeTransport;
    this._isStreamingSupported = !disableStream;
    this._isRangeSupported = !disableRange;
    this._contentLength = length;
    this._fullRequestReader = null;
    this._rangeReaders = [];
    pdfDataRangeTransport.addRangeListener((begin, chunk) => {
      this._onReceiveData({
        begin,
        chunk
      });
    });
    pdfDataRangeTransport.addProgressListener((loaded, total) => {
      this._onProgress({
        loaded,
        total
      });
    });
    pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
      this._onReceiveData({
        chunk
      });
    });
    pdfDataRangeTransport.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    });
    pdfDataRangeTransport.transportReady();
  }
  _onReceiveData({
    begin,
    chunk
  }) {
    const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;
    if (begin === void 0) {
      if (this._fullRequestReader) {
        this._fullRequestReader._enqueue(buffer);
      } else {
        this._queuedChunks.push(buffer);
      }
    } else {
      const found = this._rangeReaders.some(function(rangeReader) {
        if (rangeReader._begin !== begin) {
          return false;
        }
        rangeReader._enqueue(buffer);
        return true;
      });
      assert2(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  _onProgress(evt) {
    if (evt.total === void 0) {
      this._rangeReaders[0]?.onProgress?.({
        loaded: evt.loaded
      });
    } else {
      this._fullRequestReader?.onProgress?.({
        loaded: evt.loaded,
        total: evt.total
      });
    }
  }
  _onProgressiveDone() {
    this._fullRequestReader?.progressiveDone();
    this._progressiveDone = true;
  }
  _removeRangeReader(reader) {
    const i18 = this._rangeReaders.indexOf(reader);
    if (i18 >= 0) {
      this._rangeReaders.splice(i18, 1);
    }
  }
  getFullReader() {
    assert2(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const queuedChunks = this._queuedChunks;
    this._queuedChunks = null;
    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
    this._pdfDataRangeTransport.requestDataRange(begin, end);
    this._rangeReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeReaders.slice(0)) {
      reader.cancel(reason);
    }
    this._pdfDataRangeTransport.abort();
  }
};
var PDFDataTransportStreamReader = class {
  static {
    __name(this, "PDFDataTransportStreamReader");
  }
  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
    this._stream = stream;
    this._done = progressiveDone || false;
    this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;
    this._queuedChunks = queuedChunks || [];
    this._loaded = 0;
    for (const chunk of this._queuedChunks) {
      this._loaded += chunk.byteLength;
    }
    this._requests = [];
    this._headersReady = Promise.resolve();
    stream._fullRequestReader = this;
    this.onProgress = null;
  }
  _enqueue(chunk) {
    if (this._done) {
      return;
    }
    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunks.push(chunk);
    }
    this._loaded += chunk.byteLength;
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0) {
      const chunk = this._queuedChunks.shift();
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
  }
  progressiveDone() {
    if (this._done) {
      return;
    }
    this._done = true;
  }
};
var PDFDataTransportStreamRangeReader = class {
  static {
    __name(this, "PDFDataTransportStreamRangeReader");
  }
  constructor(stream, begin, end) {
    this._stream = stream;
    this._begin = begin;
    this._end = end;
    this._queuedChunk = null;
    this._requests = [];
    this._done = false;
    this.onProgress = null;
  }
  _enqueue(chunk) {
    if (this._done) {
      return;
    }
    if (this._requests.length === 0) {
      this._queuedChunk = chunk;
    } else {
      const requestsCapability = this._requests.shift();
      requestsCapability.resolve({
        value: chunk,
        done: false
      });
      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: void 0,
          done: true
        });
      }
      this._requests.length = 0;
    }
    this._done = true;
    this._stream._removeRangeReader(this);
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._queuedChunk) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    this._stream._removeRangeReader(this);
  }
};
;
function getFilenameFromContentDispositionHeader(contentDisposition) {
  let needsEncodingFixup = true;
  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = unescape(filename);
    filename = rfc5987decode(filename);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  tmp = rfc2231getparam(contentDisposition);
  if (tmp) {
    const filename = rfc2047decode(tmp);
    return fixupEncoding(filename);
  }
  tmp = toParamRegExp("filename", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  function toParamRegExp(attributePattern, flags) {
    return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
  }
  __name(toParamRegExp, "toParamRegExp");
  function textdecode(encoding, value) {
    if (encoding) {
      if (!/^[\x00-\xFF]+$/.test(value)) {
        return value;
      }
      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = stringToBytes(value);
        value = decoder.decode(buffer);
        needsEncodingFixup = false;
      } catch {
      }
    }
    return value;
  }
  __name(textdecode, "textdecode");
  function fixupEncoding(value) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
      value = textdecode("utf-8", value);
      if (needsEncodingFixup) {
        value = textdecode("iso-8859-1", value);
      }
    }
    return value;
  }
  __name(fixupEncoding, "fixupEncoding");
  function rfc2231getparam(contentDispositionStr) {
    const matches = [];
    let match;
    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    while ((match = iter.exec(contentDispositionStr)) !== null) {
      let [, n11, quot, part] = match;
      n11 = parseInt(n11, 10);
      if (n11 in matches) {
        if (n11 === 0) {
          break;
        }
        continue;
      }
      matches[n11] = [quot, part];
    }
    const parts = [];
    for (let n11 = 0; n11 < matches.length; ++n11) {
      if (!(n11 in matches)) {
        break;
      }
      let [quot, part] = matches[n11];
      part = rfc2616unquote(part);
      if (quot) {
        part = unescape(part);
        if (n11 === 0) {
          part = rfc5987decode(part);
        }
      }
      parts.push(part);
    }
    return parts.join("");
  }
  __name(rfc2231getparam, "rfc2231getparam");
  function rfc2616unquote(value) {
    if (value.startsWith('"')) {
      const parts = value.slice(1).split('\\"');
      for (let i18 = 0; i18 < parts.length; ++i18) {
        const quotindex = parts[i18].indexOf('"');
        if (quotindex !== -1) {
          parts[i18] = parts[i18].slice(0, quotindex);
          parts.length = i18 + 1;
        }
        parts[i18] = parts[i18].replaceAll(/\\(.)/g, "$1");
      }
      value = parts.join('"');
    }
    return value;
  }
  __name(rfc2616unquote, "rfc2616unquote");
  function rfc5987decode(extvalue) {
    const encodingend = extvalue.indexOf("'");
    if (encodingend === -1) {
      return extvalue;
    }
    const encoding = extvalue.slice(0, encodingend);
    const langvalue = extvalue.slice(encodingend + 1);
    const value = langvalue.replace(/^[^']*'/, "");
    return textdecode(encoding, value);
  }
  __name(rfc5987decode, "rfc5987decode");
  function rfc2047decode(value) {
    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
      return value;
    }
    return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
      if (encoding === "q" || encoding === "Q") {
        text = text.replaceAll("_", " ");
        text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return textdecode(charset, text);
      }
      try {
        text = atob(text);
      } catch {
      }
      return textdecode(charset, text);
    });
  }
  __name(rfc2047decode, "rfc2047decode");
  return "";
}
__name(getFilenameFromContentDispositionHeader, "getFilenameFromContentDispositionHeader");
;
function createHeaders(isHttp, httpHeaders) {
  const headers = new Headers();
  if (!isHttp || !httpHeaders || typeof httpHeaders !== "object") {
    return headers;
  }
  for (const key in httpHeaders) {
    const val = httpHeaders[key];
    if (val !== void 0) {
      headers.append(key, val);
    }
  }
  return headers;
}
__name(createHeaders, "createHeaders");
function getResponseOrigin(url) {
  return URL.parse(url)?.origin ?? null;
}
__name(getResponseOrigin, "getResponseOrigin");
function validateRangeRequestCapabilities({
  responseHeaders,
  isHttp,
  rangeChunkSize,
  disableRange
}) {
  const returnValues = {
    allowRangeRequests: false,
    suggestedLength: void 0
  };
  const length = parseInt(responseHeaders.get("Content-Length"), 10);
  if (!Number.isInteger(length)) {
    return returnValues;
  }
  returnValues.suggestedLength = length;
  if (length <= 2 * rangeChunkSize) {
    return returnValues;
  }
  if (disableRange || !isHttp) {
    return returnValues;
  }
  if (responseHeaders.get("Accept-Ranges") !== "bytes") {
    return returnValues;
  }
  const contentEncoding = responseHeaders.get("Content-Encoding") || "identity";
  if (contentEncoding !== "identity") {
    return returnValues;
  }
  returnValues.allowRangeRequests = true;
  return returnValues;
}
__name(validateRangeRequestCapabilities, "validateRangeRequestCapabilities");
function extractFilenameFromHeader(responseHeaders) {
  const contentDisposition = responseHeaders.get("Content-Disposition");
  if (contentDisposition) {
    let filename = getFilenameFromContentDispositionHeader(contentDisposition);
    if (filename.includes("%")) {
      try {
        filename = decodeURIComponent(filename);
      } catch {
      }
    }
    if (isPdfFile(filename)) {
      return filename;
    }
  }
  return null;
}
__name(extractFilenameFromHeader, "extractFilenameFromHeader");
function createResponseError(status, url) {
  return new ResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status, status === 404 || status === 0 && url.startsWith("file:"));
}
__name(createResponseError, "createResponseError");
function validateResponseStatus(status) {
  return status === 200 || status === 206;
}
__name(validateResponseStatus, "validateResponseStatus");
;
function createFetchOptions(headers, withCredentials, abortController) {
  return {
    method: "GET",
    headers,
    signal: abortController.signal,
    mode: "cors",
    credentials: withCredentials ? "include" : "same-origin",
    redirect: "follow"
  };
}
__name(createFetchOptions, "createFetchOptions");
function getArrayBuffer(val) {
  if (val instanceof Uint8Array) {
    return val.buffer;
  }
  if (val instanceof ArrayBuffer) {
    return val;
  }
  warn(`getArrayBuffer - unexpected data format: ${val}`);
  return new Uint8Array(val).buffer;
}
__name(getArrayBuffer, "getArrayBuffer");
var PDFFetchStream = class {
  static {
    __name(this, "PDFFetchStream");
  }
  _responseOrigin = null;
  constructor(source) {
    this.source = source;
    this.isHttp = /^https?:/i.test(source.url);
    this.headers = createHeaders(this.isHttp, source.httpHeaders);
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  getFullReader() {
    assert2(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFFetchStreamReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const reader = new PDFFetchStreamRangeReader(this, begin, end);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
};
var PDFFetchStreamReader = class {
  static {
    __name(this, "PDFFetchStreamReader");
  }
  constructor(stream) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    this._filename = null;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._contentLength = source.length;
    this._headersCapability = Promise.withResolvers();
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._abortController = new AbortController();
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    const headers = new Headers(stream.headers);
    const url = source.url;
    fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response) => {
      stream._responseOrigin = getResponseOrigin(response.url);
      if (!validateResponseStatus(response.status)) {
        throw createResponseError(response.status, url);
      }
      this._reader = response.body.getReader();
      this._headersCapability.resolve();
      const responseHeaders = response.headers;
      const {
        allowRangeRequests,
        suggestedLength
      } = validateRangeRequestCapabilities({
        responseHeaders,
        isHttp: stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = extractFilenameFromHeader(responseHeaders);
      if (!this._isStreamingSupported && this._isRangeSupported) {
        this.cancel(new AbortException("Streaming is disabled."));
      }
    }).catch(this._headersCapability.reject);
    this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._headersCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value,
        done
      };
    }
    this._loaded += value.byteLength;
    this.onProgress?.({
      loaded: this._loaded,
      total: this._contentLength
    });
    return {
      value: getArrayBuffer(value),
      done: false
    };
  }
  cancel(reason) {
    this._reader?.cancel(reason);
    this._abortController.abort();
  }
};
var PDFFetchStreamRangeReader = class {
  static {
    __name(this, "PDFFetchStreamRangeReader");
  }
  constructor(stream, begin, end) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._readCapability = Promise.withResolvers();
    this._isStreamingSupported = !source.disableStream;
    this._abortController = new AbortController();
    const headers = new Headers(stream.headers);
    headers.append("Range", `bytes=${begin}-${end - 1}`);
    const url = source.url;
    fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response) => {
      const responseOrigin = getResponseOrigin(response.url);
      if (responseOrigin !== stream._responseOrigin) {
        throw new Error(`Expected range response-origin "${responseOrigin}" to match "${stream._responseOrigin}".`);
      }
      if (!validateResponseStatus(response.status)) {
        throw createResponseError(response.status, url);
      }
      this._readCapability.resolve();
      this._reader = response.body.getReader();
    }).catch(this._readCapability.reject);
    this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value,
        done
      };
    }
    this._loaded += value.byteLength;
    this.onProgress?.({
      loaded: this._loaded
    });
    return {
      value: getArrayBuffer(value),
      done: false
    };
  }
  cancel(reason) {
    this._reader?.cancel(reason);
    this._abortController.abort();
  }
};
;
var OK_RESPONSE = 200;
var PARTIAL_CONTENT_RESPONSE = 206;
function network_getArrayBuffer(xhr) {
  const data = xhr.response;
  if (typeof data !== "string") {
    return data;
  }
  return stringToBytes(data).buffer;
}
__name(network_getArrayBuffer, "network_getArrayBuffer");
var NetworkManager = class {
  static {
    __name(this, "NetworkManager");
  }
  _responseOrigin = null;
  constructor({
    url,
    httpHeaders,
    withCredentials
  }) {
    this.url = url;
    this.isHttp = /^https?:/i.test(url);
    this.headers = createHeaders(this.isHttp, httpHeaders);
    this.withCredentials = withCredentials || false;
    this.currXhrId = 0;
    this.pendingRequests = /* @__PURE__ */ Object.create(null);
  }
  request(args) {
    const xhr = new XMLHttpRequest();
    const xhrId = this.currXhrId++;
    const pendingRequest = this.pendingRequests[xhrId] = {
      xhr
    };
    xhr.open("GET", this.url);
    xhr.withCredentials = this.withCredentials;
    for (const [key, val] of this.headers) {
      xhr.setRequestHeader(key, val);
    }
    if (this.isHttp && "begin" in args && "end" in args) {
      xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
    } else {
      pendingRequest.expectedStatus = OK_RESPONSE;
    }
    xhr.responseType = "arraybuffer";
    assert2(args.onError, "Expected `onError` callback to be provided.");
    xhr.onerror = () => {
      args.onError(xhr.status);
    };
    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
    xhr.onprogress = this.onProgress.bind(this, xhrId);
    pendingRequest.onHeadersReceived = args.onHeadersReceived;
    pendingRequest.onDone = args.onDone;
    pendingRequest.onError = args.onError;
    pendingRequest.onProgress = args.onProgress;
    xhr.send(null);
    return xhrId;
  }
  onProgress(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    pendingRequest.onProgress?.(evt);
  }
  onStateChange(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    const xhr = pendingRequest.xhr;
    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
      pendingRequest.onHeadersReceived();
      delete pendingRequest.onHeadersReceived;
    }
    if (xhr.readyState !== 4) {
      return;
    }
    if (!(xhrId in this.pendingRequests)) {
      return;
    }
    delete this.pendingRequests[xhrId];
    if (xhr.status === 0 && this.isHttp) {
      pendingRequest.onError(xhr.status);
      return;
    }
    const xhrStatus = xhr.status || OK_RESPONSE;
    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
      pendingRequest.onError(xhr.status);
      return;
    }
    const chunk = network_getArrayBuffer(xhr);
    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
      const rangeHeader = xhr.getResponseHeader("Content-Range");
      const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
      if (matches) {
        pendingRequest.onDone({
          begin: parseInt(matches[1], 10),
          chunk
        });
      } else {
        warn(`Missing or invalid "Content-Range" header.`);
        pendingRequest.onError(0);
      }
    } else if (chunk) {
      pendingRequest.onDone({
        begin: 0,
        chunk
      });
    } else {
      pendingRequest.onError(xhr.status);
    }
  }
  getRequestXhr(xhrId) {
    return this.pendingRequests[xhrId].xhr;
  }
  isPendingRequest(xhrId) {
    return xhrId in this.pendingRequests;
  }
  abortRequest(xhrId) {
    const xhr = this.pendingRequests[xhrId].xhr;
    delete this.pendingRequests[xhrId];
    xhr.abort();
  }
};
var PDFNetworkStream = class {
  static {
    __name(this, "PDFNetworkStream");
  }
  constructor(source) {
    this._source = source;
    this._manager = new NetworkManager(source);
    this._rangeChunkSize = source.rangeChunkSize;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(reader) {
    const i18 = this._rangeRequestReaders.indexOf(reader);
    if (i18 >= 0) {
      this._rangeRequestReaders.splice(i18, 1);
    }
  }
  getFullReader() {
    assert2(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
};
var PDFNetworkStreamFullRequestReader = class {
  static {
    __name(this, "PDFNetworkStreamFullRequestReader");
  }
  constructor(manager, source) {
    this._manager = manager;
    this._url = source.url;
    this._fullRequestId = manager.request({
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    });
    this._headersCapability = Promise.withResolvers();
    this._disableRange = source.disableRange || false;
    this._contentLength = source.length;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._isStreamingSupported = false;
    this._isRangeSupported = false;
    this._cachedChunks = [];
    this._requests = [];
    this._done = false;
    this._storedError = void 0;
    this._filename = null;
    this.onProgress = null;
  }
  _onHeadersReceived() {
    const fullRequestXhrId = this._fullRequestId;
    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
    this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);
    const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();
    const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\S ]+$/, "").split(/[\r\n]+/).map((x3) => {
      const [key, ...val] = x3.split(": ");
      return [key, val.join(": ")];
    }) : []);
    const {
      allowRangeRequests,
      suggestedLength
    } = validateRangeRequestCapabilities({
      responseHeaders,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });
    if (allowRangeRequests) {
      this._isRangeSupported = true;
    }
    this._contentLength = suggestedLength || this._contentLength;
    this._filename = extractFilenameFromHeader(responseHeaders);
    if (this._isRangeSupported) {
      this._manager.abortRequest(fullRequestXhrId);
    }
    this._headersCapability.resolve();
  }
  _onDone(data) {
    if (data) {
      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();
        requestCapability.resolve({
          value: data.chunk,
          done: false
        });
      } else {
        this._cachedChunks.push(data.chunk);
      }
    }
    this._done = true;
    if (this._cachedChunks.length > 0) {
      return;
    }
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
  }
  _onError(status) {
    this._storedError = createResponseError(status, this._url);
    this._headersCapability.reject(this._storedError);
    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }
    this._requests.length = 0;
    this._cachedChunks.length = 0;
  }
  _onProgress(evt) {
    this.onProgress?.({
      loaded: evt.loaded,
      total: evt.lengthComputable ? evt.total : this._contentLength
    });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  async read() {
    await this._headersCapability.promise;
    if (this._storedError) {
      throw this._storedError;
    }
    if (this._cachedChunks.length > 0) {
      const chunk = this._cachedChunks.shift();
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    this._headersCapability.reject(reason);
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    if (this._manager.isPendingRequest(this._fullRequestId)) {
      this._manager.abortRequest(this._fullRequestId);
    }
    this._fullRequestReader = null;
  }
};
var PDFNetworkStreamRangeRequestReader = class {
  static {
    __name(this, "PDFNetworkStreamRangeRequestReader");
  }
  constructor(manager, begin, end) {
    this._manager = manager;
    this._url = manager.url;
    this._requestId = manager.request({
      begin,
      end,
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    });
    this._requests = [];
    this._queuedChunk = null;
    this._done = false;
    this._storedError = void 0;
    this.onProgress = null;
    this.onClosed = null;
  }
  _onHeadersReceived() {
    const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);
    if (responseOrigin !== this._manager._responseOrigin) {
      this._storedError = new Error(`Expected range response-origin "${responseOrigin}" to match "${this._manager._responseOrigin}".`);
      this._onError(0);
    }
  }
  _close() {
    this.onClosed?.(this);
  }
  _onDone(data) {
    const chunk = data.chunk;
    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunk = chunk;
    }
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    this._close();
  }
  _onError(status) {
    this._storedError ??= createResponseError(status, this._url);
    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }
    this._requests.length = 0;
    this._queuedChunk = null;
  }
  _onProgress(evt) {
    if (!this.isStreamingSupported) {
      this.onProgress?.({
        loaded: evt.loaded
      });
    }
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._storedError) {
      throw this._storedError;
    }
    if (this._queuedChunk !== null) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    if (this._manager.isPendingRequest(this._requestId)) {
      this._manager.abortRequest(this._requestId);
    }
    this._close();
  }
};
;
var urlRegex = /^[a-z][a-z0-9\-+.]+:/i;
function parseUrlOrPath(sourceUrl) {
  if (urlRegex.test(sourceUrl)) {
    return new URL(sourceUrl);
  }
  const url = process.getBuiltinModule("url");
  return new URL(url.pathToFileURL(sourceUrl));
}
__name(parseUrlOrPath, "parseUrlOrPath");
var PDFNodeStream = class {
  static {
    __name(this, "PDFNodeStream");
  }
  constructor(source) {
    this.source = source;
    this.url = parseUrlOrPath(source.url);
    assert2(this.url.protocol === "file:", "PDFNodeStream only supports file:// URLs.");
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  getFullReader() {
    assert2(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNodeStreamFsFullReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(start, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);
    this._rangeRequestReaders.push(rangeReader);
    return rangeReader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
};
var PDFNodeStreamFsFullReader = class {
  static {
    __name(this, "PDFNodeStreamFsFullReader");
  }
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    const source = stream.source;
    this._contentLength = source.length;
    this._loaded = 0;
    this._filename = null;
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._readableStream = null;
    this._readCapability = Promise.withResolvers();
    this._headersCapability = Promise.withResolvers();
    const fs = process.getBuiltinModule("fs");
    fs.promises.lstat(this._url).then((stat) => {
      this._contentLength = stat.size;
      this._setReadableStream(fs.createReadStream(this._url));
      this._headersCapability.resolve();
    }, (error) => {
      if (error.code === "ENOENT") {
        error = createResponseError(0, this._url.href);
      }
      this._storedError = error;
      this._headersCapability.reject(error);
    });
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    if (this._storedError) {
      throw this._storedError;
    }
    const chunk = this._readableStream.read();
    if (chunk === null) {
      this._readCapability = Promise.withResolvers();
      return this.read();
    }
    this._loaded += chunk.length;
    this.onProgress?.({
      loaded: this._loaded,
      total: this._contentLength
    });
    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }
  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);
      return;
    }
    this._readableStream.destroy(reason);
  }
  _error(reason) {
    this._storedError = reason;
    this._readCapability.resolve();
  }
  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    readableStream.on("error", (reason) => {
      this._error(reason);
    });
    if (!this._isStreamingSupported && this._isRangeSupported) {
      this._error(new AbortException("streaming is disabled"));
    }
    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }
};
var PDFNodeStreamFsRangeReader = class {
  static {
    __name(this, "PDFNodeStreamFsRangeReader");
  }
  constructor(stream, start, end) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    this._loaded = 0;
    this._readableStream = null;
    this._readCapability = Promise.withResolvers();
    const source = stream.source;
    this._isStreamingSupported = !source.disableStream;
    const fs = process.getBuiltinModule("fs");
    this._setReadableStream(fs.createReadStream(this._url, {
      start,
      end: end - 1
    }));
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    if (this._storedError) {
      throw this._storedError;
    }
    const chunk = this._readableStream.read();
    if (chunk === null) {
      this._readCapability = Promise.withResolvers();
      return this.read();
    }
    this._loaded += chunk.length;
    this.onProgress?.({
      loaded: this._loaded
    });
    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }
  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);
      return;
    }
    this._readableStream.destroy(reason);
  }
  _error(reason) {
    this._storedError = reason;
    this._readCapability.resolve();
  }
  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    readableStream.on("error", (reason) => {
      this._error(reason);
    });
    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }
};
;
var INITIAL_DATA = Symbol("INITIAL_DATA");
var PDFObjects = class {
  static {
    __name(this, "PDFObjects");
  }
  #objs = /* @__PURE__ */ Object.create(null);
  #ensureObj(objId) {
    return this.#objs[objId] ||= {
      ...Promise.withResolvers(),
      data: INITIAL_DATA
    };
  }
  get(objId, callback = null) {
    if (callback) {
      const obj2 = this.#ensureObj(objId);
      obj2.promise.then(() => callback(obj2.data));
      return null;
    }
    const obj = this.#objs[objId];
    if (!obj || obj.data === INITIAL_DATA) {
      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
    }
    return obj.data;
  }
  has(objId) {
    const obj = this.#objs[objId];
    return !!obj && obj.data !== INITIAL_DATA;
  }
  delete(objId) {
    const obj = this.#objs[objId];
    if (!obj || obj.data === INITIAL_DATA) {
      return false;
    }
    delete this.#objs[objId];
    return true;
  }
  resolve(objId, data = null) {
    const obj = this.#ensureObj(objId);
    obj.data = data;
    obj.resolve();
  }
  clear() {
    for (const objId in this.#objs) {
      const {
        data
      } = this.#objs[objId];
      data?.bitmap?.close();
    }
    this.#objs = /* @__PURE__ */ Object.create(null);
  }
  *[Symbol.iterator]() {
    for (const objId in this.#objs) {
      const {
        data
      } = this.#objs[objId];
      if (data === INITIAL_DATA) {
        continue;
      }
      yield [objId, data];
    }
  }
};
;
var MAX_TEXT_DIVS_TO_RENDER = 1e5;
var DEFAULT_FONT_SIZE = 30;
var TextLayer = class _TextLayer {
  static {
    __name(this, "TextLayer");
  }
  #capability = Promise.withResolvers();
  #container = null;
  #disableProcessItems = false;
  #fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
  #lang = null;
  #layoutTextParams = null;
  #pageHeight = 0;
  #pageWidth = 0;
  #reader = null;
  #rootContainer = null;
  #rotation = 0;
  #scale = 0;
  #styleCache = /* @__PURE__ */ Object.create(null);
  #textContentItemsStr = [];
  #textContentSource = null;
  #textDivs = [];
  #textDivProperties = /* @__PURE__ */ new WeakMap();
  #transform = null;
  static #ascentCache = /* @__PURE__ */ new Map();
  static #canvasContexts = /* @__PURE__ */ new Map();
  static #canvasCtxFonts = /* @__PURE__ */ new WeakMap();
  static #minFontSize = null;
  static #pendingTextLayers = /* @__PURE__ */ new Set();
  constructor({
    textContentSource,
    container,
    viewport
  }) {
    if (textContentSource instanceof ReadableStream) {
      this.#textContentSource = textContentSource;
    } else if (typeof textContentSource === "object") {
      this.#textContentSource = new ReadableStream({
        start(controller) {
          controller.enqueue(textContentSource);
          controller.close();
        }
      });
    } else {
      throw new Error('No "textContentSource" parameter specified.');
    }
    this.#container = this.#rootContainer = container;
    this.#scale = viewport.scale * OutputScale.pixelRatio;
    this.#rotation = viewport.rotation;
    this.#layoutTextParams = {
      div: null,
      properties: null,
      ctx: null
    };
    const {
      pageWidth,
      pageHeight,
      pageX,
      pageY
    } = viewport.rawDims;
    this.#transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];
    this.#pageWidth = pageWidth;
    this.#pageHeight = pageHeight;
    _TextLayer.#ensureMinFontSizeComputed();
    setLayerDimensions(container, viewport);
    this.#capability.promise.finally(() => {
      _TextLayer.#pendingTextLayers.delete(this);
      this.#layoutTextParams = null;
      this.#styleCache = null;
    }).catch(() => {
    });
  }
  static get fontFamilyMap() {
    const {
      isWindows,
      isFirefox
    } = util_FeatureTest.platform;
    return shadow(this, "fontFamilyMap", /* @__PURE__ */ new Map([["sans-serif", `${isWindows && isFirefox ? "Calibri, " : ""}sans-serif`], ["monospace", `${isWindows && isFirefox ? "Lucida Console, " : ""}monospace`]]));
  }
  render() {
    const pump = /* @__PURE__ */ __name(() => {
      this.#reader.read().then(({
        value,
        done
      }) => {
        if (done) {
          this.#capability.resolve();
          return;
        }
        this.#lang ??= value.lang;
        Object.assign(this.#styleCache, value.styles);
        this.#processItems(value.items);
        pump();
      }, this.#capability.reject);
    }, "pump");
    this.#reader = this.#textContentSource.getReader();
    _TextLayer.#pendingTextLayers.add(this);
    pump();
    return this.#capability.promise;
  }
  update({
    viewport,
    onBefore = null
  }) {
    const scale = viewport.scale * OutputScale.pixelRatio;
    const rotation = viewport.rotation;
    if (rotation !== this.#rotation) {
      onBefore?.();
      this.#rotation = rotation;
      setLayerDimensions(this.#rootContainer, {
        rotation
      });
    }
    if (scale !== this.#scale) {
      onBefore?.();
      this.#scale = scale;
      const params = {
        div: null,
        properties: null,
        ctx: _TextLayer.#getCtx(this.#lang)
      };
      for (const div of this.#textDivs) {
        params.properties = this.#textDivProperties.get(div);
        params.div = div;
        this.#layout(params);
      }
    }
  }
  cancel() {
    const abortEx = new AbortException("TextLayer task cancelled.");
    this.#reader?.cancel(abortEx).catch(() => {
    });
    this.#reader = null;
    this.#capability.reject(abortEx);
  }
  get textDivs() {
    return this.#textDivs;
  }
  get textContentItemsStr() {
    return this.#textContentItemsStr;
  }
  #processItems(items) {
    if (this.#disableProcessItems) {
      return;
    }
    this.#layoutTextParams.ctx ??= _TextLayer.#getCtx(this.#lang);
    const textDivs = this.#textDivs, textContentItemsStr = this.#textContentItemsStr;
    for (const item of items) {
      if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {
        warn("Ignoring additional textDivs for performance reasons.");
        this.#disableProcessItems = true;
        return;
      }
      if (item.str === void 0) {
        if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
          const parent = this.#container;
          this.#container = document.createElement("span");
          this.#container.classList.add("markedContent");
          if (item.id) {
            this.#container.setAttribute("id", `${item.id}`);
          }
          parent.append(this.#container);
        } else if (item.type === "endMarkedContent") {
          this.#container = this.#container.parentNode;
        }
        continue;
      }
      textContentItemsStr.push(item.str);
      this.#appendText(item);
    }
  }
  #appendText(geom) {
    const textDiv = document.createElement("span");
    const textDivProperties = {
      angle: 0,
      canvasWidth: 0,
      hasText: geom.str !== "",
      hasEOL: geom.hasEOL,
      fontSize: 0
    };
    this.#textDivs.push(textDiv);
    const tx = Util.transform(this.#transform, geom.transform);
    let angle = Math.atan2(tx[1], tx[0]);
    const style = this.#styleCache[geom.fontName];
    if (style.vertical) {
      angle += Math.PI / 2;
    }
    let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;
    fontFamily = _TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;
    const fontHeight = Math.hypot(tx[2], tx[3]);
    const fontAscent = fontHeight * _TextLayer.#getAscent(fontFamily, style, this.#lang);
    let left, top;
    if (angle === 0) {
      left = tx[4];
      top = tx[5] - fontAscent;
    } else {
      left = tx[4] + fontAscent * Math.sin(angle);
      top = tx[5] - fontAscent * Math.cos(angle);
    }
    const scaleFactorStr = "calc(var(--total-scale-factor) *";
    const divStyle = textDiv.style;
    if (this.#container === this.#rootContainer) {
      divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;
      divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;
    } else {
      divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;
      divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;
    }
    divStyle.fontSize = `${scaleFactorStr}${(_TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;
    divStyle.fontFamily = fontFamily;
    textDivProperties.fontSize = fontHeight;
    textDiv.setAttribute("role", "presentation");
    textDiv.textContent = geom.str;
    textDiv.dir = geom.dir;
    if (this.#fontInspectorEnabled) {
      textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;
    }
    if (angle !== 0) {
      textDivProperties.angle = angle * (180 / Math.PI);
    }
    let shouldScaleText = false;
    if (geom.str.length > 1) {
      shouldScaleText = true;
    } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
      const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
      if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
        shouldScaleText = true;
      }
    }
    if (shouldScaleText) {
      textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;
    }
    this.#textDivProperties.set(textDiv, textDivProperties);
    this.#layoutTextParams.div = textDiv;
    this.#layoutTextParams.properties = textDivProperties;
    this.#layout(this.#layoutTextParams);
    if (textDivProperties.hasText) {
      this.#container.append(textDiv);
    }
    if (textDivProperties.hasEOL) {
      const br = document.createElement("br");
      br.setAttribute("role", "presentation");
      this.#container.append(br);
    }
  }
  #layout(params) {
    const {
      div,
      properties,
      ctx
    } = params;
    const {
      style
    } = div;
    let transform = "";
    if (_TextLayer.#minFontSize > 1) {
      transform = `scale(${1 / _TextLayer.#minFontSize})`;
    }
    if (properties.canvasWidth !== 0 && properties.hasText) {
      const {
        fontFamily
      } = style;
      const {
        canvasWidth,
        fontSize
      } = properties;
      _TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);
      const {
        width
      } = ctx.measureText(div.textContent);
      if (width > 0) {
        transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;
      }
    }
    if (properties.angle !== 0) {
      transform = `rotate(${properties.angle}deg) ${transform}`;
    }
    if (transform.length > 0) {
      style.transform = transform;
    }
  }
  static cleanup() {
    if (this.#pendingTextLayers.size > 0) {
      return;
    }
    this.#ascentCache.clear();
    for (const {
      canvas
    } of this.#canvasContexts.values()) {
      canvas.remove();
    }
    this.#canvasContexts.clear();
  }
  static #getCtx(lang = null) {
    let ctx = this.#canvasContexts.get(lang ||= "");
    if (!ctx) {
      const canvas = document.createElement("canvas");
      canvas.className = "hiddenCanvasElement";
      canvas.lang = lang;
      document.body.append(canvas);
      ctx = canvas.getContext("2d", {
        alpha: false,
        willReadFrequently: true
      });
      this.#canvasContexts.set(lang, ctx);
      this.#canvasCtxFonts.set(ctx, {
        size: 0,
        family: ""
      });
    }
    return ctx;
  }
  static #ensureCtxFont(ctx, size, family) {
    const cached = this.#canvasCtxFonts.get(ctx);
    if (size === cached.size && family === cached.family) {
      return;
    }
    ctx.font = `${size}px ${family}`;
    cached.size = size;
    cached.family = family;
  }
  static #ensureMinFontSizeComputed() {
    if (this.#minFontSize !== null) {
      return;
    }
    const div = document.createElement("div");
    div.style.opacity = 0;
    div.style.lineHeight = 1;
    div.style.fontSize = "1px";
    div.style.position = "absolute";
    div.textContent = "X";
    document.body.append(div);
    this.#minFontSize = div.getBoundingClientRect().height;
    div.remove();
  }
  static #getAscent(fontFamily, style, lang) {
    const cachedAscent = this.#ascentCache.get(fontFamily);
    if (cachedAscent) {
      return cachedAscent;
    }
    const ctx = this.#getCtx(lang);
    ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;
    this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);
    const metrics2 = ctx.measureText("");
    const ascent = metrics2.fontBoundingBoxAscent;
    const descent = Math.abs(metrics2.fontBoundingBoxDescent);
    ctx.canvas.width = ctx.canvas.height = 0;
    let ratio = 0.8;
    if (ascent) {
      ratio = ascent / (ascent + descent);
    } else {
      if (util_FeatureTest.platform.isFirefox) {
        warn("Enable the `dom.textMetrics.fontBoundingBox.enabled` preference in `about:config` to improve TextLayer rendering.");
      }
      if (style.ascent) {
        ratio = style.ascent;
      } else if (style.descent) {
        ratio = 1 + style.descent;
      }
    }
    this.#ascentCache.set(fontFamily, ratio);
    return ratio;
  }
};
;
var RENDERING_CANCELLED_TIMEOUT = 100;
function getDocument(src = {}) {
  if (typeof src === "string" || src instanceof URL) {
    src = {
      url: src
    };
  } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {
    src = {
      data: src
    };
  }
  const task = new PDFDocumentLoadingTask();
  const {
    docId
  } = task;
  const url = src.url ? getUrlProp(src.url) : null;
  const data = src.data ? getDataProp(src.data) : null;
  const httpHeaders = src.httpHeaders || null;
  const withCredentials = src.withCredentials === true;
  const password = src.password ?? null;
  const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;
  const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : 2 ** 16;
  let worker = src.worker instanceof PDFWorker ? src.worker : null;
  const verbosity2 = src.verbosity;
  const docBaseUrl = typeof src.docBaseUrl === "string" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;
  const cMapUrl = getFactoryUrlProp(src.cMapUrl);
  const cMapPacked = src.cMapPacked !== false;
  const CMapReaderFactory = src.CMapReaderFactory || (isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory);
  const iccUrl = getFactoryUrlProp(src.iccUrl);
  const standardFontDataUrl = getFactoryUrlProp(src.standardFontDataUrl);
  const StandardFontDataFactory = src.StandardFontDataFactory || (isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory);
  const wasmUrl = getFactoryUrlProp(src.wasmUrl);
  const WasmFactory = src.WasmFactory || (isNodeJS ? NodeWasmFactory : DOMWasmFactory);
  const ignoreErrors = src.stopAtErrors !== true;
  const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
  const isEvalSupported2 = src.isEvalSupported !== false;
  const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !isNodeJS;
  const isImageDecoderSupported = typeof src.isImageDecoderSupported === "boolean" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);
  const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
  const disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : isNodeJS;
  const fontExtraProperties = src.fontExtraProperties === true;
  const enableXfa = src.enableXfa === true;
  const ownerDocument = src.ownerDocument || globalThis.document;
  const disableRange = src.disableRange === true;
  const disableStream = src.disableStream === true;
  const disableAutoFetch = src.disableAutoFetch === true;
  const pdfBug = src.pdfBug === true;
  const CanvasFactory = src.CanvasFactory || (isNodeJS ? NodeCanvasFactory : DOMCanvasFactory);
  const FilterFactory = src.FilterFactory || (isNodeJS ? NodeFilterFactory : DOMFilterFactory);
  const enableHWA = src.enableHWA === true;
  const useWasm = src.useWasm !== false;
  const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;
  const useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !isNodeJS && !disableFontFace;
  const useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : !!(CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && WasmFactory === DOMWasmFactory && cMapUrl && standardFontDataUrl && wasmUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI) && isValidFetchUrl(wasmUrl, document.baseURI));
  const styleElement = null;
  setVerbosityLevel(verbosity2);
  const transportFactory = {
    canvasFactory: new CanvasFactory({
      ownerDocument,
      enableHWA
    }),
    filterFactory: new FilterFactory({
      docId,
      ownerDocument
    }),
    cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({
      baseUrl: cMapUrl,
      isCompressed: cMapPacked
    }),
    standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({
      baseUrl: standardFontDataUrl
    }),
    wasmFactory: useWorkerFetch ? null : new WasmFactory({
      baseUrl: wasmUrl
    })
  };
  if (!worker) {
    worker = PDFWorker.create({
      verbosity: verbosity2,
      port: GlobalWorkerOptions.workerPort
    });
    task._worker = worker;
  }
  const docParams = {
    docId,
    apiVersion: "5.4.296",
    data,
    password,
    disableAutoFetch,
    rangeChunkSize,
    length,
    docBaseUrl,
    enableXfa,
    evaluatorOptions: {
      maxImageSize,
      disableFontFace,
      ignoreErrors,
      isEvalSupported: isEvalSupported2,
      isOffscreenCanvasSupported,
      isImageDecoderSupported,
      canvasMaxAreaInBytes,
      fontExtraProperties,
      useSystemFonts,
      useWasm,
      useWorkerFetch,
      cMapUrl,
      iccUrl,
      standardFontDataUrl,
      wasmUrl
    }
  };
  const transportParams = {
    ownerDocument,
    pdfBug,
    styleElement,
    loadingParams: {
      disableAutoFetch,
      enableXfa
    }
  };
  worker.promise.then(function() {
    if (task.destroyed) {
      throw new Error("Loading aborted");
    }
    if (worker.destroyed) {
      throw new Error("Worker was destroyed");
    }
    const workerIdPromise = worker.messageHandler.sendWithPromise("GetDocRequest", docParams, data ? [data.buffer] : null);
    let networkStream;
    if (rangeTransport) {
      networkStream = new PDFDataTransportStream(rangeTransport, {
        disableRange,
        disableStream
      });
    } else if (!data) {
      if (!url) {
        throw new Error("getDocument - no `url` parameter provided.");
      }
      const NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : isNodeJS ? PDFNodeStream : PDFNetworkStream;
      networkStream = new NetworkStream({
        url,
        length,
        httpHeaders,
        withCredentials,
        rangeChunkSize,
        disableRange,
        disableStream
      });
    }
    return workerIdPromise.then((workerId) => {
      if (task.destroyed) {
        throw new Error("Loading aborted");
      }
      if (worker.destroyed) {
        throw new Error("Worker was destroyed");
      }
      const messageHandler = new MessageHandler(docId, workerId, worker.port);
      const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory, enableHWA);
      task._transport = transport;
      messageHandler.send("Ready", null);
    });
  }).catch(task._capability.reject);
  return task;
}
__name(getDocument, "getDocument");
var PDFDocumentLoadingTask = class _PDFDocumentLoadingTask {
  static {
    __name(this, "PDFDocumentLoadingTask");
  }
  static #docId = 0;
  _capability = Promise.withResolvers();
  _transport = null;
  _worker = null;
  docId = `d${_PDFDocumentLoadingTask.#docId++}`;
  destroyed = false;
  onPassword = null;
  onProgress = null;
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    this.destroyed = true;
    try {
      if (this._worker?.port) {
        this._worker._pendingDestroy = true;
      }
      await this._transport?.destroy();
    } catch (ex) {
      if (this._worker?.port) {
        delete this._worker._pendingDestroy;
      }
      throw ex;
    }
    this._transport = null;
    this._worker?.destroy();
    this._worker = null;
  }
  async getData() {
    return this._transport.getData();
  }
};
var PDFDataRangeTransport = class {
  static {
    __name(this, "PDFDataRangeTransport");
  }
  #capability = Promise.withResolvers();
  #progressiveDoneListeners = [];
  #progressiveReadListeners = [];
  #progressListeners = [];
  #rangeListeners = [];
  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
    this.length = length;
    this.initialData = initialData;
    this.progressiveDone = progressiveDone;
    this.contentDispositionFilename = contentDispositionFilename;
  }
  addRangeListener(listener) {
    this.#rangeListeners.push(listener);
  }
  addProgressListener(listener) {
    this.#progressListeners.push(listener);
  }
  addProgressiveReadListener(listener) {
    this.#progressiveReadListeners.push(listener);
  }
  addProgressiveDoneListener(listener) {
    this.#progressiveDoneListeners.push(listener);
  }
  onDataRange(begin, chunk) {
    for (const listener of this.#rangeListeners) {
      listener(begin, chunk);
    }
  }
  onDataProgress(loaded, total) {
    this.#capability.promise.then(() => {
      for (const listener of this.#progressListeners) {
        listener(loaded, total);
      }
    });
  }
  onDataProgressiveRead(chunk) {
    this.#capability.promise.then(() => {
      for (const listener of this.#progressiveReadListeners) {
        listener(chunk);
      }
    });
  }
  onDataProgressiveDone() {
    this.#capability.promise.then(() => {
      for (const listener of this.#progressiveDoneListeners) {
        listener();
      }
    });
  }
  transportReady() {
    this.#capability.resolve();
  }
  requestDataRange(begin, end) {
    unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {
  }
};
var PDFDocumentProxy = class {
  static {
    __name(this, "PDFDocumentProxy");
  }
  constructor(pdfInfo, transport) {
    this._pdfInfo = pdfInfo;
    this._transport = transport;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get canvasFactory() {
    return this._transport.canvasFactory;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(pageNumber) {
    return this._transport.getPage(pageNumber);
  }
  getPageIndex(ref) {
    return this._transport.getPageIndex(ref);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(id) {
    return this._transport.getDestination(id);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getAnnotationsByType(types, pageIndexesToSkip) {
    return this._transport.getAnnotationsByType(types, pageIndexesToSkip);
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({
    intent = "display"
  } = {}) {
    const {
      renderingIntent
    } = this._transport.getRenderingIntent(intent);
    return this._transport.getOptionalContentConfig(renderingIntent);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(keepLoadedFonts = false) {
    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(ref) {
    return this._transport.cachedPageNumber(ref);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
};
var PDFPageProxy = class {
  static {
    __name(this, "PDFPageProxy");
  }
  #pendingCleanup = false;
  constructor(pageIndex, pageInfo, transport, pdfBug = false) {
    this._pageIndex = pageIndex;
    this._pageInfo = pageInfo;
    this._transport = transport;
    this._stats = pdfBug ? new StatTimer() : null;
    this._pdfBug = pdfBug;
    this.commonObjs = transport.commonObjs;
    this.objs = new PDFObjects();
    this._intentStates = /* @__PURE__ */ new Map();
    this.destroyed = false;
    this.recordedBBoxes = null;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({
    scale,
    rotation = this.rotate,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  } = {}) {
    return new PageViewport({
      viewBox: this.view,
      userUnit: this.userUnit,
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }
  getAnnotations({
    intent = "display"
  } = {}) {
    const {
      renderingIntent
    } = this._transport.getRenderingIntent(intent);
    return this._transport.getAnnotations(this._pageIndex, renderingIntent);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    return this._transport._htmlForXfa?.children[this._pageIndex] || null;
  }
  render({
    canvasContext,
    canvas = canvasContext.canvas,
    viewport,
    intent = "display",
    annotationMode = AnnotationMode.ENABLE,
    transform = null,
    background = null,
    optionalContentConfigPromise = null,
    annotationCanvasMap = null,
    pageColors = null,
    printAnnotationStorage = null,
    isEditing = false,
    recordOperations = false,
    operationsFilter = null
  }) {
    this._stats?.time("Overall");
    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);
    const {
      renderingIntent,
      cacheKey
    } = intentArgs;
    this.#pendingCleanup = false;
    optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);
    let intentState = this._intentStates.get(cacheKey);
    if (!intentState) {
      intentState = /* @__PURE__ */ Object.create(null);
      this._intentStates.set(cacheKey, intentState);
    }
    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }
    const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
    if (!intentState.displayReadyCapability) {
      intentState.displayReadyCapability = Promise.withResolvers();
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };
      this._stats?.time("Page Request");
      this._pumpOperatorList(intentArgs);
    }
    const recordForDebugger = Boolean(this._pdfBug && globalThis.StepperManager?.enabled);
    const shouldRecordOperations = !this.recordedBBoxes && (recordOperations || recordForDebugger);
    const complete = /* @__PURE__ */ __name((error) => {
      intentState.renderTasks.delete(internalRenderTask);
      if (shouldRecordOperations) {
        const recordedBBoxes = internalRenderTask.gfx?.dependencyTracker.take();
        if (recordedBBoxes) {
          if (internalRenderTask.stepper) {
            internalRenderTask.stepper.setOperatorBBoxes(recordedBBoxes, internalRenderTask.gfx.dependencyTracker.takeDebugMetadata());
          }
          if (recordOperations) {
            this.recordedBBoxes = recordedBBoxes;
          }
        }
      }
      if (intentPrint) {
        this.#pendingCleanup = true;
      }
      this.#tryCleanup();
      if (error) {
        internalRenderTask.capability.reject(error);
        this._abortOperatorList({
          intentState,
          reason: error instanceof Error ? error : new Error(error)
        });
      } else {
        internalRenderTask.capability.resolve();
      }
      if (this._stats) {
        this._stats.timeEnd("Rendering");
        this._stats.timeEnd("Overall");
        if (globalThis.Stats?.enabled) {
          globalThis.Stats.add(this.pageNumber, this._stats);
        }
      }
    }, "complete");
    const internalRenderTask = new InternalRenderTask({
      callback: complete,
      params: {
        canvas,
        canvasContext,
        dependencyTracker: shouldRecordOperations ? new CanvasDependencyTracker(canvas, intentState.operatorList.length, recordForDebugger) : null,
        viewport,
        transform,
        background
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap,
      operatorList: intentState.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: this._transport.canvasFactory,
      filterFactory: this._transport.filterFactory,
      useRequestAnimationFrame: !intentPrint,
      pdfBug: this._pdfBug,
      pageColors,
      enableHWA: this._transport.enableHWA,
      operationsFilter
    });
    (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(internalRenderTask);
    const renderTask = internalRenderTask.task;
    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
      if (this.destroyed) {
        complete();
        return;
      }
      this._stats?.time("Rendering");
      if (!(optionalContentConfig.renderingIntent & renderingIntent)) {
        throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
      }
      internalRenderTask.initializeGraphics({
        transparency,
        optionalContentConfig
      });
      internalRenderTask.operatorListChanged();
    }).catch(complete);
    return renderTask;
  }
  getOperatorList({
    intent = "display",
    annotationMode = AnnotationMode.ENABLE,
    printAnnotationStorage = null,
    isEditing = false
  } = {}) {
    function operatorListChanged() {
      if (intentState.operatorList.lastChunk) {
        intentState.opListReadCapability.resolve(intentState.operatorList);
        intentState.renderTasks.delete(opListTask);
      }
    }
    __name(operatorListChanged, "operatorListChanged");
    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);
    let intentState = this._intentStates.get(intentArgs.cacheKey);
    if (!intentState) {
      intentState = /* @__PURE__ */ Object.create(null);
      this._intentStates.set(intentArgs.cacheKey, intentState);
    }
    let opListTask;
    if (!intentState.opListReadCapability) {
      opListTask = /* @__PURE__ */ Object.create(null);
      opListTask.operatorListChanged = operatorListChanged;
      intentState.opListReadCapability = Promise.withResolvers();
      (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(opListTask);
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };
      this._stats?.time("Page Request");
      this._pumpOperatorList(intentArgs);
    }
    return intentState.opListReadCapability.promise;
  }
  streamTextContent({
    includeMarkedContent = false,
    disableNormalization = false
  } = {}) {
    const TEXT_CONTENT_CHUNK_SIZE = 100;
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      includeMarkedContent: includeMarkedContent === true,
      disableNormalization: disableNormalization === true
    }, {
      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
      size(textContent) {
        return textContent.items.length;
      }
    });
  }
  getTextContent(params = {}) {
    if (this._transport._htmlForXfa) {
      return this.getXfa().then((xfa) => XfaText.textContent(xfa));
    }
    const readableStream = this.streamTextContent(params);
    return new Promise(function(resolve, reject) {
      function pump() {
        reader.read().then(function({
          value,
          done
        }) {
          if (done) {
            resolve(textContent);
            return;
          }
          textContent.lang ??= value.lang;
          Object.assign(textContent.styles, value.styles);
          textContent.items.push(...value.items);
          pump();
        }, reject);
      }
      __name(pump, "pump");
      const reader = readableStream.getReader();
      const textContent = {
        items: [],
        styles: /* @__PURE__ */ Object.create(null),
        lang: null
      };
      pump();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = true;
    const waitOn = [];
    for (const intentState of this._intentStates.values()) {
      this._abortOperatorList({
        intentState,
        reason: new Error("Page was destroyed."),
        force: true
      });
      if (intentState.opListReadCapability) {
        continue;
      }
      for (const internalRenderTask of intentState.renderTasks) {
        waitOn.push(internalRenderTask.completed);
        internalRenderTask.cancel();
      }
    }
    this.objs.clear();
    this.#pendingCleanup = false;
    return Promise.all(waitOn);
  }
  cleanup(resetStats = false) {
    this.#pendingCleanup = true;
    const success = this.#tryCleanup();
    if (resetStats && success) {
      this._stats &&= new StatTimer();
    }
    return success;
  }
  #tryCleanup() {
    if (!this.#pendingCleanup || this.destroyed) {
      return false;
    }
    for (const {
      renderTasks,
      operatorList
    } of this._intentStates.values()) {
      if (renderTasks.size > 0 || !operatorList.lastChunk) {
        return false;
      }
    }
    this._intentStates.clear();
    this.objs.clear();
    this.#pendingCleanup = false;
    return true;
  }
  _startRenderPage(transparency, cacheKey) {
    const intentState = this._intentStates.get(cacheKey);
    if (!intentState) {
      return;
    }
    this._stats?.timeEnd("Page Request");
    intentState.displayReadyCapability?.resolve(transparency);
  }
  _renderPageChunk(operatorListChunk, intentState) {
    for (let i18 = 0, ii = operatorListChunk.length; i18 < ii; i18++) {
      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i18]);
      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i18]);
    }
    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
    for (const internalRenderTask of intentState.renderTasks) {
      internalRenderTask.operatorListChanged();
    }
    if (operatorListChunk.lastChunk) {
      this.#tryCleanup();
    }
  }
  _pumpOperatorList({
    renderingIntent,
    cacheKey,
    annotationStorageSerializable,
    modifiedIds
  }) {
    const {
      map: map2,
      transfer
    } = annotationStorageSerializable;
    const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: renderingIntent,
      cacheKey,
      annotationStorage: map2,
      modifiedIds
    }, transfer);
    const reader = readableStream.getReader();
    const intentState = this._intentStates.get(cacheKey);
    intentState.streamReader = reader;
    const pump = /* @__PURE__ */ __name(() => {
      reader.read().then(({
        value,
        done
      }) => {
        if (done) {
          intentState.streamReader = null;
          return;
        }
        if (this._transport.destroyed) {
          return;
        }
        this._renderPageChunk(value, intentState);
        pump();
      }, (reason) => {
        intentState.streamReader = null;
        if (this._transport.destroyed) {
          return;
        }
        if (intentState.operatorList) {
          intentState.operatorList.lastChunk = true;
          for (const internalRenderTask of intentState.renderTasks) {
            internalRenderTask.operatorListChanged();
          }
          this.#tryCleanup();
        }
        if (intentState.displayReadyCapability) {
          intentState.displayReadyCapability.reject(reason);
        } else if (intentState.opListReadCapability) {
          intentState.opListReadCapability.reject(reason);
        } else {
          throw reason;
        }
      });
    }, "pump");
    pump();
  }
  _abortOperatorList({
    intentState,
    reason,
    force = false
  }) {
    if (!intentState.streamReader) {
      return;
    }
    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }
    if (!force) {
      if (intentState.renderTasks.size > 0) {
        return;
      }
      if (reason instanceof RenderingCancelledException) {
        let delay = RENDERING_CANCELLED_TIMEOUT;
        if (reason.extraDelay > 0 && reason.extraDelay < 1e3) {
          delay += reason.extraDelay;
        }
        intentState.streamReaderCancelTimeout = setTimeout(() => {
          intentState.streamReaderCancelTimeout = null;
          this._abortOperatorList({
            intentState,
            reason,
            force: true
          });
        }, delay);
        return;
      }
    }
    intentState.streamReader.cancel(new AbortException(reason.message)).catch(() => {
    });
    intentState.streamReader = null;
    if (this._transport.destroyed) {
      return;
    }
    for (const [curCacheKey, curIntentState] of this._intentStates) {
      if (curIntentState === intentState) {
        this._intentStates.delete(curCacheKey);
        break;
      }
    }
    this.cleanup();
  }
  get stats() {
    return this._stats;
  }
};
var PDFWorker = class _PDFWorker {
  static {
    __name(this, "PDFWorker");
  }
  #capability = Promise.withResolvers();
  #messageHandler = null;
  #port = null;
  #webWorker = null;
  static #fakeWorkerId = 0;
  static #isWorkerDisabled = false;
  static #workerPorts = /* @__PURE__ */ new WeakMap();
  static {
    if (isNodeJS) {
      this.#isWorkerDisabled = true;
      GlobalWorkerOptions.workerSrc ||= "./pdf.worker.mjs";
    }
    this._isSameOrigin = (baseUrl, otherUrl) => {
      const base = URL.parse(baseUrl);
      if (!base?.origin || base.origin === "null") {
        return false;
      }
      const other = new URL(otherUrl, base);
      return base.origin === other.origin;
    };
    this._createCDNWrapper = (url) => {
      const wrapper = `await import("${url}");`;
      return URL.createObjectURL(new Blob([wrapper], {
        type: "text/javascript"
      }));
    };
    this.fromPort = (params) => {
      deprecated("`PDFWorker.fromPort` - please use `PDFWorker.create` instead.");
      if (!params?.port) {
        throw new Error("PDFWorker.fromPort - invalid method signature.");
      }
      return this.create(params);
    };
  }
  constructor({
    name: name4 = null,
    port: port2 = null,
    verbosity: verbosity2 = getVerbosityLevel()
  } = {}) {
    this.name = name4;
    this.destroyed = false;
    this.verbosity = verbosity2;
    if (port2) {
      if (_PDFWorker.#workerPorts.has(port2)) {
        throw new Error("Cannot use more than one PDFWorker per port.");
      }
      _PDFWorker.#workerPorts.set(port2, this);
      this.#initializeFromPort(port2);
    } else {
      this.#initialize();
    }
  }
  get promise() {
    return this.#capability.promise;
  }
  #resolve() {
    this.#capability.resolve();
    this.#messageHandler.send("configure", {
      verbosity: this.verbosity
    });
  }
  get port() {
    return this.#port;
  }
  get messageHandler() {
    return this.#messageHandler;
  }
  #initializeFromPort(port2) {
    this.#port = port2;
    this.#messageHandler = new MessageHandler("main", "worker", port2);
    this.#messageHandler.on("ready", () => {
    });
    this.#resolve();
  }
  #initialize() {
    if (_PDFWorker.#isWorkerDisabled || _PDFWorker.#mainThreadWorkerMessageHandler) {
      this.#setupFakeWorker();
      return;
    }
    let {
      workerSrc
    } = _PDFWorker;
    try {
      if (!_PDFWorker._isSameOrigin(window.location, workerSrc)) {
        workerSrc = _PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);
      }
      const worker = new Worker(workerSrc, {
        type: "module"
      });
      const messageHandler = new MessageHandler("main", "worker", worker);
      const terminateEarly = /* @__PURE__ */ __name(() => {
        ac.abort();
        messageHandler.destroy();
        worker.terminate();
        if (this.destroyed) {
          this.#capability.reject(new Error("Worker was destroyed"));
        } else {
          this.#setupFakeWorker();
        }
      }, "terminateEarly");
      const ac = new AbortController();
      worker.addEventListener("error", () => {
        if (!this.#webWorker) {
          terminateEarly();
        }
      }, {
        signal: ac.signal
      });
      messageHandler.on("test", (data) => {
        ac.abort();
        if (this.destroyed || !data) {
          terminateEarly();
          return;
        }
        this.#messageHandler = messageHandler;
        this.#port = worker;
        this.#webWorker = worker;
        this.#resolve();
      });
      messageHandler.on("ready", (data) => {
        ac.abort();
        if (this.destroyed) {
          terminateEarly();
          return;
        }
        try {
          sendTest();
        } catch {
          this.#setupFakeWorker();
        }
      });
      const sendTest = /* @__PURE__ */ __name(() => {
        const testObj = new Uint8Array();
        messageHandler.send("test", testObj, [testObj.buffer]);
      }, "sendTest");
      sendTest();
      return;
    } catch {
      info("The worker has been disabled.");
    }
    this.#setupFakeWorker();
  }
  #setupFakeWorker() {
    if (!_PDFWorker.#isWorkerDisabled) {
      warn("Setting up fake worker.");
      _PDFWorker.#isWorkerDisabled = true;
    }
    _PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler) => {
      if (this.destroyed) {
        this.#capability.reject(new Error("Worker was destroyed"));
        return;
      }
      const port2 = new LoopbackPort();
      this.#port = port2;
      const id = `fake${_PDFWorker.#fakeWorkerId++}`;
      const workerHandler = new MessageHandler(id + "_worker", id, port2);
      WorkerMessageHandler.setup(workerHandler, port2);
      this.#messageHandler = new MessageHandler(id, id + "_worker", port2);
      this.#resolve();
    }).catch((reason) => {
      this.#capability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
    });
  }
  destroy() {
    this.destroyed = true;
    this.#webWorker?.terminate();
    this.#webWorker = null;
    _PDFWorker.#workerPorts.delete(this.#port);
    this.#port = null;
    this.#messageHandler?.destroy();
    this.#messageHandler = null;
  }
  static create(params) {
    const cachedPort = this.#workerPorts.get(params?.port);
    if (cachedPort) {
      if (cachedPort._pendingDestroy) {
        throw new Error("PDFWorker.create - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      }
      return cachedPort;
    }
    return new _PDFWorker(params);
  }
  static get workerSrc() {
    if (GlobalWorkerOptions.workerSrc) {
      return GlobalWorkerOptions.workerSrc;
    }
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get #mainThreadWorkerMessageHandler() {
    try {
      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
    } catch {
      return null;
    }
  }
  static get _setupFakeWorkerGlobal() {
    const loader = /* @__PURE__ */ __name(async () => {
      if (this.#mainThreadWorkerMessageHandler) {
        return this.#mainThreadWorkerMessageHandler;
      }
      const worker = await import(
        /*webpackIgnore: true*/
        /*@vite-ignore*/
        this.workerSrc
      );
      return worker.WorkerMessageHandler;
    }, "loader");
    return shadow(this, "_setupFakeWorkerGlobal", loader());
  }
};
var WorkerTransport = class {
  static {
    __name(this, "WorkerTransport");
  }
  #methodPromises = /* @__PURE__ */ new Map();
  #pageCache = /* @__PURE__ */ new Map();
  #pagePromises = /* @__PURE__ */ new Map();
  #pageRefCache = /* @__PURE__ */ new Map();
  #passwordCapability = null;
  constructor(messageHandler, loadingTask, networkStream, params, factory, enableHWA) {
    this.messageHandler = messageHandler;
    this.loadingTask = loadingTask;
    this.commonObjs = new PDFObjects();
    this.fontLoader = new FontLoader({
      ownerDocument: params.ownerDocument,
      styleElement: params.styleElement
    });
    this.loadingParams = params.loadingParams;
    this._params = params;
    this.canvasFactory = factory.canvasFactory;
    this.filterFactory = factory.filterFactory;
    this.cMapReaderFactory = factory.cMapReaderFactory;
    this.standardFontDataFactory = factory.standardFontDataFactory;
    this.wasmFactory = factory.wasmFactory;
    this.destroyed = false;
    this.destroyCapability = null;
    this._networkStream = networkStream;
    this._fullReader = null;
    this._lastProgress = null;
    this.downloadInfoCapability = Promise.withResolvers();
    this.enableHWA = enableHWA;
    this.setupMessageHandler();
  }
  #cacheSimpleMethod(name4, data = null) {
    const cachedPromise = this.#methodPromises.get(name4);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise(name4, data);
    this.#methodPromises.set(name4, promise);
    return promise;
  }
  get annotationStorage() {
    return shadow(this, "annotationStorage", new AnnotationStorage());
  }
  getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {
    let renderingIntent = RenderingIntentFlag.DISPLAY;
    let annotationStorageSerializable = SerializableEmpty;
    switch (intent) {
      case "any":
        renderingIntent = RenderingIntentFlag.ANY;
        break;
      case "display":
        break;
      case "print":
        renderingIntent = RenderingIntentFlag.PRINT;
        break;
      default:
        warn(`getRenderingIntent - invalid intent: ${intent}`);
    }
    const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
    switch (annotationMode) {
      case AnnotationMode.DISABLE:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;
        break;
      case AnnotationMode.ENABLE:
        break;
      case AnnotationMode.ENABLE_FORMS:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;
        break;
      case AnnotationMode.ENABLE_STORAGE:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;
        annotationStorageSerializable = annotationStorage.serializable;
        break;
      default:
        warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
    }
    if (isEditing) {
      renderingIntent += RenderingIntentFlag.IS_EDITING;
    }
    if (isOpList) {
      renderingIntent += RenderingIntentFlag.OPLIST;
    }
    const {
      ids: modifiedIds,
      hash: modifiedIdsHash
    } = annotationStorage.modifiedIds;
    const cacheKeyBuf = [renderingIntent, annotationStorageSerializable.hash, modifiedIdsHash];
    return {
      renderingIntent,
      cacheKey: cacheKeyBuf.join("_"),
      annotationStorageSerializable,
      modifiedIds
    };
  }
  destroy() {
    if (this.destroyCapability) {
      return this.destroyCapability.promise;
    }
    this.destroyed = true;
    this.destroyCapability = Promise.withResolvers();
    this.#passwordCapability?.reject(new Error("Worker was destroyed during onPassword callback"));
    const waitOn = [];
    for (const page of this.#pageCache.values()) {
      waitOn.push(page._destroy());
    }
    this.#pageCache.clear();
    this.#pagePromises.clear();
    this.#pageRefCache.clear();
    if (this.hasOwnProperty("annotationStorage")) {
      this.annotationStorage.resetModified();
    }
    const terminated = this.messageHandler.sendWithPromise("Terminate", null);
    waitOn.push(terminated);
    Promise.all(waitOn).then(() => {
      this.commonObjs.clear();
      this.fontLoader.clear();
      this.#methodPromises.clear();
      this.filterFactory.destroy();
      TextLayer.cleanup();
      this._networkStream?.cancelAllRequests(new AbortException("Worker was terminated."));
      this.messageHandler?.destroy();
      this.messageHandler = null;
      this.destroyCapability.resolve();
    }, this.destroyCapability.reject);
    return this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const {
      messageHandler,
      loadingTask
    } = this;
    messageHandler.on("GetReader", (data, sink) => {
      assert2(this._networkStream, "GetReader - no `IPDFStream` instance available.");
      this._fullReader = this._networkStream.getFullReader();
      this._fullReader.onProgress = (evt) => {
        this._lastProgress = {
          loaded: evt.loaded,
          total: evt.total
        };
      };
      sink.onPull = () => {
        this._fullReader.read().then(function({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }
          assert2(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch((reason) => {
          sink.error(reason);
        });
      };
      sink.onCancel = (reason) => {
        this._fullReader.cancel(reason);
        sink.ready.catch((readyReason) => {
          if (this.destroyed) {
            return;
          }
          throw readyReason;
        });
      };
    });
    messageHandler.on("ReaderHeadersReady", async (data) => {
      await this._fullReader.headersReady;
      const {
        isStreamingSupported,
        isRangeSupported,
        contentLength
      } = this._fullReader;
      if (!isStreamingSupported || !isRangeSupported) {
        if (this._lastProgress) {
          loadingTask.onProgress?.(this._lastProgress);
        }
        this._fullReader.onProgress = (evt) => {
          loadingTask.onProgress?.({
            loaded: evt.loaded,
            total: evt.total
          });
        };
      }
      return {
        isStreamingSupported,
        isRangeSupported,
        contentLength
      };
    });
    messageHandler.on("GetRangeReader", (data, sink) => {
      assert2(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
      if (!rangeReader) {
        sink.close();
        return;
      }
      sink.onPull = () => {
        rangeReader.read().then(function({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }
          assert2(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch((reason) => {
          sink.error(reason);
        });
      };
      sink.onCancel = (reason) => {
        rangeReader.cancel(reason);
        sink.ready.catch((readyReason) => {
          if (this.destroyed) {
            return;
          }
          throw readyReason;
        });
      };
    });
    messageHandler.on("GetDoc", ({
      pdfInfo
    }) => {
      this._numPages = pdfInfo.numPages;
      this._htmlForXfa = pdfInfo.htmlForXfa;
      delete pdfInfo.htmlForXfa;
      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
    });
    messageHandler.on("DocException", (ex) => {
      loadingTask._capability.reject(wrapReason(ex));
    });
    messageHandler.on("PasswordRequest", (ex) => {
      this.#passwordCapability = Promise.withResolvers();
      try {
        if (!loadingTask.onPassword) {
          throw wrapReason(ex);
        }
        const updatePassword2 = /* @__PURE__ */ __name((password) => {
          if (password instanceof Error) {
            this.#passwordCapability.reject(password);
          } else {
            this.#passwordCapability.resolve({
              password
            });
          }
        }, "updatePassword");
        loadingTask.onPassword(updatePassword2, ex.code);
      } catch (err) {
        this.#passwordCapability.reject(err);
      }
      return this.#passwordCapability.promise;
    });
    messageHandler.on("DataLoaded", (data) => {
      loadingTask.onProgress?.({
        loaded: data.length,
        total: data.length
      });
      this.downloadInfoCapability.resolve(data);
    });
    messageHandler.on("StartRenderPage", (data) => {
      if (this.destroyed) {
        return;
      }
      const page = this.#pageCache.get(data.pageIndex);
      page._startRenderPage(data.transparency, data.cacheKey);
    });
    messageHandler.on("commonobj", ([id, type, exportedData]) => {
      if (this.destroyed) {
        return null;
      }
      if (this.commonObjs.has(id)) {
        return null;
      }
      switch (type) {
        case "Font":
          if ("error" in exportedData) {
            const exportedError = exportedData.error;
            warn(`Error during font loading: ${exportedError}`);
            this.commonObjs.resolve(id, exportedError);
            break;
          }
          const fontData = new FontInfo(exportedData);
          const inspectFont = this._params.pdfBug && globalThis.FontInspector?.enabled ? (font2, url) => globalThis.FontInspector.fontAdded(font2, url) : null;
          const font = new FontFaceObject(fontData, inspectFont, exportedData.extra, exportedData.charProcOperatorList);
          this.fontLoader.bind(font).catch(() => messageHandler.sendWithPromise("FontFallback", {
            id
          })).finally(() => {
            if (!font.fontExtraProperties && font.data) {
              font.clearData();
            }
            this.commonObjs.resolve(id, font);
          });
          break;
        case "CopyLocalImage":
          const {
            imageRef
          } = exportedData;
          assert2(imageRef, "The imageRef must be defined.");
          for (const pageProxy of this.#pageCache.values()) {
            for (const [, data] of pageProxy.objs) {
              if (data?.ref !== imageRef) {
                continue;
              }
              if (!data.dataLen) {
                return null;
              }
              this.commonObjs.resolve(id, structuredClone(data));
              return data.dataLen;
            }
          }
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(id, exportedData);
          break;
        default:
          throw new Error(`Got unknown common object type ${type}`);
      }
      return null;
    });
    messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
      if (this.destroyed) {
        return;
      }
      const pageProxy = this.#pageCache.get(pageIndex);
      if (pageProxy.objs.has(id)) {
        return;
      }
      if (pageProxy._intentStates.size === 0) {
        imageData?.bitmap?.close();
        return;
      }
      switch (type) {
        case "Image":
        case "Pattern":
          pageProxy.objs.resolve(id, imageData);
          break;
        default:
          throw new Error(`Got unknown object type ${type}`);
      }
    });
    messageHandler.on("DocProgress", (data) => {
      if (this.destroyed) {
        return;
      }
      loadingTask.onProgress?.({
        loaded: data.loaded,
        total: data.total
      });
    });
    messageHandler.on("FetchBinaryData", async (data) => {
      if (this.destroyed) {
        throw new Error("Worker was destroyed.");
      }
      const factory = this[data.type];
      if (!factory) {
        throw new Error(`${data.type} not initialized, see the \`useWorkerFetch\` parameter.`);
      }
      return factory.fetch(data);
    });
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    if (this.annotationStorage.size <= 0) {
      warn("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
    }
    const {
      map: map2,
      transfer
    } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: map2,
      filename: this._fullReader?.filename ?? null
    }, transfer).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(pageNumber) {
    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
      return Promise.reject(new Error("Invalid page request."));
    }
    const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex
    }).then((pageInfo) => {
      if (this.destroyed) {
        throw new Error("Transport destroyed");
      }
      if (pageInfo.refStr) {
        this.#pageRefCache.set(pageInfo.refStr, pageNumber);
      }
      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
      this.#pageCache.set(pageIndex, page);
      return page;
    });
    this.#pagePromises.set(pageIndex, promise);
    return promise;
  }
  getPageIndex(ref) {
    if (!isRefProxy(ref)) {
      return Promise.reject(new Error("Invalid pageIndex request."));
    }
    return this.messageHandler.sendWithPromise("GetPageIndex", {
      num: ref.num,
      gen: ref.gen
    });
  }
  getAnnotations(pageIndex, intent) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex,
      intent
    });
  }
  getFieldObjects() {
    return this.#cacheSimpleMethod("GetFieldObjects");
  }
  hasJSActions() {
    return this.#cacheSimpleMethod("HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(id) {
    if (typeof id !== "string") {
      return Promise.reject(new Error("Invalid destination request."));
    }
    return this.messageHandler.sendWithPromise("GetDestination", {
      id
    });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getAnnotationsByType(types, pageIndexesToSkip) {
    return this.messageHandler.sendWithPromise("GetAnnotationsByType", {
      types,
      pageIndexesToSkip
    });
  }
  getDocJSActions() {
    return this.#cacheSimpleMethod("GetDocJSActions");
  }
  getPageJSActions(pageIndex) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex
    });
  }
  getStructTree(pageIndex) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex
    });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(renderingIntent) {
    return this.#cacheSimpleMethod("GetOptionalContentConfig").then((data) => new OptionalContentConfig(data, renderingIntent));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const name4 = "GetMetadata", cachedPromise = this.#methodPromises.get(name4);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise(name4, null).then((results) => ({
      info: results[0],
      metadata: results[1] ? new Metadata(results[1]) : null,
      contentDispositionFilename: this._fullReader?.filename ?? null,
      contentLength: this._fullReader?.contentLength ?? null
    }));
    this.#methodPromises.set(name4, promise);
    return promise;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(keepLoadedFonts = false) {
    if (this.destroyed) {
      return;
    }
    await this.messageHandler.sendWithPromise("Cleanup", null);
    for (const page of this.#pageCache.values()) {
      const cleanupSuccessful = page.cleanup();
      if (!cleanupSuccessful) {
        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
      }
    }
    this.commonObjs.clear();
    if (!keepLoadedFonts) {
      this.fontLoader.clear();
    }
    this.#methodPromises.clear();
    this.filterFactory.destroy(true);
    TextLayer.cleanup();
  }
  cachedPageNumber(ref) {
    if (!isRefProxy(ref)) {
      return null;
    }
    const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;
    return this.#pageRefCache.get(refStr) ?? null;
  }
};
var RenderTask = class {
  static {
    __name(this, "RenderTask");
  }
  #internalRenderTask = null;
  onContinue = null;
  onError = null;
  constructor(internalRenderTask) {
    this.#internalRenderTask = internalRenderTask;
  }
  get promise() {
    return this.#internalRenderTask.capability.promise;
  }
  cancel(extraDelay = 0) {
    this.#internalRenderTask.cancel(null, extraDelay);
  }
  get separateAnnots() {
    const {
      separateAnnots
    } = this.#internalRenderTask.operatorList;
    if (!separateAnnots) {
      return false;
    }
    const {
      annotationCanvasMap
    } = this.#internalRenderTask;
    return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;
  }
};
var InternalRenderTask = class _InternalRenderTask {
  static {
    __name(this, "InternalRenderTask");
  }
  #rAF = null;
  static #canvasInUse = /* @__PURE__ */ new WeakSet();
  constructor({
    callback,
    params,
    objs,
    commonObjs,
    annotationCanvasMap,
    operatorList,
    pageIndex,
    canvasFactory,
    filterFactory,
    useRequestAnimationFrame = false,
    pdfBug = false,
    pageColors = null,
    enableHWA = false,
    operationsFilter = null
  }) {
    this.callback = callback;
    this.params = params;
    this.objs = objs;
    this.commonObjs = commonObjs;
    this.annotationCanvasMap = annotationCanvasMap;
    this.operatorListIdx = null;
    this.operatorList = operatorList;
    this._pageIndex = pageIndex;
    this.canvasFactory = canvasFactory;
    this.filterFactory = filterFactory;
    this._pdfBug = pdfBug;
    this.pageColors = pageColors;
    this.running = false;
    this.graphicsReadyCallback = null;
    this.graphicsReady = false;
    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
    this.cancelled = false;
    this.capability = Promise.withResolvers();
    this.task = new RenderTask(this);
    this._cancelBound = this.cancel.bind(this);
    this._continueBound = this._continue.bind(this);
    this._scheduleNextBound = this._scheduleNext.bind(this);
    this._nextBound = this._next.bind(this);
    this._canvas = params.canvas;
    this._canvasContext = params.canvas ? null : params.canvasContext;
    this._enableHWA = enableHWA;
    this._dependencyTracker = params.dependencyTracker;
    this._operationsFilter = operationsFilter;
  }
  get completed() {
    return this.capability.promise.catch(function() {
    });
  }
  initializeGraphics({
    transparency = false,
    optionalContentConfig
  }) {
    if (this.cancelled) {
      return;
    }
    if (this._canvas) {
      if (_InternalRenderTask.#canvasInUse.has(this._canvas)) {
        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
      }
      _InternalRenderTask.#canvasInUse.add(this._canvas);
    }
    if (this._pdfBug && globalThis.StepperManager?.enabled) {
      this.stepper = globalThis.StepperManager.create(this._pageIndex);
      this.stepper.init(this.operatorList);
      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
    }
    const {
      viewport,
      transform,
      background,
      dependencyTracker
    } = this.params;
    const canvasContext = this._canvasContext || this._canvas.getContext("2d", {
      alpha: false,
      willReadFrequently: !this._enableHWA
    });
    this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
      optionalContentConfig
    }, this.annotationCanvasMap, this.pageColors, dependencyTracker);
    this.gfx.beginDrawing({
      transform,
      viewport,
      transparency,
      background
    });
    this.operatorListIdx = 0;
    this.graphicsReady = true;
    this.graphicsReadyCallback?.();
  }
  cancel(error = null, extraDelay = 0) {
    this.running = false;
    this.cancelled = true;
    this.gfx?.endDrawing();
    if (this.#rAF) {
      window.cancelAnimationFrame(this.#rAF);
      this.#rAF = null;
    }
    _InternalRenderTask.#canvasInUse.delete(this._canvas);
    error ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay);
    this.callback(error);
    this.task.onError?.(error);
  }
  operatorListChanged() {
    if (!this.graphicsReady) {
      this.graphicsReadyCallback ||= this._continueBound;
      return;
    }
    this.gfx.dependencyTracker?.growOperationsCount(this.operatorList.fnArray.length);
    this.stepper?.updateOperatorList(this.operatorList);
    if (this.running) {
      return;
    }
    this._continue();
  }
  _continue() {
    this.running = true;
    if (this.cancelled) {
      return;
    }
    if (this.task.onContinue) {
      this.task.onContinue(this._scheduleNextBound);
    } else {
      this._scheduleNext();
    }
  }
  _scheduleNext() {
    if (this._useRequestAnimationFrame) {
      this.#rAF = window.requestAnimationFrame(() => {
        this.#rAF = null;
        this._nextBound().catch(this._cancelBound);
      });
    } else {
      Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
  }
  async _next() {
    if (this.cancelled) {
      return;
    }
    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._operationsFilter);
    if (this.operatorListIdx === this.operatorList.argsArray.length) {
      this.running = false;
      if (this.operatorList.lastChunk) {
        this.gfx.endDrawing();
        _InternalRenderTask.#canvasInUse.delete(this._canvas);
        this.callback();
      }
    }
  }
};
var version5 = "5.4.296";
var build = "f56dc8601";
;
var ColorPicker = class _ColorPicker {
  static {
    __name(this, "ColorPicker");
  }
  #button = null;
  #buttonSwatch = null;
  #defaultColor;
  #dropdown = null;
  #dropdownWasFromKeyboard = false;
  #isMainColorPicker = false;
  #editor = null;
  #eventBus;
  #openDropdownAC = null;
  #uiManager = null;
  static #l10nColor = null;
  static get _keyboardManager() {
    return shadow(this, "_keyboardManager", new KeyboardManager([[["Escape", "mac+Escape"], _ColorPicker.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], _ColorPicker.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], _ColorPicker.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], _ColorPicker.prototype._moveToPrevious], [["Home", "mac+Home"], _ColorPicker.prototype._moveToBeginning], [["End", "mac+End"], _ColorPicker.prototype._moveToEnd]]));
  }
  constructor({
    editor = null,
    uiManager = null
  }) {
    if (editor) {
      this.#isMainColorPicker = false;
      this.#editor = editor;
    } else {
      this.#isMainColorPicker = true;
    }
    this.#uiManager = editor?._uiManager || uiManager;
    this.#eventBus = this.#uiManager._eventBus;
    this.#defaultColor = editor?.color?.toUpperCase() || this.#uiManager?.highlightColors.values().next().value || "#FFFF98";
    _ColorPicker.#l10nColor ||= Object.freeze({
      blue: "pdfjs-editor-colorpicker-blue",
      green: "pdfjs-editor-colorpicker-green",
      pink: "pdfjs-editor-colorpicker-pink",
      red: "pdfjs-editor-colorpicker-red",
      yellow: "pdfjs-editor-colorpicker-yellow"
    });
  }
  renderButton() {
    const button = this.#button = document.createElement("button");
    button.className = "colorPicker";
    button.tabIndex = "0";
    button.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button");
    button.ariaHasPopup = "true";
    if (this.#editor) {
      button.ariaControls = `${this.#editor.id}_colorpicker_dropdown`;
    }
    const signal = this.#uiManager._signal;
    button.addEventListener("click", this.#openDropdown.bind(this), {
      signal
    });
    button.addEventListener("keydown", this.#keyDown.bind(this), {
      signal
    });
    const swatch = this.#buttonSwatch = document.createElement("span");
    swatch.className = "swatch";
    swatch.ariaHidden = "true";
    swatch.style.backgroundColor = this.#defaultColor;
    button.append(swatch);
    return button;
  }
  renderMainDropdown() {
    const dropdown = this.#dropdown = this.#getDropdownRoot();
    dropdown.ariaOrientation = "horizontal";
    dropdown.ariaLabelledBy = "highlightColorPickerLabel";
    return dropdown;
  }
  #getDropdownRoot() {
    const div = document.createElement("div");
    const signal = this.#uiManager._signal;
    div.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    div.className = "dropdown";
    div.role = "listbox";
    div.ariaMultiSelectable = "false";
    div.ariaOrientation = "vertical";
    div.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
    if (this.#editor) {
      div.id = `${this.#editor.id}_colorpicker_dropdown`;
    }
    for (const [name4, color] of this.#uiManager.highlightColors) {
      const button = document.createElement("button");
      button.tabIndex = "0";
      button.role = "option";
      button.setAttribute("data-color", color);
      button.title = name4;
      button.setAttribute("data-l10n-id", _ColorPicker.#l10nColor[name4]);
      const swatch = document.createElement("span");
      button.append(swatch);
      swatch.className = "swatch";
      swatch.style.backgroundColor = color;
      button.ariaSelected = color === this.#defaultColor;
      button.addEventListener("click", this.#colorSelect.bind(this, color), {
        signal
      });
      div.append(button);
    }
    div.addEventListener("keydown", this.#keyDown.bind(this), {
      signal
    });
    return div;
  }
  #colorSelect(color, event) {
    event.stopPropagation();
    this.#eventBus.dispatch("switchannotationeditorparams", {
      source: this,
      type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
      value: color
    });
    this.updateColor(color);
  }
  _colorSelectFromKeyboard(event) {
    if (event.target === this.#button) {
      this.#openDropdown(event);
      return;
    }
    const color = event.target.getAttribute("data-color");
    if (!color) {
      return;
    }
    this.#colorSelect(color, event);
  }
  _moveToNext(event) {
    if (!this.#isDropdownVisible) {
      this.#openDropdown(event);
      return;
    }
    if (event.target === this.#button) {
      this.#dropdown.firstChild?.focus();
      return;
    }
    event.target.nextSibling?.focus();
  }
  _moveToPrevious(event) {
    if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {
      if (this.#isDropdownVisible) {
        this._hideDropdownFromKeyboard();
      }
      return;
    }
    if (!this.#isDropdownVisible) {
      this.#openDropdown(event);
    }
    event.target.previousSibling?.focus();
  }
  _moveToBeginning(event) {
    if (!this.#isDropdownVisible) {
      this.#openDropdown(event);
      return;
    }
    this.#dropdown.firstChild?.focus();
  }
  _moveToEnd(event) {
    if (!this.#isDropdownVisible) {
      this.#openDropdown(event);
      return;
    }
    this.#dropdown.lastChild?.focus();
  }
  #keyDown(event) {
    _ColorPicker._keyboardManager.exec(this, event);
  }
  #openDropdown(event) {
    if (this.#isDropdownVisible) {
      this.hideDropdown();
      return;
    }
    this.#dropdownWasFromKeyboard = event.detail === 0;
    if (!this.#openDropdownAC) {
      this.#openDropdownAC = new AbortController();
      window.addEventListener("pointerdown", this.#pointerDown.bind(this), {
        signal: this.#uiManager.combinedSignal(this.#openDropdownAC)
      });
    }
    this.#button.ariaExpanded = "true";
    if (this.#dropdown) {
      this.#dropdown.classList.remove("hidden");
      return;
    }
    const root = this.#dropdown = this.#getDropdownRoot();
    this.#button.append(root);
  }
  #pointerDown(event) {
    if (this.#dropdown?.contains(event.target)) {
      return;
    }
    this.hideDropdown();
  }
  hideDropdown() {
    this.#dropdown?.classList.add("hidden");
    this.#button.ariaExpanded = "false";
    this.#openDropdownAC?.abort();
    this.#openDropdownAC = null;
  }
  get #isDropdownVisible() {
    return this.#dropdown && !this.#dropdown.classList.contains("hidden");
  }
  _hideDropdownFromKeyboard() {
    if (this.#isMainColorPicker) {
      return;
    }
    if (!this.#isDropdownVisible) {
      this.#editor?.unselect();
      return;
    }
    this.hideDropdown();
    this.#button.focus({
      preventScroll: true,
      focusVisible: this.#dropdownWasFromKeyboard
    });
  }
  updateColor(color) {
    if (this.#buttonSwatch) {
      this.#buttonSwatch.style.backgroundColor = color;
    }
    if (!this.#dropdown) {
      return;
    }
    const i18 = this.#uiManager.highlightColors.values();
    for (const child of this.#dropdown.children) {
      child.ariaSelected = i18.next().value === color.toUpperCase();
    }
  }
  destroy() {
    this.#button?.remove();
    this.#button = null;
    this.#buttonSwatch = null;
    this.#dropdown?.remove();
    this.#dropdown = null;
  }
};
var BasicColorPicker = class _BasicColorPicker {
  static {
    __name(this, "BasicColorPicker");
  }
  #input = null;
  #editor = null;
  #uiManager = null;
  static #l10nColor = null;
  constructor(editor) {
    this.#editor = editor;
    this.#uiManager = editor._uiManager;
    _BasicColorPicker.#l10nColor ||= Object.freeze({
      freetext: "pdfjs-editor-color-picker-free-text-input",
      ink: "pdfjs-editor-color-picker-ink-input"
    });
  }
  renderButton() {
    if (this.#input) {
      return this.#input;
    }
    const {
      editorType,
      colorType,
      colorValue
    } = this.#editor;
    const input = this.#input = document.createElement("input");
    input.type = "color";
    input.value = colorValue || "#000000";
    input.className = "basicColorPicker";
    input.tabIndex = 0;
    input.setAttribute("data-l10n-id", _BasicColorPicker.#l10nColor[editorType]);
    input.addEventListener("input", () => {
      this.#uiManager.updateParams(colorType, input.value);
    }, {
      signal: this.#uiManager._signal
    });
    return input;
  }
  update(value) {
    if (!this.#input) {
      return;
    }
    this.#input.value = value;
  }
  destroy() {
    this.#input?.remove();
    this.#input = null;
  }
  hideDropdown() {
  }
};
;
function makeColorComp(n11) {
  return Math.floor(Math.max(0, Math.min(1, n11)) * 255).toString(16).padStart(2, "0");
}
__name(makeColorComp, "makeColorComp");
function scaleAndClamp(x3) {
  return Math.max(0, Math.min(255, 255 * x3));
}
__name(scaleAndClamp, "scaleAndClamp");
var ColorConverters = class {
  static {
    __name(this, "ColorConverters");
  }
  static CMYK_G([c21, y12, m18, k5]) {
    return ["G", 1 - Math.min(1, 0.3 * c21 + 0.59 * m18 + 0.11 * y12 + k5)];
  }
  static G_CMYK([g10]) {
    return ["CMYK", 0, 0, 0, 1 - g10];
  }
  static G_RGB([g10]) {
    return ["RGB", g10, g10, g10];
  }
  static G_rgb([g10]) {
    g10 = scaleAndClamp(g10);
    return [g10, g10, g10];
  }
  static G_HTML([g10]) {
    const G = makeColorComp(g10);
    return `#${G}${G}${G}`;
  }
  static RGB_G([r9, g10, b7]) {
    return ["G", 0.3 * r9 + 0.59 * g10 + 0.11 * b7];
  }
  static RGB_rgb(color) {
    return color.map(scaleAndClamp);
  }
  static RGB_HTML(color) {
    return `#${color.map(makeColorComp).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([c21, y12, m18, k5]) {
    return ["RGB", 1 - Math.min(1, c21 + k5), 1 - Math.min(1, m18 + k5), 1 - Math.min(1, y12 + k5)];
  }
  static CMYK_rgb([c21, y12, m18, k5]) {
    return [scaleAndClamp(1 - Math.min(1, c21 + k5)), scaleAndClamp(1 - Math.min(1, m18 + k5)), scaleAndClamp(1 - Math.min(1, y12 + k5))];
  }
  static CMYK_HTML(components) {
    const rgb = this.CMYK_RGB(components).slice(1);
    return this.RGB_HTML(rgb);
  }
  static RGB_CMYK([r9, g10, b7]) {
    const c21 = 1 - r9;
    const m18 = 1 - g10;
    const y12 = 1 - b7;
    const k5 = Math.min(c21, m18, y12);
    return ["CMYK", c21, m18, y12, k5];
  }
};
var DateFormats = (
  /* unused pure expression or super */
  null
);
var TimeFormats = (
  /* unused pure expression or super */
  null
);
;
var BaseSVGFactory = class {
  static {
    __name(this, "BaseSVGFactory");
  }
  create(width, height, skipDimensions = false) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid SVG dimensions");
    }
    const svg = this._createSVG("svg:svg");
    svg.setAttribute("version", "1.1");
    if (!skipDimensions) {
      svg.setAttribute("width", `${width}px`);
      svg.setAttribute("height", `${height}px`);
    }
    svg.setAttribute("preserveAspectRatio", "none");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    return svg;
  }
  createElement(type) {
    if (typeof type !== "string") {
      throw new Error("Invalid SVG element type");
    }
    return this._createSVG(type);
  }
  _createSVG(type) {
    unreachable("Abstract method `_createSVG` called.");
  }
};
var DOMSVGFactory = class extends BaseSVGFactory {
  static {
    __name(this, "DOMSVGFactory");
  }
  _createSVG(type) {
    return document.createElementNS(SVG_NS, type);
  }
};
;
var annotation_layer_DEFAULT_FONT_SIZE = 9;
var GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
var TIMEZONE_OFFSET = (/* @__PURE__ */ new Date()).getTimezoneOffset() * 60 * 1e3;
var AnnotationElementFactory = class {
  static {
    __name(this, "AnnotationElementFactory");
  }
  static create(parameters) {
    const subtype = parameters.data.annotationType;
    switch (subtype) {
      case AnnotationType.LINK:
        return new LinkAnnotationElement(parameters);
      case AnnotationType.TEXT:
        return new TextAnnotationElement(parameters);
      case AnnotationType.WIDGET:
        const fieldType = parameters.data.fieldType;
        switch (fieldType) {
          case "Tx":
            return new TextWidgetAnnotationElement(parameters);
          case "Btn":
            if (parameters.data.radioButton) {
              return new RadioButtonWidgetAnnotationElement(parameters);
            } else if (parameters.data.checkBox) {
              return new CheckboxWidgetAnnotationElement(parameters);
            }
            return new PushButtonWidgetAnnotationElement(parameters);
          case "Ch":
            return new ChoiceWidgetAnnotationElement(parameters);
          case "Sig":
            return new SignatureWidgetAnnotationElement(parameters);
        }
        return new WidgetAnnotationElement(parameters);
      case AnnotationType.POPUP:
        return new PopupAnnotationElement(parameters);
      case AnnotationType.FREETEXT:
        return new FreeTextAnnotationElement(parameters);
      case AnnotationType.LINE:
        return new LineAnnotationElement(parameters);
      case AnnotationType.SQUARE:
        return new SquareAnnotationElement(parameters);
      case AnnotationType.CIRCLE:
        return new CircleAnnotationElement(parameters);
      case AnnotationType.POLYLINE:
        return new PolylineAnnotationElement(parameters);
      case AnnotationType.CARET:
        return new CaretAnnotationElement(parameters);
      case AnnotationType.INK:
        return new InkAnnotationElement(parameters);
      case AnnotationType.POLYGON:
        return new PolygonAnnotationElement(parameters);
      case AnnotationType.HIGHLIGHT:
        return new HighlightAnnotationElement(parameters);
      case AnnotationType.UNDERLINE:
        return new UnderlineAnnotationElement(parameters);
      case AnnotationType.SQUIGGLY:
        return new SquigglyAnnotationElement(parameters);
      case AnnotationType.STRIKEOUT:
        return new StrikeOutAnnotationElement(parameters);
      case AnnotationType.STAMP:
        return new StampAnnotationElement(parameters);
      case AnnotationType.FILEATTACHMENT:
        return new FileAttachmentAnnotationElement(parameters);
      default:
        return new AnnotationElement(parameters);
    }
  }
};
var AnnotationElement = class _AnnotationElement {
  static {
    __name(this, "AnnotationElement");
  }
  #updates = null;
  #hasBorder = false;
  #popupElement = null;
  constructor(parameters, {
    isRenderable = false,
    ignoreBorder = false,
    createQuadrilaterals = false
  } = {}) {
    this.isRenderable = isRenderable;
    this.data = parameters.data;
    this.layer = parameters.layer;
    this.linkService = parameters.linkService;
    this.downloadManager = parameters.downloadManager;
    this.imageResourcesPath = parameters.imageResourcesPath;
    this.renderForms = parameters.renderForms;
    this.svgFactory = parameters.svgFactory;
    this.annotationStorage = parameters.annotationStorage;
    this.enableComment = parameters.enableComment;
    this.enableScripting = parameters.enableScripting;
    this.hasJSActions = parameters.hasJSActions;
    this._fieldObjects = parameters.fieldObjects;
    this.parent = parameters.parent;
    if (isRenderable) {
      this.container = this._createContainer(ignoreBorder);
    }
    if (createQuadrilaterals) {
      this._createQuadrilaterals();
    }
  }
  static _hasPopupData({
    contentsObj,
    richText
  }) {
    return !!(contentsObj?.str || richText?.str);
  }
  get _isEditable() {
    return this.data.isEditable;
  }
  get hasPopupData() {
    return _AnnotationElement._hasPopupData(this.data) || this.enableComment && !!this.commentText;
  }
  get commentData() {
    const {
      data
    } = this;
    const editor = this.annotationStorage?.getEditor(data.id);
    if (editor) {
      return editor.getData();
    }
    return data;
  }
  get hasCommentButton() {
    return this.enableComment && this.hasPopupElement;
  }
  get commentButtonPosition() {
    const editor = this.annotationStorage?.getEditor(this.data.id);
    if (editor) {
      return editor.commentButtonPositionInPage;
    }
    const {
      quadPoints,
      inkLists,
      rect
    } = this.data;
    let maxX = -Infinity;
    let maxY = -Infinity;
    if (quadPoints?.length >= 8) {
      for (let i18 = 0; i18 < quadPoints.length; i18 += 8) {
        if (quadPoints[i18 + 1] > maxY) {
          maxY = quadPoints[i18 + 1];
          maxX = quadPoints[i18 + 2];
        } else if (quadPoints[i18 + 1] === maxY) {
          maxX = Math.max(maxX, quadPoints[i18 + 2]);
        }
      }
      return [maxX, maxY];
    }
    if (inkLists?.length >= 1) {
      for (const inkList of inkLists) {
        for (let i18 = 0, ii = inkList.length; i18 < ii; i18 += 2) {
          if (inkList[i18 + 1] > maxY) {
            maxY = inkList[i18 + 1];
            maxX = inkList[i18];
          } else if (inkList[i18 + 1] === maxY) {
            maxX = Math.max(maxX, inkList[i18]);
          }
        }
      }
      if (maxX !== Infinity) {
        return [maxX, maxY];
      }
    }
    if (rect) {
      return [rect[2], rect[3]];
    }
    return null;
  }
  _normalizePoint(point) {
    const {
      page: {
        view
      },
      viewport: {
        rawDims: {
          pageWidth,
          pageHeight,
          pageX,
          pageY
        }
      }
    } = this.parent;
    point[1] = view[3] - point[1] + view[1];
    point[0] = 100 * (point[0] - pageX) / pageWidth;
    point[1] = 100 * (point[1] - pageY) / pageHeight;
    return point;
  }
  get commentText() {
    const {
      data
    } = this;
    return this.annotationStorage.getRawValue(`${AnnotationEditorPrefix}${data.id}`)?.popup?.contents || data.contentsObj?.str || "";
  }
  set commentText(text) {
    const {
      data
    } = this;
    const popup = {
      deleted: !text,
      contents: text || ""
    };
    if (!this.annotationStorage.updateEditor(data.id, {
      popup
    })) {
      this.annotationStorage.setValue(`${AnnotationEditorPrefix}${data.id}`, {
        id: data.id,
        annotationType: data.annotationType,
        pageIndex: this.parent.page._pageIndex,
        popup,
        popupRef: data.popupRef,
        modificationDate: /* @__PURE__ */ new Date()
      });
    }
    if (!text) {
      this.removePopup();
    }
  }
  removePopup() {
    (this.#popupElement?.popup || this.popup)?.remove();
    this.#popupElement = this.popup = null;
  }
  updateEdited(params) {
    if (!this.container) {
      return;
    }
    if (params.rect) {
      this.#updates ||= {
        rect: this.data.rect.slice(0)
      };
    }
    const {
      rect,
      popup: newPopup
    } = params;
    if (rect) {
      this.#setRectEdited(rect);
    }
    let popup = this.#popupElement?.popup || this.popup;
    if (!popup && newPopup?.text) {
      this._createPopup(newPopup);
      popup = this.#popupElement.popup;
    }
    if (!popup) {
      return;
    }
    popup.updateEdited(params);
    if (newPopup?.deleted) {
      popup.remove();
      this.#popupElement = null;
      this.popup = null;
    }
  }
  resetEdited() {
    if (!this.#updates) {
      return;
    }
    this.#setRectEdited(this.#updates.rect);
    this.#popupElement?.popup.resetEdited();
    this.#updates = null;
  }
  #setRectEdited(rect) {
    const {
      container: {
        style
      },
      data: {
        rect: currentRect,
        rotation
      },
      parent: {
        viewport: {
          rawDims: {
            pageWidth,
            pageHeight,
            pageX,
            pageY
          }
        }
      }
    } = this;
    currentRect?.splice(0, 4, ...rect);
    style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
    style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;
    if (rotation === 0) {
      style.width = `${100 * (rect[2] - rect[0]) / pageWidth}%`;
      style.height = `${100 * (rect[3] - rect[1]) / pageHeight}%`;
    } else {
      this.setRotation(rotation);
    }
  }
  _createContainer(ignoreBorder) {
    const {
      data,
      parent: {
        page,
        viewport
      }
    } = this;
    const container = document.createElement("section");
    container.setAttribute("data-annotation-id", data.id);
    if (!(this instanceof WidgetAnnotationElement) && !(this instanceof LinkAnnotationElement)) {
      container.tabIndex = 0;
    }
    const {
      style
    } = container;
    style.zIndex = this.parent.zIndex;
    this.parent.zIndex += 2;
    if (data.alternativeText) {
      container.title = data.alternativeText;
    }
    if (data.noRotate) {
      container.classList.add("norotate");
    }
    if (!data.rect || this instanceof PopupAnnotationElement) {
      const {
        rotation: rotation2
      } = data;
      if (!data.hasOwnCanvas && rotation2 !== 0) {
        this.setRotation(rotation2, container);
      }
      return container;
    }
    const {
      width,
      height
    } = this;
    if (!ignoreBorder && data.borderStyle.width > 0) {
      style.borderWidth = `${data.borderStyle.width}px`;
      const horizontalRadius = data.borderStyle.horizontalCornerRadius;
      const verticalRadius = data.borderStyle.verticalCornerRadius;
      if (horizontalRadius > 0 || verticalRadius > 0) {
        const radius = `calc(${horizontalRadius}px * var(--total-scale-factor)) / calc(${verticalRadius}px * var(--total-scale-factor))`;
        style.borderRadius = radius;
      } else if (this instanceof RadioButtonWidgetAnnotationElement) {
        const radius = `calc(${width}px * var(--total-scale-factor)) / calc(${height}px * var(--total-scale-factor))`;
        style.borderRadius = radius;
      }
      switch (data.borderStyle.style) {
        case AnnotationBorderStyleType.SOLID:
          style.borderStyle = "solid";
          break;
        case AnnotationBorderStyleType.DASHED:
          style.borderStyle = "dashed";
          break;
        case AnnotationBorderStyleType.BEVELED:
          warn("Unimplemented border style: beveled");
          break;
        case AnnotationBorderStyleType.INSET:
          warn("Unimplemented border style: inset");
          break;
        case AnnotationBorderStyleType.UNDERLINE:
          style.borderBottomStyle = "solid";
          break;
        default:
          break;
      }
      const borderColor = data.borderColor || null;
      if (borderColor) {
        this.#hasBorder = true;
        style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
      } else {
        style.borderWidth = 0;
      }
    }
    const rect = Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
    const {
      pageWidth,
      pageHeight,
      pageX,
      pageY
    } = viewport.rawDims;
    style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
    style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;
    const {
      rotation
    } = data;
    if (data.hasOwnCanvas || rotation === 0) {
      style.width = `${100 * width / pageWidth}%`;
      style.height = `${100 * height / pageHeight}%`;
    } else {
      this.setRotation(rotation, container);
    }
    return container;
  }
  setRotation(angle, container = this.container) {
    if (!this.data.rect) {
      return;
    }
    const {
      pageWidth,
      pageHeight
    } = this.parent.viewport.rawDims;
    let {
      width,
      height
    } = this;
    if (angle % 180 !== 0) {
      [width, height] = [height, width];
    }
    container.style.width = `${100 * width / pageWidth}%`;
    container.style.height = `${100 * height / pageHeight}%`;
    container.setAttribute("data-main-rotation", (360 - angle) % 360);
  }
  get _commonActions() {
    const setColor = /* @__PURE__ */ __name((jsName, styleName, event) => {
      const color = event.detail[jsName];
      const colorType = color[0];
      const colorArray = color.slice(1);
      event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);
      this.annotationStorage.setValue(this.data.id, {
        [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)
      });
    }, "setColor");
    return shadow(this, "_commonActions", {
      display: /* @__PURE__ */ __name((event) => {
        const {
          display
        } = event.detail;
        const hidden = display % 2 === 1;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          noView: hidden,
          noPrint: display === 1 || display === 2
        });
      }, "display"),
      print: /* @__PURE__ */ __name((event) => {
        this.annotationStorage.setValue(this.data.id, {
          noPrint: !event.detail.print
        });
      }, "print"),
      hidden: /* @__PURE__ */ __name((event) => {
        const {
          hidden
        } = event.detail;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          noPrint: hidden,
          noView: hidden
        });
      }, "hidden"),
      focus: /* @__PURE__ */ __name((event) => {
        setTimeout(() => event.target.focus({
          preventScroll: false
        }), 0);
      }, "focus"),
      userName: /* @__PURE__ */ __name((event) => {
        event.target.title = event.detail.userName;
      }, "userName"),
      readonly: /* @__PURE__ */ __name((event) => {
        event.target.disabled = event.detail.readonly;
      }, "readonly"),
      required: /* @__PURE__ */ __name((event) => {
        this._setRequired(event.target, event.detail.required);
      }, "required"),
      bgColor: /* @__PURE__ */ __name((event) => {
        setColor("bgColor", "backgroundColor", event);
      }, "bgColor"),
      fillColor: /* @__PURE__ */ __name((event) => {
        setColor("fillColor", "backgroundColor", event);
      }, "fillColor"),
      fgColor: /* @__PURE__ */ __name((event) => {
        setColor("fgColor", "color", event);
      }, "fgColor"),
      textColor: /* @__PURE__ */ __name((event) => {
        setColor("textColor", "color", event);
      }, "textColor"),
      borderColor: /* @__PURE__ */ __name((event) => {
        setColor("borderColor", "borderColor", event);
      }, "borderColor"),
      strokeColor: /* @__PURE__ */ __name((event) => {
        setColor("strokeColor", "borderColor", event);
      }, "strokeColor"),
      rotation: /* @__PURE__ */ __name((event) => {
        const angle = event.detail.rotation;
        this.setRotation(angle);
        this.annotationStorage.setValue(this.data.id, {
          rotation: angle
        });
      }, "rotation")
    });
  }
  _dispatchEventFromSandbox(actions, jsEvent) {
    const commonActions = this._commonActions;
    for (const name4 of Object.keys(jsEvent.detail)) {
      const action = actions[name4] || commonActions[name4];
      action?.(jsEvent);
    }
  }
  _setDefaultPropertiesFromJS(element) {
    if (!this.enableScripting) {
      return;
    }
    const storedData = this.annotationStorage.getRawValue(this.data.id);
    if (!storedData) {
      return;
    }
    const commonActions = this._commonActions;
    for (const [actionName, detail] of Object.entries(storedData)) {
      const action = commonActions[actionName];
      if (action) {
        const eventProxy = {
          detail: {
            [actionName]: detail
          },
          target: element
        };
        action(eventProxy);
        delete storedData[actionName];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container) {
      return;
    }
    const {
      quadPoints
    } = this.data;
    if (!quadPoints) {
      return;
    }
    const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x3) => Math.fround(x3));
    if (quadPoints.length === 8) {
      const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);
      if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {
        return;
      }
    }
    const {
      style
    } = this.container;
    let svgBuffer;
    if (this.#hasBorder) {
      const {
        borderColor,
        borderWidth
      } = style;
      style.borderWidth = 0;
      svgBuffer = ["url('data:image/svg+xml;utf8,", `<svg xmlns="http://www.w3.org/2000/svg"`, ` preserveAspectRatio="none" viewBox="0 0 1 1">`, `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`];
      this.container.classList.add("hasBorder");
    }
    const width = rectTrX - rectBlX;
    const height = rectTrY - rectBlY;
    const {
      svgFactory
    } = this;
    const svg = svgFactory.createElement("svg");
    svg.classList.add("quadrilateralsContainer");
    svg.setAttribute("width", 0);
    svg.setAttribute("height", 0);
    svg.role = "none";
    const defs = svgFactory.createElement("defs");
    svg.append(defs);
    const clipPath = svgFactory.createElement("clipPath");
    const id = `clippath_${this.data.id}`;
    clipPath.setAttribute("id", id);
    clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
    defs.append(clipPath);
    for (let i18 = 2, ii = quadPoints.length; i18 < ii; i18 += 8) {
      const trX = quadPoints[i18];
      const trY = quadPoints[i18 + 1];
      const blX = quadPoints[i18 + 2];
      const blY = quadPoints[i18 + 3];
      const rect = svgFactory.createElement("rect");
      const x3 = (blX - rectBlX) / width;
      const y12 = (rectTrY - trY) / height;
      const rectWidth = (trX - blX) / width;
      const rectHeight = (trY - blY) / height;
      rect.setAttribute("x", x3);
      rect.setAttribute("y", y12);
      rect.setAttribute("width", rectWidth);
      rect.setAttribute("height", rectHeight);
      clipPath.append(rect);
      svgBuffer?.push(`<rect vector-effect="non-scaling-stroke" x="${x3}" y="${y12}" width="${rectWidth}" height="${rectHeight}"/>`);
    }
    if (this.#hasBorder) {
      svgBuffer.push(`</g></svg>')`);
      style.backgroundImage = svgBuffer.join("");
    }
    this.container.append(svg);
    this.container.style.clipPath = `url(#${id})`;
  }
  _createPopup(popupData = null) {
    const {
      data
    } = this;
    let contentsObj, modificationDate;
    if (popupData) {
      contentsObj = {
        str: popupData.text
      };
      modificationDate = popupData.date;
    } else {
      contentsObj = data.contentsObj;
      modificationDate = data.modificationDate;
    }
    const popup = this.#popupElement = new PopupAnnotationElement({
      data: {
        color: data.color,
        titleObj: data.titleObj,
        modificationDate,
        contentsObj,
        richText: data.richText,
        parentRect: data.rect,
        borderStyle: 0,
        id: `popup_${data.id}`,
        rotation: data.rotation,
        noRotate: true
      },
      linkService: this.linkService,
      parent: this.parent,
      elements: [this]
    });
    if (!this.parent._commentManager) {
      this.parent.div.append(popup.render());
    }
  }
  get hasPopupElement() {
    return !!(this.#popupElement || this.popup || this.data.popupRef);
  }
  get extraPopupElement() {
    return this.#popupElement;
  }
  render() {
    unreachable("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(name4, skipId = null) {
    const fields = [];
    if (this._fieldObjects) {
      const fieldObj = this._fieldObjects[name4];
      if (fieldObj) {
        for (const {
          page,
          id,
          exportValues
        } of fieldObj) {
          if (page === -1) {
            continue;
          }
          if (id === skipId) {
            continue;
          }
          const exportValue = typeof exportValues === "string" ? exportValues : null;
          const domElement = document.querySelector(`[data-element-id="${id}"]`);
          if (domElement && !GetElementsByNameSet.has(domElement)) {
            warn(`_getElementsByName - element not allowed: ${id}`);
            continue;
          }
          fields.push({
            id,
            exportValue,
            domElement
          });
        }
      }
      return fields;
    }
    for (const domElement of document.getElementsByName(name4)) {
      const {
        exportValue
      } = domElement;
      const id = domElement.getAttribute("data-element-id");
      if (id === skipId) {
        continue;
      }
      if (!GetElementsByNameSet.has(domElement)) {
        continue;
      }
      fields.push({
        id,
        exportValue,
        domElement
      });
    }
    return fields;
  }
  show() {
    if (this.container) {
      this.container.hidden = false;
    }
    this.popup?.maybeShow();
  }
  hide() {
    if (this.container) {
      this.container.hidden = true;
    }
    this.popup?.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const triggers = this.getElementsToTriggerPopup();
    if (Array.isArray(triggers)) {
      for (const element of triggers) {
        element.classList.add("highlightArea");
      }
    } else {
      triggers.classList.add("highlightArea");
    }
  }
  _editOnDoubleClick() {
    if (!this._isEditable) {
      return;
    }
    const {
      annotationEditorType: mode,
      data: {
        id: editId
      }
    } = this;
    this.container.addEventListener("dblclick", () => {
      this.linkService.eventBus?.dispatch("switchannotationeditormode", {
        source: this,
        mode,
        editId,
        mustEnterInEditMode: true
      });
    });
  }
  get width() {
    return this.data.rect[2] - this.data.rect[0];
  }
  get height() {
    return this.data.rect[3] - this.data.rect[1];
  }
};
var EditorAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "EditorAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.editor = parameters.editor;
  }
  render() {
    this.container.className = "editorAnnotation";
    return this.container;
  }
  createOrUpdatePopup() {
    const {
      editor
    } = this;
    if (!editor.hasComment) {
      return;
    }
    this._createPopup(editor.comment);
    this.extraPopupElement.popup.renderCommentButton();
  }
  get hasCommentButton() {
    return this.enableComment && this.editor.hasComment;
  }
  get commentButtonPosition() {
    return this.editor.commentButtonPositionInPage;
  }
  get commentText() {
    return this.editor.comment.text;
  }
  set commentText(text) {
    this.editor.comment = text;
    if (!text) {
      this.removePopup();
    }
  }
  get commentData() {
    return this.editor.getData();
  }
  remove() {
    this.container.remove();
    this.container = null;
    this.removePopup();
  }
};
var LinkAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "LinkAnnotationElement");
  }
  constructor(parameters, options = null) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: !!options?.ignoreBorder,
      createQuadrilaterals: true
    });
    this.isTooltipOnly = parameters.data.isTooltipOnly;
  }
  render() {
    const {
      data,
      linkService
    } = this;
    const link = document.createElement("a");
    link.setAttribute("data-element-id", data.id);
    let isBound = false;
    if (data.url) {
      linkService.addLinkAttributes(link, data.url, data.newWindow);
      isBound = true;
    } else if (data.action) {
      this._bindNamedAction(link, data.action, data.overlaidText);
      isBound = true;
    } else if (data.attachment) {
      this.#bindAttachment(link, data.attachment, data.overlaidText, data.attachmentDest);
      isBound = true;
    } else if (data.setOCGState) {
      this.#bindSetOCGState(link, data.setOCGState, data.overlaidText);
      isBound = true;
    } else if (data.dest) {
      this._bindLink(link, data.dest, data.overlaidText);
      isBound = true;
    } else {
      if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
        this._bindJSAction(link, data);
        isBound = true;
      }
      if (data.resetForm) {
        this._bindResetFormAction(link, data.resetForm);
        isBound = true;
      } else if (this.isTooltipOnly && !isBound) {
        this._bindLink(link, "");
        isBound = true;
      }
    }
    this.container.classList.add("linkAnnotation");
    if (isBound) {
      this.container.append(link);
    }
    return this.container;
  }
  #setInternalLink() {
    this.container.setAttribute("data-internal-link", "");
  }
  _bindLink(link, destination, overlaidText = "") {
    link.href = this.linkService.getDestinationHash(destination);
    link.onclick = () => {
      if (destination) {
        this.linkService.goToDestination(destination);
      }
      return false;
    };
    if (destination || destination === "") {
      this.#setInternalLink();
    }
    if (overlaidText) {
      link.title = overlaidText;
    }
  }
  _bindNamedAction(link, action, overlaidText = "") {
    link.href = this.linkService.getAnchorUrl("");
    link.onclick = () => {
      this.linkService.executeNamedAction(action);
      return false;
    };
    if (overlaidText) {
      link.title = overlaidText;
    }
    this.#setInternalLink();
  }
  #bindAttachment(link, attachment, overlaidText = "", dest = null) {
    link.href = this.linkService.getAnchorUrl("");
    if (attachment.description) {
      link.title = attachment.description;
    } else if (overlaidText) {
      link.title = overlaidText;
    }
    link.onclick = () => {
      this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);
      return false;
    };
    this.#setInternalLink();
  }
  #bindSetOCGState(link, action, overlaidText = "") {
    link.href = this.linkService.getAnchorUrl("");
    link.onclick = () => {
      this.linkService.executeSetOCGState(action);
      return false;
    };
    if (overlaidText) {
      link.title = overlaidText;
    }
    this.#setInternalLink();
  }
  _bindJSAction(link, data) {
    link.href = this.linkService.getAnchorUrl("");
    const map2 = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const name4 of Object.keys(data.actions)) {
      const jsName = map2.get(name4);
      if (!jsName) {
        continue;
      }
      link[jsName] = () => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: data.id,
            name: name4
          }
        });
        return false;
      };
    }
    if (data.overlaidText) {
      link.title = data.overlaidText;
    }
    if (!link.onclick) {
      link.onclick = () => false;
    }
    this.#setInternalLink();
  }
  _bindResetFormAction(link, resetForm) {
    const otherClickAction = link.onclick;
    if (!otherClickAction) {
      link.href = this.linkService.getAnchorUrl("");
    }
    this.#setInternalLink();
    if (!this._fieldObjects) {
      warn(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
      if (!otherClickAction) {
        link.onclick = () => false;
      }
      return;
    }
    link.onclick = () => {
      otherClickAction?.();
      const {
        fields: resetFormFields,
        refs: resetFormRefs,
        include
      } = resetForm;
      const allFields = [];
      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
        const fieldIds = new Set(resetFormRefs);
        for (const fieldName of resetFormFields) {
          const fields = this._fieldObjects[fieldName] || [];
          for (const {
            id
          } of fields) {
            fieldIds.add(id);
          }
        }
        for (const fields of Object.values(this._fieldObjects)) {
          for (const field of fields) {
            if (fieldIds.has(field.id) === include) {
              allFields.push(field);
            }
          }
        }
      } else {
        for (const fields of Object.values(this._fieldObjects)) {
          allFields.push(...fields);
        }
      }
      const storage = this.annotationStorage;
      const allIds = [];
      for (const field of allFields) {
        const {
          id
        } = field;
        allIds.push(id);
        switch (field.type) {
          case "text": {
            const value = field.defaultValue || "";
            storage.setValue(id, {
              value
            });
            break;
          }
          case "checkbox":
          case "radiobutton": {
            const value = field.defaultValue === field.exportValues;
            storage.setValue(id, {
              value
            });
            break;
          }
          case "combobox":
          case "listbox": {
            const value = field.defaultValue || "";
            storage.setValue(id, {
              value
            });
            break;
          }
          default:
            continue;
        }
        const domElement = document.querySelector(`[data-element-id="${id}"]`);
        if (!domElement) {
          continue;
        } else if (!GetElementsByNameSet.has(domElement)) {
          warn(`_bindResetFormAction - element not allowed: ${id}`);
          continue;
        }
        domElement.dispatchEvent(new Event("resetform"));
      }
      if (this.enableScripting) {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: "app",
            ids: allIds,
            name: "ResetForm"
          }
        });
      }
      return false;
    };
  }
};
var TextAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "TextAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      isRenderable: true
    });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const image = document.createElement("img");
    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
    image.setAttribute("data-l10n-id", "pdfjs-text-annotation-type");
    image.setAttribute("data-l10n-args", JSON.stringify({
      type: this.data.name
    }));
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.append(image);
    return this.container;
  }
};
var WidgetAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "WidgetAnnotationElement");
  }
  render() {
    return this.container;
  }
  showElementAndHideCanvas(element) {
    if (this.data.hasOwnCanvas) {
      if (element.previousSibling?.nodeName === "CANVAS") {
        element.previousSibling.hidden = true;
      }
      element.hidden = false;
    }
  }
  _getKeyModifier(event) {
    return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;
  }
  _setEventListener(element, elementData, baseName, eventName, valueGetter) {
    if (baseName.includes("mouse")) {
      element.addEventListener(baseName, (event) => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event),
            shift: event.shiftKey,
            modifier: this._getKeyModifier(event)
          }
        });
      });
    } else {
      element.addEventListener(baseName, (event) => {
        if (baseName === "blur") {
          if (!elementData.focused || !event.relatedTarget) {
            return;
          }
          elementData.focused = false;
        } else if (baseName === "focus") {
          if (elementData.focused) {
            return;
          }
          elementData.focused = true;
        }
        if (!valueGetter) {
          return;
        }
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event)
          }
        });
      });
    }
  }
  _setEventListeners(element, elementData, names, getter) {
    for (const [baseName, eventName] of names) {
      if (eventName === "Action" || this.data.actions?.[eventName]) {
        if (eventName === "Focus" || eventName === "Blur") {
          elementData ||= {
            focused: false
          };
        }
        this._setEventListener(element, elementData, baseName, eventName, getter);
        if (eventName === "Focus" && !this.data.actions?.Blur) {
          this._setEventListener(element, elementData, "blur", "Blur", null);
        } else if (eventName === "Blur" && !this.data.actions?.Focus) {
          this._setEventListener(element, elementData, "focus", "Focus", null);
        }
      }
    }
  }
  _setBackgroundColor(element) {
    const color = this.data.backgroundColor || null;
    element.style.backgroundColor = color === null ? "transparent" : Util.makeHexColor(color[0], color[1], color[2]);
  }
  _setTextStyle(element) {
    const TEXT_ALIGNMENT = ["left", "center", "right"];
    const {
      fontColor
    } = this.data.defaultAppearanceData;
    const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;
    const style = element.style;
    let computedFontSize;
    const BORDER_SIZE = 2;
    const roundToOneDecimal = /* @__PURE__ */ __name((x3) => Math.round(10 * x3) / 10, "roundToOneDecimal");
    if (this.data.multiLine) {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
      const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;
      const lineHeight = height / numberOfLines;
      computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));
    } else {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
      computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));
    }
    style.fontSize = `calc(${computedFontSize}px * var(--total-scale-factor))`;
    style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
    if (this.data.textAlignment !== null) {
      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
    }
  }
  _setRequired(element, isRequired) {
    if (isRequired) {
      element.setAttribute("required", true);
    } else {
      element.removeAttribute("required");
    }
    element.setAttribute("aria-required", isRequired);
  }
};
var TextWidgetAnnotationElement = class extends WidgetAnnotationElement {
  static {
    __name(this, "TextWidgetAnnotationElement");
  }
  constructor(parameters) {
    const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
    super(parameters, {
      isRenderable
    });
  }
  setPropertyOnSiblings(base, key, value, keyInStorage) {
    const storage = this.annotationStorage;
    for (const element of this._getElementsByName(base.name, base.id)) {
      if (element.domElement) {
        element.domElement[key] = value;
      }
      storage.setValue(element.id, {
        [keyInStorage]: value
      });
    }
  }
  render() {
    const storage = this.annotationStorage;
    const id = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let element = null;
    if (this.renderForms) {
      const storedData = storage.getValue(id, {
        value: this.data.fieldValue
      });
      let textContent = storedData.value || "";
      const maxLen = storage.getValue(id, {
        charLimit: this.data.maxLen
      }).charLimit;
      if (maxLen && textContent.length > maxLen) {
        textContent = textContent.slice(0, maxLen);
      }
      let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join("\n") || null;
      if (fieldFormattedValues && this.data.comb) {
        fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
      }
      const elementData = {
        userValue: textContent,
        formattedValue: fieldFormattedValues,
        lastCommittedValue: null,
        commitKey: 1,
        focused: false
      };
      if (this.data.multiLine) {
        element = document.createElement("textarea");
        element.textContent = fieldFormattedValues ?? textContent;
        if (this.data.doNotScroll) {
          element.style.overflowY = "hidden";
        }
      } else {
        element = document.createElement("input");
        element.type = this.data.password ? "password" : "text";
        element.setAttribute("value", fieldFormattedValues ?? textContent);
        if (this.data.doNotScroll) {
          element.style.overflowX = "hidden";
        }
      }
      if (this.data.hasOwnCanvas) {
        element.hidden = true;
      }
      GetElementsByNameSet.add(element);
      element.setAttribute("data-element-id", id);
      element.disabled = this.data.readOnly;
      element.name = this.data.fieldName;
      element.tabIndex = 0;
      const {
        datetimeFormat,
        datetimeType,
        timeStep
      } = this.data;
      const hasDateOrTime = !!datetimeType && this.enableScripting;
      if (datetimeFormat) {
        element.title = datetimeFormat;
      }
      this._setRequired(element, this.data.required);
      if (maxLen) {
        element.maxLength = maxLen;
      }
      element.addEventListener("input", (event) => {
        storage.setValue(id, {
          value: event.target.value
        });
        this.setPropertyOnSiblings(element, "value", event.target.value, "value");
        elementData.formattedValue = null;
      });
      element.addEventListener("resetform", (event) => {
        const defaultValue = this.data.defaultFieldValue ?? "";
        element.value = elementData.userValue = defaultValue;
        elementData.formattedValue = null;
      });
      let blurListener = /* @__PURE__ */ __name((event) => {
        const {
          formattedValue
        } = elementData;
        if (formattedValue !== null && formattedValue !== void 0) {
          event.target.value = formattedValue;
        }
        event.target.scrollLeft = 0;
      }, "blurListener");
      if (this.enableScripting && this.hasJSActions) {
        element.addEventListener("focus", (event) => {
          if (elementData.focused) {
            return;
          }
          const {
            target
          } = event;
          if (hasDateOrTime) {
            target.type = datetimeType;
            if (timeStep) {
              target.step = timeStep;
            }
          }
          if (elementData.userValue) {
            const value = elementData.userValue;
            if (hasDateOrTime) {
              if (datetimeType === "time") {
                const date = new Date(value);
                const parts = [date.getHours(), date.getMinutes(), date.getSeconds()];
                target.value = parts.map((v8) => v8.toString().padStart(2, "0")).join(":");
              } else {
                target.value = new Date(value - TIMEZONE_OFFSET).toISOString().split(datetimeType === "date" ? "T" : ".", 1)[0];
              }
            } else {
              target.value = value;
            }
          }
          elementData.lastCommittedValue = target.value;
          elementData.commitKey = 1;
          if (!this.data.actions?.Focus) {
            elementData.focused = true;
          }
        });
        element.addEventListener("updatefromsandbox", (jsEvent) => {
          this.showElementAndHideCanvas(jsEvent.target);
          const actions = {
            value(event) {
              elementData.userValue = event.detail.value ?? "";
              if (!hasDateOrTime) {
                storage.setValue(id, {
                  value: elementData.userValue.toString()
                });
              }
              event.target.value = elementData.userValue;
            },
            formattedValue(event) {
              const {
                formattedValue
              } = event.detail;
              elementData.formattedValue = formattedValue;
              if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                event.target.value = formattedValue;
              }
              const data = {
                formattedValue
              };
              if (hasDateOrTime) {
                data.value = formattedValue;
              }
              storage.setValue(id, data);
            },
            selRange(event) {
              event.target.setSelectionRange(...event.detail.selRange);
            },
            charLimit: /* @__PURE__ */ __name((event) => {
              const {
                charLimit
              } = event.detail;
              const {
                target
              } = event;
              if (charLimit === 0) {
                target.removeAttribute("maxLength");
                return;
              }
              target.setAttribute("maxLength", charLimit);
              let value = elementData.userValue;
              if (!value || value.length <= charLimit) {
                return;
              }
              value = value.slice(0, charLimit);
              target.value = elementData.userValue = value;
              storage.setValue(id, {
                value
              });
              this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id,
                  name: "Keystroke",
                  value,
                  willCommit: true,
                  commitKey: 1,
                  selStart: target.selectionStart,
                  selEnd: target.selectionEnd
                }
              });
            }, "charLimit")
          };
          this._dispatchEventFromSandbox(actions, jsEvent);
        });
        element.addEventListener("keydown", (event) => {
          elementData.commitKey = 1;
          let commitKey = -1;
          if (event.key === "Escape") {
            commitKey = 0;
          } else if (event.key === "Enter" && !this.data.multiLine) {
            commitKey = 2;
          } else if (event.key === "Tab") {
            elementData.commitKey = 3;
          }
          if (commitKey === -1) {
            return;
          }
          const {
            value
          } = event.target;
          if (elementData.lastCommittedValue === value) {
            return;
          }
          elementData.lastCommittedValue = value;
          elementData.userValue = value;
          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id,
              name: "Keystroke",
              value,
              willCommit: true,
              commitKey,
              selStart: event.target.selectionStart,
              selEnd: event.target.selectionEnd
            }
          });
        });
        const _blurListener = blurListener;
        blurListener = null;
        element.addEventListener("blur", (event) => {
          if (!elementData.focused || !event.relatedTarget) {
            return;
          }
          if (!this.data.actions?.Blur) {
            elementData.focused = false;
          }
          const {
            target
          } = event;
          let {
            value
          } = target;
          if (hasDateOrTime) {
            if (value && datetimeType === "time") {
              const parts = value.split(":").map((v8) => parseInt(v8, 10));
              value = new Date(2e3, 0, 1, parts[0], parts[1], parts[2] || 0).valueOf();
              target.step = "";
            } else {
              if (!value.includes("T")) {
                value = `${value}T00:00`;
              }
              value = new Date(value).valueOf();
            }
            target.type = "text";
          }
          elementData.userValue = value;
          if (elementData.lastCommittedValue !== value) {
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                willCommit: true,
                commitKey: elementData.commitKey,
                selStart: event.target.selectionStart,
                selEnd: event.target.selectionEnd
              }
            });
          }
          _blurListener(event);
        });
        if (this.data.actions?.Keystroke) {
          element.addEventListener("beforeinput", (event) => {
            elementData.lastCommittedValue = null;
            const {
              data,
              target
            } = event;
            const {
              value,
              selectionStart,
              selectionEnd
            } = target;
            let selStart = selectionStart, selEnd = selectionEnd;
            switch (event.inputType) {
              case "deleteWordBackward": {
                const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                if (match) {
                  selStart -= match[0].length;
                }
                break;
              }
              case "deleteWordForward": {
                const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                if (match) {
                  selEnd += match[0].length;
                }
                break;
              }
              case "deleteContentBackward":
                if (selectionStart === selectionEnd) {
                  selStart -= 1;
                }
                break;
              case "deleteContentForward":
                if (selectionStart === selectionEnd) {
                  selEnd += 1;
                }
                break;
            }
            event.preventDefault();
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                change: data || "",
                willCommit: false,
                selStart,
                selEnd
              }
            });
          });
        }
        this._setEventListeners(element, elementData, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
      }
      if (blurListener) {
        element.addEventListener("blur", blurListener);
      }
      if (this.data.comb) {
        const fieldWidth = this.data.rect[2] - this.data.rect[0];
        const combWidth = fieldWidth / maxLen;
        element.classList.add("comb");
        element.style.letterSpacing = `calc(${combWidth}px * var(--total-scale-factor) - 1ch)`;
      }
    } else {
      element = document.createElement("div");
      element.textContent = this.data.fieldValue;
      element.style.verticalAlign = "middle";
      element.style.display = "table-cell";
      if (this.data.hasOwnCanvas) {
        element.hidden = true;
      }
    }
    this._setTextStyle(element);
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
};
var SignatureWidgetAnnotationElement = class extends WidgetAnnotationElement {
  static {
    __name(this, "SignatureWidgetAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      isRenderable: !!parameters.data.hasOwnCanvas
    });
  }
};
var CheckboxWidgetAnnotationElement = class extends WidgetAnnotationElement {
  static {
    __name(this, "CheckboxWidgetAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.exportValue === data.fieldValue
    }).value;
    if (typeof value === "string") {
      value = value !== "Off";
      storage.setValue(id, {
        value
      });
    }
    this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;
    this._setRequired(element, this.data.required);
    element.type = "checkbox";
    element.name = data.fieldName;
    if (value) {
      element.setAttribute("checked", true);
    }
    element.setAttribute("exportValue", data.exportValue);
    element.tabIndex = 0;
    element.addEventListener("change", (event) => {
      const {
        name: name4,
        checked
      } = event.target;
      for (const checkbox of this._getElementsByName(name4, id)) {
        const curChecked = checked && checkbox.exportValue === data.exportValue;
        if (checkbox.domElement) {
          checkbox.domElement.checked = curChecked;
        }
        storage.setValue(checkbox.id, {
          value: curChecked
        });
      }
      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", (event) => {
      const defaultValue = data.defaultFieldValue || "Off";
      event.target.checked = defaultValue === data.exportValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      element.addEventListener("updatefromsandbox", (jsEvent) => {
        const actions = {
          value(event) {
            event.target.checked = event.detail.value !== "Off";
            storage.setValue(id, {
              value: event.target.checked
            });
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
    }
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
};
var RadioButtonWidgetAnnotationElement = class extends WidgetAnnotationElement {
  static {
    __name(this, "RadioButtonWidgetAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.fieldValue === data.buttonValue
    }).value;
    if (typeof value === "string") {
      value = value !== data.buttonValue;
      storage.setValue(id, {
        value
      });
    }
    if (value) {
      for (const radio of this._getElementsByName(data.fieldName, id)) {
        storage.setValue(radio.id, {
          value: false
        });
      }
    }
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;
    this._setRequired(element, this.data.required);
    element.type = "radio";
    element.name = data.fieldName;
    if (value) {
      element.setAttribute("checked", true);
    }
    element.tabIndex = 0;
    element.addEventListener("change", (event) => {
      const {
        name: name4,
        checked
      } = event.target;
      for (const radio of this._getElementsByName(name4, id)) {
        storage.setValue(radio.id, {
          value: false
        });
      }
      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", (event) => {
      const defaultValue = data.defaultFieldValue;
      event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      const pdfButtonValue = data.buttonValue;
      element.addEventListener("updatefromsandbox", (jsEvent) => {
        const actions = {
          value: /* @__PURE__ */ __name((event) => {
            const checked = pdfButtonValue === event.detail.value;
            for (const radio of this._getElementsByName(event.target.name)) {
              const curChecked = checked && radio.id === id;
              if (radio.domElement) {
                radio.domElement.checked = curChecked;
              }
              storage.setValue(radio.id, {
                value: curChecked
              });
            }
          }, "value")
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
    }
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
};
var PushButtonWidgetAnnotationElement = class extends LinkAnnotationElement {
  static {
    __name(this, "PushButtonWidgetAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      ignoreBorder: parameters.data.hasAppearance
    });
  }
  render() {
    const container = super.render();
    container.classList.add("buttonWidgetAnnotation", "pushButton");
    const linkElement = container.lastChild;
    if (this.enableScripting && this.hasJSActions && linkElement) {
      this._setDefaultPropertiesFromJS(linkElement);
      linkElement.addEventListener("updatefromsandbox", (jsEvent) => {
        this._dispatchEventFromSandbox({}, jsEvent);
      });
    }
    return container;
  }
};
var ChoiceWidgetAnnotationElement = class extends WidgetAnnotationElement {
  static {
    __name(this, "ChoiceWidgetAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const storage = this.annotationStorage;
    const id = this.data.id;
    const storedData = storage.getValue(id, {
      value: this.data.fieldValue
    });
    const selectElement = document.createElement("select");
    GetElementsByNameSet.add(selectElement);
    selectElement.setAttribute("data-element-id", id);
    selectElement.disabled = this.data.readOnly;
    this._setRequired(selectElement, this.data.required);
    selectElement.name = this.data.fieldName;
    selectElement.tabIndex = 0;
    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
    if (!this.data.combo) {
      selectElement.size = this.data.options.length;
      if (this.data.multiSelect) {
        selectElement.multiple = true;
      }
    }
    selectElement.addEventListener("resetform", (event) => {
      const defaultValue = this.data.defaultFieldValue;
      for (const option of selectElement.options) {
        option.selected = option.value === defaultValue;
      }
    });
    for (const option of this.data.options) {
      const optionElement = document.createElement("option");
      optionElement.textContent = option.displayValue;
      optionElement.value = option.exportValue;
      if (storedData.value.includes(option.exportValue)) {
        optionElement.setAttribute("selected", true);
        addAnEmptyEntry = false;
      }
      selectElement.append(optionElement);
    }
    let removeEmptyEntry = null;
    if (addAnEmptyEntry) {
      const noneOptionElement = document.createElement("option");
      noneOptionElement.value = " ";
      noneOptionElement.setAttribute("hidden", true);
      noneOptionElement.setAttribute("selected", true);
      selectElement.prepend(noneOptionElement);
      removeEmptyEntry = /* @__PURE__ */ __name(() => {
        noneOptionElement.remove();
        selectElement.removeEventListener("input", removeEmptyEntry);
        removeEmptyEntry = null;
      }, "removeEmptyEntry");
      selectElement.addEventListener("input", removeEmptyEntry);
    }
    const getValue = /* @__PURE__ */ __name((isExport) => {
      const name4 = isExport ? "value" : "textContent";
      const {
        options,
        multiple
      } = selectElement;
      if (!multiple) {
        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name4];
      }
      return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name4]);
    }, "getValue");
    let selectedValues = getValue(false);
    const getItems = /* @__PURE__ */ __name((event) => {
      const options = event.target.options;
      return Array.prototype.map.call(options, (option) => ({
        displayValue: option.textContent,
        exportValue: option.value
      }));
    }, "getItems");
    if (this.enableScripting && this.hasJSActions) {
      selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
        const actions = {
          value(event) {
            removeEmptyEntry?.();
            const value = event.detail.value;
            const values = new Set(Array.isArray(value) ? value : [value]);
            for (const option of selectElement.options) {
              option.selected = values.has(option.value);
            }
            storage.setValue(id, {
              value: getValue(true)
            });
            selectedValues = getValue(false);
          },
          multipleSelection(event) {
            selectElement.multiple = true;
          },
          remove(event) {
            const options = selectElement.options;
            const index = event.detail.remove;
            options[index].selected = false;
            selectElement.remove(index);
            if (options.length > 0) {
              const i18 = Array.prototype.findIndex.call(options, (option) => option.selected);
              if (i18 === -1) {
                options[0].selected = true;
              }
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          clear(event) {
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }
            storage.setValue(id, {
              value: null,
              items: []
            });
            selectedValues = getValue(false);
          },
          insert(event) {
            const {
              index,
              displayValue,
              exportValue
            } = event.detail.insert;
            const selectChild = selectElement.children[index];
            const optionElement = document.createElement("option");
            optionElement.textContent = displayValue;
            optionElement.value = exportValue;
            if (selectChild) {
              selectChild.before(optionElement);
            } else {
              selectElement.append(optionElement);
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          items(event) {
            const {
              items
            } = event.detail;
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }
            for (const item of items) {
              const {
                displayValue,
                exportValue
              } = item;
              const optionElement = document.createElement("option");
              optionElement.textContent = displayValue;
              optionElement.value = exportValue;
              selectElement.append(optionElement);
            }
            if (selectElement.options.length > 0) {
              selectElement.options[0].selected = true;
            }
            storage.setValue(id, {
              value: getValue(true),
              items: getItems(event)
            });
            selectedValues = getValue(false);
          },
          indices(event) {
            const indices = new Set(event.detail.indices);
            for (const option of event.target.options) {
              option.selected = indices.has(option.index);
            }
            storage.setValue(id, {
              value: getValue(true)
            });
            selectedValues = getValue(false);
          },
          editable(event) {
            event.target.disabled = !event.detail.editable;
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      selectElement.addEventListener("input", (event) => {
        const exportValue = getValue(true);
        const change = getValue(false);
        storage.setValue(id, {
          value: exportValue
        });
        event.preventDefault();
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id,
            name: "Keystroke",
            value: selectedValues,
            change,
            changeEx: exportValue,
            willCommit: false,
            commitKey: 1,
            keyDown: false
          }
        });
      });
      this._setEventListeners(selectElement, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (event) => event.target.value);
    } else {
      selectElement.addEventListener("input", function(event) {
        storage.setValue(id, {
          value: getValue(true)
        });
      });
    }
    if (this.data.combo) {
      this._setTextStyle(selectElement);
    } else {
    }
    this._setBackgroundColor(selectElement);
    this._setDefaultPropertiesFromJS(selectElement);
    this.container.append(selectElement);
    return this.container;
  }
};
var PopupAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "PopupAnnotationElement");
  }
  constructor(parameters) {
    const {
      data,
      elements,
      parent
    } = parameters;
    const hasCommentManager = !!parent._commentManager;
    super(parameters, {
      isRenderable: !hasCommentManager && AnnotationElement._hasPopupData(data)
    });
    this.elements = elements;
    if (hasCommentManager && AnnotationElement._hasPopupData(data)) {
      const popup = this.popup = this.#createPopup();
      for (const element of elements) {
        element.popup = popup;
      }
    } else {
      this.popup = null;
    }
  }
  #createPopup() {
    return new PopupElement({
      container: this.container,
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate || this.data.creationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText,
      rect: this.data.rect,
      parentRect: this.data.parentRect || null,
      parent: this.parent,
      elements: this.elements,
      open: this.data.open,
      commentManager: this.parent._commentManager
    });
  }
  render() {
    const {
      container
    } = this;
    container.classList.add("popupAnnotation");
    container.role = "comment";
    const popup = this.popup = this.#createPopup();
    const elementIds = [];
    for (const element of this.elements) {
      element.popup = popup;
      element.container.ariaHasPopup = "dialog";
      elementIds.push(element.data.id);
      element.addHighlightArea();
    }
    this.container.setAttribute("aria-controls", elementIds.map((id) => `${AnnotationPrefix}${id}`).join(","));
    return this.container;
  }
};
var PopupElement = class {
  static {
    __name(this, "PopupElement");
  }
  #commentManager = null;
  #boundKeyDown = this.#keyDown.bind(this);
  #boundHide = this.#hide.bind(this);
  #boundShow = this.#show.bind(this);
  #boundToggle = this.#toggle.bind(this);
  #color = null;
  #container = null;
  #contentsObj = null;
  #dateObj = null;
  #elements = null;
  #parent = null;
  #parentRect = null;
  #pinned = false;
  #popup = null;
  #popupAbortController = null;
  #position = null;
  #commentButton = null;
  #commentButtonPosition = null;
  #popupPosition = null;
  #rect = null;
  #richText = null;
  #titleObj = null;
  #updates = null;
  #wasVisible = false;
  #firstElement = null;
  #commentText = null;
  constructor({
    container,
    color,
    elements,
    titleObj,
    modificationDate,
    contentsObj,
    richText,
    parent,
    rect,
    parentRect,
    open,
    commentManager = null
  }) {
    this.#container = container;
    this.#titleObj = titleObj;
    this.#contentsObj = contentsObj;
    this.#richText = richText;
    this.#parent = parent;
    this.#color = color;
    this.#rect = rect;
    this.#parentRect = parentRect;
    this.#elements = elements;
    this.#commentManager = commentManager;
    this.#firstElement = elements[0];
    this.#dateObj = PDFDateString.toDateObject(modificationDate);
    this.trigger = elements.flatMap((e10) => e10.getElementsToTriggerPopup());
    if (commentManager) {
      this.renderCommentButton();
    } else {
      this.#addEventListeners();
      this.#container.hidden = true;
      if (open) {
        this.#toggle();
      }
    }
  }
  #addEventListeners() {
    if (this.#popupAbortController) {
      return;
    }
    this.#popupAbortController = new AbortController();
    const {
      signal
    } = this.#popupAbortController;
    for (const element of this.trigger) {
      element.addEventListener("click", this.#boundToggle, {
        signal
      });
      element.addEventListener("pointerenter", this.#boundShow, {
        signal
      });
      element.addEventListener("pointerleave", this.#boundHide, {
        signal
      });
      element.classList.add("popupTriggerArea");
    }
    for (const element of this.#elements) {
      element.container?.addEventListener("keydown", this.#boundKeyDown, {
        signal
      });
    }
  }
  #setCommentButtonPosition() {
    const element = this.#elements.find((e10) => e10.hasCommentButton);
    if (!element) {
      return;
    }
    this.#commentButtonPosition = element._normalizePoint(element.commentButtonPosition);
  }
  renderCommentButton() {
    if (this.#commentButton) {
      return;
    }
    if (!this.#commentButtonPosition) {
      this.#setCommentButtonPosition();
    }
    if (!this.#commentButtonPosition) {
      return;
    }
    const {
      signal
    } = this.#popupAbortController = new AbortController();
    const hasOwnButton = !!this.#firstElement.extraPopupElement;
    const togglePopup = /* @__PURE__ */ __name(() => {
      this.#commentManager.toggleCommentPopup(this, true, void 0, !hasOwnButton);
    }, "togglePopup");
    const showPopup = /* @__PURE__ */ __name(() => {
      this.#commentManager.toggleCommentPopup(this, false, true, !hasOwnButton);
    }, "showPopup");
    const hidePopup = /* @__PURE__ */ __name(() => {
      this.#commentManager.toggleCommentPopup(this, false, false);
    }, "hidePopup");
    if (!hasOwnButton) {
      const button = this.#commentButton = document.createElement("button");
      button.className = "annotationCommentButton";
      const parentContainer = this.#firstElement.container;
      button.style.zIndex = parentContainer.style.zIndex + 1;
      button.tabIndex = 0;
      button.ariaHasPopup = "dialog";
      button.ariaControls = "commentPopup";
      button.setAttribute("data-l10n-id", "pdfjs-show-comment-button");
      this.#updateColor();
      this.#updateCommentButtonPosition();
      button.addEventListener("keydown", this.#boundKeyDown, {
        signal
      });
      button.addEventListener("click", togglePopup, {
        signal
      });
      button.addEventListener("pointerenter", showPopup, {
        signal
      });
      button.addEventListener("pointerleave", hidePopup, {
        signal
      });
      parentContainer.after(button);
    } else {
      this.#commentButton = this.#firstElement.container;
      for (const element of this.trigger) {
        element.ariaHasPopup = "dialog";
        element.ariaControls = "commentPopup";
        element.addEventListener("keydown", this.#boundKeyDown, {
          signal
        });
        element.addEventListener("click", togglePopup, {
          signal
        });
        element.addEventListener("pointerenter", showPopup, {
          signal
        });
        element.addEventListener("pointerleave", hidePopup, {
          signal
        });
        element.classList.add("popupTriggerArea");
      }
    }
  }
  #updateCommentButtonPosition() {
    if (this.#firstElement.extraPopupElement && !this.#firstElement.editor) {
      return;
    }
    this.renderCommentButton();
    const [x3, y12] = this.#commentButtonPosition;
    const {
      style
    } = this.#commentButton;
    style.left = `calc(${x3}%)`;
    style.top = `calc(${y12}% - var(--comment-button-dim))`;
  }
  #updateColor() {
    if (this.#firstElement.extraPopupElement) {
      return;
    }
    this.renderCommentButton();
    this.#commentButton.style.backgroundColor = this.commentButtonColor || "";
  }
  get commentButtonColor() {
    const {
      color,
      opacity
    } = this.#firstElement.commentData;
    if (!color) {
      return null;
    }
    return this.#parent._commentManager.makeCommentColor(color, opacity);
  }
  focusCommentButton() {
    setTimeout(() => {
      this.#commentButton?.focus();
    }, 0);
  }
  getData() {
    const {
      richText,
      color,
      opacity,
      creationDate,
      modificationDate
    } = this.#firstElement.commentData;
    return {
      contentsObj: {
        str: this.comment
      },
      richText,
      color,
      opacity,
      creationDate,
      modificationDate
    };
  }
  get elementBeforePopup() {
    return this.#commentButton;
  }
  get comment() {
    this.#commentText ||= this.#firstElement.commentText;
    return this.#commentText;
  }
  set comment(text) {
    if (text === this.comment) {
      return;
    }
    this.#firstElement.commentText = this.#commentText = text;
  }
  get parentBoundingClientRect() {
    return this.#firstElement.layer.getBoundingClientRect();
  }
  setCommentButtonStates({
    selected,
    hasPopup
  }) {
    if (!this.#commentButton) {
      return;
    }
    this.#commentButton.classList.toggle("selected", selected);
    this.#commentButton.ariaExpanded = hasPopup;
  }
  setSelectedCommentButton(selected) {
    this.#commentButton.classList.toggle("selected", selected);
  }
  get commentPopupPosition() {
    if (this.#popupPosition) {
      return this.#popupPosition;
    }
    const {
      x: x3,
      y: y12,
      height
    } = this.#commentButton.getBoundingClientRect();
    const {
      x: parentX,
      y: parentY,
      width: parentWidth,
      height: parentHeight
    } = this.#firstElement.layer.getBoundingClientRect();
    return [(x3 - parentX) / parentWidth, (y12 + height - parentY) / parentHeight];
  }
  set commentPopupPosition(pos) {
    this.#popupPosition = pos;
  }
  hasDefaultPopupPosition() {
    return this.#popupPosition === null;
  }
  get commentButtonPosition() {
    return this.#commentButtonPosition;
  }
  get commentButtonWidth() {
    return this.#commentButton.getBoundingClientRect().width / this.parentBoundingClientRect.width;
  }
  editComment(options) {
    const [posX, posY] = this.#popupPosition || this.commentButtonPosition.map((x3) => x3 / 100);
    const parentDimensions = this.parentBoundingClientRect;
    const {
      x: parentX,
      y: parentY,
      width: parentWidth,
      height: parentHeight
    } = parentDimensions;
    this.#commentManager.showDialog(null, this, parentX + posX * parentWidth, parentY + posY * parentHeight, {
      ...options,
      parentDimensions
    });
  }
  render() {
    if (this.#popup) {
      return;
    }
    const popup = this.#popup = document.createElement("div");
    popup.className = "popup";
    if (this.#color) {
      const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);
      popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
    }
    const header = document.createElement("span");
    header.className = "header";
    if (this.#titleObj?.str) {
      const title = document.createElement("span");
      title.className = "title";
      header.append(title);
      ({
        dir: title.dir,
        str: title.textContent
      } = this.#titleObj);
    }
    popup.append(header);
    if (this.#dateObj) {
      const modificationDate = document.createElement("time");
      modificationDate.className = "popupDate";
      modificationDate.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string");
      modificationDate.setAttribute("data-l10n-args", JSON.stringify({
        dateObj: this.#dateObj.valueOf()
      }));
      modificationDate.dateTime = this.#dateObj.toISOString();
      header.append(modificationDate);
    }
    renderRichText({
      html: this.#html || this.#contentsObj.str,
      dir: this.#contentsObj?.dir,
      className: "popupContent"
    }, popup);
    this.#container.append(popup);
  }
  get #html() {
    const richText = this.#richText;
    const contentsObj = this.#contentsObj;
    if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {
      return this.#richText.html || null;
    }
    return null;
  }
  get #fontSize() {
    return this.#html?.attributes?.style?.fontSize || 0;
  }
  get #fontColor() {
    return this.#html?.attributes?.style?.color || null;
  }
  #makePopupContent(text) {
    const popupLines = [];
    const popupContent = {
      str: text,
      html: {
        name: "div",
        attributes: {
          dir: "auto"
        },
        children: [{
          name: "p",
          children: popupLines
        }]
      }
    };
    const lineAttributes = {
      style: {
        color: this.#fontColor,
        fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--total-scale-factor))` : ""
      }
    };
    for (const line of text.split("\n")) {
      popupLines.push({
        name: "span",
        value: line,
        attributes: lineAttributes
      });
    }
    return popupContent;
  }
  #keyDown(event) {
    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
      return;
    }
    if (event.key === "Enter" || event.key === "Escape" && this.#pinned) {
      this.#toggle();
    }
  }
  updateEdited({
    rect,
    popup,
    deleted
  }) {
    if (this.#commentManager) {
      if (deleted) {
        this.remove();
        this.#commentText = null;
      } else if (popup) {
        if (popup.deleted) {
          this.remove();
        } else {
          this.#updateColor();
          this.#commentText = popup.text;
        }
      }
      if (rect) {
        this.#commentButtonPosition = null;
        this.#setCommentButtonPosition();
        this.#updateCommentButtonPosition();
      }
      return;
    }
    if (deleted || popup?.deleted) {
      this.remove();
      return;
    }
    this.#addEventListeners();
    this.#updates ||= {
      contentsObj: this.#contentsObj,
      richText: this.#richText
    };
    if (rect) {
      this.#position = null;
    }
    if (popup && popup.text) {
      this.#richText = this.#makePopupContent(popup.text);
      this.#dateObj = PDFDateString.toDateObject(popup.date);
      this.#contentsObj = null;
    }
    this.#popup?.remove();
    this.#popup = null;
  }
  resetEdited() {
    if (!this.#updates) {
      return;
    }
    ({
      contentsObj: this.#contentsObj,
      richText: this.#richText
    } = this.#updates);
    this.#updates = null;
    this.#popup?.remove();
    this.#popup = null;
    this.#position = null;
  }
  remove() {
    this.#popupAbortController?.abort();
    this.#popupAbortController = null;
    this.#popup?.remove();
    this.#popup = null;
    this.#wasVisible = false;
    this.#pinned = false;
    this.#commentButton?.remove();
    this.#commentButton = null;
    if (this.trigger) {
      for (const element of this.trigger) {
        element.classList.remove("popupTriggerArea");
      }
    }
  }
  #setPosition() {
    if (this.#position !== null) {
      return;
    }
    const {
      page: {
        view
      },
      viewport: {
        rawDims: {
          pageWidth,
          pageHeight,
          pageX,
          pageY
        }
      }
    } = this.#parent;
    let useParentRect = !!this.#parentRect;
    let rect = useParentRect ? this.#parentRect : this.#rect;
    for (const element of this.#elements) {
      if (!rect || Util.intersect(element.data.rect, rect) !== null) {
        rect = element.data.rect;
        useParentRect = true;
        break;
      }
    }
    const normalizedRect = Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);
    const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
    const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
    const popupLeft = normalizedRect[0] + parentWidth;
    const popupTop = normalizedRect[1];
    this.#position = [100 * (popupLeft - pageX) / pageWidth, 100 * (popupTop - pageY) / pageHeight];
    const {
      style
    } = this.#container;
    style.left = `${this.#position[0]}%`;
    style.top = `${this.#position[1]}%`;
  }
  #toggle() {
    if (this.#commentManager) {
      this.#commentManager.toggleCommentPopup(this, false);
      return;
    }
    this.#pinned = !this.#pinned;
    if (this.#pinned) {
      this.#show();
      this.#container.addEventListener("click", this.#boundToggle);
      this.#container.addEventListener("keydown", this.#boundKeyDown);
    } else {
      this.#hide();
      this.#container.removeEventListener("click", this.#boundToggle);
      this.#container.removeEventListener("keydown", this.#boundKeyDown);
    }
  }
  #show() {
    if (!this.#popup) {
      this.render();
    }
    if (!this.isVisible) {
      this.#setPosition();
      this.#container.hidden = false;
      this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1e3;
    } else if (this.#pinned) {
      this.#container.classList.add("focused");
    }
  }
  #hide() {
    this.#container.classList.remove("focused");
    if (this.#pinned || !this.isVisible) {
      return;
    }
    this.#container.hidden = true;
    this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1e3;
  }
  forceHide() {
    this.#wasVisible = this.isVisible;
    if (!this.#wasVisible) {
      return;
    }
    this.#container.hidden = true;
  }
  maybeShow() {
    if (this.#commentManager) {
      return;
    }
    this.#addEventListeners();
    if (!this.#wasVisible) {
      return;
    }
    if (!this.#popup) {
      this.#show();
    }
    this.#wasVisible = false;
    this.#container.hidden = false;
  }
  get isVisible() {
    if (this.#commentManager) {
      return false;
    }
    return this.#container.hidden === false;
  }
};
var FreeTextAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "FreeTextAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.textContent = parameters.data.textContent;
    this.textPosition = parameters.data.textPosition;
    this.annotationEditorType = AnnotationEditorType.FREETEXT;
  }
  render() {
    this.container.classList.add("freeTextAnnotation");
    if (this.textContent) {
      const content = document.createElement("div");
      content.classList.add("annotationTextContent");
      content.setAttribute("role", "comment");
      for (const line of this.textContent) {
        const lineSpan = document.createElement("span");
        lineSpan.textContent = line;
        content.append(lineSpan);
      }
      this.container.append(content);
    }
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this._editOnDoubleClick();
    return this.container;
  }
};
var LineAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "LineAnnotationElement");
  }
  #line = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const {
      data,
      width,
      height
    } = this;
    const svg = this.svgFactory.create(width, height, true);
    const line = this.#line = this.svgFactory.createElement("svg:line");
    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
    line.setAttribute("stroke-width", data.borderStyle.width || 1);
    line.setAttribute("stroke", "transparent");
    line.setAttribute("fill", "transparent");
    svg.append(line);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#line;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
var SquareAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "SquareAnnotationElement");
  }
  #square = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const {
      data,
      width,
      height
    } = this;
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const square = this.#square = this.svgFactory.createElement("svg:rect");
    square.setAttribute("x", borderWidth / 2);
    square.setAttribute("y", borderWidth / 2);
    square.setAttribute("width", width - borderWidth);
    square.setAttribute("height", height - borderWidth);
    square.setAttribute("stroke-width", borderWidth || 1);
    square.setAttribute("stroke", "transparent");
    square.setAttribute("fill", "transparent");
    svg.append(square);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#square;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
var CircleAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "CircleAnnotationElement");
  }
  #circle = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const {
      data,
      width,
      height
    } = this;
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const circle = this.#circle = this.svgFactory.createElement("svg:ellipse");
    circle.setAttribute("cx", width / 2);
    circle.setAttribute("cy", height / 2);
    circle.setAttribute("rx", width / 2 - borderWidth / 2);
    circle.setAttribute("ry", height / 2 - borderWidth / 2);
    circle.setAttribute("stroke-width", borderWidth || 1);
    circle.setAttribute("stroke", "transparent");
    circle.setAttribute("fill", "transparent");
    svg.append(circle);
    this.container.append(svg);
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#circle;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
var PolylineAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "PolylineAnnotationElement");
  }
  #polyline = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.containerClassName = "polylineAnnotation";
    this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect,
        vertices,
        borderStyle,
        popupRef
      },
      width,
      height
    } = this;
    if (!vertices) {
      return this.container;
    }
    const svg = this.svgFactory.create(width, height, true);
    let points = [];
    for (let i18 = 0, ii = vertices.length; i18 < ii; i18 += 2) {
      const x3 = vertices[i18] - rect[0];
      const y12 = rect[3] - vertices[i18 + 1];
      points.push(`${x3},${y12}`);
    }
    points = points.join(" ");
    const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);
    polyline.setAttribute("points", points);
    polyline.setAttribute("stroke-width", borderStyle.width || 1);
    polyline.setAttribute("stroke", "transparent");
    polyline.setAttribute("fill", "transparent");
    svg.append(polyline);
    this.container.append(svg);
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#polyline;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
var PolygonAnnotationElement = class extends PolylineAnnotationElement {
  static {
    __name(this, "PolygonAnnotationElement");
  }
  constructor(parameters) {
    super(parameters);
    this.containerClassName = "polygonAnnotation";
    this.svgElementName = "svg:polygon";
  }
};
var CaretAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "CaretAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("caretAnnotation");
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
};
var InkAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "InkAnnotationElement");
  }
  #polylinesGroupElement = null;
  #polylines = [];
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.containerClassName = "inkAnnotation";
    this.svgElementName = "svg:polyline";
    this.annotationEditorType = this.data.it === "InkHighlight" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;
  }
  #getTransform(rotation, rect) {
    switch (rotation) {
      case 90:
        return {
          transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,
          width: rect[3] - rect[1],
          height: rect[2] - rect[0]
        };
      case 180:
        return {
          transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,
          width: rect[2] - rect[0],
          height: rect[3] - rect[1]
        };
      case 270:
        return {
          transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,
          width: rect[3] - rect[1],
          height: rect[2] - rect[0]
        };
      default:
        return {
          transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,
          width: rect[2] - rect[0],
          height: rect[3] - rect[1]
        };
    }
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect,
        rotation,
        inkLists,
        borderStyle,
        popupRef
      }
    } = this;
    const {
      transform,
      width,
      height
    } = this.#getTransform(rotation, rect);
    const svg = this.svgFactory.create(width, height, true);
    const g10 = this.#polylinesGroupElement = this.svgFactory.createElement("svg:g");
    svg.append(g10);
    g10.setAttribute("stroke-width", borderStyle.width || 1);
    g10.setAttribute("stroke-linecap", "round");
    g10.setAttribute("stroke-linejoin", "round");
    g10.setAttribute("stroke-miterlimit", 10);
    g10.setAttribute("stroke", "transparent");
    g10.setAttribute("fill", "transparent");
    g10.setAttribute("transform", transform);
    for (let i18 = 0, ii = inkLists.length; i18 < ii; i18++) {
      const polyline = this.svgFactory.createElement(this.svgElementName);
      this.#polylines.push(polyline);
      polyline.setAttribute("points", inkLists[i18].join(","));
      g10.append(polyline);
    }
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.append(svg);
    this._editOnDoubleClick();
    return this.container;
  }
  updateEdited(params) {
    super.updateEdited(params);
    const {
      thickness,
      points,
      rect
    } = params;
    const g10 = this.#polylinesGroupElement;
    if (thickness >= 0) {
      g10.setAttribute("stroke-width", thickness || 1);
    }
    if (points) {
      for (let i18 = 0, ii = this.#polylines.length; i18 < ii; i18++) {
        this.#polylines[i18].setAttribute("points", points[i18].join(","));
      }
    }
    if (rect) {
      const {
        transform,
        width,
        height
      } = this.#getTransform(this.data.rotation, rect);
      const root = g10.parentElement;
      root.setAttribute("viewBox", `0 0 ${width} ${height}`);
      g10.setAttribute("transform", transform);
    }
  }
  getElementsToTriggerPopup() {
    return this.#polylines;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
var HighlightAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "HighlightAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
    this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;
  }
  render() {
    const {
      data: {
        overlaidText,
        popupRef
      }
    } = this;
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("highlightAnnotation");
    this._editOnDoubleClick();
    if (overlaidText) {
      const mark = document.createElement("mark");
      mark.classList.add("overlaidText");
      mark.textContent = overlaidText;
      this.container.append(mark);
    }
    return this.container;
  }
};
var UnderlineAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "UnderlineAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    const {
      data: {
        overlaidText,
        popupRef
      }
    } = this;
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("underlineAnnotation");
    if (overlaidText) {
      const underline = document.createElement("u");
      underline.classList.add("overlaidText");
      underline.textContent = overlaidText;
      this.container.append(underline);
    }
    return this.container;
  }
};
var SquigglyAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "SquigglyAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    const {
      data: {
        overlaidText,
        popupRef
      }
    } = this;
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("squigglyAnnotation");
    if (overlaidText) {
      const underline = document.createElement("u");
      underline.classList.add("overlaidText");
      underline.textContent = overlaidText;
      this.container.append(underline);
    }
    return this.container;
  }
};
var StrikeOutAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "StrikeOutAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    const {
      data: {
        overlaidText,
        popupRef
      }
    } = this;
    if (!popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("strikeoutAnnotation");
    if (overlaidText) {
      const strikeout = document.createElement("s");
      strikeout.classList.add("overlaidText");
      strikeout.textContent = overlaidText;
      this.container.append(strikeout);
    }
    return this.container;
  }
};
var StampAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "StampAnnotationElement");
  }
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.annotationEditorType = AnnotationEditorType.STAMP;
  }
  render() {
    this.container.classList.add("stampAnnotation");
    this.container.setAttribute("role", "img");
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this._editOnDoubleClick();
    return this.container;
  }
};
var FileAttachmentAnnotationElement = class extends AnnotationElement {
  static {
    __name(this, "FileAttachmentAnnotationElement");
  }
  #trigger = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true
    });
    const {
      file
    } = this.data;
    this.filename = file.filename;
    this.content = file.content;
    this.linkService.eventBus?.dispatch("fileattachmentannotation", {
      source: this,
      ...file
    });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const {
      container,
      data
    } = this;
    let trigger;
    if (data.hasAppearance || data.fillAlpha === 0) {
      trigger = document.createElement("div");
    } else {
      trigger = document.createElement("img");
      trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? "paperclip" : "pushpin"}.svg`;
      if (data.fillAlpha && data.fillAlpha < 1) {
        trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;
      }
    }
    trigger.addEventListener("dblclick", this.#download.bind(this));
    this.#trigger = trigger;
    const {
      isMac
    } = util_FeatureTest.platform;
    container.addEventListener("keydown", (evt) => {
      if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
        this.#download();
      }
    });
    if (!data.popupRef && this.hasPopupData) {
      this._createPopup();
    } else {
      trigger.classList.add("popupTriggerArea");
    }
    container.append(trigger);
    return container;
  }
  getElementsToTriggerPopup() {
    return this.#trigger;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
  #download() {
    this.downloadManager?.openOrDownloadData(this.content, this.filename);
  }
};
var AnnotationLayer = class _AnnotationLayer {
  static {
    __name(this, "AnnotationLayer");
  }
  #accessibilityManager = null;
  #annotationCanvasMap = null;
  #annotationStorage = null;
  #editableAnnotations = /* @__PURE__ */ new Map();
  #structTreeLayer = null;
  #linkService = null;
  constructor({
    div,
    accessibilityManager,
    annotationCanvasMap,
    annotationEditorUIManager,
    page,
    viewport,
    structTreeLayer,
    commentManager,
    linkService,
    annotationStorage
  }) {
    this.div = div;
    this.#accessibilityManager = accessibilityManager;
    this.#annotationCanvasMap = annotationCanvasMap;
    this.#structTreeLayer = structTreeLayer || null;
    this.#linkService = linkService || null;
    this.#annotationStorage = annotationStorage || new AnnotationStorage();
    this.page = page;
    this.viewport = viewport;
    this.zIndex = 0;
    this._annotationEditorUIManager = annotationEditorUIManager;
    this._commentManager = commentManager || null;
  }
  hasEditableAnnotations() {
    return this.#editableAnnotations.size > 0;
  }
  async #appendElement(element, id, popupElements) {
    const contentElement = element.firstChild || element;
    const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;
    const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);
    if (ariaAttributes) {
      for (const [key, value] of ariaAttributes) {
        contentElement.setAttribute(key, value);
      }
    }
    if (popupElements) {
      popupElements.at(-1).container.after(element);
    } else {
      this.div.append(element);
      this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);
    }
  }
  async render(params) {
    const {
      annotations
    } = params;
    const layer = this.div;
    setLayerDimensions(layer, this.viewport);
    const popupToElements = /* @__PURE__ */ new Map();
    const elementParams = {
      data: null,
      layer,
      linkService: this.#linkService,
      downloadManager: params.downloadManager,
      imageResourcesPath: params.imageResourcesPath || "",
      renderForms: params.renderForms !== false,
      svgFactory: new DOMSVGFactory(),
      annotationStorage: this.#annotationStorage,
      enableComment: params.enableComment === true,
      enableScripting: params.enableScripting === true,
      hasJSActions: params.hasJSActions,
      fieldObjects: params.fieldObjects,
      parent: this,
      elements: null
    };
    for (const data of annotations) {
      if (data.noHTML) {
        continue;
      }
      const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;
      if (!isPopupAnnotation) {
        if (data.rect[2] === data.rect[0] || data.rect[3] === data.rect[1]) {
          continue;
        }
      } else {
        const elements = popupToElements.get(data.id);
        if (!elements) {
          continue;
        }
        elementParams.elements = elements;
      }
      elementParams.data = data;
      const element = AnnotationElementFactory.create(elementParams);
      if (!element.isRenderable) {
        continue;
      }
      if (!isPopupAnnotation && data.popupRef) {
        const elements = popupToElements.get(data.popupRef);
        if (!elements) {
          popupToElements.set(data.popupRef, [element]);
        } else {
          elements.push(element);
        }
      }
      const rendered = element.render();
      if (data.hidden) {
        rendered.style.visibility = "hidden";
      }
      await this.#appendElement(rendered, data.id, elementParams.elements);
      element.extraPopupElement?.popup?.renderCommentButton();
      if (element._isEditable) {
        this.#editableAnnotations.set(element.data.id, element);
        this._annotationEditorUIManager?.renderAnnotationElement(element);
      }
    }
    this.#setAnnotationCanvasMap();
  }
  async addLinkAnnotations(annotations) {
    const elementParams = {
      data: null,
      layer: this.div,
      linkService: this.#linkService,
      svgFactory: new DOMSVGFactory(),
      parent: this
    };
    for (const data of annotations) {
      data.borderStyle ||= _AnnotationLayer._defaultBorderStyle;
      elementParams.data = data;
      const element = AnnotationElementFactory.create(elementParams);
      if (!element.isRenderable) {
        continue;
      }
      const rendered = element.render();
      await this.#appendElement(rendered, data.id, null);
    }
  }
  update({
    viewport
  }) {
    const layer = this.div;
    this.viewport = viewport;
    setLayerDimensions(layer, {
      rotation: viewport.rotation
    });
    this.#setAnnotationCanvasMap();
    layer.hidden = false;
  }
  #setAnnotationCanvasMap() {
    if (!this.#annotationCanvasMap) {
      return;
    }
    const layer = this.div;
    for (const [id, canvas] of this.#annotationCanvasMap) {
      const element = layer.querySelector(`[data-annotation-id="${id}"]`);
      if (!element) {
        continue;
      }
      canvas.className = "annotationContent";
      const {
        firstChild
      } = element;
      if (!firstChild) {
        element.append(canvas);
      } else if (firstChild.nodeName === "CANVAS") {
        firstChild.replaceWith(canvas);
      } else if (!firstChild.classList.contains("annotationContent")) {
        firstChild.before(canvas);
      } else {
        firstChild.after(canvas);
      }
      const editableAnnotation = this.#editableAnnotations.get(id);
      if (!editableAnnotation) {
        continue;
      }
      if (editableAnnotation._hasNoCanvas) {
        this._annotationEditorUIManager?.setMissingCanvas(id, element.id, canvas);
        editableAnnotation._hasNoCanvas = false;
      } else {
        editableAnnotation.canvas = canvas;
      }
    }
    this.#annotationCanvasMap.clear();
  }
  getEditableAnnotations() {
    return Array.from(this.#editableAnnotations.values());
  }
  getEditableAnnotation(id) {
    return this.#editableAnnotations.get(id);
  }
  addFakeAnnotation(editor) {
    const {
      div
    } = this;
    const {
      id,
      rotation
    } = editor;
    const element = new EditorAnnotationElement({
      data: {
        id,
        rect: editor.getPDFRect(),
        rotation
      },
      editor,
      layer: div,
      parent: this,
      enableComment: !!this._commentManager,
      linkService: this.#linkService,
      annotationStorage: this.#annotationStorage
    });
    const htmlElement = element.render();
    div.append(htmlElement);
    this.#accessibilityManager?.moveElementInDOM(div, htmlElement, htmlElement, false);
    element.createOrUpdatePopup();
    return element;
  }
  static get _defaultBorderStyle() {
    return shadow(this, "_defaultBorderStyle", Object.freeze({
      width: 1,
      rawWidth: 1,
      style: AnnotationBorderStyleType.SOLID,
      dashArray: [3],
      horizontalCornerRadius: 0,
      verticalCornerRadius: 0
    }));
  }
};
;
var EOL_PATTERN = /\r\n?|\n/g;
var FreeTextEditor = class _FreeTextEditor extends AnnotationEditor {
  static {
    __name(this, "FreeTextEditor");
  }
  #content = "";
  #editorDivId = `${this.id}-editor`;
  #editModeAC = null;
  #fontSize;
  _colorPicker = null;
  static _freeTextDefaultContent = "";
  static _internalPadding = 0;
  static _defaultColor = null;
  static _defaultFontSize = 10;
  static get _keyboardManager() {
    const proto = _FreeTextEditor.prototype;
    const arrowChecker = /* @__PURE__ */ __name((self2) => self2.isEmpty(), "arrowChecker");
    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
    const big = AnnotationEditorUIManager.TRANSLATE_BIG;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], proto.commitOrRemove, {
      bubbles: true
    }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], proto.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], proto._translateEmpty, {
      args: [-small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto._translateEmpty, {
      args: [-big, 0],
      checker: arrowChecker
    }], [["ArrowRight", "mac+ArrowRight"], proto._translateEmpty, {
      args: [small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto._translateEmpty, {
      args: [big, 0],
      checker: arrowChecker
    }], [["ArrowUp", "mac+ArrowUp"], proto._translateEmpty, {
      args: [0, -small],
      checker: arrowChecker
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto._translateEmpty, {
      args: [0, -big],
      checker: arrowChecker
    }], [["ArrowDown", "mac+ArrowDown"], proto._translateEmpty, {
      args: [0, small],
      checker: arrowChecker
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto._translateEmpty, {
      args: [0, big],
      checker: arrowChecker
    }]]));
  }
  static _type = "freetext";
  static _editorType = AnnotationEditorType.FREETEXT;
  constructor(params) {
    super({
      ...params,
      name: "freeTextEditor"
    });
    this.color = params.color || _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;
    this.#fontSize = params.fontSize || _FreeTextEditor._defaultFontSize;
    if (!this.annotationElementId) {
      this._uiManager.a11yAlert("pdfjs-editor-freetext-added-alert");
    }
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
    const style = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.FREETEXT_SIZE:
        _FreeTextEditor._defaultFontSize = value;
        break;
      case AnnotationEditorParamsType.FREETEXT_COLOR:
        _FreeTextEditor._defaultColor = value;
        break;
    }
  }
  updateParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.FREETEXT_SIZE:
        this.#updateFontSize(value);
        break;
      case AnnotationEditorParamsType.FREETEXT_COLOR:
        this.#updateColor(value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[AnnotationEditorParamsType.FREETEXT_SIZE, _FreeTextEditor._defaultFontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, this.color]];
  }
  get toolbarButtons() {
    this._colorPicker ||= new BasicColorPicker(this);
    return [["colorPicker", this._colorPicker]];
  }
  get colorType() {
    return AnnotationEditorParamsType.FREETEXT_COLOR;
  }
  #updateFontSize(fontSize) {
    const setFontsize = /* @__PURE__ */ __name((size) => {
      this.editorDiv.style.fontSize = `calc(${size}px * var(--total-scale-factor))`;
      this.translate(0, -(size - this.#fontSize) * this.parentScale);
      this.#fontSize = size;
      this.#setEditorDimensions();
    }, "setFontsize");
    const savedFontsize = this.#fontSize;
    this.addCommands({
      cmd: setFontsize.bind(this, fontSize),
      undo: setFontsize.bind(this, savedFontsize),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType.FREETEXT_SIZE,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  onUpdatedColor() {
    this.editorDiv.style.color = this.color;
    this._colorPicker?.update(this.color);
    super.onUpdatedColor();
  }
  #updateColor(color) {
    const setColor = /* @__PURE__ */ __name((col) => {
      this.color = col;
      this.onUpdatedColor();
    }, "setColor");
    const savedColor = this.color;
    this.addCommands({
      cmd: setColor.bind(this, color),
      undo: setColor.bind(this, savedColor),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType.FREETEXT_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  _translateEmpty(x3, y12) {
    this._uiManager.translateSelectedEditors(x3, y12, true);
  }
  getInitialTranslation() {
    const scale = this.parentScale;
    return [-_FreeTextEditor._internalPadding * scale, -(_FreeTextEditor._internalPadding + this.#fontSize) * scale];
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  enableEditMode() {
    if (!super.enableEditMode()) {
      return false;
    }
    this.overlayDiv.classList.remove("enabled");
    this.editorDiv.contentEditable = true;
    this._isDraggable = false;
    this.div.removeAttribute("aria-activedescendant");
    this.#editModeAC = new AbortController();
    const signal = this._uiManager.combinedSignal(this.#editModeAC);
    this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), {
      signal
    });
    this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
      signal
    });
    this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
      signal
    });
    this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
      signal
    });
    this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
      signal
    });
    return true;
  }
  disableEditMode() {
    if (!super.disableEditMode()) {
      return false;
    }
    this.overlayDiv.classList.add("enabled");
    this.editorDiv.contentEditable = false;
    this.div.setAttribute("aria-activedescendant", this.#editorDivId);
    this._isDraggable = true;
    this.#editModeAC?.abort();
    this.#editModeAC = null;
    this.div.focus({
      preventScroll: true
    });
    this.isEditing = false;
    this.parent.div.classList.add("freetextEditing");
    return true;
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    super.focusin(event);
    if (event.target !== this.editorDiv) {
      this.editorDiv.focus();
    }
  }
  onceAdded(focus) {
    if (this.width) {
      return;
    }
    this.enableEditMode();
    if (focus) {
      this.editorDiv.focus();
    }
    if (this._initialOptions?.isCentered) {
      this.center();
    }
    this._initialOptions = null;
  }
  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }
  remove() {
    this.isEditing = false;
    if (this.parent) {
      this.parent.setEditingState(true);
      this.parent.div.classList.add("freetextEditing");
    }
    super.remove();
  }
  #extractText() {
    const buffer = [];
    this.editorDiv.normalize();
    let prevChild = null;
    for (const child of this.editorDiv.childNodes) {
      if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === "BR") {
        continue;
      }
      buffer.push(_FreeTextEditor.#getNodeContent(child));
      prevChild = child;
    }
    return buffer.join("\n");
  }
  #setEditorDimensions() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    let rect;
    if (this.isAttachedToDOM) {
      rect = this.div.getBoundingClientRect();
    } else {
      const {
        currentLayer,
        div
      } = this;
      const savedDisplay = div.style.display;
      const savedVisibility = div.classList.contains("hidden");
      div.classList.remove("hidden");
      div.style.display = "hidden";
      currentLayer.div.append(this.div);
      rect = div.getBoundingClientRect();
      div.remove();
      div.style.display = savedDisplay;
      div.classList.toggle("hidden", savedVisibility);
    }
    if (this.rotation % 180 === this.parentRotation % 180) {
      this.width = rect.width / parentWidth;
      this.height = rect.height / parentHeight;
    } else {
      this.width = rect.height / parentWidth;
      this.height = rect.width / parentHeight;
    }
    this.fixAndSetPosition();
  }
  commit() {
    if (!this.isInEditMode()) {
      return;
    }
    super.commit();
    this.disableEditMode();
    const savedText = this.#content;
    const newText = this.#content = this.#extractText().trimEnd();
    if (savedText === newText) {
      return;
    }
    const setText = /* @__PURE__ */ __name((text) => {
      this.#content = text;
      if (!text) {
        this.remove();
        return;
      }
      this.#setContent();
      this._uiManager.rebuild(this);
      this.#setEditorDimensions();
    }, "setText");
    this.addCommands({
      cmd: /* @__PURE__ */ __name(() => {
        setText(newText);
      }, "cmd"),
      undo: /* @__PURE__ */ __name(() => {
        setText(savedText);
      }, "undo"),
      mustExec: false
    });
    this.#setEditorDimensions();
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode();
    this.editorDiv.focus();
  }
  keydown(event) {
    if (event.target === this.div && event.key === "Enter") {
      this.enterInEditMode();
      event.preventDefault();
    }
  }
  editorDivKeydown(event) {
    _FreeTextEditor._keyboardManager.exec(this, event);
  }
  editorDivFocus(event) {
    this.isEditing = true;
  }
  editorDivBlur(event) {
    this.isEditing = false;
  }
  editorDivInput(event) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment");
    this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox");
    this.editorDiv.setAttribute("aria-multiline", true);
  }
  get canChangeContent() {
    return true;
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this._isCopy || this.annotationElementId) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.editorDiv = document.createElement("div");
    this.editorDiv.className = "internal";
    this.editorDiv.setAttribute("id", this.#editorDivId);
    this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2");
    this.editorDiv.setAttribute("data-l10n-attrs", "default-content");
    this.enableEditing();
    this.editorDiv.contentEditable = true;
    const {
      style
    } = this.editorDiv;
    style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;
    style.color = this.color;
    this.div.append(this.editorDiv);
    this.overlayDiv = document.createElement("div");
    this.overlayDiv.classList.add("overlay", "enabled");
    this.div.append(this.overlayDiv);
    if (this._isCopy || this.annotationElementId) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      if (this.annotationElementId) {
        const {
          position
        } = this._initialData;
        let [tx, ty] = this.getInitialTranslation();
        [tx, ty] = this.pageTranslationToScreen(tx, ty);
        const [pageWidth, pageHeight] = this.pageDimensions;
        const [pageX, pageY] = this.pageTranslation;
        let posX, posY;
        switch (this.rotation) {
          case 0:
            posX = baseX + (position[0] - pageX) / pageWidth;
            posY = baseY + this.height - (position[1] - pageY) / pageHeight;
            break;
          case 90:
            posX = baseX + (position[0] - pageX) / pageWidth;
            posY = baseY - (position[1] - pageY) / pageHeight;
            [tx, ty] = [ty, -tx];
            break;
          case 180:
            posX = baseX - this.width + (position[0] - pageX) / pageWidth;
            posY = baseY - (position[1] - pageY) / pageHeight;
            [tx, ty] = [-tx, -ty];
            break;
          case 270:
            posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;
            posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;
            [tx, ty] = [-ty, tx];
            break;
        }
        this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
      } else {
        this._moveAfterPaste(baseX, baseY);
      }
      this.#setContent();
      this._isDraggable = true;
      this.editorDiv.contentEditable = false;
    } else {
      this._isDraggable = false;
      this.editorDiv.contentEditable = true;
    }
    return this.div;
  }
  static #getNodeContent(node) {
    return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, "");
  }
  editorDivPaste(event) {
    const clipboardData = event.clipboardData || window.clipboardData;
    const {
      types
    } = clipboardData;
    if (types.length === 1 && types[0] === "text/plain") {
      return;
    }
    event.preventDefault();
    const paste = _FreeTextEditor.#deserializeContent(clipboardData.getData("text") || "").replaceAll(EOL_PATTERN, "\n");
    if (!paste) {
      return;
    }
    const selection = window.getSelection();
    if (!selection.rangeCount) {
      return;
    }
    this.editorDiv.normalize();
    selection.deleteFromDocument();
    const range = selection.getRangeAt(0);
    if (!paste.includes("\n")) {
      range.insertNode(document.createTextNode(paste));
      this.editorDiv.normalize();
      selection.collapseToStart();
      return;
    }
    const {
      startContainer,
      startOffset
    } = range;
    const bufferBefore = [];
    const bufferAfter = [];
    if (startContainer.nodeType === Node.TEXT_NODE) {
      const parent = startContainer.parentElement;
      bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, ""));
      if (parent !== this.editorDiv) {
        let buffer = bufferBefore;
        for (const child of this.editorDiv.childNodes) {
          if (child === parent) {
            buffer = bufferAfter;
            continue;
          }
          buffer.push(_FreeTextEditor.#getNodeContent(child));
        }
      }
      bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, ""));
    } else if (startContainer === this.editorDiv) {
      let buffer = bufferBefore;
      let i18 = 0;
      for (const child of this.editorDiv.childNodes) {
        if (i18++ === startOffset) {
          buffer = bufferAfter;
        }
        buffer.push(_FreeTextEditor.#getNodeContent(child));
      }
    }
    this.#content = `${bufferBefore.join("\n")}${paste}${bufferAfter.join("\n")}`;
    this.#setContent();
    const newRange = new Range();
    let beforeLength = Math.sumPrecise(bufferBefore.map((line) => line.length));
    for (const {
      firstChild
    } of this.editorDiv.childNodes) {
      if (firstChild.nodeType === Node.TEXT_NODE) {
        const length = firstChild.nodeValue.length;
        if (beforeLength <= length) {
          newRange.setStart(firstChild, beforeLength);
          newRange.setEnd(firstChild, beforeLength);
          break;
        }
        beforeLength -= length;
      }
    }
    selection.removeAllRanges();
    selection.addRange(newRange);
  }
  #setContent() {
    this.editorDiv.replaceChildren();
    if (!this.#content) {
      return;
    }
    for (const line of this.#content.split("\n")) {
      const div = document.createElement("div");
      div.append(line ? document.createTextNode(line) : document.createElement("br"));
      this.editorDiv.append(div);
    }
  }
  #serializeContent() {
    return this.#content.replaceAll("\xA0", " ");
  }
  static #deserializeContent(content) {
    return content.replaceAll(" ", "\xA0");
  }
  get contentDiv() {
    return this.editorDiv;
  }
  getPDFRect() {
    const padding = _FreeTextEditor._internalPadding * this.parentScale;
    return this.getRect(padding, padding);
  }
  static async deserialize(data, parent, uiManager) {
    let initialData = null;
    if (data instanceof FreeTextAnnotationElement) {
      const {
        data: {
          defaultAppearanceData: {
            fontSize,
            fontColor
          },
          rect,
          rotation,
          id,
          popupRef,
          richText,
          contentsObj,
          creationDate,
          modificationDate
        },
        textContent,
        textPosition,
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      if (!textContent || textContent.length === 0) {
        return null;
      }
      initialData = data = {
        annotationType: AnnotationEditorType.FREETEXT,
        color: Array.from(fontColor),
        fontSize,
        value: textContent.join("\n"),
        position: textPosition,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        popupRef,
        comment: contentsObj?.str || null,
        richText,
        creationDate,
        modificationDate
      };
    }
    const editor = await super.deserialize(data, parent, uiManager);
    editor.#fontSize = data.fontSize;
    editor.color = Util.makeHexColor(...data.color);
    editor.#content = _FreeTextEditor.#deserializeContent(data.value);
    editor._initialData = initialData;
    if (data.comment) {
      editor.setCommentData(data);
    }
    return editor;
  }
  serialize(isForCopying = false) {
    if (this.isEmpty()) {
      return null;
    }
    if (this.deleted) {
      return this.serializeDeleted();
    }
    const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.color);
    const serialized = Object.assign(super.serialize(isForCopying), {
      color,
      fontSize: this.#fontSize,
      value: this.#serializeContent()
    });
    this.addComment(serialized);
    if (isForCopying) {
      serialized.isCopy = true;
      return serialized;
    }
    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
      return null;
    }
    serialized.id = this.annotationElementId;
    return serialized;
  }
  #hasElementChanged(serialized) {
    const {
      value,
      fontSize,
      color,
      pageIndex
    } = this._initialData;
    return this.hasEditedComment || this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c21, i18) => c21 !== color[i18]) || serialized.pageIndex !== pageIndex;
  }
  renderAnnotationElement(annotation) {
    const content = super.renderAnnotationElement(annotation);
    if (!content) {
      return null;
    }
    const {
      style
    } = content;
    style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;
    style.color = this.color;
    content.replaceChildren();
    for (const line of this.#content.split("\n")) {
      const div = document.createElement("div");
      div.append(line ? document.createTextNode(line) : document.createElement("br"));
      content.append(div);
    }
    annotation.updateEdited({
      rect: this.getPDFRect(),
      popup: this._uiManager.hasCommentManager() || this.hasEditedComment ? this.comment : {
        text: this.#content
      }
    });
    return content;
  }
  resetAnnotationElement(annotation) {
    super.resetAnnotationElement(annotation);
    annotation.resetEdited();
  }
};
;
var Outline = class {
  static {
    __name(this, "Outline");
  }
  static PRECISION = 1e-4;
  toSVGPath() {
    unreachable("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    unreachable("Abstract getter `box` must be implemented.");
  }
  serialize(_bbox, _rotation) {
    unreachable("Abstract method `serialize` must be implemented.");
  }
  static _rescale(src, tx, ty, sx, sy, dest) {
    dest ||= new Float32Array(src.length);
    for (let i18 = 0, ii = src.length; i18 < ii; i18 += 2) {
      dest[i18] = tx + src[i18] * sx;
      dest[i18 + 1] = ty + src[i18 + 1] * sy;
    }
    return dest;
  }
  static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {
    dest ||= new Float32Array(src.length);
    for (let i18 = 0, ii = src.length; i18 < ii; i18 += 2) {
      dest[i18] = tx + src[i18 + 1] * sx;
      dest[i18 + 1] = ty + src[i18] * sy;
    }
    return dest;
  }
  static _translate(src, tx, ty, dest) {
    dest ||= new Float32Array(src.length);
    for (let i18 = 0, ii = src.length; i18 < ii; i18 += 2) {
      dest[i18] = tx + src[i18];
      dest[i18 + 1] = ty + src[i18 + 1];
    }
    return dest;
  }
  static svgRound(x3) {
    return Math.round(x3 * 1e4);
  }
  static _normalizePoint(x3, y12, parentWidth, parentHeight, rotation) {
    switch (rotation) {
      case 90:
        return [1 - y12 / parentWidth, x3 / parentHeight];
      case 180:
        return [1 - x3 / parentWidth, 1 - y12 / parentHeight];
      case 270:
        return [y12 / parentWidth, 1 - x3 / parentHeight];
      default:
        return [x3 / parentWidth, y12 / parentHeight];
    }
  }
  static _normalizePagePoint(x3, y12, rotation) {
    switch (rotation) {
      case 90:
        return [1 - y12, x3];
      case 180:
        return [1 - x3, 1 - y12];
      case 270:
        return [y12, 1 - x3];
      default:
        return [x3, y12];
    }
  }
  static createBezierPoints(x1, y1, x22, y22, x3, y32) {
    return [(x1 + 5 * x22) / 6, (y1 + 5 * y22) / 6, (5 * x22 + x3) / 6, (5 * y22 + y32) / 6, (x22 + x3) / 2, (y22 + y32) / 2];
  }
};
;
var FreeDrawOutliner = class _FreeDrawOutliner {
  static {
    __name(this, "FreeDrawOutliner");
  }
  #box;
  #bottom = [];
  #innerMargin;
  #isLTR;
  #top = [];
  #last = new Float32Array(18);
  #lastX;
  #lastY;
  #min;
  #min_dist;
  #scaleFactor;
  #thickness;
  #points = [];
  static #MIN_DIST = 8;
  static #MIN_DIFF = 2;
  static #MIN = _FreeDrawOutliner.#MIN_DIST + _FreeDrawOutliner.#MIN_DIFF;
  constructor({
    x: x3,
    y: y12
  }, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
    this.#box = box;
    this.#thickness = thickness * scaleFactor;
    this.#isLTR = isLTR;
    this.#last.set([NaN, NaN, NaN, NaN, x3, y12], 6);
    this.#innerMargin = innerMargin;
    this.#min_dist = _FreeDrawOutliner.#MIN_DIST * scaleFactor;
    this.#min = _FreeDrawOutliner.#MIN * scaleFactor;
    this.#scaleFactor = scaleFactor;
    this.#points.push(x3, y12);
  }
  isEmpty() {
    return isNaN(this.#last[8]);
  }
  #getLastCoords() {
    const lastTop = this.#last.subarray(4, 6);
    const lastBottom = this.#last.subarray(16, 18);
    const [x3, y12, width, height] = this.#box;
    return [(this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x3) / width, (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y12) / height, (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x3) / width, (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y12) / height];
  }
  add({
    x: x3,
    y: y12
  }) {
    this.#lastX = x3;
    this.#lastY = y12;
    const [layerX, layerY, layerWidth, layerHeight] = this.#box;
    let [x1, y1, x22, y22] = this.#last.subarray(8, 12);
    const diffX = x3 - x22;
    const diffY = y12 - y22;
    const d15 = Math.hypot(diffX, diffY);
    if (d15 < this.#min) {
      return false;
    }
    const diffD = d15 - this.#min_dist;
    const K = diffD / d15;
    const shiftX = K * diffX;
    const shiftY = K * diffY;
    let x0 = x1;
    let y0 = y1;
    x1 = x22;
    y1 = y22;
    x22 += shiftX;
    y22 += shiftY;
    this.#points?.push(x3, y12);
    const nX = -shiftY / diffD;
    const nY = shiftX / diffD;
    const thX = nX * this.#thickness;
    const thY = nY * this.#thickness;
    this.#last.set(this.#last.subarray(2, 8), 0);
    this.#last.set([x22 + thX, y22 + thY], 4);
    this.#last.set(this.#last.subarray(14, 18), 12);
    this.#last.set([x22 - thX, y22 - thY], 16);
    if (isNaN(this.#last[6])) {
      if (this.#top.length === 0) {
        this.#last.set([x1 + thX, y1 + thY], 2);
        this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);
        this.#last.set([x1 - thX, y1 - thY], 14);
        this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);
      }
      this.#last.set([x0, y0, x1, y1, x22, y22], 6);
      return !this.isEmpty();
    }
    this.#last.set([x0, y0, x1, y1, x22, y22], 6);
    const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));
    if (angle < Math.PI / 2) {
      [x1, y1, x22, y22] = this.#last.subarray(2, 6);
      this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x22) / 2 - layerX) / layerWidth, ((y1 + y22) / 2 - layerY) / layerHeight);
      [x1, y1, x0, y0] = this.#last.subarray(14, 18);
      this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);
      return true;
    }
    [x0, y0, x1, y1, x22, y22] = this.#last.subarray(0, 6);
    this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x22) / 6 - layerX) / layerWidth, ((5 * y1 + y22) / 6 - layerY) / layerHeight, ((x1 + x22) / 2 - layerX) / layerWidth, ((y1 + y22) / 2 - layerY) / layerHeight);
    [x22, y22, x1, y1, x0, y0] = this.#last.subarray(12, 18);
    this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x22) / 6 - layerX) / layerWidth, ((5 * y1 + y22) / 6 - layerY) / layerHeight, ((x1 + x22) / 2 - layerX) / layerWidth, ((y1 + y22) / 2 - layerY) / layerHeight);
    return true;
  }
  toSVGPath() {
    if (this.isEmpty()) {
      return "";
    }
    const top = this.#top;
    const bottom = this.#bottom;
    if (isNaN(this.#last[6]) && !this.isEmpty()) {
      return this.#toSVGPathTwoPoints();
    }
    const buffer = [];
    buffer.push(`M${top[4]} ${top[5]}`);
    for (let i18 = 6; i18 < top.length; i18 += 6) {
      if (isNaN(top[i18])) {
        buffer.push(`L${top[i18 + 4]} ${top[i18 + 5]}`);
      } else {
        buffer.push(`C${top[i18]} ${top[i18 + 1]} ${top[i18 + 2]} ${top[i18 + 3]} ${top[i18 + 4]} ${top[i18 + 5]}`);
      }
    }
    this.#toSVGPathEnd(buffer);
    for (let i18 = bottom.length - 6; i18 >= 6; i18 -= 6) {
      if (isNaN(bottom[i18])) {
        buffer.push(`L${bottom[i18 + 4]} ${bottom[i18 + 5]}`);
      } else {
        buffer.push(`C${bottom[i18]} ${bottom[i18 + 1]} ${bottom[i18 + 2]} ${bottom[i18 + 3]} ${bottom[i18 + 4]} ${bottom[i18 + 5]}`);
      }
    }
    this.#toSVGPathStart(buffer);
    return buffer.join(" ");
  }
  #toSVGPathTwoPoints() {
    const [x3, y12, width, height] = this.#box;
    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
    return `M${(this.#last[2] - x3) / width} ${(this.#last[3] - y12) / height} L${(this.#last[4] - x3) / width} ${(this.#last[5] - y12) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x3) / width} ${(this.#last[17] - y12) / height} L${(this.#last[14] - x3) / width} ${(this.#last[15] - y12) / height} Z`;
  }
  #toSVGPathStart(buffer) {
    const bottom = this.#bottom;
    buffer.push(`L${bottom[4]} ${bottom[5]} Z`);
  }
  #toSVGPathEnd(buffer) {
    const [x3, y12, width, height] = this.#box;
    const lastTop = this.#last.subarray(4, 6);
    const lastBottom = this.#last.subarray(16, 18);
    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
    buffer.push(`L${(lastTop[0] - x3) / width} ${(lastTop[1] - y12) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x3) / width} ${(lastBottom[1] - y12) / height}`);
  }
  newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
    return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
  }
  getOutlines() {
    const top = this.#top;
    const bottom = this.#bottom;
    const last = this.#last;
    const [layerX, layerY, layerWidth, layerHeight] = this.#box;
    const points = new Float32Array((this.#points?.length ?? 0) + 2);
    for (let i18 = 0, ii = points.length - 2; i18 < ii; i18 += 2) {
      points[i18] = (this.#points[i18] - layerX) / layerWidth;
      points[i18 + 1] = (this.#points[i18 + 1] - layerY) / layerHeight;
    }
    points[points.length - 2] = (this.#lastX - layerX) / layerWidth;
    points[points.length - 1] = (this.#lastY - layerY) / layerHeight;
    if (isNaN(last[6]) && !this.isEmpty()) {
      return this.#getOutlineTwoPoints(points);
    }
    const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);
    let N2 = top.length;
    for (let i18 = 0; i18 < N2; i18 += 2) {
      if (isNaN(top[i18])) {
        outline[i18] = outline[i18 + 1] = NaN;
        continue;
      }
      outline[i18] = top[i18];
      outline[i18 + 1] = top[i18 + 1];
    }
    N2 = this.#getOutlineEnd(outline, N2);
    for (let i18 = bottom.length - 6; i18 >= 6; i18 -= 6) {
      for (let j2 = 0; j2 < 6; j2 += 2) {
        if (isNaN(bottom[i18 + j2])) {
          outline[N2] = outline[N2 + 1] = NaN;
          N2 += 2;
          continue;
        }
        outline[N2] = bottom[i18 + j2];
        outline[N2 + 1] = bottom[i18 + j2 + 1];
        N2 += 2;
      }
    }
    this.#getOutlineStart(outline, N2);
    return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
  }
  #getOutlineTwoPoints(points) {
    const last = this.#last;
    const [layerX, layerY, layerWidth, layerHeight] = this.#box;
    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
    const outline = new Float32Array(36);
    outline.set([NaN, NaN, NaN, NaN, (last[2] - layerX) / layerWidth, (last[3] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[4] - layerX) / layerWidth, (last[5] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (last[16] - layerX) / layerWidth, (last[17] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[14] - layerX) / layerWidth, (last[15] - layerY) / layerHeight], 0);
    return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
  }
  #getOutlineStart(outline, pos) {
    const bottom = this.#bottom;
    outline.set([NaN, NaN, NaN, NaN, bottom[4], bottom[5]], pos);
    return pos += 6;
  }
  #getOutlineEnd(outline, pos) {
    const lastTop = this.#last.subarray(4, 6);
    const lastBottom = this.#last.subarray(16, 18);
    const [layerX, layerY, layerWidth, layerHeight] = this.#box;
    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
    outline.set([NaN, NaN, NaN, NaN, (lastTop[0] - layerX) / layerWidth, (lastTop[1] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (lastBottom[0] - layerX) / layerWidth, (lastBottom[1] - layerY) / layerHeight], pos);
    return pos += 24;
  }
};
var FreeDrawOutline = class extends Outline {
  static {
    __name(this, "FreeDrawOutline");
  }
  #box;
  #bbox = new Float32Array(4);
  #innerMargin;
  #isLTR;
  #points;
  #scaleFactor;
  #outline;
  constructor(outline, points, box, scaleFactor, innerMargin, isLTR) {
    super();
    this.#outline = outline;
    this.#points = points;
    this.#box = box;
    this.#scaleFactor = scaleFactor;
    this.#innerMargin = innerMargin;
    this.#isLTR = isLTR;
    this.firstPoint = [NaN, NaN];
    this.lastPoint = [NaN, NaN];
    this.#computeMinMax(isLTR);
    const [x3, y12, width, height] = this.#bbox;
    for (let i18 = 0, ii = outline.length; i18 < ii; i18 += 2) {
      outline[i18] = (outline[i18] - x3) / width;
      outline[i18 + 1] = (outline[i18 + 1] - y12) / height;
    }
    for (let i18 = 0, ii = points.length; i18 < ii; i18 += 2) {
      points[i18] = (points[i18] - x3) / width;
      points[i18 + 1] = (points[i18 + 1] - y12) / height;
    }
  }
  toSVGPath() {
    const buffer = [`M${this.#outline[4]} ${this.#outline[5]}`];
    for (let i18 = 6, ii = this.#outline.length; i18 < ii; i18 += 6) {
      if (isNaN(this.#outline[i18])) {
        buffer.push(`L${this.#outline[i18 + 4]} ${this.#outline[i18 + 5]}`);
        continue;
      }
      buffer.push(`C${this.#outline[i18]} ${this.#outline[i18 + 1]} ${this.#outline[i18 + 2]} ${this.#outline[i18 + 3]} ${this.#outline[i18 + 4]} ${this.#outline[i18 + 5]}`);
    }
    buffer.push("Z");
    return buffer.join(" ");
  }
  serialize([blX, blY, trX, trY], rotation) {
    const width = trX - blX;
    const height = trY - blY;
    let outline;
    let points;
    switch (rotation) {
      case 0:
        outline = Outline._rescale(this.#outline, blX, trY, width, -height);
        points = Outline._rescale(this.#points, blX, trY, width, -height);
        break;
      case 90:
        outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);
        points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);
        break;
      case 180:
        outline = Outline._rescale(this.#outline, trX, blY, -width, height);
        points = Outline._rescale(this.#points, trX, blY, -width, height);
        break;
      case 270:
        outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);
        points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);
        break;
    }
    return {
      outline: Array.from(outline),
      points: [Array.from(points)]
    };
  }
  #computeMinMax(isLTR) {
    const outline = this.#outline;
    let lastX = outline[4];
    let lastY = outline[5];
    const minMax = [lastX, lastY, lastX, lastY];
    let firstPointX = lastX;
    let firstPointY = lastY;
    let lastPointX = lastX;
    let lastPointY = lastY;
    const ltrCallback = isLTR ? Math.max : Math.min;
    const bezierBbox = new Float32Array(4);
    for (let i18 = 6, ii = outline.length; i18 < ii; i18 += 6) {
      const x3 = outline[i18 + 4], y12 = outline[i18 + 5];
      if (isNaN(outline[i18])) {
        Util.pointBoundingBox(x3, y12, minMax);
        if (firstPointY > y12) {
          firstPointX = x3;
          firstPointY = y12;
        } else if (firstPointY === y12) {
          firstPointX = ltrCallback(firstPointX, x3);
        }
        if (lastPointY < y12) {
          lastPointX = x3;
          lastPointY = y12;
        } else if (lastPointY === y12) {
          lastPointX = ltrCallback(lastPointX, x3);
        }
      } else {
        bezierBbox[0] = bezierBbox[1] = Infinity;
        bezierBbox[2] = bezierBbox[3] = -Infinity;
        Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i18, i18 + 6), bezierBbox);
        Util.rectBoundingBox(bezierBbox[0], bezierBbox[1], bezierBbox[2], bezierBbox[3], minMax);
        if (firstPointY > bezierBbox[1]) {
          firstPointX = bezierBbox[0];
          firstPointY = bezierBbox[1];
        } else if (firstPointY === bezierBbox[1]) {
          firstPointX = ltrCallback(firstPointX, bezierBbox[0]);
        }
        if (lastPointY < bezierBbox[3]) {
          lastPointX = bezierBbox[2];
          lastPointY = bezierBbox[3];
        } else if (lastPointY === bezierBbox[3]) {
          lastPointX = ltrCallback(lastPointX, bezierBbox[2]);
        }
      }
      lastX = x3;
      lastY = y12;
    }
    const bbox = this.#bbox;
    bbox[0] = minMax[0] - this.#innerMargin;
    bbox[1] = minMax[1] - this.#innerMargin;
    bbox[2] = minMax[2] - minMax[0] + 2 * this.#innerMargin;
    bbox[3] = minMax[3] - minMax[1] + 2 * this.#innerMargin;
    this.firstPoint = [firstPointX, firstPointY];
    this.lastPoint = [lastPointX, lastPointY];
  }
  get box() {
    return this.#bbox;
  }
  newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
    return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
  }
  getNewOutline(thickness, innerMargin) {
    const [x3, y12, width, height] = this.#bbox;
    const [layerX, layerY, layerWidth, layerHeight] = this.#box;
    const sx = width * layerWidth;
    const sy = height * layerHeight;
    const tx = x3 * layerWidth + layerX;
    const ty = y12 * layerHeight + layerY;
    const outliner = this.newOutliner({
      x: this.#points[0] * sx + tx,
      y: this.#points[1] * sy + ty
    }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);
    for (let i18 = 2; i18 < this.#points.length; i18 += 2) {
      outliner.add({
        x: this.#points[i18] * sx + tx,
        y: this.#points[i18 + 1] * sy + ty
      });
    }
    return outliner.getOutlines();
  }
};
;
var HighlightOutliner = class {
  static {
    __name(this, "HighlightOutliner");
  }
  #box;
  #firstPoint;
  #lastPoint;
  #verticalEdges = [];
  #intervals = [];
  constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true) {
    const minMax = [Infinity, Infinity, -Infinity, -Infinity];
    const NUMBER_OF_DIGITS = 4;
    const EPSILON = 10 ** -NUMBER_OF_DIGITS;
    for (const {
      x: x3,
      y: y12,
      width,
      height
    } of boxes) {
      const x1 = Math.floor((x3 - borderWidth) / EPSILON) * EPSILON;
      const x22 = Math.ceil((x3 + width + borderWidth) / EPSILON) * EPSILON;
      const y1 = Math.floor((y12 - borderWidth) / EPSILON) * EPSILON;
      const y22 = Math.ceil((y12 + height + borderWidth) / EPSILON) * EPSILON;
      const left = [x1, y1, y22, true];
      const right = [x22, y1, y22, false];
      this.#verticalEdges.push(left, right);
      Util.rectBoundingBox(x1, y1, x22, y22, minMax);
    }
    const bboxWidth = minMax[2] - minMax[0] + 2 * innerMargin;
    const bboxHeight = minMax[3] - minMax[1] + 2 * innerMargin;
    const shiftedMinX = minMax[0] - innerMargin;
    const shiftedMinY = minMax[1] - innerMargin;
    let firstPointX = isLTR ? -Infinity : Infinity;
    let firstPointY = Infinity;
    const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);
    const lastPoint = [lastEdge[0], lastEdge[2]];
    for (const edge of this.#verticalEdges) {
      const [x3, y1, y22, left] = edge;
      if (!left && isLTR) {
        if (y1 < firstPointY) {
          firstPointY = y1;
          firstPointX = x3;
        } else if (y1 === firstPointY) {
          firstPointX = Math.max(firstPointX, x3);
        }
      } else if (left && !isLTR) {
        if (y1 < firstPointY) {
          firstPointY = y1;
          firstPointX = x3;
        } else if (y1 === firstPointY) {
          firstPointX = Math.min(firstPointX, x3);
        }
      }
      edge[0] = (x3 - shiftedMinX) / bboxWidth;
      edge[1] = (y1 - shiftedMinY) / bboxHeight;
      edge[2] = (y22 - shiftedMinY) / bboxHeight;
    }
    this.#box = new Float32Array([shiftedMinX, shiftedMinY, bboxWidth, bboxHeight]);
    this.#firstPoint = [firstPointX, firstPointY];
    this.#lastPoint = lastPoint;
  }
  getOutlines() {
    this.#verticalEdges.sort((a22, b7) => a22[0] - b7[0] || a22[1] - b7[1] || a22[2] - b7[2]);
    const outlineVerticalEdges = [];
    for (const edge of this.#verticalEdges) {
      if (edge[3]) {
        outlineVerticalEdges.push(...this.#breakEdge(edge));
        this.#insert(edge);
      } else {
        this.#remove(edge);
        outlineVerticalEdges.push(...this.#breakEdge(edge));
      }
    }
    return this.#getOutlines(outlineVerticalEdges);
  }
  #getOutlines(outlineVerticalEdges) {
    const edges = [];
    const allEdges = /* @__PURE__ */ new Set();
    for (const edge of outlineVerticalEdges) {
      const [x3, y1, y22] = edge;
      edges.push([x3, y1, edge], [x3, y22, edge]);
    }
    edges.sort((a22, b7) => a22[1] - b7[1] || a22[0] - b7[0]);
    for (let i18 = 0, ii = edges.length; i18 < ii; i18 += 2) {
      const edge1 = edges[i18][2];
      const edge2 = edges[i18 + 1][2];
      edge1.push(edge2);
      edge2.push(edge1);
      allEdges.add(edge1);
      allEdges.add(edge2);
    }
    const outlines = [];
    let outline;
    while (allEdges.size > 0) {
      const edge = allEdges.values().next().value;
      let [x3, y1, y22, edge1, edge2] = edge;
      allEdges.delete(edge);
      let lastPointX = x3;
      let lastPointY = y1;
      outline = [x3, y22];
      outlines.push(outline);
      while (true) {
        let e10;
        if (allEdges.has(edge1)) {
          e10 = edge1;
        } else if (allEdges.has(edge2)) {
          e10 = edge2;
        } else {
          break;
        }
        allEdges.delete(e10);
        [x3, y1, y22, edge1, edge2] = e10;
        if (lastPointX !== x3) {
          outline.push(lastPointX, lastPointY, x3, lastPointY === y1 ? y1 : y22);
          lastPointX = x3;
        }
        lastPointY = lastPointY === y1 ? y22 : y1;
      }
      outline.push(lastPointX, lastPointY);
    }
    return new HighlightOutline(outlines, this.#box, this.#firstPoint, this.#lastPoint);
  }
  #binarySearch(y12) {
    const array = this.#intervals;
    let start = 0;
    let end = array.length - 1;
    while (start <= end) {
      const middle = start + end >> 1;
      const y1 = array[middle][0];
      if (y1 === y12) {
        return middle;
      }
      if (y1 < y12) {
        start = middle + 1;
      } else {
        end = middle - 1;
      }
    }
    return end + 1;
  }
  #insert([, y1, y22]) {
    const index = this.#binarySearch(y1);
    this.#intervals.splice(index, 0, [y1, y22]);
  }
  #remove([, y1, y22]) {
    const index = this.#binarySearch(y1);
    for (let i18 = index; i18 < this.#intervals.length; i18++) {
      const [start, end] = this.#intervals[i18];
      if (start !== y1) {
        break;
      }
      if (start === y1 && end === y22) {
        this.#intervals.splice(i18, 1);
        return;
      }
    }
    for (let i18 = index - 1; i18 >= 0; i18--) {
      const [start, end] = this.#intervals[i18];
      if (start !== y1) {
        break;
      }
      if (start === y1 && end === y22) {
        this.#intervals.splice(i18, 1);
        return;
      }
    }
  }
  #breakEdge(edge) {
    const [x3, y1, y22] = edge;
    const results = [[x3, y1, y22]];
    const index = this.#binarySearch(y22);
    for (let i18 = 0; i18 < index; i18++) {
      const [start, end] = this.#intervals[i18];
      for (let j2 = 0, jj = results.length; j2 < jj; j2++) {
        const [, y32, y42] = results[j2];
        if (end <= y32 || y42 <= start) {
          continue;
        }
        if (y32 >= start) {
          if (y42 > end) {
            results[j2][1] = end;
          } else {
            if (jj === 1) {
              return [];
            }
            results.splice(j2, 1);
            j2--;
            jj--;
          }
          continue;
        }
        results[j2][2] = start;
        if (y42 > end) {
          results.push([x3, end, y42]);
        }
      }
    }
    return results;
  }
};
var HighlightOutline = class extends Outline {
  static {
    __name(this, "HighlightOutline");
  }
  #box;
  #outlines;
  constructor(outlines, box, firstPoint, lastPoint) {
    super();
    this.#outlines = outlines;
    this.#box = box;
    this.firstPoint = firstPoint;
    this.lastPoint = lastPoint;
  }
  toSVGPath() {
    const buffer = [];
    for (const polygon of this.#outlines) {
      let [prevX, prevY] = polygon;
      buffer.push(`M${prevX} ${prevY}`);
      for (let i18 = 2; i18 < polygon.length; i18 += 2) {
        const x3 = polygon[i18];
        const y12 = polygon[i18 + 1];
        if (x3 === prevX) {
          buffer.push(`V${y12}`);
          prevY = y12;
        } else if (y12 === prevY) {
          buffer.push(`H${x3}`);
          prevX = x3;
        }
      }
      buffer.push("Z");
    }
    return buffer.join(" ");
  }
  serialize([blX, blY, trX, trY], _rotation) {
    const outlines = [];
    const width = trX - blX;
    const height = trY - blY;
    for (const outline of this.#outlines) {
      const points = new Array(outline.length);
      for (let i18 = 0; i18 < outline.length; i18 += 2) {
        points[i18] = blX + outline[i18] * width;
        points[i18 + 1] = trY - outline[i18 + 1] * height;
      }
      outlines.push(points);
    }
    return outlines;
  }
  get box() {
    return this.#box;
  }
  get classNamesForOutlining() {
    return ["highlightOutline"];
  }
};
var FreeHighlightOutliner = class extends FreeDrawOutliner {
  static {
    __name(this, "FreeHighlightOutliner");
  }
  newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
    return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
  }
};
var FreeHighlightOutline = class extends FreeDrawOutline {
  static {
    __name(this, "FreeHighlightOutline");
  }
  newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
    return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
  }
};
;
var HighlightEditor = class _HighlightEditor extends AnnotationEditor {
  static {
    __name(this, "HighlightEditor");
  }
  #anchorNode = null;
  #anchorOffset = 0;
  #boxes;
  #clipPathId = null;
  #colorPicker = null;
  #focusOutlines = null;
  #focusNode = null;
  #focusOffset = 0;
  #highlightDiv = null;
  #highlightOutlines = null;
  #id = null;
  #isFreeHighlight = false;
  #firstPoint = null;
  #lastPoint = null;
  #outlineId = null;
  #text = "";
  #thickness;
  #methodOfCreation = "";
  static _defaultColor = null;
  static _defaultOpacity = 1;
  static _defaultThickness = 12;
  static _type = "highlight";
  static _editorType = AnnotationEditorType.HIGHLIGHT;
  static _freeHighlightId = -1;
  static _freeHighlight = null;
  static _freeHighlightClipId = "";
  static get _keyboardManager() {
    const proto = _HighlightEditor.prototype;
    return shadow(this, "_keyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], proto._moveCaret, {
      args: [0]
    }], [["ArrowRight", "mac+ArrowRight"], proto._moveCaret, {
      args: [1]
    }], [["ArrowUp", "mac+ArrowUp"], proto._moveCaret, {
      args: [2]
    }], [["ArrowDown", "mac+ArrowDown"], proto._moveCaret, {
      args: [3]
    }]]));
  }
  constructor(params) {
    super({
      ...params,
      name: "highlightEditor"
    });
    this.color = params.color || _HighlightEditor._defaultColor;
    this.#thickness = params.thickness || _HighlightEditor._defaultThickness;
    this.opacity = params.opacity || _HighlightEditor._defaultOpacity;
    this.#boxes = params.boxes || null;
    this.#methodOfCreation = params.methodOfCreation || "";
    this.#text = params.text || "";
    this._isDraggable = false;
    this.defaultL10nId = "pdfjs-editor-highlight-editor";
    if (params.highlightId > -1) {
      this.#isFreeHighlight = true;
      this.#createFreeOutlines(params);
      this.#addToDrawLayer();
    } else if (this.#boxes) {
      this.#anchorNode = params.anchorNode;
      this.#anchorOffset = params.anchorOffset;
      this.#focusNode = params.focusNode;
      this.#focusOffset = params.focusOffset;
      this.#createOutlines();
      this.#addToDrawLayer();
      this.rotate(this.rotation);
    }
    if (!this.annotationElementId) {
      this._uiManager.a11yAlert("pdfjs-editor-highlight-added-alert");
    }
  }
  get telemetryInitialData() {
    return {
      action: "added",
      type: this.#isFreeHighlight ? "free_highlight" : "highlight",
      color: this._uiManager.getNonHCMColorName(this.color),
      thickness: this.#thickness,
      methodOfCreation: this.#methodOfCreation
    };
  }
  get telemetryFinalData() {
    return {
      type: "highlight",
      color: this._uiManager.getNonHCMColorName(this.color)
    };
  }
  static computeTelemetryFinalData(data) {
    return {
      numberOfColors: data.get("color").size
    };
  }
  #createOutlines() {
    const outliner = new HighlightOutliner(this.#boxes, 1e-3);
    this.#highlightOutlines = outliner.getOutlines();
    [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;
    const outlinerForOutline = new HighlightOutliner(this.#boxes, 25e-4, 1e-3, this._uiManager.direction === "ltr");
    this.#focusOutlines = outlinerForOutline.getOutlines();
    const {
      firstPoint
    } = this.#highlightOutlines;
    this.#firstPoint = [(firstPoint[0] - this.x) / this.width, (firstPoint[1] - this.y) / this.height];
    const {
      lastPoint
    } = this.#focusOutlines;
    this.#lastPoint = [(lastPoint[0] - this.x) / this.width, (lastPoint[1] - this.y) / this.height];
  }
  #createFreeOutlines({
    highlightOutlines,
    highlightId,
    clipPathId
  }) {
    this.#highlightOutlines = highlightOutlines;
    const extraThickness = 1.5;
    this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 25e-4);
    if (highlightId >= 0) {
      this.#id = highlightId;
      this.#clipPathId = clipPathId;
      this.parent.drawLayer.finalizeDraw(highlightId, {
        bbox: highlightOutlines.box,
        path: {
          d: highlightOutlines.toSVGPath()
        }
      });
      this.#outlineId = this.parent.drawLayer.drawOutline({
        rootClass: {
          highlightOutline: true,
          free: true
        },
        bbox: this.#focusOutlines.box,
        path: {
          d: this.#focusOutlines.toSVGPath()
        }
      }, true);
    } else if (this.parent) {
      const angle = this.parent.viewport.rotation;
      this.parent.drawLayer.updateProperties(this.#id, {
        bbox: _HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),
        path: {
          d: highlightOutlines.toSVGPath()
        }
      });
      this.parent.drawLayer.updateProperties(this.#outlineId, {
        bbox: _HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),
        path: {
          d: this.#focusOutlines.toSVGPath()
        }
      });
    }
    const [x3, y12, width, height] = highlightOutlines.box;
    switch (this.rotation) {
      case 0:
        this.x = x3;
        this.y = y12;
        this.width = width;
        this.height = height;
        break;
      case 90: {
        const [pageWidth, pageHeight] = this.parentDimensions;
        this.x = y12;
        this.y = 1 - x3;
        this.width = width * pageHeight / pageWidth;
        this.height = height * pageWidth / pageHeight;
        break;
      }
      case 180:
        this.x = 1 - x3;
        this.y = 1 - y12;
        this.width = width;
        this.height = height;
        break;
      case 270: {
        const [pageWidth, pageHeight] = this.parentDimensions;
        this.x = 1 - y12;
        this.y = x3;
        this.width = width * pageHeight / pageWidth;
        this.height = height * pageWidth / pageHeight;
        break;
      }
    }
    const {
      firstPoint
    } = highlightOutlines;
    this.#firstPoint = [(firstPoint[0] - x3) / width, (firstPoint[1] - y12) / height];
    const {
      lastPoint
    } = this.#focusOutlines;
    this.#lastPoint = [(lastPoint[0] - x3) / width, (lastPoint[1] - y12) / height];
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
    _HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || "#fff066";
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
        _HighlightEditor._defaultColor = value;
        break;
      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
        _HighlightEditor._defaultThickness = value;
        break;
    }
  }
  translateInPage(x3, y12) {
  }
  get toolbarPosition() {
    return this.#lastPoint;
  }
  get commentButtonPosition() {
    return this.#firstPoint;
  }
  updateParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
        this.#updateColor(value);
        break;
      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
        this.#updateThickness(value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, _HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, _HighlightEditor._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, this.color || _HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, this.#thickness || _HighlightEditor._defaultThickness], [AnnotationEditorParamsType.HIGHLIGHT_FREE, this.#isFreeHighlight]];
  }
  onUpdatedColor() {
    this.parent?.drawLayer.updateProperties(this.#id, {
      root: {
        fill: this.color,
        "fill-opacity": this.opacity
      }
    });
    this.#colorPicker?.updateColor(this.color);
    super.onUpdatedColor();
  }
  #updateColor(color) {
    const setColorAndOpacity = /* @__PURE__ */ __name((col, opa) => {
      this.color = col;
      this.opacity = opa;
      this.onUpdatedColor();
    }, "setColorAndOpacity");
    const savedColor = this.color;
    const savedOpacity = this.opacity;
    this.addCommands({
      cmd: setColorAndOpacity.bind(this, color, _HighlightEditor._defaultOpacity),
      undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
    this._reportTelemetry({
      action: "color_changed",
      color: this._uiManager.getNonHCMColorName(color)
    }, true);
  }
  #updateThickness(thickness) {
    const savedThickness = this.#thickness;
    const setThickness = /* @__PURE__ */ __name((th) => {
      this.#thickness = th;
      this.#changeThickness(th);
    }, "setThickness");
    this.addCommands({
      cmd: setThickness.bind(this, thickness),
      undo: setThickness.bind(this, savedThickness),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType.INK_THICKNESS,
      overwriteIfSameType: true,
      keepUndo: true
    });
    this._reportTelemetry({
      action: "thickness_changed",
      thickness
    }, true);
  }
  get toolbarButtons() {
    if (this._uiManager.highlightColors) {
      const colorPicker = this.#colorPicker = new ColorPicker({
        editor: this
      });
      return [["colorPicker", colorPicker]];
    }
    return super.toolbarButtons;
  }
  disableEditing() {
    super.disableEditing();
    this.div.classList.toggle("disabled", true);
  }
  enableEditing() {
    super.enableEditing();
    this.div.classList.toggle("disabled", false);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(this.#getRotation());
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(tx, ty) {
    return super.getRect(tx, ty, this.#getRotation());
  }
  onceAdded(focus) {
    if (!this.annotationElementId) {
      this.parent.addUndoableEditor(this);
    }
    if (focus) {
      this.div.focus();
    }
  }
  remove() {
    this.#cleanDrawLayer();
    this._reportTelemetry({
      action: "deleted"
    });
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    this.#addToDrawLayer();
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  setParent(parent) {
    let mustBeSelected = false;
    if (this.parent && !parent) {
      this.#cleanDrawLayer();
    } else if (parent) {
      this.#addToDrawLayer(parent);
      mustBeSelected = !this.parent && this.div?.classList.contains("selectedEditor");
    }
    super.setParent(parent);
    this.show(this._isVisible);
    if (mustBeSelected) {
      this.select();
    }
  }
  #changeThickness(thickness) {
    if (!this.#isFreeHighlight) {
      return;
    }
    this.#createFreeOutlines({
      highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)
    });
    this.fixAndSetPosition();
    this.setDims(this.width, this.height);
  }
  #cleanDrawLayer() {
    if (this.#id === null || !this.parent) {
      return;
    }
    this.parent.drawLayer.remove(this.#id);
    this.#id = null;
    this.parent.drawLayer.remove(this.#outlineId);
    this.#outlineId = null;
  }
  #addToDrawLayer(parent = this.parent) {
    if (this.#id !== null) {
      return;
    }
    ({
      id: this.#id,
      clipPathId: this.#clipPathId
    } = parent.drawLayer.draw({
      bbox: this.#highlightOutlines.box,
      root: {
        viewBox: "0 0 1 1",
        fill: this.color,
        "fill-opacity": this.opacity
      },
      rootClass: {
        highlight: true,
        free: this.#isFreeHighlight
      },
      path: {
        d: this.#highlightOutlines.toSVGPath()
      }
    }, false, true));
    this.#outlineId = parent.drawLayer.drawOutline({
      rootClass: {
        highlightOutline: true,
        free: this.#isFreeHighlight
      },
      bbox: this.#focusOutlines.box,
      path: {
        d: this.#focusOutlines.toSVGPath()
      }
    }, this.#isFreeHighlight);
    if (this.#highlightDiv) {
      this.#highlightDiv.style.clipPath = this.#clipPathId;
    }
  }
  static #rotateBbox([x3, y12, width, height], angle) {
    switch (angle) {
      case 90:
        return [1 - y12 - height, x3, height, width];
      case 180:
        return [1 - x3 - width, 1 - y12 - height, width, height];
      case 270:
        return [y12, 1 - x3 - width, height, width];
    }
    return [x3, y12, width, height];
  }
  rotate(angle) {
    const {
      drawLayer
    } = this.parent;
    let box;
    if (this.#isFreeHighlight) {
      angle = (angle - this.rotation + 360) % 360;
      box = _HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);
    } else {
      box = _HighlightEditor.#rotateBbox([this.x, this.y, this.width, this.height], angle);
    }
    drawLayer.updateProperties(this.#id, {
      bbox: box,
      root: {
        "data-main-rotation": angle
      }
    });
    drawLayer.updateProperties(this.#outlineId, {
      bbox: _HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),
      root: {
        "data-main-rotation": angle
      }
    });
  }
  render() {
    if (this.div) {
      return this.div;
    }
    const div = super.render();
    if (this.#text) {
      div.setAttribute("aria-label", this.#text);
      div.setAttribute("role", "mark");
    }
    if (this.#isFreeHighlight) {
      div.classList.add("free");
    } else {
      this.div.addEventListener("keydown", this.#keydown.bind(this), {
        signal: this._uiManager._signal
      });
    }
    const highlightDiv = this.#highlightDiv = document.createElement("div");
    div.append(highlightDiv);
    highlightDiv.setAttribute("aria-hidden", "true");
    highlightDiv.className = "internal";
    highlightDiv.style.clipPath = this.#clipPathId;
    this.setDims(this.width, this.height);
    bindEvents(this, this.#highlightDiv, ["pointerover", "pointerleave"]);
    this.enableEditing();
    return div;
  }
  pointerover() {
    if (!this.isSelected) {
      this.parent?.drawLayer.updateProperties(this.#outlineId, {
        rootClass: {
          hovered: true
        }
      });
    }
  }
  pointerleave() {
    if (!this.isSelected) {
      this.parent?.drawLayer.updateProperties(this.#outlineId, {
        rootClass: {
          hovered: false
        }
      });
    }
  }
  #keydown(event) {
    _HighlightEditor._keyboardManager.exec(this, event);
  }
  _moveCaret(direction) {
    this.parent.unselect(this);
    switch (direction) {
      case 0:
      case 2:
        this.#setCaret(true);
        break;
      case 1:
      case 3:
        this.#setCaret(false);
        break;
    }
  }
  #setCaret(start) {
    if (!this.#anchorNode) {
      return;
    }
    const selection = window.getSelection();
    if (start) {
      selection.setPosition(this.#anchorNode, this.#anchorOffset);
    } else {
      selection.setPosition(this.#focusNode, this.#focusOffset);
    }
  }
  select() {
    super.select();
    if (!this.#outlineId) {
      return;
    }
    this.parent?.drawLayer.updateProperties(this.#outlineId, {
      rootClass: {
        hovered: false,
        selected: true
      }
    });
  }
  unselect() {
    super.unselect();
    if (!this.#outlineId) {
      return;
    }
    this.parent?.drawLayer.updateProperties(this.#outlineId, {
      rootClass: {
        selected: false
      }
    });
    if (!this.#isFreeHighlight) {
      this.#setCaret(false);
    }
  }
  get _mustFixPosition() {
    return !this.#isFreeHighlight;
  }
  show(visible = this._isVisible) {
    super.show(visible);
    if (this.parent) {
      this.parent.drawLayer.updateProperties(this.#id, {
        rootClass: {
          hidden: !visible
        }
      });
      this.parent.drawLayer.updateProperties(this.#outlineId, {
        rootClass: {
          hidden: !visible
        }
      });
    }
  }
  #getRotation() {
    return this.#isFreeHighlight ? this.rotation : 0;
  }
  #serializeBoxes() {
    if (this.#isFreeHighlight) {
      return null;
    }
    const [pageWidth, pageHeight] = this.pageDimensions;
    const [pageX, pageY] = this.pageTranslation;
    const boxes = this.#boxes;
    const quadPoints = new Float32Array(boxes.length * 8);
    let i18 = 0;
    for (const {
      x: x3,
      y: y12,
      width,
      height
    } of boxes) {
      const sx = x3 * pageWidth + pageX;
      const sy = (1 - y12) * pageHeight + pageY;
      quadPoints[i18] = quadPoints[i18 + 4] = sx;
      quadPoints[i18 + 1] = quadPoints[i18 + 3] = sy;
      quadPoints[i18 + 2] = quadPoints[i18 + 6] = sx + width * pageWidth;
      quadPoints[i18 + 5] = quadPoints[i18 + 7] = sy - height * pageHeight;
      i18 += 8;
    }
    return quadPoints;
  }
  #serializeOutlines(rect) {
    return this.#highlightOutlines.serialize(rect, this.#getRotation());
  }
  static startHighlighting(parent, isLTR, {
    target: textLayer,
    x: x3,
    y: y12
  }) {
    const {
      x: layerX,
      y: layerY,
      width: parentWidth,
      height: parentHeight
    } = textLayer.getBoundingClientRect();
    const ac = new AbortController();
    const signal = parent.combinedSignal(ac);
    const pointerUpCallback = /* @__PURE__ */ __name((e10) => {
      ac.abort();
      this.#endHighlight(parent, e10);
    }, "pointerUpCallback");
    window.addEventListener("blur", pointerUpCallback, {
      signal
    });
    window.addEventListener("pointerup", pointerUpCallback, {
      signal
    });
    window.addEventListener("pointerdown", stopEvent, {
      capture: true,
      passive: false,
      signal
    });
    window.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    textLayer.addEventListener("pointermove", this.#highlightMove.bind(this, parent), {
      signal
    });
    this._freeHighlight = new FreeHighlightOutliner({
      x: x3,
      y: y12
    }, [layerX, layerY, parentWidth, parentHeight], parent.scale, this._defaultThickness / 2, isLTR, 1e-3);
    ({
      id: this._freeHighlightId,
      clipPathId: this._freeHighlightClipId
    } = parent.drawLayer.draw({
      bbox: [0, 0, 1, 1],
      root: {
        viewBox: "0 0 1 1",
        fill: this._defaultColor,
        "fill-opacity": this._defaultOpacity
      },
      rootClass: {
        highlight: true,
        free: true
      },
      path: {
        d: this._freeHighlight.toSVGPath()
      }
    }, true, true));
  }
  static #highlightMove(parent, event) {
    if (this._freeHighlight.add(event)) {
      parent.drawLayer.updateProperties(this._freeHighlightId, {
        path: {
          d: this._freeHighlight.toSVGPath()
        }
      });
    }
  }
  static #endHighlight(parent, event) {
    if (!this._freeHighlight.isEmpty()) {
      parent.createAndAddNewEditor(event, false, {
        highlightId: this._freeHighlightId,
        highlightOutlines: this._freeHighlight.getOutlines(),
        clipPathId: this._freeHighlightClipId,
        methodOfCreation: "main_toolbar"
      });
    } else {
      parent.drawLayer.remove(this._freeHighlightId);
    }
    this._freeHighlightId = -1;
    this._freeHighlight = null;
    this._freeHighlightClipId = "";
  }
  static async deserialize(data, parent, uiManager) {
    let initialData = null;
    if (data instanceof HighlightAnnotationElement) {
      const {
        data: {
          quadPoints: quadPoints2,
          rect,
          rotation,
          id,
          color: color2,
          opacity: opacity2,
          popupRef,
          richText,
          contentsObj,
          creationDate,
          modificationDate
        },
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      initialData = data = {
        annotationType: AnnotationEditorType.HIGHLIGHT,
        color: Array.from(color2),
        opacity: opacity2,
        quadPoints: quadPoints2,
        boxes: null,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        popupRef,
        richText,
        comment: contentsObj?.str || null,
        creationDate,
        modificationDate
      };
    } else if (data instanceof InkAnnotationElement) {
      const {
        data: {
          inkLists: inkLists2,
          rect,
          rotation,
          id,
          color: color2,
          borderStyle: {
            rawWidth: thickness
          },
          popupRef,
          richText,
          contentsObj,
          creationDate,
          modificationDate
        },
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      initialData = data = {
        annotationType: AnnotationEditorType.HIGHLIGHT,
        color: Array.from(color2),
        thickness,
        inkLists: inkLists2,
        boxes: null,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        popupRef,
        richText,
        comment: contentsObj?.str || null,
        creationDate,
        modificationDate
      };
    }
    const {
      color,
      quadPoints,
      inkLists,
      opacity
    } = data;
    const editor = await super.deserialize(data, parent, uiManager);
    editor.color = Util.makeHexColor(...color);
    editor.opacity = opacity || 1;
    if (inkLists) {
      editor.#thickness = data.thickness;
    }
    editor._initialData = initialData;
    if (data.comment) {
      editor.setCommentData(data);
    }
    const [pageWidth, pageHeight] = editor.pageDimensions;
    const [pageX, pageY] = editor.pageTranslation;
    if (quadPoints) {
      const boxes = editor.#boxes = [];
      for (let i18 = 0; i18 < quadPoints.length; i18 += 8) {
        boxes.push({
          x: (quadPoints[i18] - pageX) / pageWidth,
          y: 1 - (quadPoints[i18 + 1] - pageY) / pageHeight,
          width: (quadPoints[i18 + 2] - quadPoints[i18]) / pageWidth,
          height: (quadPoints[i18 + 1] - quadPoints[i18 + 5]) / pageHeight
        });
      }
      editor.#createOutlines();
      editor.#addToDrawLayer();
      editor.rotate(editor.rotation);
    } else if (inkLists) {
      editor.#isFreeHighlight = true;
      const points = inkLists[0];
      const point = {
        x: points[0] - pageX,
        y: pageHeight - (points[1] - pageY)
      };
      const outliner = new FreeHighlightOutliner(point, [0, 0, pageWidth, pageHeight], 1, editor.#thickness / 2, true, 1e-3);
      for (let i18 = 0, ii = points.length; i18 < ii; i18 += 2) {
        point.x = points[i18] - pageX;
        point.y = pageHeight - (points[i18 + 1] - pageY);
        outliner.add(point);
      }
      const {
        id,
        clipPathId
      } = parent.drawLayer.draw({
        bbox: [0, 0, 1, 1],
        root: {
          viewBox: "0 0 1 1",
          fill: editor.color,
          "fill-opacity": editor._defaultOpacity
        },
        rootClass: {
          highlight: true,
          free: true
        },
        path: {
          d: outliner.toSVGPath()
        }
      }, true, true);
      editor.#createFreeOutlines({
        highlightOutlines: outliner.getOutlines(),
        highlightId: id,
        clipPathId
      });
      editor.#addToDrawLayer();
      editor.rotate(editor.parentRotation);
    }
    return editor;
  }
  serialize(isForCopying = false) {
    if (this.isEmpty() || isForCopying) {
      return null;
    }
    if (this.deleted) {
      return this.serializeDeleted();
    }
    const color = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));
    const serialized = super.serialize(isForCopying);
    Object.assign(serialized, {
      color,
      opacity: this.opacity,
      thickness: this.#thickness,
      quadPoints: this.#serializeBoxes(),
      outlines: this.#serializeOutlines(serialized.rect)
    });
    this.addComment(serialized);
    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
      return null;
    }
    serialized.id = this.annotationElementId;
    return serialized;
  }
  #hasElementChanged(serialized) {
    const {
      color
    } = this._initialData;
    return this.hasEditedComment || serialized.color.some((c21, i18) => c21 !== color[i18]);
  }
  renderAnnotationElement(annotation) {
    if (this.deleted) {
      annotation.hide();
      return null;
    }
    annotation.updateEdited({
      rect: this.getPDFRect(),
      popup: this.comment
    });
    return null;
  }
  static canCreateNewEmptyEditor() {
    return false;
  }
};
;
var DrawingOptions = class {
  static {
    __name(this, "DrawingOptions");
  }
  #svgProperties = /* @__PURE__ */ Object.create(null);
  updateProperty(name4, value) {
    this[name4] = value;
    this.updateSVGProperty(name4, value);
  }
  updateProperties(properties) {
    if (!properties) {
      return;
    }
    for (const [name4, value] of Object.entries(properties)) {
      if (!name4.startsWith("_")) {
        this.updateProperty(name4, value);
      }
    }
  }
  updateSVGProperty(name4, value) {
    this.#svgProperties[name4] = value;
  }
  toSVGProperties() {
    const root = this.#svgProperties;
    this.#svgProperties = /* @__PURE__ */ Object.create(null);
    return {
      root
    };
  }
  reset() {
    this.#svgProperties = /* @__PURE__ */ Object.create(null);
  }
  updateAll(options = this) {
    this.updateProperties(options);
  }
  clone() {
    unreachable("Not implemented");
  }
};
var DrawingEditor = class _DrawingEditor extends AnnotationEditor {
  static {
    __name(this, "DrawingEditor");
  }
  #drawOutlines = null;
  #mustBeCommitted;
  _colorPicker = null;
  _drawId = null;
  static _currentDrawId = -1;
  static _currentParent = null;
  static #currentDraw = null;
  static #currentDrawingAC = null;
  static #currentDrawingOptions = null;
  static #currentPointerId = NaN;
  static #currentPointerType = null;
  static #currentPointerIds = null;
  static #currentMoveTimestamp = NaN;
  static _INNER_MARGIN = 3;
  constructor(params) {
    super(params);
    this.#mustBeCommitted = params.mustBeCommitted || false;
    this._addOutlines(params);
  }
  onUpdatedColor() {
    this._colorPicker?.update(this.color);
    super.onUpdatedColor();
  }
  _addOutlines(params) {
    if (params.drawOutlines) {
      this.#createDrawOutlines(params);
      this.#addToDrawLayer();
    }
  }
  #createDrawOutlines({
    drawOutlines,
    drawId,
    drawingOptions
  }) {
    this.#drawOutlines = drawOutlines;
    this._drawingOptions ||= drawingOptions;
    if (!this.annotationElementId) {
      this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`);
    }
    if (drawId >= 0) {
      this._drawId = drawId;
      this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);
    } else {
      this._drawId = this.#createDrawing(drawOutlines, this.parent);
    }
    this.#updateBbox(drawOutlines.box);
  }
  #createDrawing(drawOutlines, parent) {
    const {
      id
    } = parent.drawLayer.draw(_DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);
    return id;
  }
  static _mergeSVGProperties(p1, p22) {
    const p1Keys = new Set(Object.keys(p1));
    for (const [key, value] of Object.entries(p22)) {
      if (p1Keys.has(key)) {
        Object.assign(p1[key], value);
      } else {
        p1[key] = value;
      }
    }
    return p1;
  }
  static getDefaultDrawingOptions(_options) {
    unreachable("Not implemented");
  }
  static get typesMap() {
    unreachable("Not implemented");
  }
  static get isDrawer() {
    return true;
  }
  static get supportMultipleDrawings() {
    return false;
  }
  static updateDefaultParams(type, value) {
    const propertyName = this.typesMap.get(type);
    if (propertyName) {
      this._defaultDrawingOptions.updateProperty(propertyName, value);
    }
    if (this._currentParent) {
      _DrawingEditor.#currentDraw.updateProperty(propertyName, value);
      this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
    }
  }
  updateParams(type, value) {
    const propertyName = this.constructor.typesMap.get(type);
    if (propertyName) {
      this._updateProperty(type, propertyName, value);
    }
  }
  static get defaultPropertiesToUpdate() {
    const properties = [];
    const options = this._defaultDrawingOptions;
    for (const [type, name4] of this.typesMap) {
      properties.push([type, options[name4]]);
    }
    return properties;
  }
  get propertiesToUpdate() {
    const properties = [];
    const {
      _drawingOptions
    } = this;
    for (const [type, name4] of this.constructor.typesMap) {
      properties.push([type, _drawingOptions[name4]]);
    }
    return properties;
  }
  _updateProperty(type, name4, value) {
    const options = this._drawingOptions;
    const savedValue = options[name4];
    const setter = /* @__PURE__ */ __name((val) => {
      options.updateProperty(name4, val);
      const bbox = this.#drawOutlines.updateProperty(name4, val);
      if (bbox) {
        this.#updateBbox(bbox);
      }
      this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());
      if (type === this.colorType) {
        this.onUpdatedColor();
      }
    }, "setter");
    this.addCommands({
      cmd: setter.bind(this, value),
      undo: setter.bind(this, savedValue),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  _onResizing() {
    this.parent?.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {
      bbox: this.#rotateBox()
    }));
  }
  _onResized() {
    this.parent?.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {
      bbox: this.#rotateBox()
    }));
  }
  _onTranslating(_x, _y) {
    this.parent?.drawLayer.updateProperties(this._drawId, {
      bbox: this.#rotateBox()
    });
  }
  _onTranslated() {
    this.parent?.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {
      bbox: this.#rotateBox()
    }));
  }
  _onStartDragging() {
    this.parent?.drawLayer.updateProperties(this._drawId, {
      rootClass: {
        moving: true
      }
    });
  }
  _onStopDragging() {
    this.parent?.drawLayer.updateProperties(this._drawId, {
      rootClass: {
        moving: false
      }
    });
  }
  commit() {
    super.commit();
    this.disableEditMode();
    this.disableEditing();
  }
  disableEditing() {
    super.disableEditing();
    this.div.classList.toggle("disabled", true);
  }
  enableEditing() {
    super.enableEditing();
    this.div.classList.toggle("disabled", false);
  }
  getBaseTranslation() {
    return [0, 0];
  }
  get isResizable() {
    return true;
  }
  onceAdded(focus) {
    if (!this.annotationElementId) {
      this.parent.addUndoableEditor(this);
    }
    this._isDraggable = true;
    if (this.#mustBeCommitted) {
      this.#mustBeCommitted = false;
      this.commit();
      this.parent.setSelected(this);
      if (focus && this.isOnScreen) {
        this.div.focus();
      }
    }
  }
  remove() {
    this.#cleanDrawLayer();
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    this.#addToDrawLayer();
    this.#updateBbox(this.#drawOutlines.box);
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  setParent(parent) {
    let mustBeSelected = false;
    if (this.parent && !parent) {
      this._uiManager.removeShouldRescale(this);
      this.#cleanDrawLayer();
    } else if (parent) {
      this._uiManager.addShouldRescale(this);
      this.#addToDrawLayer(parent);
      mustBeSelected = !this.parent && this.div?.classList.contains("selectedEditor");
    }
    super.setParent(parent);
    if (mustBeSelected) {
      this.select();
    }
  }
  #cleanDrawLayer() {
    if (this._drawId === null || !this.parent) {
      return;
    }
    this.parent.drawLayer.remove(this._drawId);
    this._drawId = null;
    this._drawingOptions.reset();
  }
  #addToDrawLayer(parent = this.parent) {
    if (this._drawId !== null && this.parent === parent) {
      return;
    }
    if (this._drawId !== null) {
      this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);
      return;
    }
    this._drawingOptions.updateAll();
    this._drawId = this.#createDrawing(this.#drawOutlines, parent);
  }
  #convertToParentSpace([x3, y12, width, height]) {
    const {
      parentDimensions: [pW, pH],
      rotation
    } = this;
    switch (rotation) {
      case 90:
        return [y12, 1 - x3, width * (pH / pW), height * (pW / pH)];
      case 180:
        return [1 - x3, 1 - y12, width, height];
      case 270:
        return [1 - y12, x3, width * (pH / pW), height * (pW / pH)];
      default:
        return [x3, y12, width, height];
    }
  }
  #convertToDrawSpace() {
    const {
      x: x3,
      y: y12,
      width,
      height,
      parentDimensions: [pW, pH],
      rotation
    } = this;
    switch (rotation) {
      case 90:
        return [1 - y12, x3, width * (pW / pH), height * (pH / pW)];
      case 180:
        return [1 - x3, 1 - y12, width, height];
      case 270:
        return [y12, 1 - x3, width * (pW / pH), height * (pH / pW)];
      default:
        return [x3, y12, width, height];
    }
  }
  #updateBbox(bbox) {
    [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);
    if (this.div) {
      this.fixAndSetPosition();
      this.setDims();
    }
    this._onResized();
  }
  #rotateBox() {
    const {
      x: x3,
      y: y12,
      width,
      height,
      rotation,
      parentRotation,
      parentDimensions: [pW, pH]
    } = this;
    switch ((rotation * 4 + parentRotation) / 90) {
      case 1:
        return [1 - y12 - height, x3, height, width];
      case 2:
        return [1 - x3 - width, 1 - y12 - height, width, height];
      case 3:
        return [y12, 1 - x3 - width, height, width];
      case 4:
        return [x3, y12 - width * (pW / pH), height * (pH / pW), width * (pW / pH)];
      case 5:
        return [1 - y12, x3, width * (pW / pH), height * (pH / pW)];
      case 6:
        return [1 - x3 - height * (pH / pW), 1 - y12, height * (pH / pW), width * (pW / pH)];
      case 7:
        return [y12 - width * (pW / pH), 1 - x3 - height * (pH / pW), width * (pW / pH), height * (pH / pW)];
      case 8:
        return [x3 - width, y12 - height, width, height];
      case 9:
        return [1 - y12, x3 - width, height, width];
      case 10:
        return [1 - x3, 1 - y12, width, height];
      case 11:
        return [y12 - height, 1 - x3, height, width];
      case 12:
        return [x3 - height * (pH / pW), y12, height * (pH / pW), width * (pW / pH)];
      case 13:
        return [1 - y12 - width * (pW / pH), x3 - height * (pH / pW), width * (pW / pH), height * (pH / pW)];
      case 14:
        return [1 - x3, 1 - y12 - width * (pW / pH), height * (pH / pW), width * (pW / pH)];
      case 15:
        return [y12, 1 - x3, width * (pW / pH), height * (pH / pW)];
      default:
        return [x3, y12, width, height];
    }
  }
  rotate() {
    if (!this.parent) {
      return;
    }
    this.parent.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties({
      bbox: this.#rotateBox()
    }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));
  }
  onScaleChanging() {
    if (!this.parent) {
      return;
    }
    this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));
  }
  static onScaleChangingWhenDrawing() {
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this._isCopy) {
      baseX = this.x;
      baseY = this.y;
    }
    const div = super.render();
    div.classList.add("draw");
    const drawDiv = document.createElement("div");
    div.append(drawDiv);
    drawDiv.setAttribute("aria-hidden", "true");
    drawDiv.className = "internal";
    this.setDims();
    this._uiManager.addShouldRescale(this);
    this.disableEditing();
    if (this._isCopy) {
      this._moveAfterPaste(baseX, baseY);
    }
    return div;
  }
  static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {
    unreachable("Not implemented");
  }
  static startDrawing(parent, uiManager, _isLTR, event) {
    const {
      target,
      offsetX: x3,
      offsetY: y12,
      pointerId,
      pointerType
    } = event;
    if (_DrawingEditor.#currentPointerType && _DrawingEditor.#currentPointerType !== pointerType) {
      return;
    }
    const {
      viewport: {
        rotation
      }
    } = parent;
    const {
      width: parentWidth,
      height: parentHeight
    } = target.getBoundingClientRect();
    const ac = _DrawingEditor.#currentDrawingAC = new AbortController();
    const signal = parent.combinedSignal(ac);
    _DrawingEditor.#currentPointerId ||= pointerId;
    _DrawingEditor.#currentPointerType ??= pointerType;
    window.addEventListener("pointerup", (e10) => {
      if (_DrawingEditor.#currentPointerId === e10.pointerId) {
        this._endDraw(e10);
      } else {
        _DrawingEditor.#currentPointerIds?.delete(e10.pointerId);
      }
    }, {
      signal
    });
    window.addEventListener("pointercancel", (e10) => {
      if (_DrawingEditor.#currentPointerId === e10.pointerId) {
        this._currentParent.endDrawingSession();
      } else {
        _DrawingEditor.#currentPointerIds?.delete(e10.pointerId);
      }
    }, {
      signal
    });
    window.addEventListener("pointerdown", (e10) => {
      if (_DrawingEditor.#currentPointerType !== e10.pointerType) {
        return;
      }
      (_DrawingEditor.#currentPointerIds ||= /* @__PURE__ */ new Set()).add(e10.pointerId);
      if (_DrawingEditor.#currentDraw.isCancellable()) {
        _DrawingEditor.#currentDraw.removeLastElement();
        if (_DrawingEditor.#currentDraw.isEmpty()) {
          this._currentParent.endDrawingSession(true);
        } else {
          this._endDraw(null);
        }
      }
    }, {
      capture: true,
      passive: false,
      signal
    });
    window.addEventListener("contextmenu", noContextMenu, {
      signal
    });
    target.addEventListener("pointermove", this._drawMove.bind(this), {
      signal
    });
    target.addEventListener("touchmove", (e10) => {
      if (e10.timeStamp === _DrawingEditor.#currentMoveTimestamp) {
        stopEvent(e10);
      }
    }, {
      signal
    });
    parent.toggleDrawing();
    uiManager._editorUndoBar?.hide();
    if (_DrawingEditor.#currentDraw) {
      parent.drawLayer.updateProperties(this._currentDrawId, _DrawingEditor.#currentDraw.startNew(x3, y12, parentWidth, parentHeight, rotation));
      return;
    }
    uiManager.updateUIForDefaultProperties(this);
    _DrawingEditor.#currentDraw = this.createDrawerInstance(x3, y12, parentWidth, parentHeight, rotation);
    _DrawingEditor.#currentDrawingOptions = this.getDefaultDrawingOptions();
    this._currentParent = parent;
    ({
      id: this._currentDrawId
    } = parent.drawLayer.draw(this._mergeSVGProperties(_DrawingEditor.#currentDrawingOptions.toSVGProperties(), _DrawingEditor.#currentDraw.defaultSVGProperties), true, false));
  }
  static _drawMove(event) {
    _DrawingEditor.#currentMoveTimestamp = -1;
    if (!_DrawingEditor.#currentDraw) {
      return;
    }
    const {
      offsetX,
      offsetY,
      pointerId
    } = event;
    if (_DrawingEditor.#currentPointerId !== pointerId) {
      return;
    }
    if (_DrawingEditor.#currentPointerIds?.size >= 1) {
      this._endDraw(event);
      return;
    }
    this._currentParent.drawLayer.updateProperties(this._currentDrawId, _DrawingEditor.#currentDraw.add(offsetX, offsetY));
    _DrawingEditor.#currentMoveTimestamp = event.timeStamp;
    stopEvent(event);
  }
  static _cleanup(all) {
    if (all) {
      this._currentDrawId = -1;
      this._currentParent = null;
      _DrawingEditor.#currentDraw = null;
      _DrawingEditor.#currentDrawingOptions = null;
      _DrawingEditor.#currentPointerType = null;
      _DrawingEditor.#currentMoveTimestamp = NaN;
    }
    if (_DrawingEditor.#currentDrawingAC) {
      _DrawingEditor.#currentDrawingAC.abort();
      _DrawingEditor.#currentDrawingAC = null;
      _DrawingEditor.#currentPointerId = NaN;
      _DrawingEditor.#currentPointerIds = null;
    }
  }
  static _endDraw(event) {
    const parent = this._currentParent;
    if (!parent) {
      return;
    }
    parent.toggleDrawing(true);
    this._cleanup(false);
    if (event?.target === parent.div) {
      parent.drawLayer.updateProperties(this._currentDrawId, _DrawingEditor.#currentDraw.end(event.offsetX, event.offsetY));
    }
    if (this.supportMultipleDrawings) {
      const draw = _DrawingEditor.#currentDraw;
      const drawId = this._currentDrawId;
      const lastElement = draw.getLastElement();
      parent.addCommands({
        cmd: /* @__PURE__ */ __name(() => {
          parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));
        }, "cmd"),
        undo: /* @__PURE__ */ __name(() => {
          parent.drawLayer.updateProperties(drawId, draw.removeLastElement());
        }, "undo"),
        mustExec: false,
        type: AnnotationEditorParamsType.DRAW_STEP
      });
      return;
    }
    this.endDrawing(false);
  }
  static endDrawing(isAborted) {
    const parent = this._currentParent;
    if (!parent) {
      return null;
    }
    parent.toggleDrawing(true);
    parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);
    if (!_DrawingEditor.#currentDraw.isEmpty()) {
      const {
        pageDimensions: [pageWidth, pageHeight],
        scale
      } = parent;
      const editor = parent.createAndAddNewEditor({
        offsetX: 0,
        offsetY: 0
      }, false, {
        drawId: this._currentDrawId,
        drawOutlines: _DrawingEditor.#currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),
        drawingOptions: _DrawingEditor.#currentDrawingOptions,
        mustBeCommitted: !isAborted
      });
      this._cleanup(true);
      return editor;
    }
    parent.drawLayer.remove(this._currentDrawId);
    this._cleanup(true);
    return null;
  }
  createDrawingOptions(_data) {
  }
  static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {
    unreachable("Not implemented");
  }
  static async deserialize(data, parent, uiManager) {
    const {
      rawDims: {
        pageWidth,
        pageHeight,
        pageX,
        pageY
      }
    } = parent.viewport;
    const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);
    const editor = await super.deserialize(data, parent, uiManager);
    editor.createDrawingOptions(data);
    editor.#createDrawOutlines({
      drawOutlines
    });
    editor.#addToDrawLayer();
    editor.onScaleChanging();
    editor.rotate();
    return editor;
  }
  serializeDraw(isForCopying) {
    const [pageX, pageY] = this.pageTranslation;
    const [pageWidth, pageHeight] = this.pageDimensions;
    return this.#drawOutlines.serialize([pageX, pageY, pageWidth, pageHeight], isForCopying);
  }
  renderAnnotationElement(annotation) {
    annotation.updateEdited({
      rect: this.getPDFRect()
    });
    return null;
  }
  static canCreateNewEmptyEditor() {
    return false;
  }
};
;
var InkDrawOutliner = class {
  static {
    __name(this, "InkDrawOutliner");
  }
  #last = new Float64Array(6);
  #line;
  #lines;
  #rotation;
  #thickness;
  #points;
  #lastSVGPath = "";
  #lastIndex = 0;
  #outlines = new InkDrawOutline();
  #parentWidth;
  #parentHeight;
  constructor(x3, y12, parentWidth, parentHeight, rotation, thickness) {
    this.#parentWidth = parentWidth;
    this.#parentHeight = parentHeight;
    this.#rotation = rotation;
    this.#thickness = thickness;
    [x3, y12] = this.#normalizePoint(x3, y12);
    const line = this.#line = [NaN, NaN, NaN, NaN, x3, y12];
    this.#points = [x3, y12];
    this.#lines = [{
      line,
      points: this.#points
    }];
    this.#last.set(line, 0);
  }
  updateProperty(name4, value) {
    if (name4 === "stroke-width") {
      this.#thickness = value;
    }
  }
  #normalizePoint(x3, y12) {
    return Outline._normalizePoint(x3, y12, this.#parentWidth, this.#parentHeight, this.#rotation);
  }
  isEmpty() {
    return !this.#lines || this.#lines.length === 0;
  }
  isCancellable() {
    return this.#points.length <= 10;
  }
  add(x3, y12) {
    [x3, y12] = this.#normalizePoint(x3, y12);
    const [x1, y1, x22, y22] = this.#last.subarray(2, 6);
    const diffX = x3 - x22;
    const diffY = y12 - y22;
    const d15 = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);
    if (d15 <= 2) {
      return null;
    }
    this.#points.push(x3, y12);
    if (isNaN(x1)) {
      this.#last.set([x22, y22, x3, y12], 2);
      this.#line.push(NaN, NaN, NaN, NaN, x3, y12);
      return {
        path: {
          d: this.toSVGPath()
        }
      };
    }
    if (isNaN(this.#last[0])) {
      this.#line.splice(6, 6);
    }
    this.#last.set([x1, y1, x22, y22, x3, y12], 0);
    this.#line.push(...Outline.createBezierPoints(x1, y1, x22, y22, x3, y12));
    return {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  end(x3, y12) {
    const change = this.add(x3, y12);
    if (change) {
      return change;
    }
    if (this.#points.length === 2) {
      return {
        path: {
          d: this.toSVGPath()
        }
      };
    }
    return null;
  }
  startNew(x3, y12, parentWidth, parentHeight, rotation) {
    this.#parentWidth = parentWidth;
    this.#parentHeight = parentHeight;
    this.#rotation = rotation;
    [x3, y12] = this.#normalizePoint(x3, y12);
    const line = this.#line = [NaN, NaN, NaN, NaN, x3, y12];
    this.#points = [x3, y12];
    const last = this.#lines.at(-1);
    if (last) {
      last.line = new Float32Array(last.line);
      last.points = new Float32Array(last.points);
    }
    this.#lines.push({
      line,
      points: this.#points
    });
    this.#last.set(line, 0);
    this.#lastIndex = 0;
    this.toSVGPath();
    return null;
  }
  getLastElement() {
    return this.#lines.at(-1);
  }
  setLastElement(element) {
    if (!this.#lines) {
      return this.#outlines.setLastElement(element);
    }
    this.#lines.push(element);
    this.#line = element.line;
    this.#points = element.points;
    this.#lastIndex = 0;
    return {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  removeLastElement() {
    if (!this.#lines) {
      return this.#outlines.removeLastElement();
    }
    this.#lines.pop();
    this.#lastSVGPath = "";
    for (let i18 = 0, ii = this.#lines.length; i18 < ii; i18++) {
      const {
        line,
        points
      } = this.#lines[i18];
      this.#line = line;
      this.#points = points;
      this.#lastIndex = 0;
      this.toSVGPath();
    }
    return {
      path: {
        d: this.#lastSVGPath
      }
    };
  }
  toSVGPath() {
    const firstX = Outline.svgRound(this.#line[4]);
    const firstY = Outline.svgRound(this.#line[5]);
    if (this.#points.length === 2) {
      this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;
      return this.#lastSVGPath;
    }
    if (this.#points.length <= 6) {
      const i18 = this.#lastSVGPath.lastIndexOf("M");
      this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i18)} M ${firstX} ${firstY}`;
      this.#lastIndex = 6;
    }
    if (this.#points.length === 4) {
      const secondX = Outline.svgRound(this.#line[10]);
      const secondY = Outline.svgRound(this.#line[11]);
      this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;
      this.#lastIndex = 12;
      return this.#lastSVGPath;
    }
    const buffer = [];
    if (this.#lastIndex === 0) {
      buffer.push(`M ${firstX} ${firstY}`);
      this.#lastIndex = 6;
    }
    for (let i18 = this.#lastIndex, ii = this.#line.length; i18 < ii; i18 += 6) {
      const [c1x, c1y, c2x, c2y, x3, y12] = this.#line.slice(i18, i18 + 6).map(Outline.svgRound);
      buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x3} ${y12}`);
    }
    this.#lastSVGPath += buffer.join(" ");
    this.#lastIndex = this.#line.length;
    return this.#lastSVGPath;
  }
  getOutlines(parentWidth, parentHeight, scale, innerMargin) {
    const last = this.#lines.at(-1);
    last.line = new Float32Array(last.line);
    last.points = new Float32Array(last.points);
    this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);
    this.#last = null;
    this.#line = null;
    this.#lines = null;
    this.#lastSVGPath = null;
    return this.#outlines;
  }
  get defaultSVGProperties() {
    return {
      root: {
        viewBox: "0 0 10000 10000"
      },
      rootClass: {
        draw: true
      },
      bbox: [0, 0, 1, 1]
    };
  }
};
var InkDrawOutline = class extends Outline {
  static {
    __name(this, "InkDrawOutline");
  }
  #bbox;
  #currentRotation = 0;
  #innerMargin;
  #lines;
  #parentWidth;
  #parentHeight;
  #parentScale;
  #rotation;
  #thickness;
  build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {
    this.#parentWidth = parentWidth;
    this.#parentHeight = parentHeight;
    this.#parentScale = parentScale;
    this.#rotation = rotation;
    this.#thickness = thickness;
    this.#innerMargin = innerMargin ?? 0;
    this.#lines = lines;
    this.#computeBbox();
  }
  get thickness() {
    return this.#thickness;
  }
  setLastElement(element) {
    this.#lines.push(element);
    return {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  removeLastElement() {
    this.#lines.pop();
    return {
      path: {
        d: this.toSVGPath()
      }
    };
  }
  toSVGPath() {
    const buffer = [];
    for (const {
      line
    } of this.#lines) {
      buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);
      if (line.length === 6) {
        buffer.push("Z");
        continue;
      }
      if (line.length === 12 && isNaN(line[6])) {
        buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);
        continue;
      }
      for (let i18 = 6, ii = line.length; i18 < ii; i18 += 6) {
        const [c1x, c1y, c2x, c2y, x3, y12] = line.subarray(i18, i18 + 6).map(Outline.svgRound);
        buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x3} ${y12}`);
      }
    }
    return buffer.join("");
  }
  serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {
    const serializedLines = [];
    const serializedPoints = [];
    const [x3, y12, width, height] = this.#getBBoxWithNoMargin();
    let tx, ty, sx, sy, x1, y1, x22, y22, rescaleFn;
    switch (this.#rotation) {
      case 0:
        rescaleFn = Outline._rescale;
        tx = pageX;
        ty = pageY + pageHeight;
        sx = pageWidth;
        sy = -pageHeight;
        x1 = pageX + x3 * pageWidth;
        y1 = pageY + (1 - y12 - height) * pageHeight;
        x22 = pageX + (x3 + width) * pageWidth;
        y22 = pageY + (1 - y12) * pageHeight;
        break;
      case 90:
        rescaleFn = Outline._rescaleAndSwap;
        tx = pageX;
        ty = pageY;
        sx = pageWidth;
        sy = pageHeight;
        x1 = pageX + y12 * pageWidth;
        y1 = pageY + x3 * pageHeight;
        x22 = pageX + (y12 + height) * pageWidth;
        y22 = pageY + (x3 + width) * pageHeight;
        break;
      case 180:
        rescaleFn = Outline._rescale;
        tx = pageX + pageWidth;
        ty = pageY;
        sx = -pageWidth;
        sy = pageHeight;
        x1 = pageX + (1 - x3 - width) * pageWidth;
        y1 = pageY + y12 * pageHeight;
        x22 = pageX + (1 - x3) * pageWidth;
        y22 = pageY + (y12 + height) * pageHeight;
        break;
      case 270:
        rescaleFn = Outline._rescaleAndSwap;
        tx = pageX + pageWidth;
        ty = pageY + pageHeight;
        sx = -pageWidth;
        sy = -pageHeight;
        x1 = pageX + (1 - y12 - height) * pageWidth;
        y1 = pageY + (1 - x3 - width) * pageHeight;
        x22 = pageX + (1 - y12) * pageWidth;
        y22 = pageY + (1 - x3) * pageHeight;
        break;
    }
    for (const {
      line,
      points
    } of this.#lines) {
      serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));
      serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));
    }
    return {
      lines: serializedLines,
      points: serializedPoints,
      rect: [x1, y1, x22, y22]
    };
  }
  static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, {
    paths: {
      lines,
      points
    },
    rotation,
    thickness
  }) {
    const newLines = [];
    let tx, ty, sx, sy, rescaleFn;
    switch (rotation) {
      case 0:
        rescaleFn = Outline._rescale;
        tx = -pageX / pageWidth;
        ty = pageY / pageHeight + 1;
        sx = 1 / pageWidth;
        sy = -1 / pageHeight;
        break;
      case 90:
        rescaleFn = Outline._rescaleAndSwap;
        tx = -pageY / pageHeight;
        ty = -pageX / pageWidth;
        sx = 1 / pageHeight;
        sy = 1 / pageWidth;
        break;
      case 180:
        rescaleFn = Outline._rescale;
        tx = pageX / pageWidth + 1;
        ty = -pageY / pageHeight;
        sx = -1 / pageWidth;
        sy = 1 / pageHeight;
        break;
      case 270:
        rescaleFn = Outline._rescaleAndSwap;
        tx = pageY / pageHeight + 1;
        ty = pageX / pageWidth + 1;
        sx = -1 / pageHeight;
        sy = -1 / pageWidth;
        break;
    }
    if (!lines) {
      lines = [];
      for (const point of points) {
        const len = point.length;
        if (len === 2) {
          lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1]]));
          continue;
        }
        if (len === 4) {
          lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1], NaN, NaN, NaN, NaN, point[2], point[3]]));
          continue;
        }
        const line = new Float32Array(3 * (len - 2));
        lines.push(line);
        let [x1, y1, x22, y22] = point.subarray(0, 4);
        line.set([NaN, NaN, NaN, NaN, x1, y1], 0);
        for (let i18 = 4; i18 < len; i18 += 2) {
          const x3 = point[i18];
          const y12 = point[i18 + 1];
          line.set(Outline.createBezierPoints(x1, y1, x22, y22, x3, y12), (i18 - 2) * 3);
          [x1, y1, x22, y22] = [x22, y22, x3, y12];
        }
      }
    }
    for (let i18 = 0, ii = lines.length; i18 < ii; i18++) {
      newLines.push({
        line: rescaleFn(lines[i18].map((x3) => x3 ?? NaN), tx, ty, sx, sy),
        points: rescaleFn(points[i18].map((x3) => x3 ?? NaN), tx, ty, sx, sy)
      });
    }
    const outlines = new this.prototype.constructor();
    outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);
    return outlines;
  }
  #getMarginComponents(thickness = this.#thickness) {
    const margin = this.#innerMargin + thickness / 2 * this.#parentScale;
    return this.#rotation % 180 === 0 ? [margin / this.#parentWidth, margin / this.#parentHeight] : [margin / this.#parentHeight, margin / this.#parentWidth];
  }
  #getBBoxWithNoMargin() {
    const [x3, y12, width, height] = this.#bbox;
    const [marginX, marginY] = this.#getMarginComponents(0);
    return [x3 + marginX, y12 + marginY, width - 2 * marginX, height - 2 * marginY];
  }
  #computeBbox() {
    const bbox = this.#bbox = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);
    for (const {
      line
    } of this.#lines) {
      if (line.length <= 12) {
        for (let i18 = 4, ii = line.length; i18 < ii; i18 += 6) {
          Util.pointBoundingBox(line[i18], line[i18 + 1], bbox);
        }
        continue;
      }
      let lastX = line[4], lastY = line[5];
      for (let i18 = 6, ii = line.length; i18 < ii; i18 += 6) {
        const [c1x, c1y, c2x, c2y, x3, y12] = line.subarray(i18, i18 + 6);
        Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x3, y12, bbox);
        lastX = x3;
        lastY = y12;
      }
    }
    const [marginX, marginY] = this.#getMarginComponents();
    bbox[0] = MathClamp(bbox[0] - marginX, 0, 1);
    bbox[1] = MathClamp(bbox[1] - marginY, 0, 1);
    bbox[2] = MathClamp(bbox[2] + marginX, 0, 1);
    bbox[3] = MathClamp(bbox[3] + marginY, 0, 1);
    bbox[2] -= bbox[0];
    bbox[3] -= bbox[1];
  }
  get box() {
    return this.#bbox;
  }
  updateProperty(name4, value) {
    if (name4 === "stroke-width") {
      return this.#updateThickness(value);
    }
    return null;
  }
  #updateThickness(thickness) {
    const [oldMarginX, oldMarginY] = this.#getMarginComponents();
    this.#thickness = thickness;
    const [newMarginX, newMarginY] = this.#getMarginComponents();
    const [diffMarginX, diffMarginY] = [newMarginX - oldMarginX, newMarginY - oldMarginY];
    const bbox = this.#bbox;
    bbox[0] -= diffMarginX;
    bbox[1] -= diffMarginY;
    bbox[2] += 2 * diffMarginX;
    bbox[3] += 2 * diffMarginY;
    return bbox;
  }
  updateParentDimensions([width, height], scale) {
    const [oldMarginX, oldMarginY] = this.#getMarginComponents();
    this.#parentWidth = width;
    this.#parentHeight = height;
    this.#parentScale = scale;
    const [newMarginX, newMarginY] = this.#getMarginComponents();
    const diffMarginX = newMarginX - oldMarginX;
    const diffMarginY = newMarginY - oldMarginY;
    const bbox = this.#bbox;
    bbox[0] -= diffMarginX;
    bbox[1] -= diffMarginY;
    bbox[2] += 2 * diffMarginX;
    bbox[3] += 2 * diffMarginY;
    return bbox;
  }
  updateRotation(rotation) {
    this.#currentRotation = rotation;
    return {
      path: {
        transform: this.rotationTransform
      }
    };
  }
  get viewBox() {
    return this.#bbox.map(Outline.svgRound).join(" ");
  }
  get defaultProperties() {
    const [x3, y12] = this.#bbox;
    return {
      root: {
        viewBox: this.viewBox
      },
      path: {
        "transform-origin": `${Outline.svgRound(x3)} ${Outline.svgRound(y12)}`
      }
    };
  }
  get rotationTransform() {
    const [, , width, height] = this.#bbox;
    let a22 = 0, b7 = 0, c21 = 0, d15 = 0, e10 = 0, f13 = 0;
    switch (this.#currentRotation) {
      case 90:
        b7 = height / width;
        c21 = -width / height;
        e10 = width;
        break;
      case 180:
        a22 = -1;
        d15 = -1;
        e10 = width;
        f13 = height;
        break;
      case 270:
        b7 = -height / width;
        c21 = width / height;
        f13 = height;
        break;
      default:
        return "";
    }
    return `matrix(${a22} ${b7} ${c21} ${d15} ${Outline.svgRound(e10)} ${Outline.svgRound(f13)})`;
  }
  getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {
    const [marginX, marginY] = this.#getMarginComponents();
    const [x3, y12, width, height] = this.#bbox;
    if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
      const tx = newX + newWidth / 2 - (x3 + width / 2);
      const ty = newY + newHeight / 2 - (y12 + height / 2);
      return {
        path: {
          "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
          transform: `${this.rotationTransform} translate(${tx} ${ty})`
        }
      };
    }
    const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
    const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
    const s2x = width / newWidth;
    const s2y = height / newHeight;
    return {
      path: {
        "transform-origin": `${Outline.svgRound(x3)} ${Outline.svgRound(y12)}`,
        transform: `${this.rotationTransform} scale(${s2x} ${s2y}) translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`
      }
    };
  }
  getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {
    const [marginX, marginY] = this.#getMarginComponents();
    const bbox = this.#bbox;
    const [x3, y12, width, height] = bbox;
    bbox[0] = newX;
    bbox[1] = newY;
    bbox[2] = newWidth;
    bbox[3] = newHeight;
    if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
      const tx2 = newX + newWidth / 2 - (x3 + width / 2);
      const ty2 = newY + newHeight / 2 - (y12 + height / 2);
      for (const {
        line,
        points
      } of this.#lines) {
        Outline._translate(line, tx2, ty2, line);
        Outline._translate(points, tx2, ty2, points);
      }
      return {
        root: {
          viewBox: this.viewBox
        },
        path: {
          "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
          transform: this.rotationTransform || null,
          d: this.toSVGPath()
        }
      };
    }
    const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
    const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
    const tx = -s1x * (x3 + marginX) + newX + marginX;
    const ty = -s1y * (y12 + marginY) + newY + marginY;
    if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {
      for (const {
        line,
        points
      } of this.#lines) {
        Outline._rescale(line, tx, ty, s1x, s1y, line);
        Outline._rescale(points, tx, ty, s1x, s1y, points);
      }
    }
    return {
      root: {
        viewBox: this.viewBox
      },
      path: {
        "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
        transform: this.rotationTransform || null,
        d: this.toSVGPath()
      }
    };
  }
  getPathTranslatedSVGProperties([newX, newY], parentDimensions) {
    const [newParentWidth, newParentHeight] = parentDimensions;
    const bbox = this.#bbox;
    const tx = newX - bbox[0];
    const ty = newY - bbox[1];
    if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) {
      for (const {
        line,
        points
      } of this.#lines) {
        Outline._translate(line, tx, ty, line);
        Outline._translate(points, tx, ty, points);
      }
    } else {
      const sx = this.#parentWidth / newParentWidth;
      const sy = this.#parentHeight / newParentHeight;
      this.#parentWidth = newParentWidth;
      this.#parentHeight = newParentHeight;
      for (const {
        line,
        points
      } of this.#lines) {
        Outline._rescale(line, tx, ty, sx, sy, line);
        Outline._rescale(points, tx, ty, sx, sy, points);
      }
      bbox[2] *= sx;
      bbox[3] *= sy;
    }
    bbox[0] = newX;
    bbox[1] = newY;
    return {
      root: {
        viewBox: this.viewBox
      },
      path: {
        d: this.toSVGPath(),
        "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`
      }
    };
  }
  get defaultSVGProperties() {
    const bbox = this.#bbox;
    return {
      root: {
        viewBox: this.viewBox
      },
      rootClass: {
        draw: true
      },
      path: {
        d: this.toSVGPath(),
        "transform-origin": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,
        transform: this.rotationTransform || null
      },
      bbox
    };
  }
};
;
var InkDrawingOptions = class _InkDrawingOptions extends DrawingOptions {
  static {
    __name(this, "InkDrawingOptions");
  }
  constructor(viewerParameters) {
    super();
    this._viewParameters = viewerParameters;
    super.updateProperties({
      fill: "none",
      stroke: AnnotationEditor._defaultLineColor,
      "stroke-opacity": 1,
      "stroke-width": 1,
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-miterlimit": 10
    });
  }
  updateSVGProperty(name4, value) {
    if (name4 === "stroke-width") {
      value ??= this["stroke-width"];
      value *= this._viewParameters.realScale;
    }
    super.updateSVGProperty(name4, value);
  }
  clone() {
    const clone = new _InkDrawingOptions(this._viewParameters);
    clone.updateAll(this);
    return clone;
  }
};
var InkEditor = class _InkEditor extends DrawingEditor {
  static {
    __name(this, "InkEditor");
  }
  static _type = "ink";
  static _editorType = AnnotationEditorType.INK;
  static _defaultDrawingOptions = null;
  constructor(params) {
    super({
      ...params,
      name: "inkEditor"
    });
    this._willKeepAspectRatio = true;
    this.defaultL10nId = "pdfjs-editor-ink-editor";
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
    this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);
  }
  static getDefaultDrawingOptions(options) {
    const clone = this._defaultDrawingOptions.clone();
    clone.updateProperties(options);
    return clone;
  }
  static get supportMultipleDrawings() {
    return true;
  }
  static get typesMap() {
    return shadow(this, "typesMap", /* @__PURE__ */ new Map([[AnnotationEditorParamsType.INK_THICKNESS, "stroke-width"], [AnnotationEditorParamsType.INK_COLOR, "stroke"], [AnnotationEditorParamsType.INK_OPACITY, "stroke-opacity"]]));
  }
  static createDrawerInstance(x3, y12, parentWidth, parentHeight, rotation) {
    return new InkDrawOutliner(x3, y12, parentWidth, parentHeight, rotation, this._defaultDrawingOptions["stroke-width"]);
  }
  static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {
    return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
  }
  static async deserialize(data, parent, uiManager) {
    let initialData = null;
    if (data instanceof InkAnnotationElement) {
      const {
        data: {
          inkLists,
          rect,
          rotation,
          id,
          color,
          opacity,
          borderStyle: {
            rawWidth: thickness
          },
          popupRef,
          richText,
          contentsObj,
          creationDate,
          modificationDate
        },
        parent: {
          page: {
            pageNumber
          }
        }
      } = data;
      initialData = data = {
        annotationType: AnnotationEditorType.INK,
        color: Array.from(color),
        thickness,
        opacity,
        paths: {
          points: inkLists
        },
        boxes: null,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        popupRef,
        richText,
        comment: contentsObj?.str || null,
        creationDate,
        modificationDate
      };
    }
    const editor = await super.deserialize(data, parent, uiManager);
    editor._initialData = initialData;
    if (data.comment) {
      editor.setCommentData(data);
    }
    return editor;
  }
  get toolbarButtons() {
    this._colorPicker ||= new BasicColorPicker(this);
    return [["colorPicker", this._colorPicker]];
  }
  get colorType() {
    return AnnotationEditorParamsType.INK_COLOR;
  }
  get color() {
    return this._drawingOptions.stroke;
  }
  get opacity() {
    return this._drawingOptions["stroke-opacity"];
  }
  onScaleChanging() {
    if (!this.parent) {
      return;
    }
    super.onScaleChanging();
    const {
      _drawId,
      _drawingOptions,
      parent
    } = this;
    _drawingOptions.updateSVGProperty("stroke-width");
    parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());
  }
  static onScaleChangingWhenDrawing() {
    const parent = this._currentParent;
    if (!parent) {
      return;
    }
    super.onScaleChangingWhenDrawing();
    this._defaultDrawingOptions.updateSVGProperty("stroke-width");
    parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
  }
  createDrawingOptions({
    color,
    thickness,
    opacity
  }) {
    this._drawingOptions = _InkEditor.getDefaultDrawingOptions({
      stroke: Util.makeHexColor(...color),
      "stroke-width": thickness,
      "stroke-opacity": opacity
    });
  }
  serialize(isForCopying = false) {
    if (this.isEmpty()) {
      return null;
    }
    if (this.deleted) {
      return this.serializeDeleted();
    }
    const {
      lines,
      points
    } = this.serializeDraw(isForCopying);
    const {
      _drawingOptions: {
        stroke,
        "stroke-opacity": opacity,
        "stroke-width": thickness
      }
    } = this;
    const serialized = Object.assign(super.serialize(isForCopying), {
      color: AnnotationEditor._colorManager.convert(stroke),
      opacity,
      thickness,
      paths: {
        lines,
        points
      }
    });
    this.addComment(serialized);
    if (isForCopying) {
      serialized.isCopy = true;
      return serialized;
    }
    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
      return null;
    }
    serialized.id = this.annotationElementId;
    return serialized;
  }
  #hasElementChanged(serialized) {
    const {
      color,
      thickness,
      opacity,
      pageIndex
    } = this._initialData;
    return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c21, i18) => c21 !== color[i18]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;
  }
  renderAnnotationElement(annotation) {
    if (this.deleted) {
      annotation.hide();
      return null;
    }
    const {
      points,
      rect
    } = this.serializeDraw(false);
    annotation.updateEdited({
      rect,
      thickness: this._drawingOptions["stroke-width"],
      points,
      popup: this.comment
    });
    return null;
  }
};
;
var ContourDrawOutline = class extends InkDrawOutline {
  static {
    __name(this, "ContourDrawOutline");
  }
  toSVGPath() {
    let path = super.toSVGPath();
    if (!path.endsWith("Z")) {
      path += "Z";
    }
    return path;
  }
};
;
var BASE_HEADER_LENGTH = 8;
var POINTS_PROPERTIES_NUMBER = 3;
var SignatureExtractor = class {
  static {
    __name(this, "SignatureExtractor");
  }
  static #PARAMETERS = {
    maxDim: 512,
    sigmaSFactor: 0.02,
    sigmaR: 25,
    kernelSize: 16
  };
  static #neighborIndexToId(i0, j0, i18, j2) {
    i18 -= i0;
    j2 -= j0;
    if (i18 === 0) {
      return j2 > 0 ? 0 : 4;
    }
    if (i18 === 1) {
      return j2 + 6;
    }
    return 2 - j2;
  }
  static #neighborIdToIndex = new Int32Array([0, 1, -1, 1, -1, 0, -1, -1, 0, -1, 1, -1, 1, 0, 1, 1]);
  static #clockwiseNonZero(buf, width, i0, j0, i18, j2, offset) {
    const id = this.#neighborIndexToId(i0, j0, i18, j2);
    for (let k5 = 0; k5 < 8; k5++) {
      const kk = (-k5 + id - offset + 16) % 8;
      const shiftI = this.#neighborIdToIndex[2 * kk];
      const shiftJ = this.#neighborIdToIndex[2 * kk + 1];
      if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {
        return kk;
      }
    }
    return -1;
  }
  static #counterClockwiseNonZero(buf, width, i0, j0, i18, j2, offset) {
    const id = this.#neighborIndexToId(i0, j0, i18, j2);
    for (let k5 = 0; k5 < 8; k5++) {
      const kk = (k5 + id + offset + 16) % 8;
      const shiftI = this.#neighborIdToIndex[2 * kk];
      const shiftJ = this.#neighborIdToIndex[2 * kk + 1];
      if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {
        return kk;
      }
    }
    return -1;
  }
  static #findContours(buf, width, height, threshold) {
    const N2 = buf.length;
    const types = new Int32Array(N2);
    for (let i18 = 0; i18 < N2; i18++) {
      types[i18] = buf[i18] <= threshold ? 1 : 0;
    }
    for (let i18 = 1; i18 < height - 1; i18++) {
      types[i18 * width] = types[i18 * width + width - 1] = 0;
    }
    for (let i18 = 0; i18 < width; i18++) {
      types[i18] = types[width * height - 1 - i18] = 0;
    }
    let nbd = 1;
    let lnbd;
    const contours = [];
    for (let i18 = 1; i18 < height - 1; i18++) {
      lnbd = 1;
      for (let j2 = 1; j2 < width - 1; j2++) {
        const ij = i18 * width + j2;
        const pix = types[ij];
        if (pix === 0) {
          continue;
        }
        let i22 = i18;
        let j22 = j2;
        if (pix === 1 && types[ij - 1] === 0) {
          nbd += 1;
          j22 -= 1;
        } else if (pix >= 1 && types[ij + 1] === 0) {
          nbd += 1;
          j22 += 1;
          if (pix > 1) {
            lnbd = pix;
          }
        } else {
          if (pix !== 1) {
            lnbd = Math.abs(pix);
          }
          continue;
        }
        const points = [j2, i18];
        const isHole = j22 === j2 + 1;
        const contour = {
          isHole,
          points,
          id: nbd,
          parent: 0
        };
        contours.push(contour);
        let contour0;
        for (const c21 of contours) {
          if (c21.id === lnbd) {
            contour0 = c21;
            break;
          }
        }
        if (!contour0) {
          contour.parent = isHole ? lnbd : 0;
        } else if (contour0.isHole) {
          contour.parent = isHole ? contour0.parent : lnbd;
        } else {
          contour.parent = isHole ? lnbd : contour0.parent;
        }
        const k5 = this.#clockwiseNonZero(types, width, i18, j2, i22, j22, 0);
        if (k5 === -1) {
          types[ij] = -nbd;
          if (types[ij] !== 1) {
            lnbd = Math.abs(types[ij]);
          }
          continue;
        }
        let shiftI = this.#neighborIdToIndex[2 * k5];
        let shiftJ = this.#neighborIdToIndex[2 * k5 + 1];
        const i1 = i18 + shiftI;
        const j1 = j2 + shiftJ;
        i22 = i1;
        j22 = j1;
        let i32 = i18;
        let j3 = j2;
        while (true) {
          const kk = this.#counterClockwiseNonZero(types, width, i32, j3, i22, j22, 1);
          shiftI = this.#neighborIdToIndex[2 * kk];
          shiftJ = this.#neighborIdToIndex[2 * kk + 1];
          const i42 = i32 + shiftI;
          const j4 = j3 + shiftJ;
          points.push(j4, i42);
          const ij3 = i32 * width + j3;
          if (types[ij3 + 1] === 0) {
            types[ij3] = -nbd;
          } else if (types[ij3] === 1) {
            types[ij3] = nbd;
          }
          if (i42 === i18 && j4 === j2 && i32 === i1 && j3 === j1) {
            if (types[ij] !== 1) {
              lnbd = Math.abs(types[ij]);
            }
            break;
          } else {
            i22 = i32;
            j22 = j3;
            i32 = i42;
            j3 = j4;
          }
        }
      }
    }
    return contours;
  }
  static #douglasPeuckerHelper(points, start, end, output) {
    if (end - start <= 4) {
      for (let i18 = start; i18 < end - 2; i18 += 2) {
        output.push(points[i18], points[i18 + 1]);
      }
      return;
    }
    const ax = points[start];
    const ay = points[start + 1];
    const abx = points[end - 4] - ax;
    const aby = points[end - 3] - ay;
    const dist = Math.hypot(abx, aby);
    const nabx = abx / dist;
    const naby = aby / dist;
    const aa = nabx * ay - naby * ax;
    const m18 = aby / abx;
    const invS = 1 / dist;
    const phi = Math.atan(m18);
    const cosPhi = Math.cos(phi);
    const sinPhi = Math.sin(phi);
    const tmax = invS * (Math.abs(cosPhi) + Math.abs(sinPhi));
    const poly = invS * (1 - tmax + tmax ** 2);
    const partialPhi = Math.max(Math.atan(Math.abs(sinPhi + cosPhi) * poly), Math.atan(Math.abs(sinPhi - cosPhi) * poly));
    let dmax = 0;
    let index = start;
    for (let i18 = start + 2; i18 < end - 2; i18 += 2) {
      const d15 = Math.abs(aa - nabx * points[i18 + 1] + naby * points[i18]);
      if (d15 > dmax) {
        index = i18;
        dmax = d15;
      }
    }
    if (dmax > (dist * partialPhi) ** 2) {
      this.#douglasPeuckerHelper(points, start, index + 2, output);
      this.#douglasPeuckerHelper(points, index, end, output);
    } else {
      output.push(ax, ay);
    }
  }
  static #douglasPeucker(points) {
    const output = [];
    const len = points.length;
    this.#douglasPeuckerHelper(points, 0, len, output);
    output.push(points[len - 2], points[len - 1]);
    return output.length <= 4 ? null : output;
  }
  static #bilateralFilter(buf, width, height, sigmaS, sigmaR, kernelSize) {
    const kernel = new Float32Array(kernelSize ** 2);
    const sigmaS2 = -2 * sigmaS ** 2;
    const halfSize = kernelSize >> 1;
    for (let i18 = 0; i18 < kernelSize; i18++) {
      const x3 = (i18 - halfSize) ** 2;
      for (let j2 = 0; j2 < kernelSize; j2++) {
        kernel[i18 * kernelSize + j2] = Math.exp((x3 + (j2 - halfSize) ** 2) / sigmaS2);
      }
    }
    const rangeValues = new Float32Array(256);
    const sigmaR2 = -2 * sigmaR ** 2;
    for (let i18 = 0; i18 < 256; i18++) {
      rangeValues[i18] = Math.exp(i18 ** 2 / sigmaR2);
    }
    const N2 = buf.length;
    const out = new Uint8Array(N2);
    const histogram = new Uint32Array(256);
    for (let i18 = 0; i18 < height; i18++) {
      for (let j2 = 0; j2 < width; j2++) {
        const ij = i18 * width + j2;
        const center = buf[ij];
        let sum2 = 0;
        let norm = 0;
        for (let k5 = 0; k5 < kernelSize; k5++) {
          const y12 = i18 + k5 - halfSize;
          if (y12 < 0 || y12 >= height) {
            continue;
          }
          for (let l14 = 0; l14 < kernelSize; l14++) {
            const x3 = j2 + l14 - halfSize;
            if (x3 < 0 || x3 >= width) {
              continue;
            }
            const neighbour = buf[y12 * width + x3];
            const w4 = kernel[k5 * kernelSize + l14] * rangeValues[Math.abs(neighbour - center)];
            sum2 += neighbour * w4;
            norm += w4;
          }
        }
        const pix = out[ij] = Math.round(sum2 / norm);
        histogram[pix]++;
      }
    }
    return [out, histogram];
  }
  static #getHistogram(buf) {
    const histogram = new Uint32Array(256);
    for (const g10 of buf) {
      histogram[g10]++;
    }
    return histogram;
  }
  static #toUint8(buf) {
    const N2 = buf.length;
    const out = new Uint8ClampedArray(N2 >> 2);
    let max = -Infinity;
    let min = Infinity;
    for (let i18 = 0, ii = out.length; i18 < ii; i18++) {
      const pix = out[i18] = buf[i18 << 2];
      max = Math.max(max, pix);
      min = Math.min(min, pix);
    }
    const ratio = 255 / (max - min);
    for (let i18 = 0, ii = out.length; i18 < ii; i18++) {
      out[i18] = (out[i18] - min) * ratio;
    }
    return out;
  }
  static #guessThreshold(histogram) {
    let i18;
    let M = -Infinity;
    let L2 = -Infinity;
    const min = histogram.findIndex((v8) => v8 !== 0);
    let pos = min;
    let spos = min;
    for (i18 = min; i18 < 256; i18++) {
      const v8 = histogram[i18];
      if (v8 > M) {
        if (i18 - pos > L2) {
          L2 = i18 - pos;
          spos = i18 - 1;
        }
        M = v8;
        pos = i18;
      }
    }
    for (i18 = spos - 1; i18 >= 0; i18--) {
      if (histogram[i18] > histogram[i18 + 1]) {
        break;
      }
    }
    return i18;
  }
  static #getGrayPixels(bitmap) {
    const originalBitmap = bitmap;
    const {
      width,
      height
    } = bitmap;
    const {
      maxDim
    } = this.#PARAMETERS;
    let newWidth = width;
    let newHeight = height;
    if (width > maxDim || height > maxDim) {
      let prevWidth = width;
      let prevHeight = height;
      let steps = Math.log2(Math.max(width, height) / maxDim);
      const isteps = Math.floor(steps);
      steps = steps === isteps ? isteps - 1 : isteps;
      for (let i18 = 0; i18 < steps; i18++) {
        newWidth = Math.ceil(prevWidth / 2);
        newHeight = Math.ceil(prevHeight / 2);
        const offscreen2 = new OffscreenCanvas(newWidth, newHeight);
        const ctx2 = offscreen2.getContext("2d");
        ctx2.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
        prevWidth = newWidth;
        prevHeight = newHeight;
        if (bitmap !== originalBitmap) {
          bitmap.close();
        }
        bitmap = offscreen2.transferToImageBitmap();
      }
      const ratio = Math.min(maxDim / newWidth, maxDim / newHeight);
      newWidth = Math.round(newWidth * ratio);
      newHeight = Math.round(newHeight * ratio);
    }
    const offscreen = new OffscreenCanvas(newWidth, newHeight);
    const ctx = offscreen.getContext("2d", {
      willReadFrequently: true
    });
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, newWidth, newHeight);
    ctx.filter = "grayscale(1)";
    ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newWidth, newHeight);
    const grayImage = ctx.getImageData(0, 0, newWidth, newHeight).data;
    const uint8Buf = this.#toUint8(grayImage);
    return [uint8Buf, newWidth, newHeight];
  }
  static extractContoursFromText(text, {
    fontFamily,
    fontStyle,
    fontWeight
  }, pageWidth, pageHeight, rotation, innerMargin) {
    let canvas = new OffscreenCanvas(1, 1);
    let ctx = canvas.getContext("2d", {
      alpha: false
    });
    const fontSize = 200;
    const font = ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
    const {
      actualBoundingBoxLeft,
      actualBoundingBoxRight,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      fontBoundingBoxAscent,
      fontBoundingBoxDescent,
      width
    } = ctx.measureText(text);
    const SCALE = 1.5;
    const canvasWidth = Math.ceil(Math.max(Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) || 0, width) * SCALE);
    const canvasHeight = Math.ceil(Math.max(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent) || fontSize, Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || fontSize) * SCALE);
    canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
    ctx = canvas.getContext("2d", {
      alpha: true,
      willReadFrequently: true
    });
    ctx.font = font;
    ctx.filter = "grayscale(1)";
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    ctx.fillStyle = "black";
    ctx.fillText(text, canvasWidth * (SCALE - 1) / 2, canvasHeight * (3 - SCALE) / 2);
    const uint8Buf = this.#toUint8(ctx.getImageData(0, 0, canvasWidth, canvasHeight).data);
    const histogram = this.#getHistogram(uint8Buf);
    const threshold = this.#guessThreshold(histogram);
    const contourList = this.#findContours(uint8Buf, canvasWidth, canvasHeight, threshold);
    return this.processDrawnLines({
      lines: {
        curves: contourList,
        width: canvasWidth,
        height: canvasHeight
      },
      pageWidth,
      pageHeight,
      rotation,
      innerMargin,
      mustSmooth: true,
      areContours: true
    });
  }
  static process(bitmap, pageWidth, pageHeight, rotation, innerMargin) {
    const [uint8Buf, width, height] = this.#getGrayPixels(bitmap);
    const [buffer, histogram] = this.#bilateralFilter(uint8Buf, width, height, Math.hypot(width, height) * this.#PARAMETERS.sigmaSFactor, this.#PARAMETERS.sigmaR, this.#PARAMETERS.kernelSize);
    const threshold = this.#guessThreshold(histogram);
    const contourList = this.#findContours(buffer, width, height, threshold);
    return this.processDrawnLines({
      lines: {
        curves: contourList,
        width,
        height
      },
      pageWidth,
      pageHeight,
      rotation,
      innerMargin,
      mustSmooth: true,
      areContours: true
    });
  }
  static processDrawnLines({
    lines,
    pageWidth,
    pageHeight,
    rotation,
    innerMargin,
    mustSmooth,
    areContours
  }) {
    if (rotation % 180 !== 0) {
      [pageWidth, pageHeight] = [pageHeight, pageWidth];
    }
    const {
      curves,
      width,
      height
    } = lines;
    const thickness = lines.thickness ?? 0;
    const linesAndPoints = [];
    const ratio = Math.min(pageWidth / width, pageHeight / height);
    const xScale = ratio / pageWidth;
    const yScale = ratio / pageHeight;
    const newCurves = [];
    for (const {
      points
    } of curves) {
      const reducedPoints = mustSmooth ? this.#douglasPeucker(points) : points;
      if (!reducedPoints) {
        continue;
      }
      newCurves.push(reducedPoints);
      const len = reducedPoints.length;
      const newPoints = new Float32Array(len);
      const line = new Float32Array(3 * (len === 2 ? 2 : len - 2));
      linesAndPoints.push({
        line,
        points: newPoints
      });
      if (len === 2) {
        newPoints[0] = reducedPoints[0] * xScale;
        newPoints[1] = reducedPoints[1] * yScale;
        line.set([NaN, NaN, NaN, NaN, newPoints[0], newPoints[1]], 0);
        continue;
      }
      let [x1, y1, x22, y22] = reducedPoints;
      x1 *= xScale;
      y1 *= yScale;
      x22 *= xScale;
      y22 *= yScale;
      newPoints.set([x1, y1, x22, y22], 0);
      line.set([NaN, NaN, NaN, NaN, x1, y1], 0);
      for (let i18 = 4; i18 < len; i18 += 2) {
        const x3 = newPoints[i18] = reducedPoints[i18] * xScale;
        const y12 = newPoints[i18 + 1] = reducedPoints[i18 + 1] * yScale;
        line.set(Outline.createBezierPoints(x1, y1, x22, y22, x3, y12), (i18 - 2) * 3);
        [x1, y1, x22, y22] = [x22, y22, x3, y12];
      }
    }
    if (linesAndPoints.length === 0) {
      return null;
    }
    const outline = areContours ? new ContourDrawOutline() : new InkDrawOutline();
    outline.build(linesAndPoints, pageWidth, pageHeight, 1, rotation, areContours ? 0 : thickness, innerMargin);
    return {
      outline,
      newCurves,
      areContours,
      thickness,
      width,
      height
    };
  }
  static async compressSignature({
    outlines,
    areContours,
    thickness,
    width,
    height
  }) {
    let minDiff = Infinity;
    let maxDiff = -Infinity;
    let outlinesLength = 0;
    for (const points of outlines) {
      outlinesLength += points.length;
      for (let i18 = 2, ii = points.length; i18 < ii; i18++) {
        const dx = points[i18] - points[i18 - 2];
        minDiff = Math.min(minDiff, dx);
        maxDiff = Math.max(maxDiff, dx);
      }
    }
    let bufferType;
    if (minDiff >= -128 && maxDiff <= 127) {
      bufferType = Int8Array;
    } else if (minDiff >= -32768 && maxDiff <= 32767) {
      bufferType = Int16Array;
    } else {
      bufferType = Int32Array;
    }
    const len = outlines.length;
    const headerLength = BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * len;
    const header = new Uint32Array(headerLength);
    let offset = 0;
    header[offset++] = headerLength * Uint32Array.BYTES_PER_ELEMENT + (outlinesLength - 2 * len) * bufferType.BYTES_PER_ELEMENT;
    header[offset++] = 0;
    header[offset++] = width;
    header[offset++] = height;
    header[offset++] = areContours ? 0 : 1;
    header[offset++] = Math.max(0, Math.floor(thickness ?? 0));
    header[offset++] = len;
    header[offset++] = bufferType.BYTES_PER_ELEMENT;
    for (const points of outlines) {
      header[offset++] = points.length - 2;
      header[offset++] = points[0];
      header[offset++] = points[1];
    }
    const cs = new CompressionStream("deflate-raw");
    const writer = cs.writable.getWriter();
    await writer.ready;
    writer.write(header);
    const BufferCtor = bufferType.prototype.constructor;
    for (const points of outlines) {
      const diffs = new BufferCtor(points.length - 2);
      for (let i18 = 2, ii = points.length; i18 < ii; i18++) {
        diffs[i18 - 2] = points[i18] - points[i18 - 2];
      }
      writer.write(diffs);
    }
    writer.close();
    const buf = await new Response(cs.readable).arrayBuffer();
    const bytes = new Uint8Array(buf);
    return toBase64Util(bytes);
  }
  static async decompressSignature(signatureData) {
    try {
      const bytes = fromBase64Util(signatureData);
      const {
        readable,
        writable
      } = new DecompressionStream("deflate-raw");
      const writer = writable.getWriter();
      await writer.ready;
      writer.write(bytes).then(async () => {
        await writer.ready;
        await writer.close();
      }).catch(() => {
      });
      let data = null;
      let offset = 0;
      for await (const chunk of readable) {
        data ||= new Uint8Array(new Uint32Array(chunk.buffer, 0, 4)[0]);
        data.set(chunk, offset);
        offset += chunk.length;
      }
      const header = new Uint32Array(data.buffer, 0, data.length >> 2);
      const version6 = header[1];
      if (version6 !== 0) {
        throw new Error(`Invalid version: ${version6}`);
      }
      const width = header[2];
      const height = header[3];
      const areContours = header[4] === 0;
      const thickness = header[5];
      const numberOfDrawings = header[6];
      const bufferType = header[7];
      const outlines = [];
      const diffsOffset = (BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * numberOfDrawings) * Uint32Array.BYTES_PER_ELEMENT;
      let diffs;
      switch (bufferType) {
        case Int8Array.BYTES_PER_ELEMENT:
          diffs = new Int8Array(data.buffer, diffsOffset);
          break;
        case Int16Array.BYTES_PER_ELEMENT:
          diffs = new Int16Array(data.buffer, diffsOffset);
          break;
        case Int32Array.BYTES_PER_ELEMENT:
          diffs = new Int32Array(data.buffer, diffsOffset);
          break;
      }
      offset = 0;
      for (let i18 = 0; i18 < numberOfDrawings; i18++) {
        const len = header[POINTS_PROPERTIES_NUMBER * i18 + BASE_HEADER_LENGTH];
        const points = new Float32Array(len + 2);
        outlines.push(points);
        for (let j2 = 0; j2 < POINTS_PROPERTIES_NUMBER - 1; j2++) {
          points[j2] = header[POINTS_PROPERTIES_NUMBER * i18 + BASE_HEADER_LENGTH + j2 + 1];
        }
        for (let j2 = 0; j2 < len; j2++) {
          points[j2 + 2] = points[j2] + diffs[offset++];
        }
      }
      return {
        areContours,
        thickness,
        outlines,
        width,
        height
      };
    } catch (e10) {
      warn(`decompressSignature: ${e10}`);
      return null;
    }
  }
};
;
var SignatureOptions = class _SignatureOptions extends DrawingOptions {
  static {
    __name(this, "SignatureOptions");
  }
  constructor() {
    super();
    super.updateProperties({
      fill: AnnotationEditor._defaultLineColor,
      "stroke-width": 0
    });
  }
  clone() {
    const clone = new _SignatureOptions();
    clone.updateAll(this);
    return clone;
  }
};
var DrawnSignatureOptions = class _DrawnSignatureOptions extends InkDrawingOptions {
  static {
    __name(this, "DrawnSignatureOptions");
  }
  constructor(viewerParameters) {
    super(viewerParameters);
    super.updateProperties({
      stroke: AnnotationEditor._defaultLineColor,
      "stroke-width": 1
    });
  }
  clone() {
    const clone = new _DrawnSignatureOptions(this._viewParameters);
    clone.updateAll(this);
    return clone;
  }
};
var SignatureEditor = class _SignatureEditor extends DrawingEditor {
  static {
    __name(this, "SignatureEditor");
  }
  #isExtracted = false;
  #description = null;
  #signatureData = null;
  #signatureUUID = null;
  static _type = "signature";
  static _editorType = AnnotationEditorType.SIGNATURE;
  static _defaultDrawingOptions = null;
  constructor(params) {
    super({
      ...params,
      mustBeCommitted: true,
      name: "signatureEditor"
    });
    this._willKeepAspectRatio = true;
    this.#signatureData = params.signatureData || null;
    this.#description = null;
    this.defaultL10nId = "pdfjs-editor-signature-editor1";
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
    this._defaultDrawingOptions = new SignatureOptions();
    this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(uiManager.viewParameters);
  }
  static getDefaultDrawingOptions(options) {
    const clone = this._defaultDrawingOptions.clone();
    clone.updateProperties(options);
    return clone;
  }
  static get supportMultipleDrawings() {
    return false;
  }
  static get typesMap() {
    return shadow(this, "typesMap", /* @__PURE__ */ new Map());
  }
  static get isDrawer() {
    return false;
  }
  get telemetryFinalData() {
    return {
      type: "signature",
      hasDescription: !!this.#description
    };
  }
  static computeTelemetryFinalData(data) {
    const hasDescriptionStats = data.get("hasDescription");
    return {
      hasAltText: hasDescriptionStats.get(true) ?? 0,
      hasNoAltText: hasDescriptionStats.get(false) ?? 0
    };
  }
  get isResizable() {
    return true;
  }
  onScaleChanging() {
    if (this._drawId === null) {
      return;
    }
    super.onScaleChanging();
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    const {
      _isCopy
    } = this;
    if (_isCopy) {
      this._isCopy = false;
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    if (this._drawId === null) {
      if (this.#signatureData) {
        const {
          lines,
          mustSmooth,
          areContours,
          description,
          uuid,
          heightInPage
        } = this.#signatureData;
        const {
          rawDims: {
            pageWidth,
            pageHeight
          },
          rotation
        } = this.parent.viewport;
        const outline = SignatureExtractor.processDrawnLines({
          lines,
          pageWidth,
          pageHeight,
          rotation,
          innerMargin: _SignatureEditor._INNER_MARGIN,
          mustSmooth,
          areContours
        });
        this.addSignature(outline, heightInPage, description, uuid);
      } else {
        this.div.setAttribute("data-l10n-args", JSON.stringify({
          description: ""
        }));
        this.div.hidden = true;
        this._uiManager.getSignature(this);
      }
    } else {
      this.div.setAttribute("data-l10n-args", JSON.stringify({
        description: this.#description || ""
      }));
    }
    if (_isCopy) {
      this._isCopy = true;
      this._moveAfterPaste(baseX, baseY);
    }
    return this.div;
  }
  setUuid(uuid) {
    this.#signatureUUID = uuid;
    this.addEditToolbar();
  }
  getUuid() {
    return this.#signatureUUID;
  }
  get description() {
    return this.#description;
  }
  set description(description) {
    this.#description = description;
    if (!this.div) {
      return;
    }
    this.div.setAttribute("data-l10n-args", JSON.stringify({
      description
    }));
    super.addEditToolbar().then((toolbar) => {
      toolbar?.updateEditSignatureButton(description);
    });
  }
  getSignaturePreview() {
    const {
      newCurves,
      areContours,
      thickness,
      width,
      height
    } = this.#signatureData;
    const maxDim = Math.max(width, height);
    const outlineData = SignatureExtractor.processDrawnLines({
      lines: {
        curves: newCurves.map((points) => ({
          points
        })),
        thickness,
        width,
        height
      },
      pageWidth: maxDim,
      pageHeight: maxDim,
      rotation: 0,
      innerMargin: 0,
      mustSmooth: false,
      areContours
    });
    return {
      areContours,
      outline: outlineData.outline
    };
  }
  get toolbarButtons() {
    if (this._uiManager.signatureManager) {
      return [["editSignature", this._uiManager.signatureManager]];
    }
    return super.toolbarButtons;
  }
  addSignature(data, heightInPage, description, uuid) {
    const {
      x: savedX,
      y: savedY
    } = this;
    const {
      outline
    } = this.#signatureData = data;
    this.#isExtracted = outline instanceof ContourDrawOutline;
    this.description = description;
    let drawingOptions;
    if (this.#isExtracted) {
      drawingOptions = _SignatureEditor.getDefaultDrawingOptions();
    } else {
      drawingOptions = _SignatureEditor._defaultDrawnSignatureOptions.clone();
      drawingOptions.updateProperties({
        "stroke-width": outline.thickness
      });
    }
    this._addOutlines({
      drawOutlines: outline,
      drawingOptions
    });
    const [, pageHeight] = this.pageDimensions;
    let newHeight = heightInPage / pageHeight;
    newHeight = newHeight >= 1 ? 0.5 : newHeight;
    this.width *= newHeight / this.height;
    if (this.width >= 1) {
      newHeight *= 0.9 / this.width;
      this.width = 0.9;
    }
    this.height = newHeight;
    this.setDims();
    this.x = savedX;
    this.y = savedY;
    this.center();
    this._onResized();
    this.onScaleChanging();
    this.rotate();
    this._uiManager.addToAnnotationStorage(this);
    this.setUuid(uuid);
    this._reportTelemetry({
      action: "pdfjs.signature.inserted",
      data: {
        hasBeenSaved: !!uuid,
        hasDescription: !!description
      }
    });
    this.div.hidden = false;
  }
  getFromImage(bitmap) {
    const {
      rawDims: {
        pageWidth,
        pageHeight
      },
      rotation
    } = this.parent.viewport;
    return SignatureExtractor.process(bitmap, pageWidth, pageHeight, rotation, _SignatureEditor._INNER_MARGIN);
  }
  getFromText(text, fontInfo) {
    const {
      rawDims: {
        pageWidth,
        pageHeight
      },
      rotation
    } = this.parent.viewport;
    return SignatureExtractor.extractContoursFromText(text, fontInfo, pageWidth, pageHeight, rotation, _SignatureEditor._INNER_MARGIN);
  }
  getDrawnSignature(curves) {
    const {
      rawDims: {
        pageWidth,
        pageHeight
      },
      rotation
    } = this.parent.viewport;
    return SignatureExtractor.processDrawnLines({
      lines: curves,
      pageWidth,
      pageHeight,
      rotation,
      innerMargin: _SignatureEditor._INNER_MARGIN,
      mustSmooth: false,
      areContours: false
    });
  }
  createDrawingOptions({
    areContours,
    thickness
  }) {
    if (areContours) {
      this._drawingOptions = _SignatureEditor.getDefaultDrawingOptions();
    } else {
      this._drawingOptions = _SignatureEditor._defaultDrawnSignatureOptions.clone();
      this._drawingOptions.updateProperties({
        "stroke-width": thickness
      });
    }
  }
  serialize(isForCopying = false) {
    if (this.isEmpty()) {
      return null;
    }
    const {
      lines,
      points
    } = this.serializeDraw(isForCopying);
    const {
      _drawingOptions: {
        "stroke-width": thickness
      }
    } = this;
    const serialized = Object.assign(super.serialize(isForCopying), {
      isSignature: true,
      areContours: this.#isExtracted,
      color: [0, 0, 0],
      thickness: this.#isExtracted ? 0 : thickness
    });
    this.addComment(serialized);
    if (isForCopying) {
      serialized.paths = {
        lines,
        points
      };
      serialized.uuid = this.#signatureUUID;
      serialized.isCopy = true;
    } else {
      serialized.lines = lines;
    }
    if (this.#description) {
      serialized.accessibilityData = {
        type: "Figure",
        alt: this.#description
      };
    }
    return serialized;
  }
  static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {
    if (data.areContours) {
      return ContourDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
    }
    return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
  }
  static async deserialize(data, parent, uiManager) {
    const editor = await super.deserialize(data, parent, uiManager);
    editor.#isExtracted = data.areContours;
    editor.description = data.accessibilityData?.alt || "";
    editor.#signatureUUID = data.uuid;
    return editor;
  }
};
;
var StampEditor = class extends AnnotationEditor {
  static {
    __name(this, "StampEditor");
  }
  #bitmap = null;
  #bitmapId = null;
  #bitmapPromise = null;
  #bitmapUrl = null;
  #bitmapFile = null;
  #bitmapFileName = "";
  #canvas = null;
  #missingCanvas = false;
  #resizeTimeoutId = null;
  #isSvg = false;
  #hasBeenAddedInUndoStack = false;
  static _type = "stamp";
  static _editorType = AnnotationEditorType.STAMP;
  constructor(params) {
    super({
      ...params,
      name: "stampEditor"
    });
    this.#bitmapUrl = params.bitmapUrl;
    this.#bitmapFile = params.bitmapFile;
    this.defaultL10nId = "pdfjs-editor-stamp-editor";
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
  }
  static isHandlingMimeForPasting(mime) {
    return SupportedImageMimeTypes.includes(mime);
  }
  static paste(item, parent) {
    parent.pasteEditor({
      mode: AnnotationEditorType.STAMP
    }, {
      bitmapFile: item.getAsFile()
    });
  }
  altTextFinish() {
    if (this._uiManager.useNewAltTextFlow) {
      this.div.hidden = false;
    }
    super.altTextFinish();
  }
  get telemetryFinalData() {
    return {
      type: "stamp",
      hasAltText: !!this.altTextData?.altText
    };
  }
  static computeTelemetryFinalData(data) {
    const hasAltTextStats = data.get("hasAltText");
    return {
      hasAltText: hasAltTextStats.get(true) ?? 0,
      hasNoAltText: hasAltTextStats.get(false) ?? 0
    };
  }
  #getBitmapFetched(data, fromId = false) {
    if (!data) {
      this.remove();
      return;
    }
    this.#bitmap = data.bitmap;
    if (!fromId) {
      this.#bitmapId = data.id;
      this.#isSvg = data.isSvg;
    }
    if (data.file) {
      this.#bitmapFileName = data.file.name;
    }
    this.#createCanvas();
  }
  #getBitmapDone() {
    this.#bitmapPromise = null;
    this._uiManager.enableWaiting(false);
    if (!this.#canvas) {
      return;
    }
    if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {
      this.addEditToolbar().then(() => {
        this._editToolbar.hide();
        this._uiManager.editAltText(this, true);
      });
      return;
    }
    if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {
      this._reportTelemetry({
        action: "pdfjs.image.image_added",
        data: {
          alt_text_modal: false,
          alt_text_type: "empty"
        }
      });
      try {
        this.mlGuessAltText();
      } catch {
      }
    }
    this.div.focus();
  }
  async mlGuessAltText(imageData = null, updateAltTextData = true) {
    if (this.hasAltTextData()) {
      return null;
    }
    const {
      mlManager
    } = this._uiManager;
    if (!mlManager) {
      throw new Error("No ML.");
    }
    if (!await mlManager.isEnabledFor("altText")) {
      throw new Error("ML isn't enabled for alt text.");
    }
    const {
      data,
      width,
      height
    } = imageData || this.copyCanvas(null, null, true).imageData;
    const response = await mlManager.guess({
      name: "altText",
      request: {
        data,
        width,
        height,
        channels: data.length / (width * height)
      }
    });
    if (!response) {
      throw new Error("No response from the AI service.");
    }
    if (response.error) {
      throw new Error("Error from the AI service.");
    }
    if (response.cancel) {
      return null;
    }
    if (!response.output) {
      throw new Error("No valid response from the AI service.");
    }
    const altText = response.output;
    await this.setGuessedAltText(altText);
    if (updateAltTextData && !this.hasAltTextData()) {
      this.altTextData = {
        alt: altText,
        decorative: false
      };
    }
    return altText;
  }
  #getBitmap() {
    if (this.#bitmapId) {
      this._uiManager.enableWaiting(true);
      this._uiManager.imageManager.getFromId(this.#bitmapId).then((data) => this.#getBitmapFetched(data, true)).finally(() => this.#getBitmapDone());
      return;
    }
    if (this.#bitmapUrl) {
      const url = this.#bitmapUrl;
      this.#bitmapUrl = null;
      this._uiManager.enableWaiting(true);
      this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data) => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());
      return;
    }
    if (this.#bitmapFile) {
      const file = this.#bitmapFile;
      this.#bitmapFile = null;
      this._uiManager.enableWaiting(true);
      this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data) => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());
      return;
    }
    const input = document.createElement("input");
    input.type = "file";
    input.accept = SupportedImageMimeTypes.join(",");
    const signal = this._uiManager._signal;
    this.#bitmapPromise = new Promise((resolve) => {
      input.addEventListener("change", async () => {
        if (!input.files || input.files.length === 0) {
          this.remove();
        } else {
          this._uiManager.enableWaiting(true);
          const data = await this._uiManager.imageManager.getFromFile(input.files[0]);
          this._reportTelemetry({
            action: "pdfjs.image.image_selected",
            data: {
              alt_text_modal: this._uiManager.useNewAltTextFlow
            }
          });
          this.#getBitmapFetched(data);
        }
        resolve();
      }, {
        signal
      });
      input.addEventListener("cancel", () => {
        this.remove();
        resolve();
      }, {
        signal
      });
    }).finally(() => this.#getBitmapDone());
    input.click();
  }
  remove() {
    if (this.#bitmapId) {
      this.#bitmap = null;
      this._uiManager.imageManager.deleteId(this.#bitmapId);
      this.#canvas?.remove();
      this.#canvas = null;
      if (this.#resizeTimeoutId) {
        clearTimeout(this.#resizeTimeoutId);
        this.#resizeTimeoutId = null;
      }
    }
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      if (this.#bitmapId) {
        this.#getBitmap();
      }
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (this.#bitmapId && this.#canvas === null) {
      this.#getBitmap();
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  onceAdded(focus) {
    this._isDraggable = true;
    if (focus) {
      this.div.focus();
    }
  }
  isEmpty() {
    return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId || this.#missingCanvas);
  }
  get toolbarButtons() {
    return [["altText", this.createAltText()]];
  }
  get isResizable() {
    return true;
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this._isCopy) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.div.hidden = true;
    this.createAltText();
    if (!this.#missingCanvas) {
      if (this.#bitmap) {
        this.#createCanvas();
      } else {
        this.#getBitmap();
      }
    }
    if (this._isCopy) {
      this._moveAfterPaste(baseX, baseY);
    }
    this._uiManager.addShouldRescale(this);
    return this.div;
  }
  setCanvas(annotationElementId, canvas) {
    const {
      id: bitmapId,
      bitmap
    } = this._uiManager.imageManager.getFromCanvas(annotationElementId, canvas);
    canvas.remove();
    if (bitmapId && this._uiManager.imageManager.isValidId(bitmapId)) {
      this.#bitmapId = bitmapId;
      if (bitmap) {
        this.#bitmap = bitmap;
      }
      this.#missingCanvas = false;
      this.#createCanvas();
    }
  }
  _onResized() {
    this.onScaleChanging();
  }
  onScaleChanging() {
    if (!this.parent) {
      return;
    }
    if (this.#resizeTimeoutId !== null) {
      clearTimeout(this.#resizeTimeoutId);
    }
    const TIME_TO_WAIT = 200;
    this.#resizeTimeoutId = setTimeout(() => {
      this.#resizeTimeoutId = null;
      this.#drawBitmap();
    }, TIME_TO_WAIT);
  }
  #createCanvas() {
    const {
      div
    } = this;
    let {
      width,
      height
    } = this.#bitmap;
    const [pageWidth, pageHeight] = this.pageDimensions;
    const MAX_RATIO = 0.75;
    if (this.width) {
      width = this.width * pageWidth;
      height = this.height * pageHeight;
    } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {
      const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);
      width *= factor;
      height *= factor;
    }
    this._uiManager.enableWaiting(false);
    const canvas = this.#canvas = document.createElement("canvas");
    canvas.setAttribute("role", "img");
    this.addContainer(canvas);
    this.width = width / pageWidth;
    this.height = height / pageHeight;
    this.setDims();
    if (this._initialOptions?.isCentered) {
      this.center();
    } else {
      this.fixAndSetPosition();
    }
    this._initialOptions = null;
    if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {
      div.hidden = false;
    }
    this.#drawBitmap();
    if (!this.#hasBeenAddedInUndoStack) {
      this.parent.addUndoableEditor(this);
      this.#hasBeenAddedInUndoStack = true;
    }
    this._reportTelemetry({
      action: "inserted_image"
    });
    if (this.#bitmapFileName) {
      this.div.setAttribute("aria-description", this.#bitmapFileName);
    }
    if (!this.annotationElementId) {
      this._uiManager.a11yAlert("pdfjs-editor-stamp-added-alert");
    }
  }
  copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {
    if (!maxDataDimension) {
      maxDataDimension = 224;
    }
    const {
      width: bitmapWidth,
      height: bitmapHeight
    } = this.#bitmap;
    const outputScale = new OutputScale();
    let bitmap = this.#bitmap;
    let width = bitmapWidth, height = bitmapHeight;
    let canvas = null;
    if (maxPreviewDimension) {
      if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {
        const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);
        width = Math.floor(bitmapWidth * ratio);
        height = Math.floor(bitmapHeight * ratio);
      }
      canvas = document.createElement("canvas");
      const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);
      const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);
      if (!this.#isSvg) {
        bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);
      }
      const ctx = canvas.getContext("2d");
      ctx.filter = this._uiManager.hcmFilter;
      let white = "white", black = "#cfcfd8";
      if (this._uiManager.hcmFilter !== "none") {
        black = "black";
      } else if (ColorScheme.isDarkMode) {
        white = "#8f8f9d";
        black = "#42414d";
      }
      const boxDim = 15;
      const boxDimWidth = boxDim * outputScale.sx;
      const boxDimHeight = boxDim * outputScale.sy;
      const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);
      const patternCtx = pattern.getContext("2d");
      patternCtx.fillStyle = white;
      patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);
      patternCtx.fillStyle = black;
      patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);
      patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);
      ctx.fillStyle = ctx.createPattern(pattern, "repeat");
      ctx.fillRect(0, 0, scaledWidth, scaledHeight);
      ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
    }
    let imageData = null;
    if (createImageData) {
      let dataWidth, dataHeight;
      if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {
        dataWidth = bitmap.width;
        dataHeight = bitmap.height;
      } else {
        bitmap = this.#bitmap;
        if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {
          const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);
          dataWidth = Math.floor(bitmapWidth * ratio);
          dataHeight = Math.floor(bitmapHeight * ratio);
          if (!this.#isSvg) {
            bitmap = this.#scaleBitmap(dataWidth, dataHeight);
          }
        }
      }
      const offscreen = new OffscreenCanvas(dataWidth, dataHeight);
      const offscreenCtx = offscreen.getContext("2d", {
        willReadFrequently: true
      });
      offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);
      imageData = {
        width: dataWidth,
        height: dataHeight,
        data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data
      };
    }
    return {
      canvas,
      width,
      height,
      imageData
    };
  }
  #scaleBitmap(width, height) {
    const {
      width: bitmapWidth,
      height: bitmapHeight
    } = this.#bitmap;
    let newWidth = bitmapWidth;
    let newHeight = bitmapHeight;
    let bitmap = this.#bitmap;
    while (newWidth > 2 * width || newHeight > 2 * height) {
      const prevWidth = newWidth;
      const prevHeight = newHeight;
      if (newWidth > 2 * width) {
        newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);
      }
      if (newHeight > 2 * height) {
        newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);
      }
      const offscreen = new OffscreenCanvas(newWidth, newHeight);
      const ctx = offscreen.getContext("2d");
      ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
      bitmap = offscreen.transferToImageBitmap();
    }
    return bitmap;
  }
  #drawBitmap() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const {
      width,
      height
    } = this;
    const outputScale = new OutputScale();
    const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);
    const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);
    const canvas = this.#canvas;
    if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {
      return;
    }
    canvas.width = scaledWidth;
    canvas.height = scaledHeight;
    const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);
    const ctx = canvas.getContext("2d");
    ctx.filter = this._uiManager.hcmFilter;
    ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
  }
  #serializeBitmap(toUrl) {
    if (toUrl) {
      if (this.#isSvg) {
        const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);
        if (url) {
          return url;
        }
      }
      const canvas = document.createElement("canvas");
      ({
        width: canvas.width,
        height: canvas.height
      } = this.#bitmap);
      const ctx = canvas.getContext("2d");
      ctx.drawImage(this.#bitmap, 0, 0);
      return canvas.toDataURL();
    }
    if (this.#isSvg) {
      const [pageWidth, pageHeight] = this.pageDimensions;
      const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);
      const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);
      const offscreen = new OffscreenCanvas(width, height);
      const ctx = offscreen.getContext("2d");
      ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);
      return offscreen.transferToImageBitmap();
    }
    return structuredClone(this.#bitmap);
  }
  static async deserialize(data, parent, uiManager) {
    let initialData = null;
    let missingCanvas = false;
    if (data instanceof StampAnnotationElement) {
      const {
        data: {
          rect: rect2,
          rotation,
          id,
          structParent,
          popupRef,
          richText,
          contentsObj,
          creationDate,
          modificationDate
        },
        container,
        parent: {
          page: {
            pageNumber
          }
        },
        canvas
      } = data;
      let bitmapId2, bitmap2;
      if (canvas) {
        delete data.canvas;
        ({
          id: bitmapId2,
          bitmap: bitmap2
        } = uiManager.imageManager.getFromCanvas(container.id, canvas));
        canvas.remove();
      } else {
        missingCanvas = true;
        data._hasNoCanvas = true;
      }
      const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get("aria-label") || "";
      initialData = data = {
        annotationType: AnnotationEditorType.STAMP,
        bitmapId: bitmapId2,
        bitmap: bitmap2,
        pageIndex: pageNumber - 1,
        rect: rect2.slice(0),
        rotation,
        annotationElementId: id,
        id,
        deleted: false,
        accessibilityData: {
          decorative: false,
          altText
        },
        isSvg: false,
        structParent,
        popupRef,
        richText,
        comment: contentsObj?.str || null,
        creationDate,
        modificationDate
      };
    }
    const editor = await super.deserialize(data, parent, uiManager);
    const {
      rect,
      bitmap,
      bitmapUrl,
      bitmapId,
      isSvg,
      accessibilityData
    } = data;
    if (missingCanvas) {
      uiManager.addMissingCanvas(data.id, editor);
      editor.#missingCanvas = true;
    } else if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
      editor.#bitmapId = bitmapId;
      if (bitmap) {
        editor.#bitmap = bitmap;
      }
    } else {
      editor.#bitmapUrl = bitmapUrl;
    }
    editor.#isSvg = isSvg;
    const [parentWidth, parentHeight] = editor.pageDimensions;
    editor.width = (rect[2] - rect[0]) / parentWidth;
    editor.height = (rect[3] - rect[1]) / parentHeight;
    if (accessibilityData) {
      editor.altTextData = accessibilityData;
    }
    editor._initialData = initialData;
    if (data.comment) {
      editor.setCommentData(data);
    }
    editor.#hasBeenAddedInUndoStack = !!initialData;
    return editor;
  }
  serialize(isForCopying = false, context2 = null) {
    if (this.isEmpty()) {
      return null;
    }
    if (this.deleted) {
      return this.serializeDeleted();
    }
    const serialized = Object.assign(super.serialize(isForCopying), {
      bitmapId: this.#bitmapId,
      isSvg: this.#isSvg
    });
    this.addComment(serialized);
    if (isForCopying) {
      serialized.bitmapUrl = this.#serializeBitmap(true);
      serialized.accessibilityData = this.serializeAltText(true);
      serialized.isCopy = true;
      return serialized;
    }
    const {
      decorative,
      altText
    } = this.serializeAltText(false);
    if (!decorative && altText) {
      serialized.accessibilityData = {
        type: "Figure",
        alt: altText
      };
    }
    if (this.annotationElementId) {
      const changes = this.#hasElementChanged(serialized);
      if (changes.isSame) {
        return null;
      }
      if (changes.isSameAltText) {
        delete serialized.accessibilityData;
      } else {
        serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;
      }
      serialized.id = this.annotationElementId;
      delete serialized.bitmapId;
      return serialized;
    }
    if (context2 === null) {
      return serialized;
    }
    context2.stamps ||= /* @__PURE__ */ new Map();
    const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;
    if (!context2.stamps.has(this.#bitmapId)) {
      context2.stamps.set(this.#bitmapId, {
        area,
        serialized
      });
      serialized.bitmap = this.#serializeBitmap(false);
    } else if (this.#isSvg) {
      const prevData = context2.stamps.get(this.#bitmapId);
      if (area > prevData.area) {
        prevData.area = area;
        prevData.serialized.bitmap.close();
        prevData.serialized.bitmap = this.#serializeBitmap(false);
      }
    }
    return serialized;
  }
  #hasElementChanged(serialized) {
    const {
      pageIndex,
      accessibilityData: {
        altText
      }
    } = this._initialData;
    const isSamePageIndex = serialized.pageIndex === pageIndex;
    const isSameAltText = (serialized.accessibilityData?.alt || "") === altText;
    return {
      isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,
      isSameAltText
    };
  }
  renderAnnotationElement(annotation) {
    if (this.deleted) {
      annotation.hide();
      return null;
    }
    annotation.updateEdited({
      rect: this.getPDFRect(),
      popup: this.comment
    });
    return null;
  }
};
;
var AnnotationEditorLayer = class _AnnotationEditorLayer {
  static {
    __name(this, "AnnotationEditorLayer");
  }
  #accessibilityManager;
  #allowClick = false;
  #annotationLayer = null;
  #clickAC = null;
  #editorFocusTimeoutId = null;
  #editors = /* @__PURE__ */ new Map();
  #hadPointerDown = false;
  #isDisabling = false;
  #isEnabling = false;
  #drawingAC = null;
  #focusedElement = null;
  #textLayer = null;
  #textSelectionAC = null;
  #textLayerDblClickAC = null;
  #lastPointerDownTimestamp = -1;
  #uiManager;
  static _initialized = false;
  static #editorTypes = new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor, SignatureEditor].map((type) => [type._editorType, type]));
  constructor({
    uiManager,
    pageIndex,
    div,
    structTreeLayer,
    accessibilityManager,
    annotationLayer,
    drawLayer,
    textLayer,
    viewport,
    l10n
  }) {
    const editorTypes = [..._AnnotationEditorLayer.#editorTypes.values()];
    if (!_AnnotationEditorLayer._initialized) {
      _AnnotationEditorLayer._initialized = true;
      for (const editorType of editorTypes) {
        editorType.initialize(l10n, uiManager);
      }
    }
    uiManager.registerEditorTypes(editorTypes);
    this.#uiManager = uiManager;
    this.pageIndex = pageIndex;
    this.div = div;
    this.#accessibilityManager = accessibilityManager;
    this.#annotationLayer = annotationLayer;
    this.viewport = viewport;
    this.#textLayer = textLayer;
    this.drawLayer = drawLayer;
    this._structTree = structTreeLayer;
    this.#uiManager.addLayer(this);
  }
  get isEmpty() {
    return this.#editors.size === 0;
  }
  get isInvisible() {
    return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;
  }
  updateToolbar(options) {
    this.#uiManager.updateToolbar(options);
  }
  updateMode(mode = this.#uiManager.getMode()) {
    this.#cleanup();
    switch (mode) {
      case AnnotationEditorType.NONE:
        this.div.classList.toggle("nonEditing", true);
        this.disableTextSelection();
        this.togglePointerEvents(false);
        this.toggleAnnotationLayerPointerEvents(true);
        this.disableClick();
        return;
      case AnnotationEditorType.INK:
        this.disableTextSelection();
        this.togglePointerEvents(true);
        this.enableClick();
        break;
      case AnnotationEditorType.HIGHLIGHT:
        this.enableTextSelection();
        this.togglePointerEvents(false);
        this.disableClick();
        break;
      default:
        this.disableTextSelection();
        this.togglePointerEvents(true);
        this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(false);
    const {
      classList
    } = this.div;
    classList.toggle("nonEditing", false);
    if (mode === AnnotationEditorType.POPUP) {
      classList.toggle("commentEditing", true);
    } else {
      classList.toggle("commentEditing", false);
      for (const editorType of _AnnotationEditorLayer.#editorTypes.values()) {
        classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);
      }
    }
    this.div.hidden = false;
  }
  hasTextLayer(textLayer) {
    return textLayer === this.#textLayer?.div;
  }
  setEditingState(isEditing) {
    this.#uiManager.setEditingState(isEditing);
  }
  addCommands(params) {
    this.#uiManager.addCommands(params);
  }
  cleanUndoStack(type) {
    this.#uiManager.cleanUndoStack(type);
  }
  toggleDrawing(enabled = false) {
    this.div.classList.toggle("drawing", !enabled);
  }
  togglePointerEvents(enabled = false) {
    this.div.classList.toggle("disabled", !enabled);
  }
  toggleAnnotationLayerPointerEvents(enabled = false) {
    this.#annotationLayer?.div.classList.toggle("disabled", !enabled);
  }
  get #allEditorsIterator() {
    return this.#editors.size !== 0 ? this.#editors.values() : this.#uiManager.getEditors(this.pageIndex);
  }
  async enable() {
    this.#isEnabling = true;
    this.div.tabIndex = 0;
    this.togglePointerEvents(true);
    this.div.classList.toggle("nonEditing", false);
    this.#textLayerDblClickAC?.abort();
    this.#textLayerDblClickAC = null;
    const annotationElementIds = /* @__PURE__ */ new Set();
    for (const editor of this.#allEditorsIterator) {
      editor.enableEditing();
      editor.show(true);
      if (editor.annotationElementId) {
        this.#uiManager.removeChangedExistingAnnotation(editor);
        annotationElementIds.add(editor.annotationElementId);
      }
    }
    const annotationLayer = this.#annotationLayer;
    if (annotationLayer) {
      for (const editable of annotationLayer.getEditableAnnotations()) {
        editable.hide();
        if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {
          continue;
        }
        if (annotationElementIds.has(editable.data.id)) {
          continue;
        }
        const editor = await this.deserialize(editable);
        if (!editor) {
          continue;
        }
        this.addOrRebuild(editor);
        editor.enableEditing();
      }
    }
    this.#isEnabling = false;
    this.#uiManager._eventBus.dispatch("editorsrendered", {
      source: this,
      pageNumber: this.pageIndex + 1
    });
  }
  disable() {
    this.#isDisabling = true;
    this.div.tabIndex = -1;
    this.togglePointerEvents(false);
    this.div.classList.toggle("nonEditing", true);
    if (this.#textLayer && !this.#textLayerDblClickAC) {
      this.#textLayerDblClickAC = new AbortController();
      const signal = this.#uiManager.combinedSignal(this.#textLayerDblClickAC);
      this.#textLayer.div.addEventListener("pointerdown", (e10) => {
        const DBL_CLICK_THRESHOLD = 500;
        const {
          clientX,
          clientY,
          timeStamp
        } = e10;
        const lastPointerDownTimestamp = this.#lastPointerDownTimestamp;
        if (timeStamp - lastPointerDownTimestamp > DBL_CLICK_THRESHOLD) {
          this.#lastPointerDownTimestamp = timeStamp;
          return;
        }
        this.#lastPointerDownTimestamp = -1;
        const {
          classList: classList2
        } = this.div;
        classList2.toggle("getElements", true);
        const elements = document.elementsFromPoint(clientX, clientY);
        classList2.toggle("getElements", false);
        if (!this.div.contains(elements[0])) {
          return;
        }
        let id;
        const regex = new RegExp(`^${AnnotationEditorPrefix}[0-9]+$`);
        for (const element of elements) {
          if (regex.test(element.id)) {
            id = element.id;
            break;
          }
        }
        if (!id) {
          return;
        }
        const editor = this.#editors.get(id);
        if (editor?.annotationElementId === null) {
          e10.stopPropagation();
          e10.preventDefault();
          editor.dblclick(e10);
        }
      }, {
        signal,
        capture: true
      });
    }
    const annotationLayer = this.#annotationLayer;
    if (annotationLayer) {
      const changedAnnotations = /* @__PURE__ */ new Map();
      const resetAnnotations = /* @__PURE__ */ new Map();
      for (const editor of this.#allEditorsIterator) {
        editor.disableEditing();
        if (!editor.annotationElementId) {
          editor.updateFakeAnnotationElement(annotationLayer);
          continue;
        }
        if (editor.serialize() !== null) {
          changedAnnotations.set(editor.annotationElementId, editor);
          continue;
        } else {
          resetAnnotations.set(editor.annotationElementId, editor);
        }
        this.getEditableAnnotation(editor.annotationElementId)?.show();
        editor.remove();
      }
      const editables = annotationLayer.getEditableAnnotations();
      for (const editable of editables) {
        const {
          id
        } = editable.data;
        if (this.#uiManager.isDeletedAnnotationElement(id)) {
          editable.updateEdited({
            deleted: true
          });
          continue;
        }
        let editor = resetAnnotations.get(id);
        if (editor) {
          editor.resetAnnotationElement(editable);
          editor.show(false);
          editable.show();
          continue;
        }
        editor = changedAnnotations.get(id);
        if (editor) {
          this.#uiManager.addChangedExistingAnnotation(editor);
          if (editor.renderAnnotationElement(editable)) {
            editor.show(false);
          }
        }
        editable.show();
      }
    }
    this.#cleanup();
    if (this.isEmpty) {
      this.div.hidden = true;
    }
    const {
      classList
    } = this.div;
    for (const editorType of _AnnotationEditorLayer.#editorTypes.values()) {
      classList.remove(`${editorType._type}Editing`);
    }
    this.disableTextSelection();
    this.toggleAnnotationLayerPointerEvents(true);
    this.#isDisabling = false;
  }
  getEditableAnnotation(id) {
    return this.#annotationLayer?.getEditableAnnotation(id) || null;
  }
  setActiveEditor(editor) {
    const currentActive = this.#uiManager.getActive();
    if (currentActive === editor) {
      return;
    }
    this.#uiManager.setActiveEditor(editor);
  }
  enableTextSelection() {
    this.div.tabIndex = -1;
    if (this.#textLayer?.div && !this.#textSelectionAC) {
      this.#textSelectionAC = new AbortController();
      const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);
      this.#textLayer.div.addEventListener("pointerdown", this.#textLayerPointerDown.bind(this), {
        signal
      });
      this.#textLayer.div.classList.add("highlighting");
    }
  }
  disableTextSelection() {
    this.div.tabIndex = 0;
    if (this.#textLayer?.div && this.#textSelectionAC) {
      this.#textSelectionAC.abort();
      this.#textSelectionAC = null;
      this.#textLayer.div.classList.remove("highlighting");
    }
  }
  #textLayerPointerDown(event) {
    this.#uiManager.unselectAll();
    const {
      target
    } = event;
    if (target === this.#textLayer.div || (target.getAttribute("role") === "img" || target.classList.contains("endOfContent")) && this.#textLayer.div.contains(target)) {
      const {
        isMac
      } = util_FeatureTest.platform;
      if (event.button !== 0 || event.ctrlKey && isMac) {
        return;
      }
      this.#uiManager.showAllEditors("highlight", true, true);
      this.#textLayer.div.classList.add("free");
      this.toggleDrawing();
      HighlightEditor.startHighlighting(this, this.#uiManager.direction === "ltr", {
        target: this.#textLayer.div,
        x: event.x,
        y: event.y
      });
      this.#textLayer.div.addEventListener("pointerup", () => {
        this.#textLayer.div.classList.remove("free");
        this.toggleDrawing(true);
      }, {
        once: true,
        signal: this.#uiManager._signal
      });
      event.preventDefault();
    }
  }
  enableClick() {
    if (this.#clickAC) {
      return;
    }
    this.#clickAC = new AbortController();
    const signal = this.#uiManager.combinedSignal(this.#clickAC);
    this.div.addEventListener("pointerdown", this.pointerdown.bind(this), {
      signal
    });
    const pointerup = this.pointerup.bind(this);
    this.div.addEventListener("pointerup", pointerup, {
      signal
    });
    this.div.addEventListener("pointercancel", pointerup, {
      signal
    });
  }
  disableClick() {
    this.#clickAC?.abort();
    this.#clickAC = null;
  }
  attach(editor) {
    this.#editors.set(editor.id, editor);
    const {
      annotationElementId
    } = editor;
    if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {
      this.#uiManager.removeDeletedAnnotationElement(editor);
    }
  }
  detach(editor) {
    this.#editors.delete(editor.id);
    this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
    if (!this.#isDisabling && editor.annotationElementId) {
      this.#uiManager.addDeletedAnnotationElement(editor);
    }
  }
  remove(editor) {
    this.detach(editor);
    this.#uiManager.removeEditor(editor);
    editor.div.remove();
    editor.isAttachedToDOM = false;
  }
  changeParent(editor) {
    if (editor.parent === this) {
      return;
    }
    if (editor.parent && editor.annotationElementId) {
      this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);
      AnnotationEditor.deleteAnnotationElement(editor);
      editor.annotationElementId = null;
    }
    this.attach(editor);
    editor.parent?.detach(editor);
    editor.setParent(this);
    if (editor.div && editor.isAttachedToDOM) {
      editor.div.remove();
      this.div.append(editor.div);
    }
  }
  add(editor) {
    if (editor.parent === this && editor.isAttachedToDOM) {
      return;
    }
    this.changeParent(editor);
    this.#uiManager.addEditor(editor);
    this.attach(editor);
    if (!editor.isAttachedToDOM) {
      const div = editor.render();
      this.div.append(div);
      editor.isAttachedToDOM = true;
    }
    editor.fixAndSetPosition();
    editor.onceAdded(!this.#isEnabling);
    this.#uiManager.addToAnnotationStorage(editor);
    editor._reportTelemetry(editor.telemetryInitialData);
  }
  moveEditorInDOM(editor) {
    if (!editor.isAttachedToDOM) {
      return;
    }
    const {
      activeElement
    } = document;
    if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {
      editor._focusEventsAllowed = false;
      this.#editorFocusTimeoutId = setTimeout(() => {
        this.#editorFocusTimeoutId = null;
        if (!editor.div.contains(document.activeElement)) {
          editor.div.addEventListener("focusin", () => {
            editor._focusEventsAllowed = true;
          }, {
            once: true,
            signal: this.#uiManager._signal
          });
          activeElement.focus();
        } else {
          editor._focusEventsAllowed = true;
        }
      }, 0);
    }
    editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
  }
  addOrRebuild(editor) {
    if (editor.needsToBeRebuilt()) {
      editor.parent ||= this;
      editor.rebuild();
      editor.show();
    } else {
      this.add(editor);
    }
  }
  addUndoableEditor(editor) {
    const cmd = /* @__PURE__ */ __name(() => editor._uiManager.rebuild(editor), "cmd");
    const undo = /* @__PURE__ */ __name(() => {
      editor.remove();
    }, "undo");
    this.addCommands({
      cmd,
      undo,
      mustExec: false
    });
  }
  getEditorByUID(uid) {
    for (const editor of this.#editors.values()) {
      if (editor.uid === uid) {
        return editor;
      }
    }
    return null;
  }
  getNextId() {
    return this.#uiManager.getId();
  }
  get #currentEditorType() {
    return _AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());
  }
  combinedSignal(ac) {
    return this.#uiManager.combinedSignal(ac);
  }
  #createNewEditor(params) {
    const editorType = this.#currentEditorType;
    return editorType ? new editorType.prototype.constructor(params) : null;
  }
  canCreateNewEmptyEditor() {
    return this.#currentEditorType?.canCreateNewEmptyEditor();
  }
  async pasteEditor(options, params) {
    this.updateToolbar(options);
    await this.#uiManager.updateMode(options.mode);
    const {
      offsetX,
      offsetY
    } = this.#getCenterPoint();
    const id = this.getNextId();
    const editor = this.#createNewEditor({
      parent: this,
      id,
      x: offsetX,
      y: offsetY,
      uiManager: this.#uiManager,
      isCentered: true,
      ...params
    });
    if (editor) {
      this.add(editor);
    }
  }
  async deserialize(data) {
    return await _AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;
  }
  createAndAddNewEditor(event, isCentered, data = {}) {
    const id = this.getNextId();
    const editor = this.#createNewEditor({
      parent: this,
      id,
      x: event.offsetX,
      y: event.offsetY,
      uiManager: this.#uiManager,
      isCentered,
      ...data
    });
    if (editor) {
      this.add(editor);
    }
    return editor;
  }
  get boundingClientRect() {
    return this.div.getBoundingClientRect();
  }
  #getCenterPoint() {
    const {
      x: x3,
      y: y12,
      width,
      height
    } = this.boundingClientRect;
    const tlX = Math.max(0, x3);
    const tlY = Math.max(0, y12);
    const brX = Math.min(window.innerWidth, x3 + width);
    const brY = Math.min(window.innerHeight, y12 + height);
    const centerX = (tlX + brX) / 2 - x3;
    const centerY = (tlY + brY) / 2 - y12;
    const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];
    return {
      offsetX,
      offsetY
    };
  }
  addNewEditor(data = {}) {
    this.createAndAddNewEditor(this.#getCenterPoint(), true, data);
  }
  setSelected(editor) {
    this.#uiManager.setSelected(editor);
  }
  toggleSelected(editor) {
    this.#uiManager.toggleSelected(editor);
  }
  unselect(editor) {
    this.#uiManager.unselect(editor);
  }
  pointerup(event) {
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    if (event.target !== this.div) {
      return;
    }
    if (!this.#hadPointerDown) {
      return;
    }
    this.#hadPointerDown = false;
    if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) {
      return;
    }
    if (!this.#allowClick) {
      this.#allowClick = true;
      return;
    }
    const currentMode = this.#uiManager.getMode();
    if (currentMode === AnnotationEditorType.STAMP || currentMode === AnnotationEditorType.SIGNATURE) {
      this.#uiManager.unselectAll();
      return;
    }
    this.createAndAddNewEditor(event, false);
  }
  pointerdown(event) {
    if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {
      this.enableTextSelection();
    }
    if (this.#hadPointerDown) {
      this.#hadPointerDown = false;
      return;
    }
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    if (event.target !== this.div) {
      return;
    }
    this.#hadPointerDown = true;
    if (this.#currentEditorType?.isDrawer) {
      this.startDrawingSession(event);
      return;
    }
    const editor = this.#uiManager.getActive();
    this.#allowClick = !editor || editor.isEmpty();
  }
  startDrawingSession(event) {
    this.div.focus({
      preventScroll: true
    });
    if (this.#drawingAC) {
      this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);
      return;
    }
    this.#uiManager.setCurrentDrawingSession(this);
    this.#drawingAC = new AbortController();
    const signal = this.#uiManager.combinedSignal(this.#drawingAC);
    this.div.addEventListener("blur", ({
      relatedTarget
    }) => {
      if (relatedTarget && !this.div.contains(relatedTarget)) {
        this.#focusedElement = null;
        this.commitOrRemove();
      }
    }, {
      signal
    });
    this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);
  }
  pause(on) {
    if (on) {
      const {
        activeElement
      } = document;
      if (this.div.contains(activeElement)) {
        this.#focusedElement = activeElement;
      }
      return;
    }
    if (this.#focusedElement) {
      setTimeout(() => {
        this.#focusedElement?.focus();
        this.#focusedElement = null;
      }, 0);
    }
  }
  endDrawingSession(isAborted = false) {
    if (!this.#drawingAC) {
      return null;
    }
    this.#uiManager.setCurrentDrawingSession(null);
    this.#drawingAC.abort();
    this.#drawingAC = null;
    this.#focusedElement = null;
    return this.#currentEditorType.endDrawing(isAborted);
  }
  findNewParent(editor, x3, y12) {
    const layer = this.#uiManager.findParent(x3, y12);
    if (layer === null || layer === this) {
      return false;
    }
    layer.changeParent(editor);
    return true;
  }
  commitOrRemove() {
    if (this.#drawingAC) {
      this.endDrawingSession();
      return true;
    }
    return false;
  }
  onScaleChanging() {
    if (!this.#drawingAC) {
      return;
    }
    this.#currentEditorType.onScaleChangingWhenDrawing(this);
  }
  destroy() {
    this.commitOrRemove();
    if (this.#uiManager.getActive()?.parent === this) {
      this.#uiManager.commitOrRemove();
      this.#uiManager.setActiveEditor(null);
    }
    if (this.#editorFocusTimeoutId) {
      clearTimeout(this.#editorFocusTimeoutId);
      this.#editorFocusTimeoutId = null;
    }
    for (const editor of this.#editors.values()) {
      this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
      editor.setParent(null);
      editor.isAttachedToDOM = false;
      editor.div.remove();
    }
    this.div = null;
    this.#editors.clear();
    this.#uiManager.removeLayer(this);
  }
  #cleanup() {
    for (const editor of this.#editors.values()) {
      if (editor.isEmpty()) {
        editor.remove();
      }
    }
  }
  render({
    viewport
  }) {
    this.viewport = viewport;
    setLayerDimensions(this.div, viewport);
    for (const editor of this.#uiManager.getEditors(this.pageIndex)) {
      this.add(editor);
      editor.rebuild();
    }
    this.updateMode();
  }
  update({
    viewport
  }) {
    this.#uiManager.commitOrRemove();
    this.#cleanup();
    const oldRotation = this.viewport.rotation;
    const rotation = viewport.rotation;
    this.viewport = viewport;
    setLayerDimensions(this.div, {
      rotation
    });
    if (oldRotation !== rotation) {
      for (const editor of this.#editors.values()) {
        editor.rotate(rotation);
      }
    }
  }
  get pageDimensions() {
    const {
      pageWidth,
      pageHeight
    } = this.viewport.rawDims;
    return [pageWidth, pageHeight];
  }
  get scale() {
    return this.#uiManager.viewParameters.realScale;
  }
};
;
var DrawLayer = class _DrawLayer {
  static {
    __name(this, "DrawLayer");
  }
  #parent = null;
  #mapping = /* @__PURE__ */ new Map();
  #toUpdate = /* @__PURE__ */ new Map();
  static #id = 0;
  constructor({
    pageIndex
  }) {
    this.pageIndex = pageIndex;
  }
  setParent(parent) {
    if (!this.#parent) {
      this.#parent = parent;
      return;
    }
    if (this.#parent !== parent) {
      if (this.#mapping.size > 0) {
        for (const root of this.#mapping.values()) {
          root.remove();
          parent.append(root);
        }
      }
      this.#parent = parent;
    }
  }
  static get _svgFactory() {
    return shadow(this, "_svgFactory", new DOMSVGFactory());
  }
  static #setBox(element, [x3, y12, width, height]) {
    const {
      style
    } = element;
    style.top = `${100 * y12}%`;
    style.left = `${100 * x3}%`;
    style.width = `${100 * width}%`;
    style.height = `${100 * height}%`;
  }
  #createSVG() {
    const svg = _DrawLayer._svgFactory.create(1, 1, true);
    this.#parent.append(svg);
    svg.setAttribute("aria-hidden", true);
    return svg;
  }
  #createClipPath(defs, pathId) {
    const clipPath = _DrawLayer._svgFactory.createElement("clipPath");
    defs.append(clipPath);
    const clipPathId = `clip_${pathId}`;
    clipPath.setAttribute("id", clipPathId);
    clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
    const clipPathUse = _DrawLayer._svgFactory.createElement("use");
    clipPath.append(clipPathUse);
    clipPathUse.setAttribute("href", `#${pathId}`);
    clipPathUse.classList.add("clip");
    return clipPathId;
  }
  #updateProperties(element, properties) {
    for (const [key, value] of Object.entries(properties)) {
      if (value === null) {
        element.removeAttribute(key);
      } else {
        element.setAttribute(key, value);
      }
    }
  }
  draw(properties, isPathUpdatable = false, hasClip = false) {
    const id = _DrawLayer.#id++;
    const root = this.#createSVG();
    const defs = _DrawLayer._svgFactory.createElement("defs");
    root.append(defs);
    const path = _DrawLayer._svgFactory.createElement("path");
    defs.append(path);
    const pathId = `path_p${this.pageIndex}_${id}`;
    path.setAttribute("id", pathId);
    path.setAttribute("vector-effect", "non-scaling-stroke");
    if (isPathUpdatable) {
      this.#toUpdate.set(id, path);
    }
    const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;
    const use = _DrawLayer._svgFactory.createElement("use");
    root.append(use);
    use.setAttribute("href", `#${pathId}`);
    this.updateProperties(root, properties);
    this.#mapping.set(id, root);
    return {
      id,
      clipPathId: `url(#${clipPathId})`
    };
  }
  drawOutline(properties, mustRemoveSelfIntersections) {
    const id = _DrawLayer.#id++;
    const root = this.#createSVG();
    const defs = _DrawLayer._svgFactory.createElement("defs");
    root.append(defs);
    const path = _DrawLayer._svgFactory.createElement("path");
    defs.append(path);
    const pathId = `path_p${this.pageIndex}_${id}`;
    path.setAttribute("id", pathId);
    path.setAttribute("vector-effect", "non-scaling-stroke");
    let maskId;
    if (mustRemoveSelfIntersections) {
      const mask = _DrawLayer._svgFactory.createElement("mask");
      defs.append(mask);
      maskId = `mask_p${this.pageIndex}_${id}`;
      mask.setAttribute("id", maskId);
      mask.setAttribute("maskUnits", "objectBoundingBox");
      const rect = _DrawLayer._svgFactory.createElement("rect");
      mask.append(rect);
      rect.setAttribute("width", "1");
      rect.setAttribute("height", "1");
      rect.setAttribute("fill", "white");
      const use = _DrawLayer._svgFactory.createElement("use");
      mask.append(use);
      use.setAttribute("href", `#${pathId}`);
      use.setAttribute("stroke", "none");
      use.setAttribute("fill", "black");
      use.setAttribute("fill-rule", "nonzero");
      use.classList.add("mask");
    }
    const use1 = _DrawLayer._svgFactory.createElement("use");
    root.append(use1);
    use1.setAttribute("href", `#${pathId}`);
    if (maskId) {
      use1.setAttribute("mask", `url(#${maskId})`);
    }
    const use2 = use1.cloneNode();
    root.append(use2);
    use1.classList.add("mainOutline");
    use2.classList.add("secondaryOutline");
    this.updateProperties(root, properties);
    this.#mapping.set(id, root);
    return id;
  }
  finalizeDraw(id, properties) {
    this.#toUpdate.delete(id);
    this.updateProperties(id, properties);
  }
  updateProperties(elementOrId, properties) {
    if (!properties) {
      return;
    }
    const {
      root,
      bbox,
      rootClass,
      path
    } = properties;
    const element = typeof elementOrId === "number" ? this.#mapping.get(elementOrId) : elementOrId;
    if (!element) {
      return;
    }
    if (root) {
      this.#updateProperties(element, root);
    }
    if (bbox) {
      _DrawLayer.#setBox(element, bbox);
    }
    if (rootClass) {
      const {
        classList
      } = element;
      for (const [className, value] of Object.entries(rootClass)) {
        classList.toggle(className, value);
      }
    }
    if (path) {
      const defs = element.firstChild;
      const pathElement = defs.firstChild;
      this.#updateProperties(pathElement, path);
    }
  }
  updateParent(id, layer) {
    if (layer === this) {
      return;
    }
    const root = this.#mapping.get(id);
    if (!root) {
      return;
    }
    layer.#parent.append(root);
    this.#mapping.delete(id);
    layer.#mapping.set(id, root);
  }
  remove(id) {
    this.#toUpdate.delete(id);
    if (this.#parent === null) {
      return;
    }
    this.#mapping.get(id).remove();
    this.#mapping.delete(id);
  }
  destroy() {
    this.#parent = null;
    for (const root of this.#mapping.values()) {
      root.remove();
    }
    this.#mapping.clear();
    this.#toUpdate.clear();
  }
};
;
{
  globalThis._pdfjsTestingUtils = {
    HighlightOutliner
  };
}
globalThis.pdfjsLib = {
  AbortException,
  AnnotationEditorLayer,
  AnnotationEditorParamsType,
  AnnotationEditorType,
  AnnotationEditorUIManager,
  AnnotationLayer,
  AnnotationMode,
  AnnotationType,
  applyOpacity,
  build,
  ColorPicker,
  createValidAbsoluteUrl,
  CSSConstants,
  DOMSVGFactory,
  DrawLayer,
  FeatureTest: util_FeatureTest,
  fetchData,
  findContrastColor,
  getDocument,
  getFilenameFromUrl,
  getPdfFilenameFromUrl,
  getRGB,
  getUuid,
  getXfaPageViewport,
  GlobalWorkerOptions,
  ImageKind: util_ImageKind,
  InvalidPDFException,
  isDataScheme,
  isPdfFile,
  isValidExplicitDest,
  MathClamp,
  noContextMenu,
  normalizeUnicode,
  OPS,
  OutputScale,
  PasswordResponses,
  PDFDataRangeTransport,
  PDFDateString,
  PDFWorker,
  PermissionFlag,
  PixelsPerInch,
  RenderingCancelledException,
  renderRichText,
  ResponseException,
  setLayerDimensions,
  shadow,
  SignatureExtractor,
  stopEvent,
  SupportedImageMimeTypes,
  TextLayer,
  TouchManager,
  updateUrlHash,
  Util,
  VerbosityLevel,
  version: version5,
  XfaLayer
};

// node_modules/@mahindar5/common-lib/dist/chunk-RGB6VMDK.js
GlobalWorkerOptions.workerSrc = new URL("pdfjs-dist/build/pdf.worker.min.mjs", import_meta2.url).toString();
var k4 = class {
  static {
    __name(this, "k");
  }
  static {
    j(this, "PdfSalaryExtractorService");
  }
  async extractFromDirectory() {
    let y12 = await window.showDirectoryPicker(), f13 = [];
    for await (let r9 of y12.values()) r9.kind === "file" && r9.name.endsWith(".pdf") && f13.push({ name: r9.name.replace(".pdf", ""), file: await r9.getFile() });
    let d15 = Object.fromEntries(await Promise.all(f13.sort((r9, o21) => o21.name.localeCompare(r9.name)).map(async ({ name: r9, file: o21 }) => [r9, await this.readPdf(o21)]))), x3 = Object.keys(d15).sort((r9, o21) => o21.localeCompare(r9)), T6 = x3.flatMap((r9) => this.extractSalaryData(d15[r9]).map(({ key: o21, value: v8 }) => {
      let [a22, s18, l14] = o21.split("|");
      return { superHeader: a22, headerTitle: s18, title: l14, [r9]: v8 };
    })), m18 = Array.from(T3(T6, ["superHeader", "headerTitle", "title"]).values()).sort((r9, o21) => r9.superHeader.localeCompare(o21.superHeader) || r9.headerTitle.localeCompare(o21.headerTitle) || r9.title.localeCompare(o21.title)), u20 = m9(m18, ["superHeader", "headerTitle", "title", ...x3]), c21 = await (await y12.getFileHandle("output.csv", { create: true })).createWritable();
    await c21.write(u20), await c21.close();
  }
  async readPdf(y12) {
    let f13 = await getDocument({ data: await y12.arrayBuffer() }).promise, d15 = [];
    for (let x3 = 1; x3 <= f13.numPages; x3++) d15.push(...(await (await f13.getPage(x3)).getTextContent()).items);
    return d15;
  }
  extractSalaryData(y12) {
    let f13 = y12.findIndex((a22) => a22.str === "DATE"), d15 = f13 >= 0 ? y12.slice(f13) : y12, x3 = d15.findIndex((a22) => a22.str?.includes("R0ML")), T6 = x3 >= 0 ? d15.slice(0, x3) : d15, m18 = /* @__PURE__ */ new Map();
    T6.forEach((a22) => {
      if (!a22.str?.trim()) return;
      let s18 = Math.round(a22.transform[5]);
      (m18.get(s18) ?? m18.set(s18, []).get(s18)).push({ text: a22.str.trim(), x: a22.transform[4], xEnd: a22.width + a22.transform[4] });
    });
    let u20 = j((a22) => Math.round(a22 / 10) * 10, "roundX"), p15 = j((a22, s18) => Math.max(a22.x, s18.x) < Math.min(a22.xEnd, s18.xEnd), "overlaps"), c21 = j((a22) => isNaN(a22), "isText"), r9 = [];
    for (let [a22, s18] of m18.entries()) {
      let l14 = [];
      for (let e10 = 0; e10 < s18.length; e10++) {
        let t11 = s18[e10], n11 = s18[e10 + 1];
        n11 && c21(t11.text) && c21(n11.text) && Math.abs(n11.x - t11.x) < 30 ? (l14.push({ text: `${t11.text} ${n11.text}`, x: u20(t11.x), xEnd: u20(n11.xEnd) }), e10++) : l14.push({ ...t11, x: u20(t11.x), xEnd: u20(t11.xEnd) });
      }
      let h12 = r9[r9.length - 1];
      if (h12?.rowData.every((e10) => c21(e10.text)) && l14.every((e10) => c21(e10.text))) {
        let e10 = new Map(h12.rowData.map((t11) => {
          let n11 = l14.find((b7) => p15(t11, b7));
          return [t11.x, { ...t11, text: n11 ? `${t11.text} ${n11.text}`.trim() : t11.text }];
        }));
        l14.filter((t11) => !h12.rowData.some((n11) => p15(n11, t11))).forEach((t11) => e10.set(t11.x, t11)), h12.rowData = [...e10.values()].sort((t11, n11) => t11.x - n11.x);
      } else r9.push({ y: a22, rowData: l14 });
    }
    let o21 = [], v8 = [];
    for (let a22 of r9) {
      let s18 = a22.rowData.every((e10) => c21(e10.text)), l14 = s18 ? a22.rowData.flatMap((e10, t11) => ["EARNINGS", "DEDUCTIONS"].includes(e10.text) ? [t11] : []) : a22.rowData.flatMap((e10, t11) => c21(e10.text) && t11 > 0 && t11 < a22.rowData.length - 1 ? [t11] : []), h12 = l14.length ? (s18 ? l14 : [0, ...l14]).map((e10, t11, n11) => ({ y: a22.y, rowData: a22.rowData.slice(e10, n11[t11 + 1]) })) : [a22];
      for (let e10 of h12) if (e10.rowData.every((t11) => c21(t11.text))) o21.push({ sh: e10.rowData[0], headers: e10.rowData.slice(1), y: e10.y });
      else {
        let t11 = o21.filter((i18) => p15(e10.rowData[0], i18.sh) && i18.y > e10.y).reduce((i18, D6) => !i18 || D6.y - e10.y < i18.y - e10.y ? D6 : i18, null);
        if (!t11) continue;
        let n11 = p15(e10.rowData[0], t11.sh) ? e10.rowData[0] : null, b7 = n11?.text || "Other", E3 = b7 === "NET PAY";
        for (let i18 of e10.rowData.slice(n11 ? 1 : 0)) {
          let D6 = t11.headers.filter((w4) => p15(i18, w4)), C3 = E3 ? "TOTAL" : t11.sh.text, O3 = E3 ? "TOTAL" : D6.length ? D6.map((w4) => w4.text).join(" ") : t11.headers.length ? t11.headers.reduce((w4, M) => Math.abs(M.x - i18.x) < Math.abs(w4.x - i18.x) ? M : w4).text : "";
          v8.push({ key: `${E3 ? "1" : t11.sh.text === "EARNINGS" ? "2" : "3"}.${C3}|${O3}|${b7}`, value: i18.text });
        }
      }
    }
    return v8;
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-I3GH3NUU.js
var d11 = class {
  static {
    __name(this, "d");
  }
  static {
    j(this, "PipWindowService");
  }
  pipWindow;
  isActive = false;
  onClose;
  async open(a22, e10, r9, o21, s18, n11 = false) {
    this.isActive && this.close();
    let i18 = await window.documentPictureInPicture?.requestWindow({ width: 280, height: 250 });
    if (!i18) return false;
    this.pipWindow = i18, this.isActive = true, this.onClose = s18;
    let p15 = n11 ? "0" : "1", c21 = n11 ? "body:hover .overlay { opacity: 1; }" : "";
    return i18.document.body.innerHTML = `
			<style>
				* { margin: 0; padding: 0; box-sizing: border-box; }
				body {
					font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
					background: #000;
					color: #fff;
					position: relative;
					height: 100vh;
					overflow: hidden;
				}
				.image { width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0; }
				.overlay {
					position: absolute;
					bottom: 0;
					left: 0;
					right: 0;
					background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.8) 60%, transparent 100%);
					padding: 20px 15px 15px;
					opacity: ${p15};
					transition: opacity 0.3s ease;
					display: flex;
					flex-direction: column;
				}
				${c21}
				.controls { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; margin-bottom: 10px; }
				.info { margin-top: auto; }
				.title {
					font-family: 'Circular Std', 'Circular', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
					font-size: 16px;
					font-weight: 700;
					margin-bottom: 6px;
					overflow: hidden;
					text-overflow: ellipsis;
					white-space: nowrap;
					text-shadow: 0 2px 4px rgba(0,0,0,0.8);
				}
				.subtitle {
					font-family: 'Circular Std', 'Circular', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
					font-size: 12px;
					color: #ddd;
					line-height: 1.5;
					text-shadow: 0 1px 3px rgba(0,0,0,0.8);
				}
				.subtitle-line {
					overflow: hidden;
					text-overflow: ellipsis;
					white-space: nowrap;
					margin-bottom: 2px;
				}
				.subtitle-line:last-child {
					margin-bottom: 0;
				}
				button {
					background: none;
					border: none;
					width: 42px;
					height: 42px;
					cursor: pointer;
					color: #fff;
					font-size: 20px;
					display: flex;
					align-items: center;
					justify-content: center;
					transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
					filter: drop-shadow(0 2px 8px rgba(0,0,0,0.6));
				}
				button:hover {
					transform: scale(1.2);
					filter: drop-shadow(0 4px 12px rgba(0,0,0,0.8)) drop-shadow(0 0 8px rgba(255,255,255,0.4));
				}
				button:active {
					transform: scale(1.05);
					filter: drop-shadow(0 1px 4px rgba(0,0,0,0.5));
				}
			</style>
			<img class="image" src="${a22}" alt="Album Art" />
			<div class="overlay">
				<div class="controls">
					${o21.map((t11) => `<button id="${t11.id}" title="${t11.title || t11.id}">${t11.label}</button>`).join("")}
				</div>
				<div class="info">
					<div class="title" title="${e10}">${e10}</div>
					<div class="subtitle">
						${r9.map((t11) => `<div class="subtitle-line" title="${t11}">${t11}</div>`).join("")}
					</div>
				</div>
			</div>
		`, o21.forEach((t11) => {
      i18.document.getElementById(t11.id)?.addEventListener("click", () => t11.action());
    }), i18.addEventListener("pagehide", () => {
      this.isActive = false, this.pipWindow = void 0, this.onClose?.();
    }), true;
  }
  update(a22, e10, r9) {
    if (!this.pipWindow || !this.isActive) return;
    let o21 = this.pipWindow.document.querySelector(".image"), s18 = this.pipWindow.document.querySelector(".title"), n11 = this.pipWindow.document.querySelector(".subtitle");
    o21 && (o21.src = a22), s18 && (s18.textContent = e10, s18.title = e10), n11 && (n11.innerHTML = r9.map((i18) => `<div class="subtitle-line" title="${i18}">${i18}</div>`).join(""));
  }
  close() {
    this.pipWindow?.close(), this.isActive = false, this.pipWindow = void 0;
  }
  get active() {
    return this.isActive;
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-S2BIDZCZ.js
var T5 = /* @__PURE__ */ new Map(), h11 = j((r9) => async (n11, e10) => {
  let { baseUrl: i18, endpoint: p15 = "/rpc" } = r9, d15 = typeof r9.headers == "function" ? await r9.headers() : r9.headers, u20 = `${i18}${p15}`, s18 = new AbortController(), a22 = setTimeout(() => s18.abort(), e10);
  try {
    let t11 = await fetch(u20, { method: "POST", headers: { "Content-Type": "application/json", ...d15 || {} }, body: JSON.stringify(n11), signal: s18.signal });
    if (clearTimeout(a22), !t11.ok) throw new Error(`HTTP ${t11.status}: ${t11.statusText}`);
    return await t11.json();
  } catch (t11) {
    throw clearTimeout(a22), t11 instanceof Error && t11.name === "AbortError" ? new Error(`HTTP RPC timeout after ${e10}ms`) : t11;
  }
}, "createHttpTransport");
function m15(r9, n11, e10 = "http") {
  return m2(h11(n11), T5, r9, e10);
}
__name(m15, "m");
j(m15, "resolveHttpRpc");

// node_modules/@mahindar5/common-lib/dist/chunk-RBS46MQB.js
var w2 = /* @__PURE__ */ new Map(), m16 = /* @__PURE__ */ new Map(), R5 = j((t11) => async (n11, r9) => {
  let e10 = m16.get(t11);
  return (!e10 || e10.readyState !== WebSocket.OPEN) && (e10 = new WebSocket(t11), m16.set(t11, e10), await new Promise((o21, c21) => {
    e10.onopen = () => o21(), e10.onerror = () => c21(new Error("WebSocket connection failed"));
  })), new Promise((o21, c21) => {
    let a22 = j((g10) => {
      let i18 = JSON.parse(g10.data);
      i18.requestId === n11.requestId && (e10.removeEventListener("message", a22), o21(i18));
    }, "messageHandler");
    e10.addEventListener("message", a22), e10.send(JSON.stringify(n11));
  });
}, "createWebSocketTransport");
function S4(t11, n11, r9 = "websocket") {
  return m2(R5(n11), w2, t11, r9);
}
__name(S4, "S");
j(S4, "resolveWebSocketRpc");

// node_modules/@mahindar5/common-lib/dist/chunk-RG567WRJ.js
var s12 = /* @__PURE__ */ new Map(), d12 = /* @__PURE__ */ new Map(), p11 = false;
function c14(n11) {
  let e10 = n11.data;
  if (!e10?.requestId) return;
  let r9 = s12.get(e10.requestId);
  r9 && (s12.delete(e10.requestId), r9.resolve(e10));
}
__name(c14, "c");
j(c14, "handleWindowRpcResponse");
function a18() {
  p11 || (p11 = true, window.addEventListener("message", c14));
}
__name(a18, "a");
j(a18, "ensureWindowRpcListenerSetup");
var w3 = j((n11, e10) => (a18(), new Promise((r9, t11) => {
  s12.set(n11.requestId, { resolve: r9, reject: t11 }), window.parent.postMessage(n11, "*"), setTimeout(() => {
    s12.has(n11.requestId) && (s12.delete(n11.requestId), t11(new Error(`Window RPC timeout after ${e10}ms`)));
  }, e10);
})), "windowRpcTransport");
function f11(n11, e10 = "window") {
  return m2(w3, d12, n11, e10);
}
__name(f11, "f");
j(f11, "resolveWindowRpc");

// node_modules/@mahindar5/common-lib/dist/chunk-X7PWFHYY.js
function d13(o21) {
  let s18 = [];
  return Object.entries(o21).forEach(([e10, r9]) => {
    let a22 = e10.charAt(0).toUpperCase() + e10.slice(1).replace("-", " ");
    s18.push({ value: `${e10}-theme`, displayName: a22, color: r9.color, background: r9.background, isDark: false }), s18.push({ value: `${e10}-dark-theme`, displayName: `${a22} Dark`, color: r9.colorDark, background: r9.backgroundDark, isDark: true });
  }), s18.sort((e10, r9) => {
    let a22 = e10.displayName.replace(" Dark", ""), t11 = r9.displayName.replace(" Dark", "");
    return a22 === t11 ? e10.isDark ? 1 : -1 : a22.localeCompare(t11);
  }), s18;
}
__name(d13, "d");
j(d13, "generateThemeList");
function p12(o21) {
  let s18 = [], e10 = Object.keys(o21);
  for (let r9 = 0; r9 < e10.length; r9++) for (let a22 = 0; a22 < e10.length; a22++) {
    let t11 = e10[r9], n11 = e10[a22], i18 = o21[t11], l14 = { color: i18.color, background: i18.background, colorDark: i18.colorDark, backgroundDark: i18.backgroundDark, displayName: `${g9(t11)} & ${g9(n11)}`, name: `${t11}-${n11}`, primary: t11, accent: n11 };
    s18.push(l14);
  }
  return s18.sort((r9, a22) => (r9.displayName || "").localeCompare(a22.displayName || ""));
}
__name(p12, "p");
j(p12, "generateColorCombinations");
function u17(o21, s18) {
  let e10 = Object.keys(o21).sort(), r9 = e10, a22 = s18.getStoredThemeData();
  if (a22) {
    let t11 = a22.isDark, [n11, i18] = a22.themeName.split("-"), l14 = r9.find((m18) => m18 === i18) || r9[0], k5 = e10.find((m18) => m18 === n11) || e10[0];
    return { isDarkMode: t11, selectedPrimaryColor: k5, selectedTertiaryColor: l14, themeName: a22.themeName };
  } else {
    let t11 = e10[0], n11 = r9[0];
    return { isDarkMode: false, selectedPrimaryColor: t11, selectedTertiaryColor: n11, themeName: `${t11}-${n11}` };
  }
}
__name(u17, "u");
j(u17, "initializeThemeFromStorage");
function g9(o21) {
  return o21.charAt(0).toUpperCase() + o21.slice(1);
}
__name(g9, "g");
j(g9, "capitalizeFirstLetter");

// node_modules/@mahindar5/common-lib/dist/chunk-OMKFWPYC.js
function d14(n11, r9 = {}) {
  let e10 = null, l14 = { rootMargin: "0px", threshold: [0.5, 0.75, 1], ...r9 };
  return { observer: new IntersectionObserver((c21) => {
    let s18 = 0, i18 = null;
    if (c21.forEach((t11) => {
      t11.isIntersecting && t11.intersectionRatio > s18 && (s18 = t11.intersectionRatio, i18 = t11.target);
    }), i18) {
      let t11 = i18;
      e10 && e10 !== t11 && e10.pause(), t11.paused && (e10 = t11, e10.play().catch(() => {
      }));
    } else e10 && e10.play().catch(() => {
    });
    n11?.(e10);
  }, l14), getCurrentVideo: j(() => e10, "getCurrentVideo") };
}
__name(d14, "d");
j(d14, "createVideoIntersectionObserver");
function u18(n11, r9) {
  r9.forEach((e10) => {
    n11.observe(e10);
  });
}
__name(u18, "u");
j(u18, "observeVideoElements");

// node_modules/@mahindar5/common-lib/dist/chunk-E4GZCGR7.js
function c15(i18, f13, o21, t11) {
  let y12 = /* @__PURE__ */ new Set([...Object.keys(i18 || {}), ...Object.keys(f13 || {})]);
  for (let d15 of y12) {
    let s18 = `${o21}.${d15}`, e10 = i18?.[d15], n11 = f13?.[d15];
    e10 === void 0 && n11 !== void 0 ? t11.push({ path: s18, current: void 0, fresh: n11, type: "added" }) : e10 !== void 0 && n11 === void 0 ? t11.push({ path: s18, current: e10, fresh: void 0, type: "deleted" }) : typeof e10 == "object" && typeof n11 == "object" && e10 !== null && n11 !== null ? c15(e10, n11, s18, t11) : JSON.stringify(e10) !== JSON.stringify(n11) && t11.push({ path: s18, current: e10, fresh: n11, type: "modified" });
  }
}
__name(c15, "c");
j(c15, "compareObjects2");

// node_modules/@mahindar5/common-lib/dist/chunk-UK5OURJ4.js
function o18(d15, s18) {
  d15.sort((t11, e10) => e10.subscribers - t11.subscribers);
  let r9 = s18.map((t11) => {
    let e10 = d15.filter((n11) => t11.subreddits.includes(n11.displayName)).map((n11) => n11.displayName), a22 = t11.subreddits.filter((n11) => !d15.map((b7) => b7.displayName).includes(n11)), l14 = d15.filter((n11) => !t11.subreddits.includes(n11.displayName)).map((n11) => n11.displayName);
    return { mrname: t11.name, mrCount: t11.subreddits.length, subredditsInMulti: e10, subredditsNotSubscribedButInMulti: a22, subredditsSubscribedButNotInMulti: l14 };
  }), i18 = d15.filter((t11) => !s18.flatMap((e10) => e10.subreddits).includes(t11.displayName)).map((t11) => t11.displayName);
  return r9.push({ mrname: "Not in any custom feed", mrCount: i18.length, subredditsInMulti: i18, subredditsNotSubscribedButInMulti: [], subredditsSubscribedButNotInMulti: [] }), r9;
}
__name(o18, "o");
j(o18, "processRedditData");
function c16(d15, s18) {
  return d15.map((i18) => {
    let t11 = s18.filter((e10) => e10.subreddits.includes(i18.displayName));
    return { name: i18.displayName, notification_level: i18.notificationLevel, original_content_tag_enabled: i18.originalContentTagEnabled, over18: i18.over18, quarantine: i18.quarantine, subreddit_type: i18.subredditType, subscribers: i18.subscribers, hide_ads: i18.hideAds, mrname: t11.map((e10) => e10.displayName).join(", "), mrCount: t11.length, suggestedname: void 0 };
  });
}
__name(c16, "c");
j(c16, "mapSubredditsWithMultiRedditInfo");

// node_modules/@mahindar5/common-lib/dist/chunk-VHRZDLKB.js
var e5 = { login: "log-in", "ai-chat": "chatbubble", "ai-agent": "terminal", settings: "settings", dashboard: "bar-chart", gpt: "chatbubbles", "dlink-router": "wifi", "folder-overview": "folder-open", "split-wiser": "calculator", "wealth-simple": "trending-up", "pdf-sal": "document-text", spotify: "musical-notes", tabs: "albums", userroles: "people", reddit: "logo-reddit", "build-and-release": "construct", "flipkart-scrape": "bag", "amazon-scrape": "bag-handle", "jiomart-scrape": "storefront", "bigbasket-scrape": "basket", errors: "bug", tab6: "tablet-landscape", tab61: "tablet-portrait", tab2: "duplicate", tab3: "copy", tab4: "albums", "shaw-router": "wifi", "playback-rate": "speedometer", "reload-page": "refresh-circle", "screen-capture": "camera", flipkart: "bag", "hathway-router": "wifi", list: "list", ioniccode: "code-slash", "heart-rate-monitor": "pulse", "extension-data": "extension-puzzle", "pc-optimum-tabs": "card", "download-cache": "download", "token-callback": "key", "box-breathing": "leaf" };

// node_modules/@mahindar5/common-lib/dist/chunk-ESOZ2FXD.js
function b4(i18) {
  return i18.reduce((n11, o21) => {
    let r9 = new Date(o21.timestamp).toLocaleDateString("en-CA");
    return n11[r9] = n11[r9] || [], n11[r9].push({ ...o21, day: r9 }), n11;
  }, {});
}
__name(b4, "b");
j(b4, "getDayLevelData");
function C2(i18, n11, o21) {
  let r9 = Object.keys(i18), D6 = Math.max(...r9.map((m18) => i18[m18].length)), t11 = [];
  return r9.forEach((m18) => {
    let g10 = i18[m18].slice().reverse(), [l14, T6, h12] = m18.split("-").map(Number), s18 = new Date(l14, T6 - 1, h12), c21 = new Date(s18.getUTCFullYear(), s18.getUTCMonth(), s18.getUTCDate(), 0, 0, 0), y12 = new Date(s18.getUTCFullYear(), s18.getUTCMonth(), s18.getUTCDate(), 23, 59, 59, 999);
    for (let e10 = 0; e10 < D6; e10++) {
      let a22 = g10[e10], d15 = a22 ? new Date(a22.timestamp) : c21, p15 = a22?.endTimestamp && e10 !== g10.length - 1 ? new Date(a22.endTimestamp) : y12;
      e10 === 0 && (t11[0] = t11[0] || { data: [], backgroundColor: [], times: [] }, t11[0].data.push(n11(c21, d15)), t11[0].backgroundColor.push(o21(a22?.type === "added" ? "removed" : "added")), t11[0].times.push({ startTime: c21, endTime: d15 })), t11[e10 + 1] = t11[e10 + 1] || { data: [], backgroundColor: [], times: [] }, t11[e10 + 1].data.push(a22 ? n11(d15, p15) : 0), t11[e10 + 1].backgroundColor.push(o21(a22?.type || "")), t11[e10 + 1].times.push({ startTime: d15, endTime: p15 });
    }
  }), t11;
}
__name(C2, "C");
j(C2, "buildDayLevelChartDatasets");

// node_modules/@mahindar5/common-lib/dist/chunk-YQM6UDWJ.js
function s13(r9, o21, i18) {
  return r9.sort((a22, e10) => {
    let t11, n11;
    return o21 === "amount" ? (t11 = a22.amount ? parseFloat(a22.amount) : 0, a22.amountSign === "negative" && (t11 *= -1), n11 = e10.amount ? parseFloat(e10.amount) : 0, e10.amountSign === "negative" && (n11 *= -1)) : (t11 = a22[o21] || "", n11 = e10[o21] || ""), i18 === "asc" ? t11 > n11 ? 1 : t11 < n11 ? -1 : 0 : t11 < n11 ? 1 : t11 > n11 ? -1 : 0;
  });
}
__name(s13, "s");
j(s13, "sortActivities");

// node_modules/@mahindar5/common-lib/dist/chunk-C4LVV2FW.js
function p13(e10, n11, l14) {
  let c21 = /* @__PURE__ */ new Map(), a22 = [];
  for (let s18 of e10.split(",").map((t11) => t11.trim()).filter(Boolean)) {
    let t11 = n11.find((r9) => r9.trackId === s18);
    if (t11) {
      let r9 = t11.playlistName, i18 = c21.get(r9);
      c21.set(r9, { playlistName: r9, trackIds: [t11.uri, ...i18?.trackIds || []] });
    } else a22.push("spotify:track:" + s18);
  }
  return { newTracks: { playlistName: "TrackIds not found in modal tracks or corrupted", trackIds: a22, checked: false }, existingTracks: c21 };
}
__name(p13, "p");
j(p13, "populateTrackIds");

// node_modules/@mahindar5/common-lib/dist/chunk-XUVQ4PH2.js
function s14(r9, e10 = "-") {
  return r9.split(e10).map((t11) => t11.charAt(0)?.toUpperCase() + t11.slice(1).toLowerCase()).join(" ");
}
__name(s14, "s");
j(s14, "capitalizeWords");

// node_modules/@mahindar5/common-lib/dist/chunk-LONJLXIL.js
function b5(t11, a22, o21, l14, n11) {
  let c21 = new Date(t11), i18 = parseInt(a22) * 3, s18 = i18 + 3, J = 1e3, w4 = l14.Scheduler || 3e4, u20 = Object.keys(o21).filter((e10) => new Date(e10).toDateString() === c21.toDateString() && new Date(e10).getHours() >= i18 && new Date(e10).getHours() < s18).sort();
  if (u20.length === 0) return [];
  let d15 = [];
  for (let e10 = 0; e10 < u20.length; e10++) if (d15.push(u20[e10]), e10 < u20.length - 1) {
    let g10 = new Date(u20[e10]).getTime(), m18 = new Date(u20[e10 + 1]).getTime();
    for (; g10 + w4 + J < m18; ) {
      g10 += w4;
      let f13 = new Date(g10).toISOString();
      d15.push(f13);
    }
  }
  u20 = d15;
  let p15 = {}, T6 = {};
  return n11.forEach((e10) => {
    p15[e10] = null, T6[e10] = false;
  }), u20.map((e10, g10) => {
    let m18 = o21[e10] || {}, f13 = { time: new Date(e10), newTimestamp: !o21[e10] };
    return n11.forEach((h12) => {
      f13[h12] = S5(h12, e10, m18.succeededJobs || [], m18.failedJobs || [], p15, T6, l14);
    }), f13;
  });
}
__name(b5, "b");
j(b5, "processAndFilterJobData");
function S5(t11, a22, o21, l14, n11, c21, r9) {
  let i18 = new Date(a22).getTime(), s18 = n11[t11] ? new Date(n11[t11]).getTime() : null;
  return o21.includes(t11) ? (n11[t11] = a22, c21[t11] = false, "success") : l14.includes(t11) ? (n11[t11] = a22, c21[t11] = false, "fail") : s18 !== null && i18 >= s18 + r9[t11] && !c21[t11] ? (c21[t11] = true, "missed") : "neutral";
}
__name(S5, "S");
j(S5, "getJobStatus");
function y10(t11, a22, o21, l14) {
  let n11 = t11;
  if (a22.length > 0 ? n11 = n11.map((r9) => {
    let i18 = { time: r9.time, newTimestamp: r9.newTimestamp };
    return a22.forEach((s18) => {
      i18[s18] = r9[s18];
    }), i18;
  }) : n11 = n11.map((r9) => {
    let i18 = { time: r9.time, newTimestamp: r9.newTimestamp };
    return l14.forEach((s18) => {
      i18[s18] = r9[s18];
    }), i18;
  }), o21) {
    let r9 = o21.toLowerCase();
    n11 = n11.filter((i18) => Object.values(i18).some((s18) => s18 && s18.toString().toLowerCase().includes(r9)));
  }
  let c21 = a22.length > 0 ? [...a22] : [...l14];
  return { filteredData: n11, displayedJobNames: c21 };
}
__name(y10, "y");
j(y10, "filterDataBySelectedJobsAndSearchText");

// node_modules/@mahindar5/common-lib/dist/chunk-HA3XWTYK.js
async function p14(r9, d15, s18, l14 = 0.5) {
  let u20 = r9 ? { displaySurface: "monitor", width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30 } } : { displaySurface: "monitor" }, m18 = r9 ? { echoCancellation: false, autoGainControl: false, noiseSuppression: false, sampleRate: { ideal: 48e3 }, channelCount: { ideal: 2 } } : true, S7 = { echoCancellation: true, autoGainControl: true, noiseSuppression: true, sampleRate: { ideal: 48e3 }, channelCount: { ideal: 1 } }, e10 = await navigator.mediaDevices.getDisplayMedia({ video: u20, audio: m18 });
  if (e10.getAudioTracks().length === 0) throw s18(), new Error("Desktop stream audio was not selected");
  e10.getTracks().forEach((a22) => {
    a22.addEventListener("ended", () => s18());
  });
  let i18 = d15 ? await navigator.mediaDevices.getUserMedia({ audio: S7 }) : null, t11 = new AudioContext(), n11 = t11.createMediaStreamDestination();
  if (e10.getAudioTracks().length > 0) {
    let a22 = t11.createMediaStreamSource(e10), o21 = t11.createGain();
    o21.gain.value = 1, a22.connect(o21).connect(n11);
  }
  if (i18?.getAudioTracks().length) {
    let a22 = t11.createMediaStreamSource(i18), o21 = t11.createGain();
    o21.gain.value = l14, a22.connect(o21).connect(n11);
  }
  return { combinedStream: new MediaStream([...e10.getVideoTracks(), ...n11.stream.getAudioTracks()]), desktopStream: e10, voiceStream: i18, audioContext: t11 };
}
__name(p14, "p");
j(p14, "getMediaStream");

// node_modules/@mahindar5/common-lib/dist/chunk-DVQFC2FS.js
async function m17(o21) {
  let n11 = [], a22 = 1;
  for (let i18 of o21) if (i18.name.endsWith(".json")) try {
    let s18 = await i18.text(), c21 = JSON.parse(s18);
    for (let u20 of c21.questionnaires) for (let t11 of u20.questions) {
      let l14 = { id: a22++, text: t11.text, textHtml: t11.textHtml, rationaleHtml: t11.rationaleHtml, type: t11.type, choices: t11.choices.map((e10) => ({ id: e10.id, text: e10.text, textHtml: e10.textHtml, isCorrect: e10.isCorrect, userSelected: false })) };
      n11.push(l14);
    }
  } catch (s18) {
    console.error(`Error parsing Microsoft exam file ${i18.name}:`, s18);
  }
  return n11;
}
__name(m17, "m");
j(m17, "parseMicrosoftExamFiles");

// node_modules/@mahindar5/common-lib/dist/chunk-CLPCXIP3.js
function s15(e10, r9, t11 = true) {
  if (!e10 || r9 <= 0) return null;
  let o21 = {};
  for (let n11 in e10) e10.hasOwnProperty(n11) && typeof e10[n11] == "number" && (!t11 || !n11.includes("Percent")) && (o21[n11] = e10[n11] * r9, isNaN(o21[n11]) && (o21[n11] = 0));
  return o21;
}
__name(s15, "s");
j(s15, "calculateScaledNutrition");
function l12(e10) {
  let { totalFat: r9 = 0, totalCarbohydrate: t11 = 0, protein: o21 = 0 } = e10, n11 = (r9 + t11 + o21) * 0.01;
  return { fatRatio: r9 / n11, carbRatio: t11 / n11, proteinRatio: o21 / n11 };
}
__name(l12, "l");
j(l12, "calculateNutritionRatio");
function a19(e10) {
  return e10 ? parseFloat(e10.replace(/[^\d.-]/g, "")) : 0;
}
__name(a19, "a");
j(a19, "parseValue");
function c17(e10) {
  if (!e10) return 0;
  e10.includes("(") && (e10 = e10.split("(")[1]);
  let r9 = a19(e10);
  return e10.toLowerCase().includes("kg") ? r9 * 1e6 : e10.toLowerCase().includes("g") && !e10.toLowerCase().includes("mg") || e10.toLowerCase().includes("l") && !e10.toLowerCase().includes("ml") ? r9 * 1e3 : e10.toLowerCase().includes("cup") ? r9 * 24e4 : r9;
}
__name(c17, "c");
j(c17, "convertToMg");
function u19(e10) {
  if (!e10) return null;
  let r9 = { calories: a19(e10.calories?.valueInGram), caloriesPercent: a19(e10.calories?.valuePercent), totalFat: c17(e10.totalFat?.valueInGram), totalFatPercent: a19(e10.totalFat?.valuePercent), totalCarbohydrate: c17(e10.totalCarbohydrate?.valueInGram), totalCarbohydratePercent: a19(e10.totalCarbohydrate?.valuePercent), protein: c17(e10.protein?.valueInGram), proteinPercent: a19(e10.protein?.valuePercent), potassium: c17(e10.potassium?.valueInGram), potassiumPercent: a19(e10.potassium?.valuePercent), cholesterol: c17(e10.cholesterol?.valueInGram), cholesterolPercent: a19(e10.cholesterol?.valuePercent), sodium: c17(e10.sodium?.valueInGram), sodiumPercent: a19(e10.sodium?.valuePercent) };
  return e10.microNutrition?.forEach((t11) => {
    let o21 = `microNutrition${t11.code.charAt(0).toUpperCase() + t11.code.slice(1)}`;
    r9[o21] = c17(t11.valueInGram), r9[`${o21}Percent`] = a19(t11.valuePercent);
  }), e10.topNutrition?.forEach((t11) => {
    let o21 = `topNutrition${t11.code.charAt(0).toUpperCase() + t11.code.slice(1)}`;
    r9[o21] = c17(t11.valueInGram), r9[`${o21}Percent`] = a19(t11.valuePercent);
  }), e10.totalFat?.subNutrients?.forEach((t11) => {
    let o21 = `totalFat${t11.code.charAt(0).toUpperCase() + t11.code.slice(1)}`;
    r9[o21] = c17(t11.valueInGram), r9[`${o21}Percent`] = a19(t11.valuePercent);
  }), e10.totalCarbohydrate?.subNutrients?.forEach((t11) => {
    let o21 = `totalCarbohydrate${t11.code.charAt(0).toUpperCase() + t11.code.slice(1)}`;
    r9[o21] = c17(t11.valueInGram), r9[`${o21}Percent`] = a19(t11.valuePercent);
  }), r9;
}
__name(u19, "u");
j(u19, "extractNutrition");

// node_modules/@mahindar5/common-lib/dist/chunk-3RZ3KCDK.js
function i14(n11, t11, d15 = "text/plain") {
  let s18 = new Blob([n11], { type: d15 }), c21 = URL.createObjectURL(s18), o21 = document.createElement("a");
  o21.href = c21, o21.download = t11.includes(".") ? t11 : `${t11}_${Date.now()}`, document.body.appendChild(o21), o21.click(), document.body.removeChild(o21), URL.revokeObjectURL(c21);
}
__name(i14, "i");
j(i14, "downloadFile");
function r6(n11, t11) {
  i14(n11, t11.endsWith(".csv") ? t11 : `${t11}.csv`, "text/csv");
}
__name(r6, "r");
j(r6, "downloadCsv");

// node_modules/@mahindar5/common-lib/dist/chunk-ALDTSL2N.js
function o19(e10, t11, a22) {
  let i18 = `If there is any #Question, please provide the answer to the question and then summarize the text below.
Analyze the text below and provide:
A detailed summary of the main ideas and supporting points.
A clear timeline of events, if applicable, in chronological order. The timeline should be presented as simple numbered or indented lines for readability, compatible with plain text formatting in Notepad.
Key highlights or important takeaways in a concise manner, using simple formatting like dashes or colons to separate items, avoiding Markdown or rich text styles.
Ensure the response uses plain text formatting compatible with Notepad for clear readability without advanced styling.

${e10?.trim() ? `#Question: ${e10}` : ""}

Text:${t11?.replace(/\n/g, " ")}`;
  return a22 && (i18 = `
#Query: ${e10}
${t11?.replace(/\n/g, " ")}
		`), i18;
}
__name(o19, "o");
j(o19, "generateTabContentTemplate");

// node_modules/@mahindar5/common-lib/dist/chunk-R65NY7YR.js
function c18(t11) {
  return Array.isArray(t11);
}
__name(c18, "c");
j(c18, "isArray");
function f12(t11, n11, o21 = "asc") {
  return [...t11].sort((i18, u20) => {
    let [e10, r9] = o21 === "asc" ? [i18[n11], u20[n11]] : [u20[n11], i18[n11]];
    return e10 === void 0 ? 1 : r9 === void 0 ? -1 : typeof e10 == "number" && typeof r9 == "number" ? e10 - r9 : typeof e10 == "boolean" && typeof r9 == "boolean" ? Number(e10) - Number(r9) : e10?.getTime && r9?.getTime && typeof e10.getTime == "function" && typeof r9.getTime == "function" ? e10.getTime() - r9.getTime() : String(e10).localeCompare(String(r9));
  });
}
__name(f12, "f");
j(f12, "sortObjectsByField");
function y11(t11, n11) {
  let o21 = {};
  return t11.forEach((i18) => {
    let u20 = String(i18[n11]);
    (o21[u20] = o21[u20] || []).push(i18);
  }), o21;
}
__name(y11, "y");
j(y11, "groupByField");

// node_modules/@mahindar5/common-lib/dist/chunk-RIWZEJR3.js
function i15(n11, g10) {
  console.log(`${n11} working, ${g10}`);
}
__name(i15, "i");
j(i15, "devLog");

// node_modules/@mahindar5/common-lib/dist/chunk-2U4LZ355.js
function s16(e10) {
  return i16(e10) || l13(e10);
}
__name(s16, "s");
j(s16, "getLinkElementForKey");
function i16(e10) {
  return document.head.querySelector(`link[rel="stylesheet"].${r7(e10)}`);
}
__name(i16, "i");
j(i16, "getExistingLinkElementByKey");
function l13(e10) {
  let n11 = document.createElement("link");
  return n11.setAttribute("rel", "stylesheet"), n11.classList.add(r7(e10)), document.head.appendChild(n11), n11;
}
__name(l13, "l");
j(l13, "createLinkElementWithKey");
function r7(e10) {
  return `style-manager-${e10}`;
}
__name(r7, "r");
j(r7, "getClassNameForKey");

// node_modules/@mahindar5/common-lib/dist/chunk-QGKM5CH3.js
function o20(e10, t11) {
  return Object.entries(t11).find(([, n11]) => typeof n11 == "string" && typeof e10 == "string" ? n11.toLowerCase() === e10.toLowerCase() : n11 === e10)?.[0];
}
__name(o20, "o");
j(o20, "getEnumKeyFromValue");
function i17(e10) {
  return Object.keys(e10).filter((t11) => isNaN(Number(t11))).map((t11) => ({ text: t11, value: e10[t11] }));
}
__name(i17, "i");
j(i17, "enumToSelectOptions");

// node_modules/@mahindar5/common-lib/dist/chunk-H23XF5K6.js
async function s17() {
  try {
    let r9 = await (await (await navigator.bluetooth.requestDevice({ acceptAllDevices: true })).gatt.connect()).getPrimaryServices();
    console.log("Services and Characteristics:");
    for (let t11 of r9) console.log(`Service UUID: ${t11.uuid}`), (await t11.getCharacteristics()).forEach((i18) => {
      console.log(`  Characteristic UUID: ${i18.uuid}`);
    });
  } catch (e10) {
    console.error("Error:", e10);
  }
}
__name(s17, "s");
j(s17, "listBluetoothServicesAndCharacteristics");

// node_modules/@mahindar5/common-lib/dist/chunk-ZE6ZKTR6.js
function a20(s18) {
  return new Promise((t11, o21) => {
    let r9 = new FileReader();
    r9.onload = () => {
      try {
        let e10 = JSON.parse(r9.result);
        t11(e10);
      } catch (e10) {
        o21(e10);
      }
    }, r9.onerror = (e10) => o21(e10), r9.readAsText(s18);
  });
}
__name(a20, "a");
j(a20, "importConfig");

// node_modules/@mahindar5/common-lib/dist/chunk-WQMMRBYB.js
async function c19(n11, t11) {
  for await (let i18 of n11.values()) {
    if (i18.kind === "file") {
      let e10 = await i18.getFile(), a22 = { lastModified: e10.lastModified, name: e10.name, value: e10.size, type: e10.type, webkitRelativePath: e10.webkitRelativePath };
      t11.children = [...t11.children || [], a22];
    }
    if (i18.kind === "directory") {
      let e10 = await n11.getDirectoryHandle(i18.name, { create: false }), a22 = { kind: e10.kind, name: e10.name };
      t11.children = [...t11.children || [], a22], await c19(e10, a22);
    }
  }
}
__name(c19, "c");
j(c19, "handleDirectoryEntry");

// node_modules/@mahindar5/common-lib/dist/chunk-TSDQXFMN.js
async function b6(t11, e10, c21, s18, f13) {
  if (e10 && s18 && t11 && c21) try {
    let r9 = doc(A, t11, e10), i18 = await getDoc(r9);
    if (i18.exists()) {
      let m18 = i18.data(), g10 = doc(A, c21, s18);
      await setDoc(g10, m18), f13 && await deleteDoc(r9);
    }
  } catch (r9) {
    console.error("Error copying document:", r9);
  }
}
__name(b6, "b");
j(b6, "copyFirestoreDocument");

// node_modules/@mahindar5/common-lib/dist/chunk-APVLFW2F.js
var e6 = class {
  static {
    __name(this, "e");
  }
  static {
    j(this, "FirestoreUtils");
  }
  async saveToFirestore(s18, t11, i18) {
    let a22 = doc(A, s18, t11);
    await setDoc(a22, i18, { merge: true });
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-A6NFX2HP.js
var c20 = j(() => console.log("Log decorator"), "log");

// node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis = typeof globalThis === "object" ? globalThis : global;

// node_modules/@opentelemetry/api/build/esm/version.js
var VERSION = "1.9.0";

// node_modules/@opentelemetry/api/build/esm/internal/semver.js
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return /* @__PURE__ */ __name(function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    }, "isExactmatch");
  }
  function _reject(v8) {
    rejectedVersions.add(v8);
    return false;
  }
  __name(_reject, "_reject");
  function _accept(v8) {
    acceptedVersions.add(v8);
    return true;
  }
  __name(_accept, "_accept");
  return /* @__PURE__ */ __name(function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  }, "isCompatible");
}
__name(_makeCompatibilityCheck, "_makeCompatibilityCheck");
var isCompatible = _makeCompatibilityCheck(VERSION);

// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
var major = VERSION.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis;
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag3.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
__name(registerGlobal, "registerGlobal");
function getGlobal2(type) {
  var _a, _b;
  var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
__name(getGlobal2, "getGlobal");
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
__name(unregisterGlobal, "unregisterGlobal");

// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
var __read2 = function(o21, n11) {
  var m18 = typeof Symbol === "function" && o21[Symbol.iterator];
  if (!m18) return o21;
  var i18 = m18.call(o21), r9, ar = [], e10;
  try {
    while ((n11 === void 0 || n11-- > 0) && !(r9 = i18.next()).done) ar.push(r9.value);
  } catch (error) {
    e10 = { error };
  } finally {
    try {
      if (r9 && !r9.done && (m18 = i18["return"])) m18.call(i18);
    } finally {
      if (e10) throw e10.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i18 = 0, l14 = from.length, ar; i18 < l14; i18++) {
    if (ar || !(i18 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i18);
      ar[i18] = from[i18];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger = (
  /** @class */
  function() {
    function DiagComponentLogger2(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    __name(DiagComponentLogger2, "DiagComponentLogger");
    DiagComponentLogger2.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("debug", this._namespace, args);
    };
    DiagComponentLogger2.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("error", this._namespace, args);
    };
    DiagComponentLogger2.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("info", this._namespace, args);
    };
    DiagComponentLogger2.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("warn", this._namespace, args);
    };
    DiagComponentLogger2.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("verbose", this._namespace, args);
    };
    return DiagComponentLogger2;
  }()
);
function logProxy(funcName, namespace, args) {
  var logger2 = getGlobal2("diag");
  if (!logger2) {
    return;
  }
  args.unshift(namespace);
  return logger2[funcName].apply(logger2, __spreadArray2([], __read2(args), false));
}
__name(logProxy, "logProxy");

// node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
(function(DiagLogLevel2) {
  DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
  DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
  DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
  DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
  DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));

// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger2) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger2 = logger2 || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger2[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger2);
    }
    return function() {
    };
  }
  __name(_filterFunc, "_filterFunc");
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
__name(createLogLevelDiagLogger, "createLogLevelDiagLogger");

// node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read3 = function(o21, n11) {
  var m18 = typeof Symbol === "function" && o21[Symbol.iterator];
  if (!m18) return o21;
  var i18 = m18.call(o21), r9, ar = [], e10;
  try {
    while ((n11 === void 0 || n11-- > 0) && !(r9 = i18.next()).done) ar.push(r9.value);
  } catch (error) {
    e10 = { error };
  } finally {
    try {
      if (r9 && !r9.done && (m18 = i18["return"])) m18.call(i18);
    } finally {
      if (e10) throw e10.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i18 = 0, l14 = from.length, ar; i18 < l14; i18++) {
    if (ar || !(i18 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i18);
      ar[i18] = from[i18];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME = "diag";
var DiagAPI = (
  /** @class */
  function() {
    function DiagAPI2() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger2 = getGlobal2("diag");
          if (!logger2)
            return;
          return logger2[funcName].apply(logger2, __spreadArray3([], __read3(args), false));
        };
      }
      __name(_logProxy, "_logProxy");
      var self2 = this;
      var setLogger = /* @__PURE__ */ __name(function(logger2, optionsOrLogLevel) {
        var _a, _b, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
        }
        if (logger2 === self2) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self2.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal2("diag");
        var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger2);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal("diag", newLogger, self2, true);
      }, "setLogger");
      self2.setLogger = setLogger;
      self2.disable = function() {
        unregisterGlobal(API_NAME, self2);
      };
      self2.createComponentLogger = function(options) {
        return new DiagComponentLogger(options);
      };
      self2.verbose = _logProxy("verbose");
      self2.debug = _logProxy("debug");
      self2.info = _logProxy("info");
      self2.warn = _logProxy("warn");
      self2.error = _logProxy("error");
    }
    __name(DiagAPI2, "DiagAPI");
    DiagAPI2.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI2();
      }
      return this._instance;
    };
    return DiagAPI2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read4 = function(o21, n11) {
  var m18 = typeof Symbol === "function" && o21[Symbol.iterator];
  if (!m18) return o21;
  var i18 = m18.call(o21), r9, ar = [], e10;
  try {
    while ((n11 === void 0 || n11-- > 0) && !(r9 = i18.next()).done) ar.push(r9.value);
  } catch (error) {
    e10 = { error };
  } finally {
    try {
      if (r9 && !r9.done && (m18 = i18["return"])) m18.call(i18);
    } finally {
      if (e10) throw e10.error;
    }
  }
  return ar;
};
var __values2 = function(o21) {
  var s18 = typeof Symbol === "function" && Symbol.iterator, m18 = s18 && o21[s18], i18 = 0;
  if (m18) return m18.call(o21);
  if (o21 && typeof o21.length === "number") return {
    next: /* @__PURE__ */ __name(function() {
      if (o21 && i18 >= o21.length) o21 = void 0;
      return { value: o21 && o21[i18++], done: !o21 };
    }, "next")
  };
  throw new TypeError(s18 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var BaggageImpl = (
  /** @class */
  function() {
    function BaggageImpl2(entries) {
      this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
    }
    __name(BaggageImpl2, "BaggageImpl");
    BaggageImpl2.prototype.getEntry = function(key) {
      var entry = this._entries.get(key);
      if (!entry) {
        return void 0;
      }
      return Object.assign({}, entry);
    };
    BaggageImpl2.prototype.getAllEntries = function() {
      return Array.from(this._entries.entries()).map(function(_a) {
        var _b = __read4(_a, 2), k5 = _b[0], v8 = _b[1];
        return [k5, v8];
      });
    };
    BaggageImpl2.prototype.setEntry = function(key, entry) {
      var newBaggage = new BaggageImpl2(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    };
    BaggageImpl2.prototype.removeEntry = function(key) {
      var newBaggage = new BaggageImpl2(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    };
    BaggageImpl2.prototype.removeEntries = function() {
      var e_1, _a;
      var keys = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
      }
      var newBaggage = new BaggageImpl2(this._entries);
      try {
        for (var keys_1 = __values2(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
          var key = keys_1_1.value;
          newBaggage._entries.delete(key);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return newBaggage;
    };
    BaggageImpl2.prototype.clear = function() {
      return new BaggageImpl2();
    };
    return BaggageImpl2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");

// node_modules/@opentelemetry/api/build/esm/baggage/utils.js
var diag = DiagAPI.instance();
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
__name(createBaggage, "createBaggage");
function baggageEntryMetadataFromString(str) {
  if (typeof str !== "string") {
    diag.error("Cannot create baggage metadata from unknown type: " + typeof str);
    str = "";
  }
  return {
    __TYPE__: baggageEntryMetadataSymbol,
    toString: /* @__PURE__ */ __name(function() {
      return str;
    }, "toString")
  };
}
__name(baggageEntryMetadataFromString, "baggageEntryMetadataFromString");

// node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
__name(createContextKey, "createContextKey");
var BaseContext = (
  /** @class */
  /* @__PURE__ */ function() {
    function BaseContext2(parentContext) {
      var self2 = this;
      self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self2.getValue = function(key) {
        return self2._currentContext.get(key);
      };
      self2.setValue = function(key, value) {
        var context2 = new BaseContext2(self2._currentContext);
        context2._currentContext.set(key, value);
        return context2;
      };
      self2.deleteValue = function(key) {
        var context2 = new BaseContext2(self2._currentContext);
        context2._currentContext.delete(key);
        return context2;
      };
    }
    __name(BaseContext2, "BaseContext");
    return BaseContext2;
  }()
);
var ROOT_CONTEXT = new BaseContext();

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
var __extends2 = /* @__PURE__ */ function() {
  var extendStatics2 = /* @__PURE__ */ __name(function(d15, b7) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d16, b8) {
      d16.__proto__ = b8;
    } || function(d16, b8) {
      for (var p15 in b8) if (Object.prototype.hasOwnProperty.call(b8, p15)) d16[p15] = b8[p15];
    };
    return extendStatics2(d15, b7);
  }, "extendStatics");
  return function(d15, b7) {
    if (typeof b7 !== "function" && b7 !== null)
      throw new TypeError("Class extends value " + String(b7) + " is not a constructor or null");
    extendStatics2(d15, b7);
    function __() {
      this.constructor = d15;
    }
    __name(__, "__");
    d15.prototype = b7 === null ? Object.create(b7) : (__.prototype = b7.prototype, new __());
  };
}();
var NoopMeter = (
  /** @class */
  function() {
    function NoopMeter2() {
    }
    __name(NoopMeter2, "NoopMeter");
    NoopMeter2.prototype.createGauge = function(_name, _options) {
      return NOOP_GAUGE_METRIC;
    };
    NoopMeter2.prototype.createHistogram = function(_name, _options) {
      return NOOP_HISTOGRAM_METRIC;
    };
    NoopMeter2.prototype.createCounter = function(_name, _options) {
      return NOOP_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
      return NOOP_UP_DOWN_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
      return NOOP_OBSERVABLE_GAUGE_METRIC;
    };
    NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
      return NOOP_OBSERVABLE_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
      return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    };
    NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
    };
    NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
    };
    return NoopMeter2;
  }()
);
var NoopMetric = (
  /** @class */
  /* @__PURE__ */ function() {
    function NoopMetric2() {
    }
    __name(NoopMetric2, "NoopMetric");
    return NoopMetric2;
  }()
);
var NoopCounterMetric = (
  /** @class */
  function(_super) {
    __extends2(NoopCounterMetric2, _super);
    function NoopCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __name(NoopCounterMetric2, "NoopCounterMetric");
    NoopCounterMetric2.prototype.add = function(_value, _attributes) {
    };
    return NoopCounterMetric2;
  }(NoopMetric)
);
var NoopUpDownCounterMetric = (
  /** @class */
  function(_super) {
    __extends2(NoopUpDownCounterMetric2, _super);
    function NoopUpDownCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __name(NoopUpDownCounterMetric2, "NoopUpDownCounterMetric");
    NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
    };
    return NoopUpDownCounterMetric2;
  }(NoopMetric)
);
var NoopGaugeMetric = (
  /** @class */
  function(_super) {
    __extends2(NoopGaugeMetric2, _super);
    function NoopGaugeMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __name(NoopGaugeMetric2, "NoopGaugeMetric");
    NoopGaugeMetric2.prototype.record = function(_value, _attributes) {
    };
    return NoopGaugeMetric2;
  }(NoopMetric)
);
var NoopHistogramMetric = (
  /** @class */
  function(_super) {
    __extends2(NoopHistogramMetric2, _super);
    function NoopHistogramMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __name(NoopHistogramMetric2, "NoopHistogramMetric");
    NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
    };
    return NoopHistogramMetric2;
  }(NoopMetric)
);
var NoopObservableMetric = (
  /** @class */
  function() {
    function NoopObservableMetric2() {
    }
    __name(NoopObservableMetric2, "NoopObservableMetric");
    NoopObservableMetric2.prototype.addCallback = function(_callback) {
    };
    NoopObservableMetric2.prototype.removeCallback = function(_callback) {
    };
    return NoopObservableMetric2;
  }()
);
var NoopObservableCounterMetric = (
  /** @class */
  function(_super) {
    __extends2(NoopObservableCounterMetric2, _super);
    function NoopObservableCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __name(NoopObservableCounterMetric2, "NoopObservableCounterMetric");
    return NoopObservableCounterMetric2;
  }(NoopObservableMetric)
);
var NoopObservableGaugeMetric = (
  /** @class */
  function(_super) {
    __extends2(NoopObservableGaugeMetric2, _super);
    function NoopObservableGaugeMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __name(NoopObservableGaugeMetric2, "NoopObservableGaugeMetric");
    return NoopObservableGaugeMetric2;
  }(NoopObservableMetric)
);
var NoopObservableUpDownCounterMetric = (
  /** @class */
  function(_super) {
    __extends2(NoopObservableUpDownCounterMetric2, _super);
    function NoopObservableUpDownCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __name(NoopObservableUpDownCounterMetric2, "NoopObservableUpDownCounterMetric");
    return NoopObservableUpDownCounterMetric2;
  }(NoopObservableMetric)
);
var NOOP_METER = new NoopMeter();
var NOOP_COUNTER_METRIC = new NoopCounterMetric();
var NOOP_GAUGE_METRIC = new NoopGaugeMetric();
var NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
var NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
var NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
var NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
function createNoopMeter() {
  return NOOP_METER;
}
__name(createNoopMeter, "createNoopMeter");

// node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter = {
  get: /* @__PURE__ */ __name(function(carrier, key) {
    if (carrier == null) {
      return void 0;
    }
    return carrier[key];
  }, "get"),
  keys: /* @__PURE__ */ __name(function(carrier) {
    if (carrier == null) {
      return [];
    }
    return Object.keys(carrier);
  }, "keys")
};
var defaultTextMapSetter = {
  set: /* @__PURE__ */ __name(function(carrier, key, value) {
    if (carrier == null) {
      return;
    }
    carrier[key] = value;
  }, "set")
};

// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read5 = function(o21, n11) {
  var m18 = typeof Symbol === "function" && o21[Symbol.iterator];
  if (!m18) return o21;
  var i18 = m18.call(o21), r9, ar = [], e10;
  try {
    while ((n11 === void 0 || n11-- > 0) && !(r9 = i18.next()).done) ar.push(r9.value);
  } catch (error) {
    e10 = { error };
  } finally {
    try {
      if (r9 && !r9.done && (m18 = i18["return"])) m18.call(i18);
    } finally {
      if (e10) throw e10.error;
    }
  }
  return ar;
};
var __spreadArray4 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i18 = 0, l14 = from.length, ar; i18 < l14; i18++) {
    if (ar || !(i18 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i18);
      ar[i18] = from[i18];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = (
  /** @class */
  function() {
    function NoopContextManager2() {
    }
    __name(NoopContextManager2, "NoopContextManager");
    NoopContextManager2.prototype.active = function() {
      return ROOT_CONTEXT;
    };
    NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray4([thisArg], __read5(args), false));
    };
    NoopContextManager2.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager2.prototype.enable = function() {
      return this;
    };
    NoopContextManager2.prototype.disable = function() {
      return this;
    };
    return NoopContextManager2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/api/context.js
var __read6 = function(o21, n11) {
  var m18 = typeof Symbol === "function" && o21[Symbol.iterator];
  if (!m18) return o21;
  var i18 = m18.call(o21), r9, ar = [], e10;
  try {
    while ((n11 === void 0 || n11-- > 0) && !(r9 = i18.next()).done) ar.push(r9.value);
  } catch (error) {
    e10 = { error };
  } finally {
    try {
      if (r9 && !r9.done && (m18 = i18["return"])) m18.call(i18);
    } finally {
      if (e10) throw e10.error;
    }
  }
  return ar;
};
var __spreadArray5 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i18 = 0, l14 = from.length, ar; i18 < l14; i18++) {
    if (ar || !(i18 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i18);
      ar[i18] = from[i18];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME2 = "context";
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
var ContextAPI = (
  /** @class */
  function() {
    function ContextAPI2() {
    }
    __name(ContextAPI2, "ContextAPI");
    ContextAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI2();
      }
      return this._instance;
    };
    ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
    };
    ContextAPI2.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI2.prototype.with = function(context2, fn, thisArg) {
      var _a;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a = this._getContextManager()).with.apply(_a, __spreadArray5([context2, fn, thisArg], __read6(args), false));
    };
    ContextAPI2.prototype.bind = function(context2, target) {
      return this._getContextManager().bind(context2, target);
    };
    ContextAPI2.prototype._getContextManager = function() {
      return getGlobal2(API_NAME2) || NOOP_CONTEXT_MANAGER;
    };
    ContextAPI2.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal(API_NAME2, DiagAPI.instance());
    };
    return ContextAPI2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
(function(TraceFlags2) {
  TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
  TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));

// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID = "0000000000000000";
var INVALID_TRACEID = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT = {
  traceId: INVALID_TRACEID,
  spanId: INVALID_SPANID,
  traceFlags: TraceFlags.NONE
};

// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan = (
  /** @class */
  function() {
    function NonRecordingSpan2(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT;
      }
      this._spanContext = _spanContext;
    }
    __name(NonRecordingSpan2, "NonRecordingSpan");
    NonRecordingSpan2.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.addLink = function(_link2) {
      return this;
    };
    NonRecordingSpan2.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan2.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan2.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan2.prototype.end = function(_endTime) {
    };
    NonRecordingSpan2.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
__name(getSpan, "getSpan");
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
__name(getActiveSpan, "getActiveSpan");
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
__name(setSpan, "setSpan");
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
__name(deleteSpan, "deleteSpan");
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
__name(setSpanContext, "setSpanContext");
function getSpanContext(context2) {
  var _a;
  return (_a = getSpan(context2)) === null || _a === void 0 ? void 0 : _a.spanContext();
}
__name(getSpanContext, "getSpanContext");

// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
__name(isValidTraceId, "isValidTraceId");
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
__name(isValidSpanId, "isValidSpanId");
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
__name(isSpanContextValid, "isSpanContextValid");
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
__name(wrapSpanContext, "wrapSpanContext");

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
var contextApi = ContextAPI.getInstance();
var NoopTracer = (
  /** @class */
  function() {
    function NoopTracer2() {
    }
    __name(NoopTracer2, "NoopTracer");
    NoopTracer2.prototype.startSpan = function(name4, options, context2) {
      if (context2 === void 0) {
        context2 = contextApi.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan();
      }
      var parentFromContext = context2 && getSpanContext(context2);
      if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
        return new NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan();
      }
    };
    NoopTracer2.prototype.startActiveSpan = function(name4, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
      var span = this.startSpan(name4, opts, parentContext);
      var contextWithSpanSet = setSpan(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer2;
  }()
);
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
__name(isSpanContext, "isSpanContext");

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER = new NoopTracer();
var ProxyTracer = (
  /** @class */
  function() {
    function ProxyTracer2(_provider, name4, version6, options) {
      this._provider = _provider;
      this.name = name4;
      this.version = version6;
      this.options = options;
    }
    __name(ProxyTracer2, "ProxyTracer");
    ProxyTracer2.prototype.startSpan = function(name4, options, context2) {
      return this._getTracer().startSpan(name4, options, context2);
    };
    ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer2.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider = (
  /** @class */
  function() {
    function NoopTracerProvider2() {
    }
    __name(NoopTracerProvider2, "NoopTracerProvider");
    NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer();
    };
    return NoopTracerProvider2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
var ProxyTracerProvider = (
  /** @class */
  function() {
    function ProxyTracerProvider2() {
    }
    __name(ProxyTracerProvider2, "ProxyTracerProvider");
    ProxyTracerProvider2.prototype.getTracer = function(name4, version6, options) {
      var _a;
      return (_a = this.getDelegateTracer(name4, version6, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name4, version6, options);
    };
    ProxyTracerProvider2.prototype.getDelegate = function() {
      var _a;
      return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
    };
    ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider2.prototype.getDelegateTracer = function(name4, version6, options) {
      var _a;
      return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name4, version6, options);
    };
    return ProxyTracerProvider2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
(function(SpanStatusCode2) {
  SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
  SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
  SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));

// node_modules/@opentelemetry/api/build/esm/context-api.js
var context = ContextAPI.getInstance();

// node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2 = DiagAPI.instance();

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider = (
  /** @class */
  function() {
    function NoopMeterProvider2() {
    }
    __name(NoopMeterProvider2, "NoopMeterProvider");
    NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
      return NOOP_METER;
    };
    return NoopMeterProvider2;
  }()
);
var NOOP_METER_PROVIDER = new NoopMeterProvider();

// node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME3 = "metrics";
var MetricsAPI = (
  /** @class */
  function() {
    function MetricsAPI2() {
    }
    __name(MetricsAPI2, "MetricsAPI");
    MetricsAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new MetricsAPI2();
      }
      return this._instance;
    };
    MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
      return registerGlobal(API_NAME3, provider, DiagAPI.instance());
    };
    MetricsAPI2.prototype.getMeterProvider = function() {
      return getGlobal2(API_NAME3) || NOOP_METER_PROVIDER;
    };
    MetricsAPI2.prototype.getMeter = function(name4, version6, options) {
      return this.getMeterProvider().getMeter(name4, version6, options);
    };
    MetricsAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME3, DiagAPI.instance());
    };
    return MetricsAPI2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics = MetricsAPI.getInstance();

// node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator = (
  /** @class */
  function() {
    function NoopTextMapPropagator2() {
    }
    __name(NoopTextMapPropagator2, "NoopTextMapPropagator");
    NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
    };
    NoopTextMapPropagator2.prototype.extract = function(context2, _carrier) {
      return context2;
    };
    NoopTextMapPropagator2.prototype.fields = function() {
      return [];
    };
    return NoopTextMapPropagator2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
var BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
function getBaggage(context2) {
  return context2.getValue(BAGGAGE_KEY) || void 0;
}
__name(getBaggage, "getBaggage");
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
__name(getActiveBaggage, "getActiveBaggage");
function setBaggage(context2, baggage) {
  return context2.setValue(BAGGAGE_KEY, baggage);
}
__name(setBaggage, "setBaggage");
function deleteBaggage(context2) {
  return context2.deleteValue(BAGGAGE_KEY);
}
__name(deleteBaggage, "deleteBaggage");

// node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME4 = "propagation";
var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
var PropagationAPI = (
  /** @class */
  function() {
    function PropagationAPI2() {
      this.createBaggage = createBaggage;
      this.getBaggage = getBaggage;
      this.getActiveBaggage = getActiveBaggage;
      this.setBaggage = setBaggage;
      this.deleteBaggage = deleteBaggage;
    }
    __name(PropagationAPI2, "PropagationAPI");
    PropagationAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new PropagationAPI2();
      }
      return this._instance;
    };
    PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
      return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
    };
    PropagationAPI2.prototype.inject = function(context2, carrier, setter) {
      if (setter === void 0) {
        setter = defaultTextMapSetter;
      }
      return this._getGlobalPropagator().inject(context2, carrier, setter);
    };
    PropagationAPI2.prototype.extract = function(context2, carrier, getter) {
      if (getter === void 0) {
        getter = defaultTextMapGetter;
      }
      return this._getGlobalPropagator().extract(context2, carrier, getter);
    };
    PropagationAPI2.prototype.fields = function() {
      return this._getGlobalPropagator().fields();
    };
    PropagationAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME4, DiagAPI.instance());
    };
    PropagationAPI2.prototype._getGlobalPropagator = function() {
      return getGlobal2(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
    };
    return PropagationAPI2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation = PropagationAPI.getInstance();

// node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME5 = "trace";
var TraceAPI = (
  /** @class */
  function() {
    function TraceAPI2() {
      this._proxyTracerProvider = new ProxyTracerProvider();
      this.wrapSpanContext = wrapSpanContext;
      this.isSpanContextValid = isSpanContextValid;
      this.deleteSpan = deleteSpan;
      this.getSpan = getSpan;
      this.getActiveSpan = getActiveSpan;
      this.getSpanContext = getSpanContext;
      this.setSpan = setSpan;
      this.setSpanContext = setSpanContext;
    }
    __name(TraceAPI2, "TraceAPI");
    TraceAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI2();
      }
      return this._instance;
    };
    TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI2.prototype.getTracerProvider = function() {
      return getGlobal2(API_NAME5) || this._proxyTracerProvider;
    };
    TraceAPI2.prototype.getTracer = function(name4, version6) {
      return this.getTracerProvider().getTracer(name4, version6);
    };
    TraceAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME5, DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace = TraceAPI.getInstance();

// node_modules/@opentelemetry/api/build/esm/index.js
var esm_default = {
  context,
  diag: diag2,
  metrics,
  propagation,
  trace
};

// node_modules/@mahindar5/common-lib/dist/chunk-EBN7ZXFV.js
function S6(p15, o21, n11) {
  let m18 = n11.value;
  n11.value = async function(...r9) {
    let a22 = context.active(), t11 = { className: p15.constructor.name, methodName: o21 };
    if (n5()) try {
      t11.originalUrl = location.href, t11.originalHostUrl = new URL(location.href).host;
    } catch {
    }
    if (t5()) try {
      if (t11.nodeVersion = process.version, t11.nodeEnv = process.env.NODE_ENV || "unknown", t11.hostname = k("os").hostname(), t11.pid = process.pid.toString(), r9.length > 0 && r9[0] && typeof r9[0] == "object") {
        let e10 = r9[0];
        e10.url && e10.method && (t11.requestUrl = e10.url.toString(), t11.requestMethod = e10.method.toString(), e10.headers && (e10.headers["user-agent"] && (t11.userAgent = e10.headers["user-agent"].toString()), (e10.headers["x-request-id"] || e10.headers["request-id"]) && (t11.requestId = (e10.headers["x-request-id"] || e10.headers["request-id"]).toString())));
      }
    } catch (e10) {
      t11.nodeAttributeError = e10.message;
    }
    let s18 = trace.getTracer("my-app").startSpan(o21, { attributes: t11 }, a22);
    try {
      return await context.with(trace.setSpan(a22, s18), async () => {
        let e10 = await m18.apply(this, r9);
        return s18.setStatus({ code: SpanStatusCode.OK }), e10;
      });
    } catch (e10) {
      throw s18.setStatus({ code: SpanStatusCode.ERROR, message: e10.message }), e10;
    } finally {
      s18.end();
    }
  };
}
__name(S6, "S");
j(S6, "Tracer");

// node_modules/@mahindar5/common-lib/dist/chunk-6KLP6ZUM.js
var e7 = { namespace: "@mahindar5/common-lib", version: "1.3.28", commit: "b718ebc77fbd48e29675f8788e88f755201904fc", branch: "main", lastCommitMessage: "Refactor PipWindowService to support multiple subtitle lines and improve styling", lastCommitAuthor: "mahindar5", lastCommitDate: "2025-11-03 13:15:48 -0800", buildNumber: "1762204584011", buildId: "build-1762204584011", buildUrl: "", buildEnvironment: "development", buildHost: "runnervmf2e7y", buildTarget: "development", nodeVersion: "v24.11.0", npmVersion: "11.6.1", os: "linux", arch: "x64", buildDate: "11/3/2025", buildTime: "9:16:23 PM", timestamp: "2025-11-03T21:16:23.991Z" };

// node_modules/@mahindar5/common-lib/dist/chunk-FX6FTCGN.js
var E2 = { FILE_START: "#FILE:", FILE_END: "#END_FILE" };

// node_modules/@mahindar5/common-lib/dist/chunk-OM2WWEQF.js
var a21 = [{ address: "46:E1:1A:3D:8C:DF", mac: "Mahindar-s-S22-Ultra", owner: "mahindar" }, { address: "60:6C:66:4E:84:28", mac: "DESKTOP-COTEKCJ", owner: "mahindar" }, { address: "60:A5:E2:18:14:97", mac: "DESKTOP-NUHLUK", owner: "mahindar" }, { address: "64:49:7D:D3:7F:F7", mac: "SAW-L1875433703", owner: "mahindar" }, { address: "4E:58:D9:F2:C0:5C", mac: "Mohit-s-Z-Flip5", owner: "mohit" }, { address: "70:D8:23:F7:A9:31", mac: "CANCAL667686L", owner: "mohit" }, { address: "10:3F:44:3E:CB:1D", mac: "M2007J3SP", owner: "mohit" }, { address: "B4:6D:83:3E:41:30", mac: "DESKTOP-LFQBJ0M", owner: "mohit" }, { address: "CC:2D:83:F2:1E:7C", mac: "android-a0d22fcb68f4230e", owner: "mohit" }, { address: "FE:4B:1E:56:B4:74", mac: "iPhone", owner: "mohit" }, { address: "5A:1B:07:5F:19:CA", mac: "5a:1b:07:5f:19:ca", owner: "mohit" }, { address: "4A:75:99:E4:77:4F", mac: "Galaxy-S10", owner: "sanat" }, { address: "10:A5:1D:2F:EC:34", mac: "S-SMOGATAR7320", owner: "sanat" }, { address: "EE:90:2E:20:CA:98", mac: "iPhone", owner: "sanat" }, { address: "E0:9D:31:24:94:24", mac: "DESKTOP-J371IOQ", owner: "sanat" }, { address: "90:11:95:81:EF:9F", mac: "90:11:95:81:EF:9F", owner: "sanat" }, { address: "BE:AB:6C:EA:7D:21", mac: "BE:AB:6C:EA:7D:21", owner: "sanat" }, { address: "74:F2:FA:54:21:92", mac: "Redmi-10", owner: "sanat" }, { address: "46:C9:16:B6:84:F0", mac: "iPhone", owner: "sanat" }, { address: "38:87:D5:5C:E2:3E", mac: "T7300-0340464", owner: "sanat" }, { address: "16:83:D5:63:43:C7", mac: "Pixel-8-Pro", owner: "adithya" }, { address: "80:38:FB:16:C0:F1", mac: "Adithya-PC27", owner: "adithya" }, { address: "EA:1D:F9:56:66:D7", mac: "Sai-kiran-reddy-s-Z-Fold4", owner: "sai kiran" }, { address: "A6:88:A3:6B:61:48", mac: "SKRC-s-S25-Ultra", owner: "sai kiran" }, { address: "10:63:C8:4B:19:CD", mac: "LAPTOP-MQR0KVKL", owner: "sai kiran" }, { address: "A4:77:33:E6:AE:84", mac: "Chromecast", owner: "sai kiran" }, { address: "78:2B:64:5A:3F:85", mac: "Bose-Smart-Soundbar-300", owner: "sai kiran" }, { address: "70:70:AA:97:B2:39", mac: "70:70:aa:97:b2:39", owner: "sai kiran" }, { address: "7E:FE:67:FE:BC:D9", mac: "7e:fe:67:fe:bc:d9", owner: "vikas" }, { address: "10:0B:A9:16:B2:9C", mac: "DESKTOP-N8BDK64", owner: "vikas" }, { address: "36:5B:DD:39:2D:DD", mac: "36:5B:DD:39:2D:DD", owner: "vikas" }, { address: "AA:9E:AD:BB:C1:82", mac: "aa:9e:ad:bb:c1:82", owner: "vikas" }, { address: "80:AD:16:C2:72:28", mac: "RedmiNote5-Redmi", owner: "sanat" }, { address: "", mac: "02:79:BF:B6:E3:A5", owner: "vikas" }, { address: "B4:69:21:CD:D4:99", mac: "5CDN8474SGN", owner: "narender" }, { address: "14:5A:FC:5A:1C:65", mac: "LAPTOP-M3BO8SOH", owner: "narender" }, { address: "70:BB:E9:4C:C1:3E", mac: "RedmiNote6Pro-RedmiN", owner: "narender" }, { address: "", mac: "DESKTOP-0FUN6S2", owner: "~narender-before-format" }, { address: "94:B8:6D:B7:C9:2E", mac: "DESKTOP-NUHLUT", owner: "mahindar" }, { address: "60:6C:66:4E:84:28", mac: "DESKTOP-FE3SNIP", owner: "mahindar" }, { address: "A0:A4:C5:87:69:9B", mac: "PUNASC264247L", owner: "mohit" }, { address: "B4:6D:83:3E:41:30", mac: "DESKTOP-82A09H7", owner: "mohit" }, { address: "70:CF:49:7A:DB:A9", mac: "LAPTOP-CQGHHDOK", owner: "mohit" }, { address: "", mac: "Vostro3558f5ea3bf2", owner: "mohit" }, { address: "90:CD:B6:C7:35:F1", mac: "90:CD:B6:C7:35:F1", owner: "mohit-or-OwnerDevice" }, { address: "00:BB:3A:FF:65:78", mac: "00:bb:3a:ff:65:78", owner: "~mohit-kindle-or-sravan" }, { address: "E2:B4:0D:68:FB:5F", mac: "e2:b4:0d:68:fb:5f", owner: "sravan-OwnerDevice-or-mohit" }, { address: "94:17:00:EF:B8:BF", mac: "POCOM2Pro-POCOM2Pro", owner: "sravan" }, { address: "", mac: "HYDPCM209623L", owner: "sravan" }, { address: "60:A5:E2:91:6D:97", mac: "CANBRN565553L", owner: "sravan" }, { address: "F8:FF:C2:37:88:F7", mac: "Shravans-MBP", owner: "sravan" }, { address: "94:17:00:EF:B8:BF", mac: "94:17:00:ef:b8:bf", owner: "sravan M2pro" }, { address: "90:61:AE:EC:31:A5", mac: "USABOS208674L", owner: "~sravan-or-m" }, { address: "60:A5:E2:18:14:97", mac: "hcltadmin", owner: "mahindar" }, { address: "70:BB:E9:19:CF:B1", mac: "POCOF1-POCOF1", owner: "mahindar" }, { address: "36:BC:8E:A0:F0:C7", mac: "Galaxy-S22-Ultra", owner: "mahindar" }, { address: "EA:90:1C:DF:11:44", mac: "Galaxy-S21-5G", owner: "rajesh" }, { address: "08:54:BB:A4:24:32", mac: "08:54:BB:A4:24:32", owner: "projector" }, { address: "", mac: "LP-5CD8474SGN", owner: "" }, { address: "", mac: "f0:d7:aa:5c:e2:37", owner: "" }, { address: "", mac: "CA:4C:16:15:B8:C9", owner: "Radha Krishna" }, { address: "AC:15:F4:4E:45:3F", mac: "iPad", owner: "Vikas" }, { address: "42:AF:99:93:1E:E9", mac: "Ankams-Galaxy-S9", owner: "Mahesh" }, { address: "AA:9C:49:08:C0:1C", mac: "Dasari-Hari-s-M32", owner: "Hari" }];

// node_modules/@mahindar5/common-lib/dist/chunk-4RP7LGZH.js
var e8 = [{ prop: "regularMarketPrice", title: "Current" }, { prop: "regularMarketDayLow", title: "Day Low", orderType: "buy_quantity" }, { prop: "regularMarketDayHigh", title: "Day High", orderType: "sell_quantity" }, { prop: "averagePrice", title: "Average" }, { prop: "min", title: "Min Buy", orderType: "buy_quantity" }, { prop: "lastPurchasePrice", title: "Prev Order", orderType: "buy_quantity" }, { prop: "fiftyTwoWeekLow", title: "52 Week Low", orderType: "buy_quantity" }, { prop: "lastPendingPurchasePrice", title: "Last Pending", orderType: "buy_quantity" }, { prop: "minPendingPurchasePrice", title: "Min Pending", orderType: "buy_quantity" }, { prop: "maxSell", title: "Max Sell", orderType: "sell_quantity" }, { prop: "lastPurchasePriceSell", title: "Prev Order Sell", orderType: "sell_quantity" }, { prop: "fiftyTwoWeekHigh", title: "52 Week High", orderType: "sell_quantity" }, { prop: "lastPendingPurchasePriceSell", title: "Last Pending Sell", orderType: "sell_quantity" }, { prop: "maxPendingPurchasePriceSell", title: "Max Pending Sell", orderType: "sell_quantity" }, { prop: "regularMarketOpen", title: "Open" }, { prop: "regularMarketPreviousClose", title: "Prev Close" }];

// node_modules/@mahindar5/common-lib/dist/chunk-C6KGANCS.js
var r8 = ((e10) => (e10.BuyQuantity = "buy_quantity", e10.SellQuantity = "sell_quantity", e10))(r8 || {});

// src/cors-mini.ts
var import_http = require("http");
var import_https = require("https");
var import_url = require("url");
var ALLOWED_KEYS = [process.env.API_KEY].filter(Boolean);
function withCORS(headers, req) {
  headers["access-control-allow-origin"] = "*";
  if (req.headers["access-control-request-method"]) {
    headers["access-control-allow-methods"] = req.headers["access-control-request-method"];
    delete req.headers["access-control-request-method"];
  }
  if (req.headers["access-control-request-headers"]) {
    headers["access-control-allow-headers"] = req.headers["access-control-request-headers"];
    delete req.headers["access-control-request-headers"];
  }
  return headers;
}
__name(withCORS, "withCORS");
function isRequestWithValidAPIKey(req) {
  const apiKey = req.headers["x-api-key"];
  return ALLOWED_KEYS.length > 0 && ALLOWED_KEYS.includes(apiKey);
}
__name(isRequestWithValidAPIKey, "isRequestWithValidAPIKey");
async function readBody(req) {
  const chunks = [];
  for await (const chunk of req) chunks.push(chunk);
  return JSON.parse(Buffer.concat(chunks).toString());
}
__name(readBody, "readBody");
function proxyRequest(req, res) {
  const target = req.url?.slice(1);
  if (!target) {
    console.log(`\u26A0 Invalid request - no target URL: ${req.method} ${req.url} from ${req.socket.remoteAddress}`);
    res.writeHead(400, { "Content-Type": "text/plain" });
    res.end("Invalid URL: URL must be in the format /https://example.com");
    return;
  }
  let parsedTarget;
  try {
    parsedTarget = (0, import_url.parse)(target);
    if (!parsedTarget.protocol || !parsedTarget.host) {
      throw new Error("Incomplete URL provided");
    }
  } catch (err) {
    console.log(`\u26A0 Invalid URL format: ${target} from ${req.socket.remoteAddress} - ${err instanceof Error ? err.message : "Unknown error"}`);
    res.writeHead(400, { "Content-Type": "text/plain" });
    res.end(`Invalid URL: ${err instanceof Error ? err.message : "Unknown error"}`);
    return;
  }
  const options = {
    protocol: parsedTarget.protocol,
    hostname: parsedTarget.hostname,
    port: parsedTarget.port,
    path: parsedTarget.path || "/",
    method: req.method,
    headers: { ...req.headers, host: parsedTarget.hostname || void 0 }
  };
  const protocolHandler = parsedTarget.protocol === "https:" ? import_https.request : import_http.request;
  const proxy = protocolHandler(options, (proxyRes) => {
    console.log(`\u2713 ${req.method} ${target} -> ${proxyRes.statusCode}`);
    res.writeHead(proxyRes.statusCode || 500, withCORS(proxyRes.headers || {}, req));
    proxyRes.pipe(res, { end: true });
  });
  proxy.on("error", (err) => {
    console.log(`\u2717 Proxy error for ${target}: ${err.message}`);
    res.writeHead(500, withCORS({}, req));
    res.end(`Proxy error: ${err.message}`);
  });
  req.pipe(proxy, { end: true });
}
__name(proxyRequest, "proxyRequest");
var server = (0, import_http.createServer)(async (req, res) => {
  if (req.url === "/alive") {
    console.log(`\u{1F493} Health check from ${req.socket.remoteAddress}`);
    res.writeHead(200, { "Content-Type": "text/plain" });
    res.end("Alive Test");
    return;
  }
  if (req.method === "OPTIONS") {
    res.writeHead(200, withCORS({}, req));
    res.end();
    return;
  }
  if (!isRequestWithValidAPIKey(req)) {
    console.log(`\u26A0 Unauthorized access attempt: ${req.method} ${req.url} from ${req.socket.remoteAddress}`);
    res.writeHead(404, withCORS({ "Content-Type": "text/plain" }, req));
    res.end("Not Found");
    return;
  }
  if (req.url === "/rpc" && req.method === "POST") {
    try {
      const request = await readBody(req);
      const response = await y2(request, { expectedTarget: "http" });
      res.writeHead(200, { "Content-Type": "application/json", ...withCORS({}, req) });
      res.end(JSON.stringify(response));
    } catch (error) {
      res.writeHead(500, { "Content-Type": "application/json", ...withCORS({}, req) });
      res.end(JSON.stringify({ success: false, error: String(error) }));
    }
    return;
  }
  if (req.url === "/" || req.url === "") {
    res.writeHead(200, { "Content-Type": "text/plain", ...withCORS({}, req) });
    res.end("CORS Proxy + RPC server running. Endpoints: /rpc, /https://example.com");
    return;
  }
  proxyRequest(req, res);
});
var port = Number(process.env.PORT) || 8080;
server.listen(port, () => console.log(`\u{1F680} CORS Proxy + RPC server on port ${port}`));

// node_modules/@mahindar5/common-lib/dist/chunk-UN3HAFMY.js
var e9 = __toESM(require("os"), 1);
var t9 = class {
  static {
    __name(this, "t");
  }
  static {
    j(this, "NodeDeviceRegistrationService");
  }
  deviceId = null;
  async getDeviceId() {
    return this.deviceId ? this.deviceId : (this.deviceId = await this.generateDeviceId(), this.deviceId);
  }
  async generateDeviceId() {
    return process.env.RENDER_SERVICE_ID || "local-node";
  }
  async generateDeviceId2() {
    let n11 = process.env.RENDER_SERVICE_ID || "local-node", o21 = e9.platform(), r9 = e9.cpus()[0]?.model || "unknown", i18 = e9.cpus().length, c21 = String(e9.totalmem()).slice(0, 5), a22 = e9.hostname();
    return [o21, "Node", r9, i18, c21, a22, n11].join("|");
  }
};

// node_modules/@mahindar5/common-lib/dist/chunk-KPPD7QBE.js
async function t10() {
  if (typeof process < "u") {
    let [s18, o21, e10, l14, i18, r9] = await Promise.all([import("child_process"), import("http"), import("url"), import("fs"), import("os"), import("path")]);
    globalThis.exec = s18.exec, globalThis.createServer = o21.createServer, globalThis.parse = e10.parse, globalThis.fs = l14, globalThis.os = i18, globalThis.path = r9;
  }
}
__name(t10, "t");
j(t10, "pollyfillGlobalModules");

// src/index.ts
var jobs = [
  t6,
  i6,
  u11,
  h6,
  e2,
  o9,
  p8,
  D4,
  f9,
  o10,
  y6,
  d5,
  I
];
c2(t9, [], e);
c2(i10, [], "AuthService");
jobs.forEach((JobClass) => {
  c2(JobClass);
  console.log(`\u2705 Registered: ${JobClass.name}`);
});
console.log("\u{1F680} Jobs initialized");
//# sourceMappingURL=index.js.map
